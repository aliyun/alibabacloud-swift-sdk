import Foundation
import Tea
import TeaUtils
import AlibabacloudOpenApi
import AlibabaCloudOpenApiUtil
import AlibabacloudEndpointUtil

public class Adb4MysqlSparkDiagnosisInfo : Tea.TeaModel {
    public var diagnosisCode: String?

    public var diagnosisCodeLabel: String?

    public var diagnosisMsg: String?

    public var diagnosisType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.diagnosisCode != nil {
            map["DiagnosisCode"] = self.diagnosisCode!
        }
        if self.diagnosisCodeLabel != nil {
            map["DiagnosisCodeLabel"] = self.diagnosisCodeLabel!
        }
        if self.diagnosisMsg != nil {
            map["DiagnosisMsg"] = self.diagnosisMsg!
        }
        if self.diagnosisType != nil {
            map["DiagnosisType"] = self.diagnosisType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DiagnosisCode"] as? String {
            self.diagnosisCode = value
        }
        if let value = dict["DiagnosisCodeLabel"] as? String {
            self.diagnosisCodeLabel = value
        }
        if let value = dict["DiagnosisMsg"] as? String {
            self.diagnosisMsg = value
        }
        if let value = dict["DiagnosisType"] as? String {
            self.diagnosisType = value
        }
    }
}

public class ColDetailModel : Tea.TeaModel {
    public var columnName: String?

    public var createTime: String?

    public var description_: String?

    public var distributeKey: Bool?

    public var nullable: Bool?

    public var partitionKey: Bool?

    public var primaryKey: Bool?

    public var schemaName: String?

    public var tableName: String?

    public var type: String?

    public var updateTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.columnName != nil {
            map["ColumnName"] = self.columnName!
        }
        if self.createTime != nil {
            map["CreateTime"] = self.createTime!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.distributeKey != nil {
            map["DistributeKey"] = self.distributeKey!
        }
        if self.nullable != nil {
            map["Nullable"] = self.nullable!
        }
        if self.partitionKey != nil {
            map["PartitionKey"] = self.partitionKey!
        }
        if self.primaryKey != nil {
            map["PrimaryKey"] = self.primaryKey!
        }
        if self.schemaName != nil {
            map["SchemaName"] = self.schemaName!
        }
        if self.tableName != nil {
            map["TableName"] = self.tableName!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        if self.updateTime != nil {
            map["UpdateTime"] = self.updateTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ColumnName"] as? String {
            self.columnName = value
        }
        if let value = dict["CreateTime"] as? String {
            self.createTime = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["DistributeKey"] as? Bool {
            self.distributeKey = value
        }
        if let value = dict["Nullable"] as? Bool {
            self.nullable = value
        }
        if let value = dict["PartitionKey"] as? Bool {
            self.partitionKey = value
        }
        if let value = dict["PrimaryKey"] as? Bool {
            self.primaryKey = value
        }
        if let value = dict["SchemaName"] as? String {
            self.schemaName = value
        }
        if let value = dict["TableName"] as? String {
            self.tableName = value
        }
        if let value = dict["Type"] as? String {
            self.type = value
        }
        if let value = dict["UpdateTime"] as? String {
            self.updateTime = value
        }
    }
}

public class CstoreIndexModel : Tea.TeaModel {
    public var columnOrds: [String]?

    public var createTime: String?

    public var databaseName: String?

    public var indexColumns: [FieldSchemaModel]?

    public var indexName: String?

    public var indexType: String?

    public var options: [String: String]?

    public var physicalTableName: String?

    public var updateTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.columnOrds != nil {
            map["ColumnOrds"] = self.columnOrds!
        }
        if self.createTime != nil {
            map["CreateTime"] = self.createTime!
        }
        if self.databaseName != nil {
            map["DatabaseName"] = self.databaseName!
        }
        if self.indexColumns != nil {
            var tmp : [Any] = []
            for k in self.indexColumns! {
                tmp.append(k.toMap())
            }
            map["IndexColumns"] = tmp
        }
        if self.indexName != nil {
            map["IndexName"] = self.indexName!
        }
        if self.indexType != nil {
            map["IndexType"] = self.indexType!
        }
        if self.options != nil {
            map["Options"] = self.options!
        }
        if self.physicalTableName != nil {
            map["PhysicalTableName"] = self.physicalTableName!
        }
        if self.updateTime != nil {
            map["UpdateTime"] = self.updateTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ColumnOrds"] as? [String] {
            self.columnOrds = value
        }
        if let value = dict["CreateTime"] as? String {
            self.createTime = value
        }
        if let value = dict["DatabaseName"] as? String {
            self.databaseName = value
        }
        if let value = dict["IndexColumns"] as? [Any?] {
            var tmp : [FieldSchemaModel] = []
            for v in value {
                if v != nil {
                    var model = FieldSchemaModel()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.indexColumns = tmp
        }
        if let value = dict["IndexName"] as? String {
            self.indexName = value
        }
        if let value = dict["IndexType"] as? String {
            self.indexType = value
        }
        if let value = dict["Options"] as? [String: String] {
            self.options = value
        }
        if let value = dict["PhysicalTableName"] as? String {
            self.physicalTableName = value
        }
        if let value = dict["UpdateTime"] as? String {
            self.updateTime = value
        }
    }
}

public class DatabaseSummaryModel : Tea.TeaModel {
    public var createTime: String?

    public var description_: String?

    public var owner: String?

    public var schemaName: String?

    public var updateTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.createTime != nil {
            map["CreateTime"] = self.createTime!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.owner != nil {
            map["Owner"] = self.owner!
        }
        if self.schemaName != nil {
            map["SchemaName"] = self.schemaName!
        }
        if self.updateTime != nil {
            map["UpdateTime"] = self.updateTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CreateTime"] as? String {
            self.createTime = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["Owner"] as? String {
            self.owner = value
        }
        if let value = dict["SchemaName"] as? String {
            self.schemaName = value
        }
        if let value = dict["UpdateTime"] as? String {
            self.updateTime = value
        }
    }
}

public class Detail : Tea.TeaModel {
    public var appType: String?

    public var DBClusterId: String?

    public var data: String?

    public var durationInMillis: Int64?

    public var estimateExecutionCpuTimeInSeconds: Int64?

    public var lastAttemptId: String?

    public var lastUpdatedTimeInMillis: Int64?

    public var logRootPath: String?

    public var resourceGroupName: String?

    public var startedTimeInMillis: Int64?

    public var submittedTimeInMillis: Int64?

    public var terminatedTimeInMillis: Int64?

    public var webUiAddress: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appType != nil {
            map["AppType"] = self.appType!
        }
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.durationInMillis != nil {
            map["DurationInMillis"] = self.durationInMillis!
        }
        if self.estimateExecutionCpuTimeInSeconds != nil {
            map["EstimateExecutionCpuTimeInSeconds"] = self.estimateExecutionCpuTimeInSeconds!
        }
        if self.lastAttemptId != nil {
            map["LastAttemptId"] = self.lastAttemptId!
        }
        if self.lastUpdatedTimeInMillis != nil {
            map["LastUpdatedTimeInMillis"] = self.lastUpdatedTimeInMillis!
        }
        if self.logRootPath != nil {
            map["LogRootPath"] = self.logRootPath!
        }
        if self.resourceGroupName != nil {
            map["ResourceGroupName"] = self.resourceGroupName!
        }
        if self.startedTimeInMillis != nil {
            map["StartedTimeInMillis"] = self.startedTimeInMillis!
        }
        if self.submittedTimeInMillis != nil {
            map["SubmittedTimeInMillis"] = self.submittedTimeInMillis!
        }
        if self.terminatedTimeInMillis != nil {
            map["TerminatedTimeInMillis"] = self.terminatedTimeInMillis!
        }
        if self.webUiAddress != nil {
            map["WebUiAddress"] = self.webUiAddress!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppType"] as? String {
            self.appType = value
        }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["Data"] as? String {
            self.data = value
        }
        if let value = dict["DurationInMillis"] as? Int64 {
            self.durationInMillis = value
        }
        if let value = dict["EstimateExecutionCpuTimeInSeconds"] as? Int64 {
            self.estimateExecutionCpuTimeInSeconds = value
        }
        if let value = dict["LastAttemptId"] as? String {
            self.lastAttemptId = value
        }
        if let value = dict["LastUpdatedTimeInMillis"] as? Int64 {
            self.lastUpdatedTimeInMillis = value
        }
        if let value = dict["LogRootPath"] as? String {
            self.logRootPath = value
        }
        if let value = dict["ResourceGroupName"] as? String {
            self.resourceGroupName = value
        }
        if let value = dict["StartedTimeInMillis"] as? Int64 {
            self.startedTimeInMillis = value
        }
        if let value = dict["SubmittedTimeInMillis"] as? Int64 {
            self.submittedTimeInMillis = value
        }
        if let value = dict["TerminatedTimeInMillis"] as? Int64 {
            self.terminatedTimeInMillis = value
        }
        if let value = dict["WebUiAddress"] as? String {
            self.webUiAddress = value
        }
    }
}

public class FieldSchemaModel : Tea.TeaModel {
    public var autoIncrement: Bool?

    public var columnRawName: String?

    public var comment: String?

    public var compressFloatUseShort: Bool?

    public var compression: String?

    public var createTime: String?

    public var dataType: String?

    public var databaseName: String?

    public var defaultValue: String?

    public var delimiter: String?

    public var encode: String?

    public var isPartitionKey: Bool?

    public var mappedName: String?

    public var name: String?

    public var nullable: Bool?

    public var onUpdate: String?

    public var ordinalPosition: Int64?

    public var physicalColumnName: String?

    public var pkPosition: Int64?

    public var precision: Int64?

    public var primarykey: Bool?

    public var scale: Int64?

    public var tableName: String?

    public var tokenizer: String?

    public var type: String?

    public var updateTime: String?

    public var valueType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.autoIncrement != nil {
            map["AutoIncrement"] = self.autoIncrement!
        }
        if self.columnRawName != nil {
            map["ColumnRawName"] = self.columnRawName!
        }
        if self.comment != nil {
            map["Comment"] = self.comment!
        }
        if self.compressFloatUseShort != nil {
            map["CompressFloatUseShort"] = self.compressFloatUseShort!
        }
        if self.compression != nil {
            map["Compression"] = self.compression!
        }
        if self.createTime != nil {
            map["CreateTime"] = self.createTime!
        }
        if self.dataType != nil {
            map["DataType"] = self.dataType!
        }
        if self.databaseName != nil {
            map["DatabaseName"] = self.databaseName!
        }
        if self.defaultValue != nil {
            map["DefaultValue"] = self.defaultValue!
        }
        if self.delimiter != nil {
            map["Delimiter"] = self.delimiter!
        }
        if self.encode != nil {
            map["Encode"] = self.encode!
        }
        if self.isPartitionKey != nil {
            map["IsPartitionKey"] = self.isPartitionKey!
        }
        if self.mappedName != nil {
            map["MappedName"] = self.mappedName!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.nullable != nil {
            map["Nullable"] = self.nullable!
        }
        if self.onUpdate != nil {
            map["OnUpdate"] = self.onUpdate!
        }
        if self.ordinalPosition != nil {
            map["OrdinalPosition"] = self.ordinalPosition!
        }
        if self.physicalColumnName != nil {
            map["PhysicalColumnName"] = self.physicalColumnName!
        }
        if self.pkPosition != nil {
            map["PkPosition"] = self.pkPosition!
        }
        if self.precision != nil {
            map["Precision"] = self.precision!
        }
        if self.primarykey != nil {
            map["Primarykey"] = self.primarykey!
        }
        if self.scale != nil {
            map["Scale"] = self.scale!
        }
        if self.tableName != nil {
            map["TableName"] = self.tableName!
        }
        if self.tokenizer != nil {
            map["Tokenizer"] = self.tokenizer!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        if self.updateTime != nil {
            map["UpdateTime"] = self.updateTime!
        }
        if self.valueType != nil {
            map["ValueType"] = self.valueType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AutoIncrement"] as? Bool {
            self.autoIncrement = value
        }
        if let value = dict["ColumnRawName"] as? String {
            self.columnRawName = value
        }
        if let value = dict["Comment"] as? String {
            self.comment = value
        }
        if let value = dict["CompressFloatUseShort"] as? Bool {
            self.compressFloatUseShort = value
        }
        if let value = dict["Compression"] as? String {
            self.compression = value
        }
        if let value = dict["CreateTime"] as? String {
            self.createTime = value
        }
        if let value = dict["DataType"] as? String {
            self.dataType = value
        }
        if let value = dict["DatabaseName"] as? String {
            self.databaseName = value
        }
        if let value = dict["DefaultValue"] as? String {
            self.defaultValue = value
        }
        if let value = dict["Delimiter"] as? String {
            self.delimiter = value
        }
        if let value = dict["Encode"] as? String {
            self.encode = value
        }
        if let value = dict["IsPartitionKey"] as? Bool {
            self.isPartitionKey = value
        }
        if let value = dict["MappedName"] as? String {
            self.mappedName = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["Nullable"] as? Bool {
            self.nullable = value
        }
        if let value = dict["OnUpdate"] as? String {
            self.onUpdate = value
        }
        if let value = dict["OrdinalPosition"] as? Int64 {
            self.ordinalPosition = value
        }
        if let value = dict["PhysicalColumnName"] as? String {
            self.physicalColumnName = value
        }
        if let value = dict["PkPosition"] as? Int64 {
            self.pkPosition = value
        }
        if let value = dict["Precision"] as? Int64 {
            self.precision = value
        }
        if let value = dict["Primarykey"] as? Bool {
            self.primarykey = value
        }
        if let value = dict["Scale"] as? Int64 {
            self.scale = value
        }
        if let value = dict["TableName"] as? String {
            self.tableName = value
        }
        if let value = dict["Tokenizer"] as? String {
            self.tokenizer = value
        }
        if let value = dict["Type"] as? String {
            self.type = value
        }
        if let value = dict["UpdateTime"] as? String {
            self.updateTime = value
        }
        if let value = dict["ValueType"] as? String {
            self.valueType = value
        }
    }
}

public class Filters : Tea.TeaModel {
    public class ExecutionTimeRange : Tea.TeaModel {
        public var maxTimeInSeconds: Int64?

        public var minTimeInSeconds: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.maxTimeInSeconds != nil {
                map["MaxTimeInSeconds"] = self.maxTimeInSeconds!
            }
            if self.minTimeInSeconds != nil {
                map["MinTimeInSeconds"] = self.minTimeInSeconds!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["MaxTimeInSeconds"] as? Int64 {
                self.maxTimeInSeconds = value
            }
            if let value = dict["MinTimeInSeconds"] as? Int64 {
                self.minTimeInSeconds = value
            }
        }
    }
    public class SubmitTimeRange : Tea.TeaModel {
        public var maxTimeInMills: Int64?

        public var minTimeInMills: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.maxTimeInMills != nil {
                map["MaxTimeInMills"] = self.maxTimeInMills!
            }
            if self.minTimeInMills != nil {
                map["MinTimeInMills"] = self.minTimeInMills!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["MaxTimeInMills"] as? Int64 {
                self.maxTimeInMills = value
            }
            if let value = dict["MinTimeInMills"] as? Int64 {
                self.minTimeInMills = value
            }
        }
    }
    public class TermiatedTimeRange : Tea.TeaModel {
        public var maxTimeInMills: Int64?

        public var minTimeInMills: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.maxTimeInMills != nil {
                map["MaxTimeInMills"] = self.maxTimeInMills!
            }
            if self.minTimeInMills != nil {
                map["MinTimeInMills"] = self.minTimeInMills!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["MaxTimeInMills"] as? Int64 {
                self.maxTimeInMills = value
            }
            if let value = dict["MinTimeInMills"] as? Int64 {
                self.minTimeInMills = value
            }
        }
    }
    public var appIdRegex: String?

    public var appNameRegex: String?

    public var appState: String?

    public var appType: String?

    public var executionTimeRange: Filters.ExecutionTimeRange?

    public var submitTimeRange: Filters.SubmitTimeRange?

    public var termiatedTimeRange: Filters.TermiatedTimeRange?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.executionTimeRange?.validate()
        try self.submitTimeRange?.validate()
        try self.termiatedTimeRange?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appIdRegex != nil {
            map["AppIdRegex"] = self.appIdRegex!
        }
        if self.appNameRegex != nil {
            map["AppNameRegex"] = self.appNameRegex!
        }
        if self.appState != nil {
            map["AppState"] = self.appState!
        }
        if self.appType != nil {
            map["AppType"] = self.appType!
        }
        if self.executionTimeRange != nil {
            map["ExecutionTimeRange"] = self.executionTimeRange?.toMap()
        }
        if self.submitTimeRange != nil {
            map["SubmitTimeRange"] = self.submitTimeRange?.toMap()
        }
        if self.termiatedTimeRange != nil {
            map["TermiatedTimeRange"] = self.termiatedTimeRange?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppIdRegex"] as? String {
            self.appIdRegex = value
        }
        if let value = dict["AppNameRegex"] as? String {
            self.appNameRegex = value
        }
        if let value = dict["AppState"] as? String {
            self.appState = value
        }
        if let value = dict["AppType"] as? String {
            self.appType = value
        }
        if let value = dict["ExecutionTimeRange"] as? [String: Any?] {
            var model = Filters.ExecutionTimeRange()
            model.fromMap(value)
            self.executionTimeRange = model
        }
        if let value = dict["SubmitTimeRange"] as? [String: Any?] {
            var model = Filters.SubmitTimeRange()
            model.fromMap(value)
            self.submitTimeRange = model
        }
        if let value = dict["TermiatedTimeRange"] as? [String: Any?] {
            var model = Filters.TermiatedTimeRange()
            model.fromMap(value)
            self.termiatedTimeRange = model
        }
    }
}

public class LogAnalyzeResult : Tea.TeaModel {
    public var appErrorAdvice: String?

    public var appErrorCode: String?

    public var appErrorLog: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appErrorAdvice != nil {
            map["AppErrorAdvice"] = self.appErrorAdvice!
        }
        if self.appErrorCode != nil {
            map["AppErrorCode"] = self.appErrorCode!
        }
        if self.appErrorLog != nil {
            map["AppErrorLog"] = self.appErrorLog!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppErrorAdvice"] as? String {
            self.appErrorAdvice = value
        }
        if let value = dict["AppErrorCode"] as? String {
            self.appErrorCode = value
        }
        if let value = dict["AppErrorLog"] as? String {
            self.appErrorLog = value
        }
    }
}

public class OperatorNode : Tea.TeaModel {
    public class Stats : Tea.TeaModel {
        public var bytes: Int64?

        public var outputRows: Int64?

        public var parameters: String?

        public var peakMemory: Int64?

        public var timeCost: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.bytes != nil {
                map["bytes"] = self.bytes!
            }
            if self.outputRows != nil {
                map["outputRows"] = self.outputRows!
            }
            if self.parameters != nil {
                map["parameters"] = self.parameters!
            }
            if self.peakMemory != nil {
                map["peakMemory"] = self.peakMemory!
            }
            if self.timeCost != nil {
                map["timeCost"] = self.timeCost!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["bytes"] as? Int64 {
                self.bytes = value
            }
            if let value = dict["outputRows"] as? Int64 {
                self.outputRows = value
            }
            if let value = dict["parameters"] as? String {
                self.parameters = value
            }
            if let value = dict["peakMemory"] as? Int64 {
                self.peakMemory = value
            }
            if let value = dict["timeCost"] as? Int64 {
                self.timeCost = value
            }
        }
    }
    public var children: [OperatorNode]?

    public var id: Int32?

    public var levelWidth: Int32?

    public var nodeDepth: Int32?

    public var nodeName: String?

    public var nodeWidth: Int32?

    public var parentId: Int32?

    public var stats: OperatorNode.Stats?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.stats?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.children != nil {
            var tmp : [Any] = []
            for k in self.children! {
                tmp.append(k.toMap())
            }
            map["children"] = tmp
        }
        if self.id != nil {
            map["id"] = self.id!
        }
        if self.levelWidth != nil {
            map["levelWidth"] = self.levelWidth!
        }
        if self.nodeDepth != nil {
            map["nodeDepth"] = self.nodeDepth!
        }
        if self.nodeName != nil {
            map["nodeName"] = self.nodeName!
        }
        if self.nodeWidth != nil {
            map["nodeWidth"] = self.nodeWidth!
        }
        if self.parentId != nil {
            map["parentId"] = self.parentId!
        }
        if self.stats != nil {
            map["stats"] = self.stats?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["children"] as? [Any?] {
            var tmp : [OperatorNode] = []
            for v in value {
                if v != nil {
                    var model = OperatorNode()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.children = tmp
        }
        if let value = dict["id"] as? Int32 {
            self.id = value
        }
        if let value = dict["levelWidth"] as? Int32 {
            self.levelWidth = value
        }
        if let value = dict["nodeDepth"] as? Int32 {
            self.nodeDepth = value
        }
        if let value = dict["nodeName"] as? String {
            self.nodeName = value
        }
        if let value = dict["nodeWidth"] as? Int32 {
            self.nodeWidth = value
        }
        if let value = dict["parentId"] as? Int32 {
            self.parentId = value
        }
        if let value = dict["stats"] as? [String: Any?] {
            var model = OperatorNode.Stats()
            model.fromMap(value)
            self.stats = model
        }
    }
}

public class SerDeInfoModel : Tea.TeaModel {
    public var name: String?

    public var parameters: [String: String]?

    public var serDeId: Int64?

    public var serializationLib: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.parameters != nil {
            map["Parameters"] = self.parameters!
        }
        if self.serDeId != nil {
            map["SerDeId"] = self.serDeId!
        }
        if self.serializationLib != nil {
            map["SerializationLib"] = self.serializationLib!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["Parameters"] as? [String: String] {
            self.parameters = value
        }
        if let value = dict["SerDeId"] as? Int64 {
            self.serDeId = value
        }
        if let value = dict["SerializationLib"] as? String {
            self.serializationLib = value
        }
    }
}

public class SparkAnalyzeLogTask : Tea.TeaModel {
    public var DBClusterId: String?

    public var result: LogAnalyzeResult?

    public var ruleMatched: Bool?

    public var startedTimeInMillis: Int64?

    public var submittedTimeInMillis: Int64?

    public var taskErrMsg: String?

    public var taskId: Int64?

    public var taskState: String?

    public var terminatedTimeInMillis: Int64?

    public var userId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        if self.ruleMatched != nil {
            map["RuleMatched"] = self.ruleMatched!
        }
        if self.startedTimeInMillis != nil {
            map["StartedTimeInMillis"] = self.startedTimeInMillis!
        }
        if self.submittedTimeInMillis != nil {
            map["SubmittedTimeInMillis"] = self.submittedTimeInMillis!
        }
        if self.taskErrMsg != nil {
            map["TaskErrMsg"] = self.taskErrMsg!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        if self.taskState != nil {
            map["TaskState"] = self.taskState!
        }
        if self.terminatedTimeInMillis != nil {
            map["TerminatedTimeInMillis"] = self.terminatedTimeInMillis!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["Result"] as? [String: Any?] {
            var model = LogAnalyzeResult()
            model.fromMap(value)
            self.result = model
        }
        if let value = dict["RuleMatched"] as? Bool {
            self.ruleMatched = value
        }
        if let value = dict["StartedTimeInMillis"] as? Int64 {
            self.startedTimeInMillis = value
        }
        if let value = dict["SubmittedTimeInMillis"] as? Int64 {
            self.submittedTimeInMillis = value
        }
        if let value = dict["TaskErrMsg"] as? String {
            self.taskErrMsg = value
        }
        if let value = dict["TaskId"] as? Int64 {
            self.taskId = value
        }
        if let value = dict["TaskState"] as? String {
            self.taskState = value
        }
        if let value = dict["TerminatedTimeInMillis"] as? Int64 {
            self.terminatedTimeInMillis = value
        }
        if let value = dict["UserId"] as? Int64 {
            self.userId = value
        }
    }
}

public class SparkAppInfo : Tea.TeaModel {
    public var appId: String?

    public var appName: String?

    public var DBClusterId: String?

    public var detail: Detail?

    public var message: String?

    public var priority: String?

    public var state: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.detail?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.detail != nil {
            map["Detail"] = self.detail?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.priority != nil {
            map["Priority"] = self.priority!
        }
        if self.state != nil {
            map["State"] = self.state!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["AppName"] as? String {
            self.appName = value
        }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["Detail"] as? [String: Any?] {
            var model = Detail()
            model.fromMap(value)
            self.detail = model
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["Priority"] as? String {
            self.priority = value
        }
        if let value = dict["State"] as? String {
            self.state = value
        }
    }
}

public class SparkAttemptInfo : Tea.TeaModel {
    public var attemptId: String?

    public var detail: Detail?

    public var message: String?

    public var priority: String?

    public var state: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.detail?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.attemptId != nil {
            map["AttemptId"] = self.attemptId!
        }
        if self.detail != nil {
            map["Detail"] = self.detail?.toMap()
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.priority != nil {
            map["Priority"] = self.priority!
        }
        if self.state != nil {
            map["State"] = self.state!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AttemptId"] as? String {
            self.attemptId = value
        }
        if let value = dict["Detail"] as? [String: Any?] {
            var model = Detail()
            model.fromMap(value)
            self.detail = model
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["Priority"] as? String {
            self.priority = value
        }
        if let value = dict["State"] as? String {
            self.state = value
        }
    }
}

public class SparkBatchSQL : Tea.TeaModel {
    public var DBClusterId: String?

    public var errMessage: String?

    public var query: String?

    public var queryEndTime: Int64?

    public var queryId: String?

    public var queryStartTime: Int64?

    public var queryState: String?

    public var querySubmissionTime: Int64?

    public var resourceGroupName: String?

    public var schema: String?

    public var statements: [SparkBatchSQLStatement]?

    public var uid: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.errMessage != nil {
            map["ErrMessage"] = self.errMessage!
        }
        if self.query != nil {
            map["Query"] = self.query!
        }
        if self.queryEndTime != nil {
            map["QueryEndTime"] = self.queryEndTime!
        }
        if self.queryId != nil {
            map["QueryId"] = self.queryId!
        }
        if self.queryStartTime != nil {
            map["QueryStartTime"] = self.queryStartTime!
        }
        if self.queryState != nil {
            map["QueryState"] = self.queryState!
        }
        if self.querySubmissionTime != nil {
            map["QuerySubmissionTime"] = self.querySubmissionTime!
        }
        if self.resourceGroupName != nil {
            map["ResourceGroupName"] = self.resourceGroupName!
        }
        if self.schema != nil {
            map["Schema"] = self.schema!
        }
        if self.statements != nil {
            var tmp : [Any] = []
            for k in self.statements! {
                tmp.append(k.toMap())
            }
            map["Statements"] = tmp
        }
        if self.uid != nil {
            map["Uid"] = self.uid!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["ErrMessage"] as? String {
            self.errMessage = value
        }
        if let value = dict["Query"] as? String {
            self.query = value
        }
        if let value = dict["QueryEndTime"] as? Int64 {
            self.queryEndTime = value
        }
        if let value = dict["QueryId"] as? String {
            self.queryId = value
        }
        if let value = dict["QueryStartTime"] as? Int64 {
            self.queryStartTime = value
        }
        if let value = dict["QueryState"] as? String {
            self.queryState = value
        }
        if let value = dict["QuerySubmissionTime"] as? Int64 {
            self.querySubmissionTime = value
        }
        if let value = dict["ResourceGroupName"] as? String {
            self.resourceGroupName = value
        }
        if let value = dict["Schema"] as? String {
            self.schema = value
        }
        if let value = dict["Statements"] as? [Any?] {
            var tmp : [SparkBatchSQLStatement] = []
            for v in value {
                if v != nil {
                    var model = SparkBatchSQLStatement()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.statements = tmp
        }
        if let value = dict["Uid"] as? Int64 {
            self.uid = value
        }
    }
}

public class SparkBatchSQLStatement : Tea.TeaModel {
    public var appId: String?

    public var code: String?

    public var endTime: Int64?

    public var error: String?

    public var result: String?

    public var resultUri: String?

    public var startTime: Int64?

    public var state: String?

    public var statementId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.error != nil {
            map["Error"] = self.error!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        if self.resultUri != nil {
            map["ResultUri"] = self.resultUri!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.state != nil {
            map["State"] = self.state!
        }
        if self.statementId != nil {
            map["StatementId"] = self.statementId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["EndTime"] as? Int64 {
            self.endTime = value
        }
        if let value = dict["Error"] as? String {
            self.error = value
        }
        if let value = dict["Result"] as? String {
            self.result = value
        }
        if let value = dict["ResultUri"] as? String {
            self.resultUri = value
        }
        if let value = dict["StartTime"] as? Int64 {
            self.startTime = value
        }
        if let value = dict["State"] as? String {
            self.state = value
        }
        if let value = dict["StatementId"] as? String {
            self.statementId = value
        }
    }
}

public class SparkOperatorInfo : Tea.TeaModel {
    public var metricValue: Int64?

    public var operatorName: [UInt8]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.metricValue != nil {
            map["MetricValue"] = self.metricValue!
        }
        if self.operatorName != nil {
            map["OperatorName"] = self.operatorName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["MetricValue"] as? Int64 {
            self.metricValue = value
        }
        if let value = dict["OperatorName"] as? [UInt8] {
            self.operatorName = value
        }
    }
}

public class SparkSession : Tea.TeaModel {
    public var active: String?

    public var aliyunUid: Int64?

    public var sessionId: Int64?

    public var state: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.active != nil {
            map["Active"] = self.active!
        }
        if self.aliyunUid != nil {
            map["AliyunUid"] = self.aliyunUid!
        }
        if self.sessionId != nil {
            map["SessionId"] = self.sessionId!
        }
        if self.state != nil {
            map["State"] = self.state!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Active"] as? String {
            self.active = value
        }
        if let value = dict["AliyunUid"] as? Int64 {
            self.aliyunUid = value
        }
        if let value = dict["SessionId"] as? Int64 {
            self.sessionId = value
        }
        if let value = dict["State"] as? String {
            self.state = value
        }
    }
}

public class Statement : Tea.TeaModel {
    public var aliyunUid: Int64?

    public var code: String?

    public var codeState: String?

    public var codeType: String?

    public var endTime: Int64?

    public var error: String?

    public var haveRows: Bool?

    public var output: String?

    public var resourceGroup: String?

    public var sessionId: Int64?

    public var startTime: Int64?

    public var statementId: Int64?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aliyunUid != nil {
            map["AliyunUid"] = self.aliyunUid!
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.codeState != nil {
            map["CodeState"] = self.codeState!
        }
        if self.codeType != nil {
            map["CodeType"] = self.codeType!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.error != nil {
            map["Error"] = self.error!
        }
        if self.haveRows != nil {
            map["HaveRows"] = self.haveRows!
        }
        if self.output != nil {
            map["Output"] = self.output!
        }
        if self.resourceGroup != nil {
            map["ResourceGroup"] = self.resourceGroup!
        }
        if self.sessionId != nil {
            map["SessionId"] = self.sessionId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.statementId != nil {
            map["StatementId"] = self.statementId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AliyunUid"] as? Int64 {
            self.aliyunUid = value
        }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["CodeState"] as? String {
            self.codeState = value
        }
        if let value = dict["CodeType"] as? String {
            self.codeType = value
        }
        if let value = dict["EndTime"] as? Int64 {
            self.endTime = value
        }
        if let value = dict["Error"] as? String {
            self.error = value
        }
        if let value = dict["HaveRows"] as? Bool {
            self.haveRows = value
        }
        if let value = dict["Output"] as? String {
            self.output = value
        }
        if let value = dict["ResourceGroup"] as? String {
            self.resourceGroup = value
        }
        if let value = dict["SessionId"] as? Int64 {
            self.sessionId = value
        }
        if let value = dict["StartTime"] as? Int64 {
            self.startTime = value
        }
        if let value = dict["StatementId"] as? Int64 {
            self.statementId = value
        }
        if let value = dict["TotalCount"] as? Int64 {
            self.totalCount = value
        }
    }
}

public class StatementInfo : Tea.TeaModel {
    public var code: String?

    public var completedTimeInMills: Int64?

    public var output: String?

    public var process: Double?

    public var startedTimeInMills: Int64?

    public var state: String?

    public var statementId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.completedTimeInMills != nil {
            map["CompletedTimeInMills"] = self.completedTimeInMills!
        }
        if self.output != nil {
            map["Output"] = self.output!
        }
        if self.process != nil {
            map["Process"] = self.process!
        }
        if self.startedTimeInMills != nil {
            map["StartedTimeInMills"] = self.startedTimeInMills!
        }
        if self.state != nil {
            map["State"] = self.state!
        }
        if self.statementId != nil {
            map["StatementId"] = self.statementId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["CompletedTimeInMills"] as? Int64 {
            self.completedTimeInMills = value
        }
        if let value = dict["Output"] as? String {
            self.output = value
        }
        if let value = dict["Process"] as? Double {
            self.process = value
        }
        if let value = dict["StartedTimeInMills"] as? Int64 {
            self.startedTimeInMills = value
        }
        if let value = dict["State"] as? String {
            self.state = value
        }
        if let value = dict["StatementId"] as? String {
            self.statementId = value
        }
    }
}

public class StorageDescriptorModel : Tea.TeaModel {
    public var compressed: Bool?

    public var inputFormat: String?

    public var location: String?

    public var numBuckets: Int64?

    public var outputFormat: String?

    public var parameters: [String: String]?

    public var sdId: Int64?

    public var serDeInfo: SerDeInfoModel?

    public var storedAsSubDirectories: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.serDeInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.compressed != nil {
            map["Compressed"] = self.compressed!
        }
        if self.inputFormat != nil {
            map["InputFormat"] = self.inputFormat!
        }
        if self.location != nil {
            map["Location"] = self.location!
        }
        if self.numBuckets != nil {
            map["NumBuckets"] = self.numBuckets!
        }
        if self.outputFormat != nil {
            map["OutputFormat"] = self.outputFormat!
        }
        if self.parameters != nil {
            map["Parameters"] = self.parameters!
        }
        if self.sdId != nil {
            map["SdId"] = self.sdId!
        }
        if self.serDeInfo != nil {
            map["SerDeInfo"] = self.serDeInfo?.toMap()
        }
        if self.storedAsSubDirectories != nil {
            map["StoredAsSubDirectories"] = self.storedAsSubDirectories!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Compressed"] as? Bool {
            self.compressed = value
        }
        if let value = dict["InputFormat"] as? String {
            self.inputFormat = value
        }
        if let value = dict["Location"] as? String {
            self.location = value
        }
        if let value = dict["NumBuckets"] as? Int64 {
            self.numBuckets = value
        }
        if let value = dict["OutputFormat"] as? String {
            self.outputFormat = value
        }
        if let value = dict["Parameters"] as? [String: String] {
            self.parameters = value
        }
        if let value = dict["SdId"] as? Int64 {
            self.sdId = value
        }
        if let value = dict["SerDeInfo"] as? [String: Any?] {
            var model = SerDeInfoModel()
            model.fromMap(value)
            self.serDeInfo = model
        }
        if let value = dict["StoredAsSubDirectories"] as? Bool {
            self.storedAsSubDirectories = value
        }
    }
}

public class TableDetailModel : Tea.TeaModel {
    public var catalog: String?

    public var columns: [ColDetailModel]?

    public var createTime: String?

    public var description_: String?

    public var owner: String?

    public var schemaName: String?

    public var tableName: String?

    public var tableType: String?

    public var updateTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.catalog != nil {
            map["Catalog"] = self.catalog!
        }
        if self.columns != nil {
            var tmp : [Any] = []
            for k in self.columns! {
                tmp.append(k.toMap())
            }
            map["Columns"] = tmp
        }
        if self.createTime != nil {
            map["CreateTime"] = self.createTime!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.owner != nil {
            map["Owner"] = self.owner!
        }
        if self.schemaName != nil {
            map["SchemaName"] = self.schemaName!
        }
        if self.tableName != nil {
            map["TableName"] = self.tableName!
        }
        if self.tableType != nil {
            map["TableType"] = self.tableType!
        }
        if self.updateTime != nil {
            map["UpdateTime"] = self.updateTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Catalog"] as? String {
            self.catalog = value
        }
        if let value = dict["Columns"] as? [Any?] {
            var tmp : [ColDetailModel] = []
            for v in value {
                if v != nil {
                    var model = ColDetailModel()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.columns = tmp
        }
        if let value = dict["CreateTime"] as? String {
            self.createTime = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["Owner"] as? String {
            self.owner = value
        }
        if let value = dict["SchemaName"] as? String {
            self.schemaName = value
        }
        if let value = dict["TableName"] as? String {
            self.tableName = value
        }
        if let value = dict["TableType"] as? String {
            self.tableType = value
        }
        if let value = dict["UpdateTime"] as? String {
            self.updateTime = value
        }
    }
}

public class TableModel : Tea.TeaModel {
    public var archiveType: String?

    public var blockSize: Int64?

    public var bucket: Int64?

    public var bucketCount: Int64?

    public var cols: [FieldSchemaModel]?

    public var comment: String?

    public var compression: String?

    public var createTime: String?

    public var currentVersion: Int64?

    public var dbName: String?

    public var dictEncode: Bool?

    public var distributeColumns: [FieldSchemaModel]?

    public var distributeType: String?

    public var enableDfs: Bool?

    public var hotPartitionCount: Int64?

    public var indexes: [CstoreIndexModel]?

    public var isAllIndex: Bool?

    public var isFulltextDict: Bool?

    public var maxColumnId: Int64?

    public var parameters: [String: String]?

    public var partitionColumn: String?

    public var partitionCount: Int64?

    public var partitionKeys: [FieldSchemaModel]?

    public var partitionType: String?

    public var physicalDatabaseName: String?

    public var physicalTableName: String?

    public var previousVersion: Int64?

    public var rawTableName: String?

    public var routeColumns: [FieldSchemaModel]?

    public var routeEffectiveColumn: FieldSchemaModel?

    public var routeType: String?

    public var rtEngineType: String?

    public var rtIndexAll: Bool?

    public var rtModeType: String?

    public var sd: StorageDescriptorModel?

    public var storagePolicy: String?

    public var subpartitionColumn: String?

    public var subpartitionCount: Int64?

    public var subpartitionType: String?

    public var tableEngineName: String?

    public var tableName: String?

    public var tableType: String?

    public var tblId: Int64?

    public var temporary: Bool?

    public var updateTime: String?

    public var viewExpandedText: String?

    public var viewOriginalText: String?

    public var viewSecurityMode: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.routeEffectiveColumn?.validate()
        try self.sd?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.archiveType != nil {
            map["ArchiveType"] = self.archiveType!
        }
        if self.blockSize != nil {
            map["BlockSize"] = self.blockSize!
        }
        if self.bucket != nil {
            map["Bucket"] = self.bucket!
        }
        if self.bucketCount != nil {
            map["BucketCount"] = self.bucketCount!
        }
        if self.cols != nil {
            var tmp : [Any] = []
            for k in self.cols! {
                tmp.append(k.toMap())
            }
            map["Cols"] = tmp
        }
        if self.comment != nil {
            map["Comment"] = self.comment!
        }
        if self.compression != nil {
            map["Compression"] = self.compression!
        }
        if self.createTime != nil {
            map["CreateTime"] = self.createTime!
        }
        if self.currentVersion != nil {
            map["CurrentVersion"] = self.currentVersion!
        }
        if self.dbName != nil {
            map["DbName"] = self.dbName!
        }
        if self.dictEncode != nil {
            map["DictEncode"] = self.dictEncode!
        }
        if self.distributeColumns != nil {
            var tmp : [Any] = []
            for k in self.distributeColumns! {
                tmp.append(k.toMap())
            }
            map["DistributeColumns"] = tmp
        }
        if self.distributeType != nil {
            map["DistributeType"] = self.distributeType!
        }
        if self.enableDfs != nil {
            map["EnableDfs"] = self.enableDfs!
        }
        if self.hotPartitionCount != nil {
            map["HotPartitionCount"] = self.hotPartitionCount!
        }
        if self.indexes != nil {
            var tmp : [Any] = []
            for k in self.indexes! {
                tmp.append(k.toMap())
            }
            map["Indexes"] = tmp
        }
        if self.isAllIndex != nil {
            map["IsAllIndex"] = self.isAllIndex!
        }
        if self.isFulltextDict != nil {
            map["IsFulltextDict"] = self.isFulltextDict!
        }
        if self.maxColumnId != nil {
            map["MaxColumnId"] = self.maxColumnId!
        }
        if self.parameters != nil {
            map["Parameters"] = self.parameters!
        }
        if self.partitionColumn != nil {
            map["PartitionColumn"] = self.partitionColumn!
        }
        if self.partitionCount != nil {
            map["PartitionCount"] = self.partitionCount!
        }
        if self.partitionKeys != nil {
            var tmp : [Any] = []
            for k in self.partitionKeys! {
                tmp.append(k.toMap())
            }
            map["PartitionKeys"] = tmp
        }
        if self.partitionType != nil {
            map["PartitionType"] = self.partitionType!
        }
        if self.physicalDatabaseName != nil {
            map["PhysicalDatabaseName"] = self.physicalDatabaseName!
        }
        if self.physicalTableName != nil {
            map["PhysicalTableName"] = self.physicalTableName!
        }
        if self.previousVersion != nil {
            map["PreviousVersion"] = self.previousVersion!
        }
        if self.rawTableName != nil {
            map["RawTableName"] = self.rawTableName!
        }
        if self.routeColumns != nil {
            var tmp : [Any] = []
            for k in self.routeColumns! {
                tmp.append(k.toMap())
            }
            map["RouteColumns"] = tmp
        }
        if self.routeEffectiveColumn != nil {
            map["RouteEffectiveColumn"] = self.routeEffectiveColumn?.toMap()
        }
        if self.routeType != nil {
            map["RouteType"] = self.routeType!
        }
        if self.rtEngineType != nil {
            map["RtEngineType"] = self.rtEngineType!
        }
        if self.rtIndexAll != nil {
            map["RtIndexAll"] = self.rtIndexAll!
        }
        if self.rtModeType != nil {
            map["RtModeType"] = self.rtModeType!
        }
        if self.sd != nil {
            map["Sd"] = self.sd?.toMap()
        }
        if self.storagePolicy != nil {
            map["StoragePolicy"] = self.storagePolicy!
        }
        if self.subpartitionColumn != nil {
            map["SubpartitionColumn"] = self.subpartitionColumn!
        }
        if self.subpartitionCount != nil {
            map["SubpartitionCount"] = self.subpartitionCount!
        }
        if self.subpartitionType != nil {
            map["SubpartitionType"] = self.subpartitionType!
        }
        if self.tableEngineName != nil {
            map["TableEngineName"] = self.tableEngineName!
        }
        if self.tableName != nil {
            map["TableName"] = self.tableName!
        }
        if self.tableType != nil {
            map["TableType"] = self.tableType!
        }
        if self.tblId != nil {
            map["TblId"] = self.tblId!
        }
        if self.temporary != nil {
            map["Temporary"] = self.temporary!
        }
        if self.updateTime != nil {
            map["UpdateTime"] = self.updateTime!
        }
        if self.viewExpandedText != nil {
            map["ViewExpandedText"] = self.viewExpandedText!
        }
        if self.viewOriginalText != nil {
            map["ViewOriginalText"] = self.viewOriginalText!
        }
        if self.viewSecurityMode != nil {
            map["ViewSecurityMode"] = self.viewSecurityMode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ArchiveType"] as? String {
            self.archiveType = value
        }
        if let value = dict["BlockSize"] as? Int64 {
            self.blockSize = value
        }
        if let value = dict["Bucket"] as? Int64 {
            self.bucket = value
        }
        if let value = dict["BucketCount"] as? Int64 {
            self.bucketCount = value
        }
        if let value = dict["Cols"] as? [Any?] {
            var tmp : [FieldSchemaModel] = []
            for v in value {
                if v != nil {
                    var model = FieldSchemaModel()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.cols = tmp
        }
        if let value = dict["Comment"] as? String {
            self.comment = value
        }
        if let value = dict["Compression"] as? String {
            self.compression = value
        }
        if let value = dict["CreateTime"] as? String {
            self.createTime = value
        }
        if let value = dict["CurrentVersion"] as? Int64 {
            self.currentVersion = value
        }
        if let value = dict["DbName"] as? String {
            self.dbName = value
        }
        if let value = dict["DictEncode"] as? Bool {
            self.dictEncode = value
        }
        if let value = dict["DistributeColumns"] as? [Any?] {
            var tmp : [FieldSchemaModel] = []
            for v in value {
                if v != nil {
                    var model = FieldSchemaModel()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.distributeColumns = tmp
        }
        if let value = dict["DistributeType"] as? String {
            self.distributeType = value
        }
        if let value = dict["EnableDfs"] as? Bool {
            self.enableDfs = value
        }
        if let value = dict["HotPartitionCount"] as? Int64 {
            self.hotPartitionCount = value
        }
        if let value = dict["Indexes"] as? [Any?] {
            var tmp : [CstoreIndexModel] = []
            for v in value {
                if v != nil {
                    var model = CstoreIndexModel()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.indexes = tmp
        }
        if let value = dict["IsAllIndex"] as? Bool {
            self.isAllIndex = value
        }
        if let value = dict["IsFulltextDict"] as? Bool {
            self.isFulltextDict = value
        }
        if let value = dict["MaxColumnId"] as? Int64 {
            self.maxColumnId = value
        }
        if let value = dict["Parameters"] as? [String: String] {
            self.parameters = value
        }
        if let value = dict["PartitionColumn"] as? String {
            self.partitionColumn = value
        }
        if let value = dict["PartitionCount"] as? Int64 {
            self.partitionCount = value
        }
        if let value = dict["PartitionKeys"] as? [Any?] {
            var tmp : [FieldSchemaModel] = []
            for v in value {
                if v != nil {
                    var model = FieldSchemaModel()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.partitionKeys = tmp
        }
        if let value = dict["PartitionType"] as? String {
            self.partitionType = value
        }
        if let value = dict["PhysicalDatabaseName"] as? String {
            self.physicalDatabaseName = value
        }
        if let value = dict["PhysicalTableName"] as? String {
            self.physicalTableName = value
        }
        if let value = dict["PreviousVersion"] as? Int64 {
            self.previousVersion = value
        }
        if let value = dict["RawTableName"] as? String {
            self.rawTableName = value
        }
        if let value = dict["RouteColumns"] as? [Any?] {
            var tmp : [FieldSchemaModel] = []
            for v in value {
                if v != nil {
                    var model = FieldSchemaModel()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.routeColumns = tmp
        }
        if let value = dict["RouteEffectiveColumn"] as? [String: Any?] {
            var model = FieldSchemaModel()
            model.fromMap(value)
            self.routeEffectiveColumn = model
        }
        if let value = dict["RouteType"] as? String {
            self.routeType = value
        }
        if let value = dict["RtEngineType"] as? String {
            self.rtEngineType = value
        }
        if let value = dict["RtIndexAll"] as? Bool {
            self.rtIndexAll = value
        }
        if let value = dict["RtModeType"] as? String {
            self.rtModeType = value
        }
        if let value = dict["Sd"] as? [String: Any?] {
            var model = StorageDescriptorModel()
            model.fromMap(value)
            self.sd = model
        }
        if let value = dict["StoragePolicy"] as? String {
            self.storagePolicy = value
        }
        if let value = dict["SubpartitionColumn"] as? String {
            self.subpartitionColumn = value
        }
        if let value = dict["SubpartitionCount"] as? Int64 {
            self.subpartitionCount = value
        }
        if let value = dict["SubpartitionType"] as? String {
            self.subpartitionType = value
        }
        if let value = dict["TableEngineName"] as? String {
            self.tableEngineName = value
        }
        if let value = dict["TableName"] as? String {
            self.tableName = value
        }
        if let value = dict["TableType"] as? String {
            self.tableType = value
        }
        if let value = dict["TblId"] as? Int64 {
            self.tblId = value
        }
        if let value = dict["Temporary"] as? Bool {
            self.temporary = value
        }
        if let value = dict["UpdateTime"] as? String {
            self.updateTime = value
        }
        if let value = dict["ViewExpandedText"] as? String {
            self.viewExpandedText = value
        }
        if let value = dict["ViewOriginalText"] as? String {
            self.viewOriginalText = value
        }
        if let value = dict["ViewSecurityMode"] as? String {
            self.viewSecurityMode = value
        }
    }
}

public class TableSummaryModel : Tea.TeaModel {
    public var createTime: String?

    public var description_: String?

    public var mvDetailModel: OpenStructMvDetailModel?

    public var owner: String?

    public var SQL: String?

    public var schemaName: String?

    public var tableName: String?

    public var tableSize: Int64?

    public var tableType: String?

    public var updateTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.mvDetailModel?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.createTime != nil {
            map["CreateTime"] = self.createTime!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.mvDetailModel != nil {
            map["MvDetailModel"] = self.mvDetailModel?.toMap()
        }
        if self.owner != nil {
            map["Owner"] = self.owner!
        }
        if self.SQL != nil {
            map["SQL"] = self.SQL!
        }
        if self.schemaName != nil {
            map["SchemaName"] = self.schemaName!
        }
        if self.tableName != nil {
            map["TableName"] = self.tableName!
        }
        if self.tableSize != nil {
            map["TableSize"] = self.tableSize!
        }
        if self.tableType != nil {
            map["TableType"] = self.tableType!
        }
        if self.updateTime != nil {
            map["UpdateTime"] = self.updateTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CreateTime"] as? String {
            self.createTime = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["MvDetailModel"] as? [String: Any?] {
            var model = OpenStructMvDetailModel()
            model.fromMap(value)
            self.mvDetailModel = model
        }
        if let value = dict["Owner"] as? String {
            self.owner = value
        }
        if let value = dict["SQL"] as? String {
            self.SQL = value
        }
        if let value = dict["SchemaName"] as? String {
            self.schemaName = value
        }
        if let value = dict["TableName"] as? String {
            self.tableName = value
        }
        if let value = dict["TableSize"] as? Int64 {
            self.tableSize = value
        }
        if let value = dict["TableType"] as? String {
            self.tableType = value
        }
        if let value = dict["UpdateTime"] as? String {
            self.updateTime = value
        }
    }
}

public class OpenStructMVRecommendResultModel : Tea.TeaModel {
    public var acceleratedQueriesCount: Int64?

    public var baseTables: [OpenStructMvBaseTableDetailModel]?

    public var savedScanbytes: Int64?

    public var subquery: String?

    public var subqueryId: Int64?

    public var supportIncrementalRefresh: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceleratedQueriesCount != nil {
            map["AcceleratedQueriesCount"] = self.acceleratedQueriesCount!
        }
        if self.baseTables != nil {
            var tmp : [Any] = []
            for k in self.baseTables! {
                tmp.append(k.toMap())
            }
            map["BaseTables"] = tmp
        }
        if self.savedScanbytes != nil {
            map["SavedScanbytes"] = self.savedScanbytes!
        }
        if self.subquery != nil {
            map["Subquery"] = self.subquery!
        }
        if self.subqueryId != nil {
            map["SubqueryId"] = self.subqueryId!
        }
        if self.supportIncrementalRefresh != nil {
            map["SupportIncrementalRefresh"] = self.supportIncrementalRefresh!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AcceleratedQueriesCount"] as? Int64 {
            self.acceleratedQueriesCount = value
        }
        if let value = dict["BaseTables"] as? [Any?] {
            var tmp : [OpenStructMvBaseTableDetailModel] = []
            for v in value {
                if v != nil {
                    var model = OpenStructMvBaseTableDetailModel()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.baseTables = tmp
        }
        if let value = dict["SavedScanbytes"] as? Int64 {
            self.savedScanbytes = value
        }
        if let value = dict["Subquery"] as? String {
            self.subquery = value
        }
        if let value = dict["SubqueryId"] as? Int64 {
            self.subqueryId = value
        }
        if let value = dict["SupportIncrementalRefresh"] as? Bool {
            self.supportIncrementalRefresh = value
        }
    }
}

public class OpenStructMvBaseTableDetailModel : Tea.TeaModel {
    public var dataVolumn: String?

    public var enableBinlog: Bool?

    public var schemaName: String?

    public var tableName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dataVolumn != nil {
            map["DataVolumn"] = self.dataVolumn!
        }
        if self.enableBinlog != nil {
            map["EnableBinlog"] = self.enableBinlog!
        }
        if self.schemaName != nil {
            map["SchemaName"] = self.schemaName!
        }
        if self.tableName != nil {
            map["TableName"] = self.tableName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DataVolumn"] as? String {
            self.dataVolumn = value
        }
        if let value = dict["EnableBinlog"] as? Bool {
            self.enableBinlog = value
        }
        if let value = dict["SchemaName"] as? String {
            self.schemaName = value
        }
        if let value = dict["TableName"] as? String {
            self.tableName = value
        }
    }
}

public class OpenStructMvDetailModel : Tea.TeaModel {
    public var baseTableNames: [[String]]?

    public var explicitHit: Int64?

    public var firstRefreshTime: String?

    public var implicitHit: Int64?

    public var isInactive: Bool?

    public var localSize: Int64?

    public var queryRewriteEnabled: Bool?

    public var refreshInterval: String?

    public var refreshState: String?

    public var remoteSize: Int64?

    public var resourceGroup: String?

    public var updatedAt: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.baseTableNames != nil {
            map["BaseTableNames"] = self.baseTableNames!
        }
        if self.explicitHit != nil {
            map["ExplicitHit"] = self.explicitHit!
        }
        if self.firstRefreshTime != nil {
            map["FirstRefreshTime"] = self.firstRefreshTime!
        }
        if self.implicitHit != nil {
            map["ImplicitHit"] = self.implicitHit!
        }
        if self.isInactive != nil {
            map["IsInactive"] = self.isInactive!
        }
        if self.localSize != nil {
            map["LocalSize"] = self.localSize!
        }
        if self.queryRewriteEnabled != nil {
            map["QueryRewriteEnabled"] = self.queryRewriteEnabled!
        }
        if self.refreshInterval != nil {
            map["RefreshInterval"] = self.refreshInterval!
        }
        if self.refreshState != nil {
            map["RefreshState"] = self.refreshState!
        }
        if self.remoteSize != nil {
            map["RemoteSize"] = self.remoteSize!
        }
        if self.resourceGroup != nil {
            map["ResourceGroup"] = self.resourceGroup!
        }
        if self.updatedAt != nil {
            map["UpdatedAt"] = self.updatedAt!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["BaseTableNames"] as? [[String]] {
            self.baseTableNames = value
        }
        if let value = dict["ExplicitHit"] as? Int64 {
            self.explicitHit = value
        }
        if let value = dict["FirstRefreshTime"] as? String {
            self.firstRefreshTime = value
        }
        if let value = dict["ImplicitHit"] as? Int64 {
            self.implicitHit = value
        }
        if let value = dict["IsInactive"] as? Bool {
            self.isInactive = value
        }
        if let value = dict["LocalSize"] as? Int64 {
            self.localSize = value
        }
        if let value = dict["QueryRewriteEnabled"] as? Bool {
            self.queryRewriteEnabled = value
        }
        if let value = dict["RefreshInterval"] as? String {
            self.refreshInterval = value
        }
        if let value = dict["RefreshState"] as? String {
            self.refreshState = value
        }
        if let value = dict["RemoteSize"] as? Int64 {
            self.remoteSize = value
        }
        if let value = dict["ResourceGroup"] as? String {
            self.resourceGroup = value
        }
        if let value = dict["UpdatedAt"] as? String {
            self.updatedAt = value
        }
    }
}

public class OpenStructMvRecommendSubTaskModel : Tea.TeaModel {
    public var endTime: String?

    public var scanQueriesCount: Int64?

    public var startTime: String?

    public var status: String?

    public var subQueriesCount: Int64?

    public var subtaskId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.scanQueriesCount != nil {
            map["ScanQueriesCount"] = self.scanQueriesCount!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.subQueriesCount != nil {
            map["SubQueriesCount"] = self.subQueriesCount!
        }
        if self.subtaskId != nil {
            map["SubtaskId"] = self.subtaskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["ScanQueriesCount"] as? Int64 {
            self.scanQueriesCount = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
        if let value = dict["Status"] as? String {
            self.status = value
        }
        if let value = dict["SubQueriesCount"] as? Int64 {
            self.subQueriesCount = value
        }
        if let value = dict["SubtaskId"] as? Int64 {
            self.subtaskId = value
        }
    }
}

public class OpenStructMvRecommendTaskModel : Tea.TeaModel {
    public var createdTime: String?

    public var description_: String?

    public var lastRunAt: String?

    public var scanQueriesRange: Int32?

    public var schedulingSettings: String?

    public var taskName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.createdTime != nil {
            map["CreatedTime"] = self.createdTime!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.lastRunAt != nil {
            map["LastRunAt"] = self.lastRunAt!
        }
        if self.scanQueriesRange != nil {
            map["ScanQueriesRange"] = self.scanQueriesRange!
        }
        if self.schedulingSettings != nil {
            map["SchedulingSettings"] = self.schedulingSettings!
        }
        if self.taskName != nil {
            map["TaskName"] = self.taskName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CreatedTime"] as? String {
            self.createdTime = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["LastRunAt"] as? String {
            self.lastRunAt = value
        }
        if let value = dict["ScanQueriesRange"] as? Int32 {
            self.scanQueriesRange = value
        }
        if let value = dict["SchedulingSettings"] as? String {
            self.schedulingSettings = value
        }
        if let value = dict["TaskName"] as? String {
            self.taskName = value
        }
    }
}

public class OpenStructRefreshJobModel : Tea.TeaModel {
    public var endTime: String?

    public var name: String?

    public var processid: String?

    public var refreshInterval: String?

    public var refreshModel: String?

    public var resourceGroup: String?

    public var schemaName: String?

    public var startTime: String?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.processid != nil {
            map["Processid"] = self.processid!
        }
        if self.refreshInterval != nil {
            map["RefreshInterval"] = self.refreshInterval!
        }
        if self.refreshModel != nil {
            map["RefreshModel"] = self.refreshModel!
        }
        if self.resourceGroup != nil {
            map["ResourceGroup"] = self.resourceGroup!
        }
        if self.schemaName != nil {
            map["SchemaName"] = self.schemaName!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["Processid"] as? String {
            self.processid = value
        }
        if let value = dict["RefreshInterval"] as? String {
            self.refreshInterval = value
        }
        if let value = dict["RefreshModel"] as? String {
            self.refreshModel = value
        }
        if let value = dict["ResourceGroup"] as? String {
            self.resourceGroup = value
        }
        if let value = dict["SchemaName"] as? String {
            self.schemaName = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
        if let value = dict["Status"] as? String {
            self.status = value
        }
    }
}

public class AllocateClusterPublicConnectionRequest : Tea.TeaModel {
    public var connectionStringPrefix: String?

    public var DBClusterId: String?

    public var engine: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.connectionStringPrefix != nil {
            map["ConnectionStringPrefix"] = self.connectionStringPrefix!
        }
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.engine != nil {
            map["Engine"] = self.engine!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ConnectionStringPrefix"] as? String {
            self.connectionStringPrefix = value
        }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["Engine"] as? String {
            self.engine = value
        }
    }
}

public class AllocateClusterPublicConnectionResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class AllocateClusterPublicConnectionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AllocateClusterPublicConnectionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = AllocateClusterPublicConnectionResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ApplyAdviceByIdRequest : Tea.TeaModel {
    public var adviceDate: Int64?

    public var adviceId: String?

    public var DBClusterId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.adviceDate != nil {
            map["AdviceDate"] = self.adviceDate!
        }
        if self.adviceId != nil {
            map["AdviceId"] = self.adviceId!
        }
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AdviceDate"] as? Int64 {
            self.adviceDate = value
        }
        if let value = dict["AdviceId"] as? String {
            self.adviceId = value
        }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class ApplyAdviceByIdResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ApplyAdviceByIdResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ApplyAdviceByIdResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ApplyAdviceByIdResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class AttachUserENIRequest : Tea.TeaModel {
    public var DBClusterId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
    }
}

public class AttachUserENIResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class AttachUserENIResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AttachUserENIResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = AttachUserENIResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class BatchApplyAdviceByIdListRequest : Tea.TeaModel {
    public var adviceDate: Int64?

    public var adviceIdList: String?

    public var DBClusterId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.adviceDate != nil {
            map["AdviceDate"] = self.adviceDate!
        }
        if self.adviceIdList != nil {
            map["AdviceIdList"] = self.adviceIdList!
        }
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AdviceDate"] as? Int64 {
            self.adviceDate = value
        }
        if let value = dict["AdviceIdList"] as? String {
            self.adviceIdList = value
        }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class BatchApplyAdviceByIdListResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class BatchApplyAdviceByIdListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: BatchApplyAdviceByIdListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = BatchApplyAdviceByIdListResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class BindAccountRequest : Tea.TeaModel {
    public var accountName: String?

    public var DBClusterId: String?

    public var ramUser: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accountName != nil {
            map["AccountName"] = self.accountName!
        }
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.ramUser != nil {
            map["RamUser"] = self.ramUser!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AccountName"] as? String {
            self.accountName = value
        }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["RamUser"] as? String {
            self.ramUser = value
        }
    }
}

public class BindAccountResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class BindAccountResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: BindAccountResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = BindAccountResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class BindDBResourceGroupWithUserRequest : Tea.TeaModel {
    public var DBClusterId: String?

    public var groupName: String?

    public var groupUser: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.groupName != nil {
            map["GroupName"] = self.groupName!
        }
        if self.groupUser != nil {
            map["GroupUser"] = self.groupUser!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["GroupName"] as? String {
            self.groupName = value
        }
        if let value = dict["GroupUser"] as? String {
            self.groupUser = value
        }
    }
}

public class BindDBResourceGroupWithUserResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class BindDBResourceGroupWithUserResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: BindDBResourceGroupWithUserResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = BindDBResourceGroupWithUserResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CancelSparkReplStatementRequest : Tea.TeaModel {
    public var appId: String?

    public var sessionId: Int64?

    public var statementId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.sessionId != nil {
            map["SessionId"] = self.sessionId!
        }
        if self.statementId != nil {
            map["StatementId"] = self.statementId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["SessionId"] as? Int64 {
            self.sessionId = value
        }
        if let value = dict["StatementId"] as? Int64 {
            self.statementId = value
        }
    }
}

public class CancelSparkReplStatementResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var aliyunUid: Int64?

        public var code: String?

        public var codeState: String?

        public var codeType: String?

        public var columns: [String]?

        public var endTime: Int64?

        public var error: String?

        public var output: String?

        public var outputType: String?

        public var startTime: Int64?

        public var statementId: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.aliyunUid != nil {
                map["AliyunUid"] = self.aliyunUid!
            }
            if self.code != nil {
                map["Code"] = self.code!
            }
            if self.codeState != nil {
                map["CodeState"] = self.codeState!
            }
            if self.codeType != nil {
                map["CodeType"] = self.codeType!
            }
            if self.columns != nil {
                map["Columns"] = self.columns!
            }
            if self.endTime != nil {
                map["EndTime"] = self.endTime!
            }
            if self.error != nil {
                map["Error"] = self.error!
            }
            if self.output != nil {
                map["Output"] = self.output!
            }
            if self.outputType != nil {
                map["OutputType"] = self.outputType!
            }
            if self.startTime != nil {
                map["StartTime"] = self.startTime!
            }
            if self.statementId != nil {
                map["StatementId"] = self.statementId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AliyunUid"] as? Int64 {
                self.aliyunUid = value
            }
            if let value = dict["Code"] as? String {
                self.code = value
            }
            if let value = dict["CodeState"] as? String {
                self.codeState = value
            }
            if let value = dict["CodeType"] as? String {
                self.codeType = value
            }
            if let value = dict["Columns"] as? [String] {
                self.columns = value
            }
            if let value = dict["EndTime"] as? Int64 {
                self.endTime = value
            }
            if let value = dict["Error"] as? String {
                self.error = value
            }
            if let value = dict["Output"] as? String {
                self.output = value
            }
            if let value = dict["OutputType"] as? String {
                self.outputType = value
            }
            if let value = dict["StartTime"] as? Int64 {
                self.startTime = value
            }
            if let value = dict["StatementId"] as? Int64 {
                self.statementId = value
            }
        }
    }
    public var data: CancelSparkReplStatementResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [String: Any?] {
            var model = CancelSparkReplStatementResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class CancelSparkReplStatementResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CancelSparkReplStatementResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CancelSparkReplStatementResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CancelSparkWarehouseBatchSQLRequest : Tea.TeaModel {
    public var agency: String?

    public var DBClusterId: String?

    public var queryId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.agency != nil {
            map["Agency"] = self.agency!
        }
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.queryId != nil {
            map["QueryId"] = self.queryId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Agency"] as? String {
            self.agency = value
        }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["QueryId"] as? String {
            self.queryId = value
        }
    }
}

public class CancelSparkWarehouseBatchSQLResponseBody : Tea.TeaModel {
    public var data: SparkBatchSQL?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [String: Any?] {
            var model = SparkBatchSQL()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class CancelSparkWarehouseBatchSQLResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CancelSparkWarehouseBatchSQLResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CancelSparkWarehouseBatchSQLResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CheckBindRamUserRequest : Tea.TeaModel {
    public var DBClusterId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class CheckBindRamUserResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? Bool {
            self.result = value
        }
    }
}

public class CheckBindRamUserResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CheckBindRamUserResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CheckBindRamUserResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CheckSampleDataSetRequest : Tea.TeaModel {
    public var DBClusterId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
    }
}

public class CheckSampleDataSetResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Status"] as? String {
            self.status = value
        }
    }
}

public class CheckSampleDataSetResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CheckSampleDataSetResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CheckSampleDataSetResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateAPSJobRequest : Tea.TeaModel {
    public var apsJobName: String?

    public var dbList: String?

    public var destinationEndpointInstanceID: String?

    public var destinationEndpointPassword: String?

    public var destinationEndpointUserName: String?

    public var partitionList: String?

    public var regionId: String?

    public var sourceEndpointInstanceID: String?

    public var sourceEndpointPassword: String?

    public var sourceEndpointRegion: String?

    public var sourceEndpointUserName: String?

    public var targetTableMode: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apsJobName != nil {
            map["ApsJobName"] = self.apsJobName!
        }
        if self.dbList != nil {
            map["DbList"] = self.dbList!
        }
        if self.destinationEndpointInstanceID != nil {
            map["DestinationEndpointInstanceID"] = self.destinationEndpointInstanceID!
        }
        if self.destinationEndpointPassword != nil {
            map["DestinationEndpointPassword"] = self.destinationEndpointPassword!
        }
        if self.destinationEndpointUserName != nil {
            map["DestinationEndpointUserName"] = self.destinationEndpointUserName!
        }
        if self.partitionList != nil {
            map["PartitionList"] = self.partitionList!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.sourceEndpointInstanceID != nil {
            map["SourceEndpointInstanceID"] = self.sourceEndpointInstanceID!
        }
        if self.sourceEndpointPassword != nil {
            map["SourceEndpointPassword"] = self.sourceEndpointPassword!
        }
        if self.sourceEndpointRegion != nil {
            map["SourceEndpointRegion"] = self.sourceEndpointRegion!
        }
        if self.sourceEndpointUserName != nil {
            map["SourceEndpointUserName"] = self.sourceEndpointUserName!
        }
        if self.targetTableMode != nil {
            map["TargetTableMode"] = self.targetTableMode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ApsJobName"] as? String {
            self.apsJobName = value
        }
        if let value = dict["DbList"] as? String {
            self.dbList = value
        }
        if let value = dict["DestinationEndpointInstanceID"] as? String {
            self.destinationEndpointInstanceID = value
        }
        if let value = dict["DestinationEndpointPassword"] as? String {
            self.destinationEndpointPassword = value
        }
        if let value = dict["DestinationEndpointUserName"] as? String {
            self.destinationEndpointUserName = value
        }
        if let value = dict["PartitionList"] as? String {
            self.partitionList = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["SourceEndpointInstanceID"] as? String {
            self.sourceEndpointInstanceID = value
        }
        if let value = dict["SourceEndpointPassword"] as? String {
            self.sourceEndpointPassword = value
        }
        if let value = dict["SourceEndpointRegion"] as? String {
            self.sourceEndpointRegion = value
        }
        if let value = dict["SourceEndpointUserName"] as? String {
            self.sourceEndpointUserName = value
        }
        if let value = dict["TargetTableMode"] as? String {
            self.targetTableMode = value
        }
    }
}

public class CreateAPSJobResponseBody : Tea.TeaModel {
    public var apsJobId: String?

    public var code: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apsJobId != nil {
            map["ApsJobId"] = self.apsJobId!
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ApsJobId"] as? String {
            self.apsJobId = value
        }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class CreateAPSJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateAPSJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateAPSJobResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateAccountRequest : Tea.TeaModel {
    public var accountDescription: String?

    public var accountName: String?

    public var accountPassword: String?

    public var accountType: String?

    public var DBClusterId: String?

    public var engine: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accountDescription != nil {
            map["AccountDescription"] = self.accountDescription!
        }
        if self.accountName != nil {
            map["AccountName"] = self.accountName!
        }
        if self.accountPassword != nil {
            map["AccountPassword"] = self.accountPassword!
        }
        if self.accountType != nil {
            map["AccountType"] = self.accountType!
        }
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.engine != nil {
            map["Engine"] = self.engine!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AccountDescription"] as? String {
            self.accountDescription = value
        }
        if let value = dict["AccountName"] as? String {
            self.accountName = value
        }
        if let value = dict["AccountPassword"] as? String {
            self.accountPassword = value
        }
        if let value = dict["AccountType"] as? String {
            self.accountType = value
        }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["Engine"] as? String {
            self.engine = value
        }
    }
}

public class CreateAccountResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class CreateAccountResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateAccountResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateAccountResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateApsCopyWorkloadRequest : Tea.TeaModel {
    public var DBClusterId: String?

    public var datasourceId: Int32?

    public var dbName: String?

    public var regionId: String?

    public var tableName: String?

    public var workloadId: String?

    public var workloadType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.datasourceId != nil {
            map["DatasourceId"] = self.datasourceId!
        }
        if self.dbName != nil {
            map["DbName"] = self.dbName!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.tableName != nil {
            map["TableName"] = self.tableName!
        }
        if self.workloadId != nil {
            map["WorkloadId"] = self.workloadId!
        }
        if self.workloadType != nil {
            map["WorkloadType"] = self.workloadType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["DatasourceId"] as? Int32 {
            self.datasourceId = value
        }
        if let value = dict["DbName"] as? String {
            self.dbName = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["TableName"] as? String {
            self.tableName = value
        }
        if let value = dict["WorkloadId"] as? String {
            self.workloadId = value
        }
        if let value = dict["WorkloadType"] as? String {
            self.workloadType = value
        }
    }
}

public class CreateApsCopyWorkloadResponseBody : Tea.TeaModel {
    public var code: String?

    public var data: [String: Any]?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any] {
            self.data = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class CreateApsCopyWorkloadResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateApsCopyWorkloadResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateApsCopyWorkloadResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateApsDatasoureRequest : Tea.TeaModel {
    public class DatabricksInfo : Tea.TeaModel {
        public var accessToken: String?

        public var workspaceURL: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accessToken != nil {
                map["AccessToken"] = self.accessToken!
            }
            if self.workspaceURL != nil {
                map["WorkspaceURL"] = self.workspaceURL!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AccessToken"] as? String {
                self.accessToken = value
            }
            if let value = dict["WorkspaceURL"] as? String {
                self.workspaceURL = value
            }
        }
    }
    public class HiveInfo : Tea.TeaModel {
        public var clusterId: String?

        public var hostConfig: String?

        public var metaStoreUri: String?

        public var securityGroup: String?

        public var vswitch: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.clusterId != nil {
                map["ClusterId"] = self.clusterId!
            }
            if self.hostConfig != nil {
                map["HostConfig"] = self.hostConfig!
            }
            if self.metaStoreUri != nil {
                map["MetaStoreUri"] = self.metaStoreUri!
            }
            if self.securityGroup != nil {
                map["SecurityGroup"] = self.securityGroup!
            }
            if self.vswitch != nil {
                map["Vswitch"] = self.vswitch!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ClusterId"] as? String {
                self.clusterId = value
            }
            if let value = dict["HostConfig"] as? String {
                self.hostConfig = value
            }
            if let value = dict["MetaStoreUri"] as? String {
                self.metaStoreUri = value
            }
            if let value = dict["SecurityGroup"] as? String {
                self.securityGroup = value
            }
            if let value = dict["Vswitch"] as? String {
                self.vswitch = value
            }
        }
    }
    public class KafkaInfo : Tea.TeaModel {
        public var kafkaClusterId: String?

        public var kafkaTopic: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.kafkaClusterId != nil {
                map["KafkaClusterId"] = self.kafkaClusterId!
            }
            if self.kafkaTopic != nil {
                map["KafkaTopic"] = self.kafkaTopic!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["KafkaClusterId"] as? String {
                self.kafkaClusterId = value
            }
            if let value = dict["KafkaTopic"] as? String {
                self.kafkaTopic = value
            }
        }
    }
    public class PolarDBMysqlInfo : Tea.TeaModel {
        public var across: Bool?

        public var acrossRole: String?

        public var acrossUid: String?

        public var connectUrl: String?

        public var instanceId: String?

        public var password: String?

        public var regionId: String?

        public var securityGroup: String?

        public var userName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.across != nil {
                map["Across"] = self.across!
            }
            if self.acrossRole != nil {
                map["AcrossRole"] = self.acrossRole!
            }
            if self.acrossUid != nil {
                map["AcrossUid"] = self.acrossUid!
            }
            if self.connectUrl != nil {
                map["ConnectUrl"] = self.connectUrl!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.password != nil {
                map["Password"] = self.password!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.securityGroup != nil {
                map["SecurityGroup"] = self.securityGroup!
            }
            if self.userName != nil {
                map["UserName"] = self.userName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Across"] as? Bool {
                self.across = value
            }
            if let value = dict["AcrossRole"] as? String {
                self.acrossRole = value
            }
            if let value = dict["AcrossUid"] as? String {
                self.acrossUid = value
            }
            if let value = dict["ConnectUrl"] as? String {
                self.connectUrl = value
            }
            if let value = dict["InstanceId"] as? String {
                self.instanceId = value
            }
            if let value = dict["Password"] as? String {
                self.password = value
            }
            if let value = dict["RegionId"] as? String {
                self.regionId = value
            }
            if let value = dict["SecurityGroup"] as? String {
                self.securityGroup = value
            }
            if let value = dict["UserName"] as? String {
                self.userName = value
            }
        }
    }
    public class PolarDBXInfo : Tea.TeaModel {
        public var instanceId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["InstanceId"] as? String {
                self.instanceId = value
            }
        }
    }
    public class RdsMysqlInfo : Tea.TeaModel {
        public var connectUrl: String?

        public var instanceId: String?

        public var password: String?

        public var regionId: String?

        public var securityGroup: String?

        public var userName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.connectUrl != nil {
                map["ConnectUrl"] = self.connectUrl!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.password != nil {
                map["Password"] = self.password!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.securityGroup != nil {
                map["SecurityGroup"] = self.securityGroup!
            }
            if self.userName != nil {
                map["UserName"] = self.userName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ConnectUrl"] as? String {
                self.connectUrl = value
            }
            if let value = dict["InstanceId"] as? String {
                self.instanceId = value
            }
            if let value = dict["Password"] as? String {
                self.password = value
            }
            if let value = dict["RegionId"] as? String {
                self.regionId = value
            }
            if let value = dict["SecurityGroup"] as? String {
                self.securityGroup = value
            }
            if let value = dict["UserName"] as? String {
                self.userName = value
            }
        }
    }
    public class SlsInfo : Tea.TeaModel {
        public var across: Bool?

        public var acrossRole: String?

        public var acrossUid: String?

        public var project: String?

        public var sourceRegionId: String?

        public var store: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.across != nil {
                map["Across"] = self.across!
            }
            if self.acrossRole != nil {
                map["AcrossRole"] = self.acrossRole!
            }
            if self.acrossUid != nil {
                map["AcrossUid"] = self.acrossUid!
            }
            if self.project != nil {
                map["Project"] = self.project!
            }
            if self.sourceRegionId != nil {
                map["SourceRegionId"] = self.sourceRegionId!
            }
            if self.store != nil {
                map["Store"] = self.store!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Across"] as? Bool {
                self.across = value
            }
            if let value = dict["AcrossRole"] as? String {
                self.acrossRole = value
            }
            if let value = dict["AcrossUid"] as? String {
                self.acrossUid = value
            }
            if let value = dict["Project"] as? String {
                self.project = value
            }
            if let value = dict["SourceRegionId"] as? String {
                self.sourceRegionId = value
            }
            if let value = dict["Store"] as? String {
                self.store = value
            }
        }
    }
    public var DBClusterId: String?

    public var databricksInfo: CreateApsDatasoureRequest.DatabricksInfo?

    public var datasourceDescription: String?

    public var datasourceName: String?

    public var datasourceType: String?

    public var hiveInfo: CreateApsDatasoureRequest.HiveInfo?

    public var kafkaInfo: CreateApsDatasoureRequest.KafkaInfo?

    public var mode: String?

    public var polarDBMysqlInfo: CreateApsDatasoureRequest.PolarDBMysqlInfo?

    public var polarDBXInfo: CreateApsDatasoureRequest.PolarDBXInfo?

    public var rdsMysqlInfo: CreateApsDatasoureRequest.RdsMysqlInfo?

    public var regionId: String?

    public var slsInfo: CreateApsDatasoureRequest.SlsInfo?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.databricksInfo?.validate()
        try self.hiveInfo?.validate()
        try self.kafkaInfo?.validate()
        try self.polarDBMysqlInfo?.validate()
        try self.polarDBXInfo?.validate()
        try self.rdsMysqlInfo?.validate()
        try self.slsInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.databricksInfo != nil {
            map["DatabricksInfo"] = self.databricksInfo?.toMap()
        }
        if self.datasourceDescription != nil {
            map["DatasourceDescription"] = self.datasourceDescription!
        }
        if self.datasourceName != nil {
            map["DatasourceName"] = self.datasourceName!
        }
        if self.datasourceType != nil {
            map["DatasourceType"] = self.datasourceType!
        }
        if self.hiveInfo != nil {
            map["HiveInfo"] = self.hiveInfo?.toMap()
        }
        if self.kafkaInfo != nil {
            map["KafkaInfo"] = self.kafkaInfo?.toMap()
        }
        if self.mode != nil {
            map["Mode"] = self.mode!
        }
        if self.polarDBMysqlInfo != nil {
            map["PolarDBMysqlInfo"] = self.polarDBMysqlInfo?.toMap()
        }
        if self.polarDBXInfo != nil {
            map["PolarDBXInfo"] = self.polarDBXInfo?.toMap()
        }
        if self.rdsMysqlInfo != nil {
            map["RdsMysqlInfo"] = self.rdsMysqlInfo?.toMap()
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.slsInfo != nil {
            map["SlsInfo"] = self.slsInfo?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["DatabricksInfo"] as? [String: Any?] {
            var model = CreateApsDatasoureRequest.DatabricksInfo()
            model.fromMap(value)
            self.databricksInfo = model
        }
        if let value = dict["DatasourceDescription"] as? String {
            self.datasourceDescription = value
        }
        if let value = dict["DatasourceName"] as? String {
            self.datasourceName = value
        }
        if let value = dict["DatasourceType"] as? String {
            self.datasourceType = value
        }
        if let value = dict["HiveInfo"] as? [String: Any?] {
            var model = CreateApsDatasoureRequest.HiveInfo()
            model.fromMap(value)
            self.hiveInfo = model
        }
        if let value = dict["KafkaInfo"] as? [String: Any?] {
            var model = CreateApsDatasoureRequest.KafkaInfo()
            model.fromMap(value)
            self.kafkaInfo = model
        }
        if let value = dict["Mode"] as? String {
            self.mode = value
        }
        if let value = dict["PolarDBMysqlInfo"] as? [String: Any?] {
            var model = CreateApsDatasoureRequest.PolarDBMysqlInfo()
            model.fromMap(value)
            self.polarDBMysqlInfo = model
        }
        if let value = dict["PolarDBXInfo"] as? [String: Any?] {
            var model = CreateApsDatasoureRequest.PolarDBXInfo()
            model.fromMap(value)
            self.polarDBXInfo = model
        }
        if let value = dict["RdsMysqlInfo"] as? [String: Any?] {
            var model = CreateApsDatasoureRequest.RdsMysqlInfo()
            model.fromMap(value)
            self.rdsMysqlInfo = model
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["SlsInfo"] as? [String: Any?] {
            var model = CreateApsDatasoureRequest.SlsInfo()
            model.fromMap(value)
            self.slsInfo = model
        }
    }
}

public class CreateApsDatasoureShrinkRequest : Tea.TeaModel {
    public var DBClusterId: String?

    public var databricksInfoShrink: String?

    public var datasourceDescription: String?

    public var datasourceName: String?

    public var datasourceType: String?

    public var hiveInfoShrink: String?

    public var kafkaInfoShrink: String?

    public var mode: String?

    public var polarDBMysqlInfoShrink: String?

    public var polarDBXInfoShrink: String?

    public var rdsMysqlInfoShrink: String?

    public var regionId: String?

    public var slsInfoShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.databricksInfoShrink != nil {
            map["DatabricksInfo"] = self.databricksInfoShrink!
        }
        if self.datasourceDescription != nil {
            map["DatasourceDescription"] = self.datasourceDescription!
        }
        if self.datasourceName != nil {
            map["DatasourceName"] = self.datasourceName!
        }
        if self.datasourceType != nil {
            map["DatasourceType"] = self.datasourceType!
        }
        if self.hiveInfoShrink != nil {
            map["HiveInfo"] = self.hiveInfoShrink!
        }
        if self.kafkaInfoShrink != nil {
            map["KafkaInfo"] = self.kafkaInfoShrink!
        }
        if self.mode != nil {
            map["Mode"] = self.mode!
        }
        if self.polarDBMysqlInfoShrink != nil {
            map["PolarDBMysqlInfo"] = self.polarDBMysqlInfoShrink!
        }
        if self.polarDBXInfoShrink != nil {
            map["PolarDBXInfo"] = self.polarDBXInfoShrink!
        }
        if self.rdsMysqlInfoShrink != nil {
            map["RdsMysqlInfo"] = self.rdsMysqlInfoShrink!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.slsInfoShrink != nil {
            map["SlsInfo"] = self.slsInfoShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["DatabricksInfo"] as? String {
            self.databricksInfoShrink = value
        }
        if let value = dict["DatasourceDescription"] as? String {
            self.datasourceDescription = value
        }
        if let value = dict["DatasourceName"] as? String {
            self.datasourceName = value
        }
        if let value = dict["DatasourceType"] as? String {
            self.datasourceType = value
        }
        if let value = dict["HiveInfo"] as? String {
            self.hiveInfoShrink = value
        }
        if let value = dict["KafkaInfo"] as? String {
            self.kafkaInfoShrink = value
        }
        if let value = dict["Mode"] as? String {
            self.mode = value
        }
        if let value = dict["PolarDBMysqlInfo"] as? String {
            self.polarDBMysqlInfoShrink = value
        }
        if let value = dict["PolarDBXInfo"] as? String {
            self.polarDBXInfoShrink = value
        }
        if let value = dict["RdsMysqlInfo"] as? String {
            self.rdsMysqlInfoShrink = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["SlsInfo"] as? String {
            self.slsInfoShrink = value
        }
    }
}

public class CreateApsDatasoureResponseBody : Tea.TeaModel {
    public var code: String?

    public var DBClusterId: String?

    public var data: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["Data"] as? String {
            self.data = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class CreateApsDatasoureResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateApsDatasoureResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateApsDatasoureResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateApsHiveJobRequest : Tea.TeaModel {
    public var advancedConfig: String?

    public var conflictStrategy: String?

    public var DBClusterId: String?

    public var datasourceId: Int64?

    public var fullComputeUnit: String?

    public var ossLocation: String?

    public var parallelism: Int32?

    public var regionId: String?

    public var resourceGroup: String?

    public var syncAllowExpression: String?

    public var syncDenyExpression: String?

    public var targetType: String?

    public var workloadName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.advancedConfig != nil {
            map["AdvancedConfig"] = self.advancedConfig!
        }
        if self.conflictStrategy != nil {
            map["ConflictStrategy"] = self.conflictStrategy!
        }
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.datasourceId != nil {
            map["DatasourceId"] = self.datasourceId!
        }
        if self.fullComputeUnit != nil {
            map["FullComputeUnit"] = self.fullComputeUnit!
        }
        if self.ossLocation != nil {
            map["OssLocation"] = self.ossLocation!
        }
        if self.parallelism != nil {
            map["Parallelism"] = self.parallelism!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroup != nil {
            map["ResourceGroup"] = self.resourceGroup!
        }
        if self.syncAllowExpression != nil {
            map["SyncAllowExpression"] = self.syncAllowExpression!
        }
        if self.syncDenyExpression != nil {
            map["SyncDenyExpression"] = self.syncDenyExpression!
        }
        if self.targetType != nil {
            map["TargetType"] = self.targetType!
        }
        if self.workloadName != nil {
            map["WorkloadName"] = self.workloadName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AdvancedConfig"] as? String {
            self.advancedConfig = value
        }
        if let value = dict["ConflictStrategy"] as? String {
            self.conflictStrategy = value
        }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["DatasourceId"] as? Int64 {
            self.datasourceId = value
        }
        if let value = dict["FullComputeUnit"] as? String {
            self.fullComputeUnit = value
        }
        if let value = dict["OssLocation"] as? String {
            self.ossLocation = value
        }
        if let value = dict["Parallelism"] as? Int32 {
            self.parallelism = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroup"] as? String {
            self.resourceGroup = value
        }
        if let value = dict["SyncAllowExpression"] as? String {
            self.syncAllowExpression = value
        }
        if let value = dict["SyncDenyExpression"] as? String {
            self.syncDenyExpression = value
        }
        if let value = dict["TargetType"] as? String {
            self.targetType = value
        }
        if let value = dict["WorkloadName"] as? String {
            self.workloadName = value
        }
    }
}

public class CreateApsHiveJobResponseBody : Tea.TeaModel {
    public var code: String?

    public var data: String?

    public var httpStatusCode: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? String {
            self.data = value
        }
        if let value = dict["HttpStatusCode"] as? String {
            self.httpStatusCode = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class CreateApsHiveJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateApsHiveJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateApsHiveJobResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateApsSlsADBJobRequest : Tea.TeaModel {
    public class Columns : Tea.TeaModel {
        public var mapName: String?

        public var mapType: String?

        public var name: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.mapName != nil {
                map["MapName"] = self.mapName!
            }
            if self.mapType != nil {
                map["MapType"] = self.mapType!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["MapName"] as? String {
                self.mapName = value
            }
            if let value = dict["MapType"] as? String {
                self.mapType = value
            }
            if let value = dict["Name"] as? String {
                self.name = value
            }
            if let value = dict["Type"] as? String {
                self.type = value
            }
        }
    }
    public class UnixTimestampConvert : Tea.TeaModel {
        public var convert: String?

        public var format: String?

        public var transform: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.convert != nil {
                map["Convert"] = self.convert!
            }
            if self.format != nil {
                map["Format"] = self.format!
            }
            if self.transform != nil {
                map["Transform"] = self.transform!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Convert"] as? String {
                self.convert = value
            }
            if let value = dict["Format"] as? String {
                self.format = value
            }
            if let value = dict["Transform"] as? Bool {
                self.transform = value
            }
        }
    }
    public var acrossRole: String?

    public var acrossUid: String?

    public var advancedConfig: String?

    public var columns: [CreateApsSlsADBJobRequest.Columns]?

    public var DBClusterId: String?

    public var datasourceId: Int64?

    public var dbName: String?

    public var dirtyDataHandleMode: String?

    public var dirtyDataProcessPattern: String?

    public var exactlyOnce: String?

    public var fullComputeUnit: String?

    public var hudiAdvancedConfig: String?

    public var incrementalComputeUnit: String?

    public var lakehouseId: Int64?

    public var maxOffsetsPerTrigger: Int64?

    public var ossLocation: String?

    public var outputFormat: String?

    public var partitionSpecs: [[String: Any]]?

    public var password: String?

    public var primaryKeyDefinition: String?

    public var project: String?

    public var regionId: String?

    public var resourceGroup: String?

    public var sourceRegionId: String?

    public var startingOffsets: String?

    public var store: String?

    public var tableName: String?

    public var targetGenerateRule: String?

    public var targetType: String?

    public var unixTimestampConvert: CreateApsSlsADBJobRequest.UnixTimestampConvert?

    public var userName: String?

    public var workloadName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.unixTimestampConvert?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acrossRole != nil {
            map["AcrossRole"] = self.acrossRole!
        }
        if self.acrossUid != nil {
            map["AcrossUid"] = self.acrossUid!
        }
        if self.advancedConfig != nil {
            map["AdvancedConfig"] = self.advancedConfig!
        }
        if self.columns != nil {
            var tmp : [Any] = []
            for k in self.columns! {
                tmp.append(k.toMap())
            }
            map["Columns"] = tmp
        }
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.datasourceId != nil {
            map["DatasourceId"] = self.datasourceId!
        }
        if self.dbName != nil {
            map["DbName"] = self.dbName!
        }
        if self.dirtyDataHandleMode != nil {
            map["DirtyDataHandleMode"] = self.dirtyDataHandleMode!
        }
        if self.dirtyDataProcessPattern != nil {
            map["DirtyDataProcessPattern"] = self.dirtyDataProcessPattern!
        }
        if self.exactlyOnce != nil {
            map["ExactlyOnce"] = self.exactlyOnce!
        }
        if self.fullComputeUnit != nil {
            map["FullComputeUnit"] = self.fullComputeUnit!
        }
        if self.hudiAdvancedConfig != nil {
            map["HudiAdvancedConfig"] = self.hudiAdvancedConfig!
        }
        if self.incrementalComputeUnit != nil {
            map["IncrementalComputeUnit"] = self.incrementalComputeUnit!
        }
        if self.lakehouseId != nil {
            map["LakehouseId"] = self.lakehouseId!
        }
        if self.maxOffsetsPerTrigger != nil {
            map["MaxOffsetsPerTrigger"] = self.maxOffsetsPerTrigger!
        }
        if self.ossLocation != nil {
            map["OssLocation"] = self.ossLocation!
        }
        if self.outputFormat != nil {
            map["OutputFormat"] = self.outputFormat!
        }
        if self.partitionSpecs != nil {
            map["PartitionSpecs"] = self.partitionSpecs!
        }
        if self.password != nil {
            map["Password"] = self.password!
        }
        if self.primaryKeyDefinition != nil {
            map["PrimaryKeyDefinition"] = self.primaryKeyDefinition!
        }
        if self.project != nil {
            map["Project"] = self.project!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroup != nil {
            map["ResourceGroup"] = self.resourceGroup!
        }
        if self.sourceRegionId != nil {
            map["SourceRegionId"] = self.sourceRegionId!
        }
        if self.startingOffsets != nil {
            map["StartingOffsets"] = self.startingOffsets!
        }
        if self.store != nil {
            map["Store"] = self.store!
        }
        if self.tableName != nil {
            map["TableName"] = self.tableName!
        }
        if self.targetGenerateRule != nil {
            map["TargetGenerateRule"] = self.targetGenerateRule!
        }
        if self.targetType != nil {
            map["TargetType"] = self.targetType!
        }
        if self.unixTimestampConvert != nil {
            map["UnixTimestampConvert"] = self.unixTimestampConvert?.toMap()
        }
        if self.userName != nil {
            map["UserName"] = self.userName!
        }
        if self.workloadName != nil {
            map["WorkloadName"] = self.workloadName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AcrossRole"] as? String {
            self.acrossRole = value
        }
        if let value = dict["AcrossUid"] as? String {
            self.acrossUid = value
        }
        if let value = dict["AdvancedConfig"] as? String {
            self.advancedConfig = value
        }
        if let value = dict["Columns"] as? [Any?] {
            var tmp : [CreateApsSlsADBJobRequest.Columns] = []
            for v in value {
                if v != nil {
                    var model = CreateApsSlsADBJobRequest.Columns()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.columns = tmp
        }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["DatasourceId"] as? Int64 {
            self.datasourceId = value
        }
        if let value = dict["DbName"] as? String {
            self.dbName = value
        }
        if let value = dict["DirtyDataHandleMode"] as? String {
            self.dirtyDataHandleMode = value
        }
        if let value = dict["DirtyDataProcessPattern"] as? String {
            self.dirtyDataProcessPattern = value
        }
        if let value = dict["ExactlyOnce"] as? String {
            self.exactlyOnce = value
        }
        if let value = dict["FullComputeUnit"] as? String {
            self.fullComputeUnit = value
        }
        if let value = dict["HudiAdvancedConfig"] as? String {
            self.hudiAdvancedConfig = value
        }
        if let value = dict["IncrementalComputeUnit"] as? String {
            self.incrementalComputeUnit = value
        }
        if let value = dict["LakehouseId"] as? Int64 {
            self.lakehouseId = value
        }
        if let value = dict["MaxOffsetsPerTrigger"] as? Int64 {
            self.maxOffsetsPerTrigger = value
        }
        if let value = dict["OssLocation"] as? String {
            self.ossLocation = value
        }
        if let value = dict["OutputFormat"] as? String {
            self.outputFormat = value
        }
        if let value = dict["PartitionSpecs"] as? [[String: Any]] {
            self.partitionSpecs = value
        }
        if let value = dict["Password"] as? String {
            self.password = value
        }
        if let value = dict["PrimaryKeyDefinition"] as? String {
            self.primaryKeyDefinition = value
        }
        if let value = dict["Project"] as? String {
            self.project = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroup"] as? String {
            self.resourceGroup = value
        }
        if let value = dict["SourceRegionId"] as? String {
            self.sourceRegionId = value
        }
        if let value = dict["StartingOffsets"] as? String {
            self.startingOffsets = value
        }
        if let value = dict["Store"] as? String {
            self.store = value
        }
        if let value = dict["TableName"] as? String {
            self.tableName = value
        }
        if let value = dict["TargetGenerateRule"] as? String {
            self.targetGenerateRule = value
        }
        if let value = dict["TargetType"] as? String {
            self.targetType = value
        }
        if let value = dict["UnixTimestampConvert"] as? [String: Any?] {
            var model = CreateApsSlsADBJobRequest.UnixTimestampConvert()
            model.fromMap(value)
            self.unixTimestampConvert = model
        }
        if let value = dict["UserName"] as? String {
            self.userName = value
        }
        if let value = dict["WorkloadName"] as? String {
            self.workloadName = value
        }
    }
}

public class CreateApsSlsADBJobShrinkRequest : Tea.TeaModel {
    public var acrossRole: String?

    public var acrossUid: String?

    public var advancedConfig: String?

    public var columnsShrink: String?

    public var DBClusterId: String?

    public var datasourceId: Int64?

    public var dbName: String?

    public var dirtyDataHandleMode: String?

    public var dirtyDataProcessPattern: String?

    public var exactlyOnce: String?

    public var fullComputeUnit: String?

    public var hudiAdvancedConfig: String?

    public var incrementalComputeUnit: String?

    public var lakehouseId: Int64?

    public var maxOffsetsPerTrigger: Int64?

    public var ossLocation: String?

    public var outputFormat: String?

    public var partitionSpecsShrink: String?

    public var password: String?

    public var primaryKeyDefinition: String?

    public var project: String?

    public var regionId: String?

    public var resourceGroup: String?

    public var sourceRegionId: String?

    public var startingOffsets: String?

    public var store: String?

    public var tableName: String?

    public var targetGenerateRule: String?

    public var targetType: String?

    public var unixTimestampConvertShrink: String?

    public var userName: String?

    public var workloadName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acrossRole != nil {
            map["AcrossRole"] = self.acrossRole!
        }
        if self.acrossUid != nil {
            map["AcrossUid"] = self.acrossUid!
        }
        if self.advancedConfig != nil {
            map["AdvancedConfig"] = self.advancedConfig!
        }
        if self.columnsShrink != nil {
            map["Columns"] = self.columnsShrink!
        }
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.datasourceId != nil {
            map["DatasourceId"] = self.datasourceId!
        }
        if self.dbName != nil {
            map["DbName"] = self.dbName!
        }
        if self.dirtyDataHandleMode != nil {
            map["DirtyDataHandleMode"] = self.dirtyDataHandleMode!
        }
        if self.dirtyDataProcessPattern != nil {
            map["DirtyDataProcessPattern"] = self.dirtyDataProcessPattern!
        }
        if self.exactlyOnce != nil {
            map["ExactlyOnce"] = self.exactlyOnce!
        }
        if self.fullComputeUnit != nil {
            map["FullComputeUnit"] = self.fullComputeUnit!
        }
        if self.hudiAdvancedConfig != nil {
            map["HudiAdvancedConfig"] = self.hudiAdvancedConfig!
        }
        if self.incrementalComputeUnit != nil {
            map["IncrementalComputeUnit"] = self.incrementalComputeUnit!
        }
        if self.lakehouseId != nil {
            map["LakehouseId"] = self.lakehouseId!
        }
        if self.maxOffsetsPerTrigger != nil {
            map["MaxOffsetsPerTrigger"] = self.maxOffsetsPerTrigger!
        }
        if self.ossLocation != nil {
            map["OssLocation"] = self.ossLocation!
        }
        if self.outputFormat != nil {
            map["OutputFormat"] = self.outputFormat!
        }
        if self.partitionSpecsShrink != nil {
            map["PartitionSpecs"] = self.partitionSpecsShrink!
        }
        if self.password != nil {
            map["Password"] = self.password!
        }
        if self.primaryKeyDefinition != nil {
            map["PrimaryKeyDefinition"] = self.primaryKeyDefinition!
        }
        if self.project != nil {
            map["Project"] = self.project!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroup != nil {
            map["ResourceGroup"] = self.resourceGroup!
        }
        if self.sourceRegionId != nil {
            map["SourceRegionId"] = self.sourceRegionId!
        }
        if self.startingOffsets != nil {
            map["StartingOffsets"] = self.startingOffsets!
        }
        if self.store != nil {
            map["Store"] = self.store!
        }
        if self.tableName != nil {
            map["TableName"] = self.tableName!
        }
        if self.targetGenerateRule != nil {
            map["TargetGenerateRule"] = self.targetGenerateRule!
        }
        if self.targetType != nil {
            map["TargetType"] = self.targetType!
        }
        if self.unixTimestampConvertShrink != nil {
            map["UnixTimestampConvert"] = self.unixTimestampConvertShrink!
        }
        if self.userName != nil {
            map["UserName"] = self.userName!
        }
        if self.workloadName != nil {
            map["WorkloadName"] = self.workloadName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AcrossRole"] as? String {
            self.acrossRole = value
        }
        if let value = dict["AcrossUid"] as? String {
            self.acrossUid = value
        }
        if let value = dict["AdvancedConfig"] as? String {
            self.advancedConfig = value
        }
        if let value = dict["Columns"] as? String {
            self.columnsShrink = value
        }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["DatasourceId"] as? Int64 {
            self.datasourceId = value
        }
        if let value = dict["DbName"] as? String {
            self.dbName = value
        }
        if let value = dict["DirtyDataHandleMode"] as? String {
            self.dirtyDataHandleMode = value
        }
        if let value = dict["DirtyDataProcessPattern"] as? String {
            self.dirtyDataProcessPattern = value
        }
        if let value = dict["ExactlyOnce"] as? String {
            self.exactlyOnce = value
        }
        if let value = dict["FullComputeUnit"] as? String {
            self.fullComputeUnit = value
        }
        if let value = dict["HudiAdvancedConfig"] as? String {
            self.hudiAdvancedConfig = value
        }
        if let value = dict["IncrementalComputeUnit"] as? String {
            self.incrementalComputeUnit = value
        }
        if let value = dict["LakehouseId"] as? Int64 {
            self.lakehouseId = value
        }
        if let value = dict["MaxOffsetsPerTrigger"] as? Int64 {
            self.maxOffsetsPerTrigger = value
        }
        if let value = dict["OssLocation"] as? String {
            self.ossLocation = value
        }
        if let value = dict["OutputFormat"] as? String {
            self.outputFormat = value
        }
        if let value = dict["PartitionSpecs"] as? String {
            self.partitionSpecsShrink = value
        }
        if let value = dict["Password"] as? String {
            self.password = value
        }
        if let value = dict["PrimaryKeyDefinition"] as? String {
            self.primaryKeyDefinition = value
        }
        if let value = dict["Project"] as? String {
            self.project = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroup"] as? String {
            self.resourceGroup = value
        }
        if let value = dict["SourceRegionId"] as? String {
            self.sourceRegionId = value
        }
        if let value = dict["StartingOffsets"] as? String {
            self.startingOffsets = value
        }
        if let value = dict["Store"] as? String {
            self.store = value
        }
        if let value = dict["TableName"] as? String {
            self.tableName = value
        }
        if let value = dict["TargetGenerateRule"] as? String {
            self.targetGenerateRule = value
        }
        if let value = dict["TargetType"] as? String {
            self.targetType = value
        }
        if let value = dict["UnixTimestampConvert"] as? String {
            self.unixTimestampConvertShrink = value
        }
        if let value = dict["UserName"] as? String {
            self.userName = value
        }
        if let value = dict["WorkloadName"] as? String {
            self.workloadName = value
        }
    }
}

public class CreateApsSlsADBJobResponseBody : Tea.TeaModel {
    public var code: String?

    public var data: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? String {
            self.data = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class CreateApsSlsADBJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateApsSlsADBJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateApsSlsADBJobResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateDBClusterRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var backupSetId: String?

    public var cloneSourceRegionId: String?

    public var computeResource: String?

    public var DBClusterDescription: String?

    public var DBClusterNetworkType: String?

    public var DBClusterVersion: String?

    public var diskEncryption: Bool?

    public var enableDefaultResourcePool: Bool?

    public var kmsId: String?

    public var payType: String?

    public var period: String?

    public var productForm: String?

    public var productVersion: String?

    public var regionId: String?

    public var reservedNodeCount: Int32?

    public var reservedNodeSize: String?

    public var resourceGroupId: String?

    public var restoreToTime: String?

    public var restoreType: String?

    public var secondaryVSwitchId: String?

    public var secondaryZoneId: String?

    public var sourceDbClusterId: String?

    public var storageResource: String?

    public var tag: [CreateDBClusterRequest.Tag]?

    public var usedTime: String?

    public var VPCId: String?

    public var vSwitchId: String?

    public var zoneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.backupSetId != nil {
            map["BackupSetId"] = self.backupSetId!
        }
        if self.cloneSourceRegionId != nil {
            map["CloneSourceRegionId"] = self.cloneSourceRegionId!
        }
        if self.computeResource != nil {
            map["ComputeResource"] = self.computeResource!
        }
        if self.DBClusterDescription != nil {
            map["DBClusterDescription"] = self.DBClusterDescription!
        }
        if self.DBClusterNetworkType != nil {
            map["DBClusterNetworkType"] = self.DBClusterNetworkType!
        }
        if self.DBClusterVersion != nil {
            map["DBClusterVersion"] = self.DBClusterVersion!
        }
        if self.diskEncryption != nil {
            map["DiskEncryption"] = self.diskEncryption!
        }
        if self.enableDefaultResourcePool != nil {
            map["EnableDefaultResourcePool"] = self.enableDefaultResourcePool!
        }
        if self.kmsId != nil {
            map["KmsId"] = self.kmsId!
        }
        if self.payType != nil {
            map["PayType"] = self.payType!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.productForm != nil {
            map["ProductForm"] = self.productForm!
        }
        if self.productVersion != nil {
            map["ProductVersion"] = self.productVersion!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.reservedNodeCount != nil {
            map["ReservedNodeCount"] = self.reservedNodeCount!
        }
        if self.reservedNodeSize != nil {
            map["ReservedNodeSize"] = self.reservedNodeSize!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.restoreToTime != nil {
            map["RestoreToTime"] = self.restoreToTime!
        }
        if self.restoreType != nil {
            map["RestoreType"] = self.restoreType!
        }
        if self.secondaryVSwitchId != nil {
            map["SecondaryVSwitchId"] = self.secondaryVSwitchId!
        }
        if self.secondaryZoneId != nil {
            map["SecondaryZoneId"] = self.secondaryZoneId!
        }
        if self.sourceDbClusterId != nil {
            map["SourceDbClusterId"] = self.sourceDbClusterId!
        }
        if self.storageResource != nil {
            map["StorageResource"] = self.storageResource!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.usedTime != nil {
            map["UsedTime"] = self.usedTime!
        }
        if self.VPCId != nil {
            map["VPCId"] = self.VPCId!
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["BackupSetId"] as? String {
            self.backupSetId = value
        }
        if let value = dict["CloneSourceRegionId"] as? String {
            self.cloneSourceRegionId = value
        }
        if let value = dict["ComputeResource"] as? String {
            self.computeResource = value
        }
        if let value = dict["DBClusterDescription"] as? String {
            self.DBClusterDescription = value
        }
        if let value = dict["DBClusterNetworkType"] as? String {
            self.DBClusterNetworkType = value
        }
        if let value = dict["DBClusterVersion"] as? String {
            self.DBClusterVersion = value
        }
        if let value = dict["DiskEncryption"] as? Bool {
            self.diskEncryption = value
        }
        if let value = dict["EnableDefaultResourcePool"] as? Bool {
            self.enableDefaultResourcePool = value
        }
        if let value = dict["KmsId"] as? String {
            self.kmsId = value
        }
        if let value = dict["PayType"] as? String {
            self.payType = value
        }
        if let value = dict["Period"] as? String {
            self.period = value
        }
        if let value = dict["ProductForm"] as? String {
            self.productForm = value
        }
        if let value = dict["ProductVersion"] as? String {
            self.productVersion = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ReservedNodeCount"] as? Int32 {
            self.reservedNodeCount = value
        }
        if let value = dict["ReservedNodeSize"] as? String {
            self.reservedNodeSize = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["RestoreToTime"] as? String {
            self.restoreToTime = value
        }
        if let value = dict["RestoreType"] as? String {
            self.restoreType = value
        }
        if let value = dict["SecondaryVSwitchId"] as? String {
            self.secondaryVSwitchId = value
        }
        if let value = dict["SecondaryZoneId"] as? String {
            self.secondaryZoneId = value
        }
        if let value = dict["SourceDbClusterId"] as? String {
            self.sourceDbClusterId = value
        }
        if let value = dict["StorageResource"] as? String {
            self.storageResource = value
        }
        if let value = dict["Tag"] as? [Any?] {
            var tmp : [CreateDBClusterRequest.Tag] = []
            for v in value {
                if v != nil {
                    var model = CreateDBClusterRequest.Tag()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tag = tmp
        }
        if let value = dict["UsedTime"] as? String {
            self.usedTime = value
        }
        if let value = dict["VPCId"] as? String {
            self.VPCId = value
        }
        if let value = dict["VSwitchId"] as? String {
            self.vSwitchId = value
        }
        if let value = dict["ZoneId"] as? String {
            self.zoneId = value
        }
    }
}

public class CreateDBClusterResponseBody : Tea.TeaModel {
    public var DBClusterId: String?

    public var orderId: String?

    public var requestId: String?

    public var resourceGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["OrderId"] as? String {
            self.orderId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
    }
}

public class CreateDBClusterResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateDBClusterResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateDBClusterResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateDBResourceGroupRequest : Tea.TeaModel {
    public class RayConfig : Tea.TeaModel {
        public class WorkerGroups : Tea.TeaModel {
            public var allocateUnit: String?

            public var groupName: String?

            public var maxWorkerQuantity: Int32?

            public var minWorkerQuantity: Int32?

            public var workerDiskCapacity: String?

            public var workerSpecName: String?

            public var workerSpecType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.allocateUnit != nil {
                    map["AllocateUnit"] = self.allocateUnit!
                }
                if self.groupName != nil {
                    map["GroupName"] = self.groupName!
                }
                if self.maxWorkerQuantity != nil {
                    map["MaxWorkerQuantity"] = self.maxWorkerQuantity!
                }
                if self.minWorkerQuantity != nil {
                    map["MinWorkerQuantity"] = self.minWorkerQuantity!
                }
                if self.workerDiskCapacity != nil {
                    map["WorkerDiskCapacity"] = self.workerDiskCapacity!
                }
                if self.workerSpecName != nil {
                    map["WorkerSpecName"] = self.workerSpecName!
                }
                if self.workerSpecType != nil {
                    map["WorkerSpecType"] = self.workerSpecType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AllocateUnit"] as? String {
                    self.allocateUnit = value
                }
                if let value = dict["GroupName"] as? String {
                    self.groupName = value
                }
                if let value = dict["MaxWorkerQuantity"] as? Int32 {
                    self.maxWorkerQuantity = value
                }
                if let value = dict["MinWorkerQuantity"] as? Int32 {
                    self.minWorkerQuantity = value
                }
                if let value = dict["WorkerDiskCapacity"] as? String {
                    self.workerDiskCapacity = value
                }
                if let value = dict["WorkerSpecName"] as? String {
                    self.workerSpecName = value
                }
                if let value = dict["WorkerSpecType"] as? String {
                    self.workerSpecType = value
                }
            }
        }
        public var category: String?

        public var headSpec: String?

        public var workerGroups: [CreateDBResourceGroupRequest.RayConfig.WorkerGroups]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.category != nil {
                map["Category"] = self.category!
            }
            if self.headSpec != nil {
                map["HeadSpec"] = self.headSpec!
            }
            if self.workerGroups != nil {
                var tmp : [Any] = []
                for k in self.workerGroups! {
                    tmp.append(k.toMap())
                }
                map["WorkerGroups"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Category"] as? String {
                self.category = value
            }
            if let value = dict["HeadSpec"] as? String {
                self.headSpec = value
            }
            if let value = dict["WorkerGroups"] as? [Any?] {
                var tmp : [CreateDBResourceGroupRequest.RayConfig.WorkerGroups] = []
                for v in value {
                    if v != nil {
                        var model = CreateDBResourceGroupRequest.RayConfig.WorkerGroups()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.workerGroups = tmp
            }
        }
    }
    public class Rules : Tea.TeaModel {
        public var groupName: String?

        public var queryTime: String?

        public var targetGroupName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.groupName != nil {
                map["GroupName"] = self.groupName!
            }
            if self.queryTime != nil {
                map["QueryTime"] = self.queryTime!
            }
            if self.targetGroupName != nil {
                map["TargetGroupName"] = self.targetGroupName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["GroupName"] as? String {
                self.groupName = value
            }
            if let value = dict["QueryTime"] as? String {
                self.queryTime = value
            }
            if let value = dict["TargetGroupName"] as? String {
                self.targetGroupName = value
            }
        }
    }
    public var autoStopInterval: String?

    public var clusterMode: String?

    public var clusterSizeResource: String?

    public var DBClusterId: String?

    public var enableSpot: Bool?

    public var engine: String?

    public var engineParams: [String: Any]?

    public var groupName: String?

    public var groupType: String?

    public var maxClusterCount: Int32?

    public var maxComputeResource: String?

    public var maxGpuQuantity: Int32?

    public var minClusterCount: Int32?

    public var minComputeResource: String?

    public var minGpuQuantity: Int32?

    public var rayConfig: CreateDBResourceGroupRequest.RayConfig?

    public var regionId: String?

    public var rules: [CreateDBResourceGroupRequest.Rules]?

    public var specName: String?

    public var targetResourceGroupName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.rayConfig?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.autoStopInterval != nil {
            map["AutoStopInterval"] = self.autoStopInterval!
        }
        if self.clusterMode != nil {
            map["ClusterMode"] = self.clusterMode!
        }
        if self.clusterSizeResource != nil {
            map["ClusterSizeResource"] = self.clusterSizeResource!
        }
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.enableSpot != nil {
            map["EnableSpot"] = self.enableSpot!
        }
        if self.engine != nil {
            map["Engine"] = self.engine!
        }
        if self.engineParams != nil {
            map["EngineParams"] = self.engineParams!
        }
        if self.groupName != nil {
            map["GroupName"] = self.groupName!
        }
        if self.groupType != nil {
            map["GroupType"] = self.groupType!
        }
        if self.maxClusterCount != nil {
            map["MaxClusterCount"] = self.maxClusterCount!
        }
        if self.maxComputeResource != nil {
            map["MaxComputeResource"] = self.maxComputeResource!
        }
        if self.maxGpuQuantity != nil {
            map["MaxGpuQuantity"] = self.maxGpuQuantity!
        }
        if self.minClusterCount != nil {
            map["MinClusterCount"] = self.minClusterCount!
        }
        if self.minComputeResource != nil {
            map["MinComputeResource"] = self.minComputeResource!
        }
        if self.minGpuQuantity != nil {
            map["MinGpuQuantity"] = self.minGpuQuantity!
        }
        if self.rayConfig != nil {
            map["RayConfig"] = self.rayConfig?.toMap()
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.rules != nil {
            var tmp : [Any] = []
            for k in self.rules! {
                tmp.append(k.toMap())
            }
            map["Rules"] = tmp
        }
        if self.specName != nil {
            map["SpecName"] = self.specName!
        }
        if self.targetResourceGroupName != nil {
            map["TargetResourceGroupName"] = self.targetResourceGroupName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AutoStopInterval"] as? String {
            self.autoStopInterval = value
        }
        if let value = dict["ClusterMode"] as? String {
            self.clusterMode = value
        }
        if let value = dict["ClusterSizeResource"] as? String {
            self.clusterSizeResource = value
        }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["EnableSpot"] as? Bool {
            self.enableSpot = value
        }
        if let value = dict["Engine"] as? String {
            self.engine = value
        }
        if let value = dict["EngineParams"] as? [String: Any] {
            self.engineParams = value
        }
        if let value = dict["GroupName"] as? String {
            self.groupName = value
        }
        if let value = dict["GroupType"] as? String {
            self.groupType = value
        }
        if let value = dict["MaxClusterCount"] as? Int32 {
            self.maxClusterCount = value
        }
        if let value = dict["MaxComputeResource"] as? String {
            self.maxComputeResource = value
        }
        if let value = dict["MaxGpuQuantity"] as? Int32 {
            self.maxGpuQuantity = value
        }
        if let value = dict["MinClusterCount"] as? Int32 {
            self.minClusterCount = value
        }
        if let value = dict["MinComputeResource"] as? String {
            self.minComputeResource = value
        }
        if let value = dict["MinGpuQuantity"] as? Int32 {
            self.minGpuQuantity = value
        }
        if let value = dict["RayConfig"] as? [String: Any?] {
            var model = CreateDBResourceGroupRequest.RayConfig()
            model.fromMap(value)
            self.rayConfig = model
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["Rules"] as? [Any?] {
            var tmp : [CreateDBResourceGroupRequest.Rules] = []
            for v in value {
                if v != nil {
                    var model = CreateDBResourceGroupRequest.Rules()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.rules = tmp
        }
        if let value = dict["SpecName"] as? String {
            self.specName = value
        }
        if let value = dict["TargetResourceGroupName"] as? String {
            self.targetResourceGroupName = value
        }
    }
}

public class CreateDBResourceGroupShrinkRequest : Tea.TeaModel {
    public var autoStopInterval: String?

    public var clusterMode: String?

    public var clusterSizeResource: String?

    public var DBClusterId: String?

    public var enableSpot: Bool?

    public var engine: String?

    public var engineParamsShrink: String?

    public var groupName: String?

    public var groupType: String?

    public var maxClusterCount: Int32?

    public var maxComputeResource: String?

    public var maxGpuQuantity: Int32?

    public var minClusterCount: Int32?

    public var minComputeResource: String?

    public var minGpuQuantity: Int32?

    public var rayConfigShrink: String?

    public var regionId: String?

    public var rulesShrink: String?

    public var specName: String?

    public var targetResourceGroupName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.autoStopInterval != nil {
            map["AutoStopInterval"] = self.autoStopInterval!
        }
        if self.clusterMode != nil {
            map["ClusterMode"] = self.clusterMode!
        }
        if self.clusterSizeResource != nil {
            map["ClusterSizeResource"] = self.clusterSizeResource!
        }
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.enableSpot != nil {
            map["EnableSpot"] = self.enableSpot!
        }
        if self.engine != nil {
            map["Engine"] = self.engine!
        }
        if self.engineParamsShrink != nil {
            map["EngineParams"] = self.engineParamsShrink!
        }
        if self.groupName != nil {
            map["GroupName"] = self.groupName!
        }
        if self.groupType != nil {
            map["GroupType"] = self.groupType!
        }
        if self.maxClusterCount != nil {
            map["MaxClusterCount"] = self.maxClusterCount!
        }
        if self.maxComputeResource != nil {
            map["MaxComputeResource"] = self.maxComputeResource!
        }
        if self.maxGpuQuantity != nil {
            map["MaxGpuQuantity"] = self.maxGpuQuantity!
        }
        if self.minClusterCount != nil {
            map["MinClusterCount"] = self.minClusterCount!
        }
        if self.minComputeResource != nil {
            map["MinComputeResource"] = self.minComputeResource!
        }
        if self.minGpuQuantity != nil {
            map["MinGpuQuantity"] = self.minGpuQuantity!
        }
        if self.rayConfigShrink != nil {
            map["RayConfig"] = self.rayConfigShrink!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.rulesShrink != nil {
            map["Rules"] = self.rulesShrink!
        }
        if self.specName != nil {
            map["SpecName"] = self.specName!
        }
        if self.targetResourceGroupName != nil {
            map["TargetResourceGroupName"] = self.targetResourceGroupName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AutoStopInterval"] as? String {
            self.autoStopInterval = value
        }
        if let value = dict["ClusterMode"] as? String {
            self.clusterMode = value
        }
        if let value = dict["ClusterSizeResource"] as? String {
            self.clusterSizeResource = value
        }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["EnableSpot"] as? Bool {
            self.enableSpot = value
        }
        if let value = dict["Engine"] as? String {
            self.engine = value
        }
        if let value = dict["EngineParams"] as? String {
            self.engineParamsShrink = value
        }
        if let value = dict["GroupName"] as? String {
            self.groupName = value
        }
        if let value = dict["GroupType"] as? String {
            self.groupType = value
        }
        if let value = dict["MaxClusterCount"] as? Int32 {
            self.maxClusterCount = value
        }
        if let value = dict["MaxComputeResource"] as? String {
            self.maxComputeResource = value
        }
        if let value = dict["MaxGpuQuantity"] as? Int32 {
            self.maxGpuQuantity = value
        }
        if let value = dict["MinClusterCount"] as? Int32 {
            self.minClusterCount = value
        }
        if let value = dict["MinComputeResource"] as? String {
            self.minComputeResource = value
        }
        if let value = dict["MinGpuQuantity"] as? Int32 {
            self.minGpuQuantity = value
        }
        if let value = dict["RayConfig"] as? String {
            self.rayConfigShrink = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["Rules"] as? String {
            self.rulesShrink = value
        }
        if let value = dict["SpecName"] as? String {
            self.specName = value
        }
        if let value = dict["TargetResourceGroupName"] as? String {
            self.targetResourceGroupName = value
        }
    }
}

public class CreateDBResourceGroupResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class CreateDBResourceGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateDBResourceGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateDBResourceGroupResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateElasticPlanRequest : Tea.TeaModel {
    public var autoScale: Bool?

    public var cronExpression: String?

    public var DBClusterId: String?

    public var elasticPlanName: String?

    public var enabled: Bool?

    public var endTime: String?

    public var resourceGroupName: String?

    public var startTime: String?

    public var targetSize: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.autoScale != nil {
            map["AutoScale"] = self.autoScale!
        }
        if self.cronExpression != nil {
            map["CronExpression"] = self.cronExpression!
        }
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.elasticPlanName != nil {
            map["ElasticPlanName"] = self.elasticPlanName!
        }
        if self.enabled != nil {
            map["Enabled"] = self.enabled!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.resourceGroupName != nil {
            map["ResourceGroupName"] = self.resourceGroupName!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.targetSize != nil {
            map["TargetSize"] = self.targetSize!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AutoScale"] as? Bool {
            self.autoScale = value
        }
        if let value = dict["CronExpression"] as? String {
            self.cronExpression = value
        }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["ElasticPlanName"] as? String {
            self.elasticPlanName = value
        }
        if let value = dict["Enabled"] as? Bool {
            self.enabled = value
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["ResourceGroupName"] as? String {
            self.resourceGroupName = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
        if let value = dict["TargetSize"] as? String {
            self.targetSize = value
        }
        if let value = dict["Type"] as? String {
            self.type = value
        }
    }
}

public class CreateElasticPlanResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class CreateElasticPlanResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateElasticPlanResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateElasticPlanResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateLakeStorageRequest : Tea.TeaModel {
    public class Permissions : Tea.TeaModel {
        public var account: String?

        public var read: Bool?

        public var type: String?

        public var write: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.account != nil {
                map["Account"] = self.account!
            }
            if self.read != nil {
                map["Read"] = self.read!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.write != nil {
                map["Write"] = self.write!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Account"] as? String {
                self.account = value
            }
            if let value = dict["Read"] as? Bool {
                self.read = value
            }
            if let value = dict["Type"] as? String {
                self.type = value
            }
            if let value = dict["Write"] as? Bool {
                self.write = value
            }
        }
    }
    public var clientToken: String?

    public var DBClusterId: String?

    public var description_: String?

    public var permissions: [CreateLakeStorageRequest.Permissions]?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.permissions != nil {
            var tmp : [Any] = []
            for k in self.permissions! {
                tmp.append(k.toMap())
            }
            map["Permissions"] = tmp
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["Permissions"] as? [Any?] {
            var tmp : [CreateLakeStorageRequest.Permissions] = []
            for v in value {
                if v != nil {
                    var model = CreateLakeStorageRequest.Permissions()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.permissions = tmp
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class CreateLakeStorageShrinkRequest : Tea.TeaModel {
    public var clientToken: String?

    public var DBClusterId: String?

    public var description_: String?

    public var permissionsShrink: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.permissionsShrink != nil {
            map["Permissions"] = self.permissionsShrink!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["Permissions"] as? String {
            self.permissionsShrink = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class CreateLakeStorageResponseBody : Tea.TeaModel {
    public var code: String?

    public var data: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? String {
            self.data = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class CreateLakeStorageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateLakeStorageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateLakeStorageResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateOssSubDirectoryRequest : Tea.TeaModel {
    public var DBClusterId: String?

    public var path: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.path != nil {
            map["Path"] = self.path!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["Path"] as? String {
            self.path = value
        }
    }
}

public class CreateOssSubDirectoryResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var clientCRC: Int64?

        public var ETag: String?

        public var requestId: String?

        public var serverCRC: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.clientCRC != nil {
                map["ClientCRC"] = self.clientCRC!
            }
            if self.ETag != nil {
                map["ETag"] = self.ETag!
            }
            if self.requestId != nil {
                map["RequestId"] = self.requestId!
            }
            if self.serverCRC != nil {
                map["ServerCRC"] = self.serverCRC!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ClientCRC"] as? Int64 {
                self.clientCRC = value
            }
            if let value = dict["ETag"] as? String {
                self.ETag = value
            }
            if let value = dict["RequestId"] as? String {
                self.requestId = value
            }
            if let value = dict["ServerCRC"] as? Int64 {
                self.serverCRC = value
            }
        }
    }
    public var data: CreateOssSubDirectoryResponseBody.Data?

    public var httpStatusCode: Int64?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [String: Any?] {
            var model = CreateOssSubDirectoryResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["HttpStatusCode"] as? Int64 {
            self.httpStatusCode = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class CreateOssSubDirectoryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateOssSubDirectoryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateOssSubDirectoryResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreatePerformanceViewRequest : Tea.TeaModel {
    public class ViewDetail : Tea.TeaModel {
        public class Categories : Tea.TeaModel {
            public class Keys : Tea.TeaModel {
                public var keyName: String?

                public var selected: Bool?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.keyName != nil {
                        map["KeyName"] = self.keyName!
                    }
                    if self.selected != nil {
                        map["Selected"] = self.selected!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["KeyName"] as? String {
                        self.keyName = value
                    }
                    if let value = dict["Selected"] as? Bool {
                        self.selected = value
                    }
                }
            }
            public var category: String?

            public var keys: [CreatePerformanceViewRequest.ViewDetail.Categories.Keys]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.category != nil {
                    map["Category"] = self.category!
                }
                if self.keys != nil {
                    var tmp : [Any] = []
                    for k in self.keys! {
                        tmp.append(k.toMap())
                    }
                    map["Keys"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Category"] as? String {
                    self.category = value
                }
                if let value = dict["Keys"] as? [Any?] {
                    var tmp : [CreatePerformanceViewRequest.ViewDetail.Categories.Keys] = []
                    for v in value {
                        if v != nil {
                            var model = CreatePerformanceViewRequest.ViewDetail.Categories.Keys()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.keys = tmp
                }
            }
        }
        public var categories: [CreatePerformanceViewRequest.ViewDetail.Categories]?

        public var chartLinked: Bool?

        public var chartsPerLine: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.categories != nil {
                var tmp : [Any] = []
                for k in self.categories! {
                    tmp.append(k.toMap())
                }
                map["Categories"] = tmp
            }
            if self.chartLinked != nil {
                map["ChartLinked"] = self.chartLinked!
            }
            if self.chartsPerLine != nil {
                map["ChartsPerLine"] = self.chartsPerLine!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Categories"] as? [Any?] {
                var tmp : [CreatePerformanceViewRequest.ViewDetail.Categories] = []
                for v in value {
                    if v != nil {
                        var model = CreatePerformanceViewRequest.ViewDetail.Categories()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.categories = tmp
            }
            if let value = dict["ChartLinked"] as? Bool {
                self.chartLinked = value
            }
            if let value = dict["ChartsPerLine"] as? Int32 {
                self.chartsPerLine = value
            }
        }
    }
    public var createFromViewType: String?

    public var DBClusterId: String?

    public var fillOriginViewKeys: Bool?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var viewDetail: CreatePerformanceViewRequest.ViewDetail?

    public var viewName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.viewDetail?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.createFromViewType != nil {
            map["CreateFromViewType"] = self.createFromViewType!
        }
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.fillOriginViewKeys != nil {
            map["FillOriginViewKeys"] = self.fillOriginViewKeys!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.viewDetail != nil {
            map["ViewDetail"] = self.viewDetail?.toMap()
        }
        if self.viewName != nil {
            map["ViewName"] = self.viewName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CreateFromViewType"] as? String {
            self.createFromViewType = value
        }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["FillOriginViewKeys"] as? Bool {
            self.fillOriginViewKeys = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["ViewDetail"] as? [String: Any?] {
            var model = CreatePerformanceViewRequest.ViewDetail()
            model.fromMap(value)
            self.viewDetail = model
        }
        if let value = dict["ViewName"] as? String {
            self.viewName = value
        }
    }
}

public class CreatePerformanceViewShrinkRequest : Tea.TeaModel {
    public var createFromViewType: String?

    public var DBClusterId: String?

    public var fillOriginViewKeys: Bool?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var viewDetailShrink: String?

    public var viewName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.createFromViewType != nil {
            map["CreateFromViewType"] = self.createFromViewType!
        }
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.fillOriginViewKeys != nil {
            map["FillOriginViewKeys"] = self.fillOriginViewKeys!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.viewDetailShrink != nil {
            map["ViewDetail"] = self.viewDetailShrink!
        }
        if self.viewName != nil {
            map["ViewName"] = self.viewName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CreateFromViewType"] as? String {
            self.createFromViewType = value
        }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["FillOriginViewKeys"] as? Bool {
            self.fillOriginViewKeys = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["ViewDetail"] as? String {
            self.viewDetailShrink = value
        }
        if let value = dict["ViewName"] as? String {
            self.viewName = value
        }
    }
}

public class CreatePerformanceViewResponseBody : Tea.TeaModel {
    public var accessDeniedDetail: String?

    public var createStatus: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessDeniedDetail != nil {
            map["AccessDeniedDetail"] = self.accessDeniedDetail!
        }
        if self.createStatus != nil {
            map["CreateStatus"] = self.createStatus!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AccessDeniedDetail"] as? String {
            self.accessDeniedDetail = value
        }
        if let value = dict["CreateStatus"] as? String {
            self.createStatus = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class CreatePerformanceViewResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreatePerformanceViewResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreatePerformanceViewResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateSparkTemplateRequest : Tea.TeaModel {
    public var appType: String?

    public var DBClusterId: String?

    public var name: String?

    public var parentId: Int64?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appType != nil {
            map["AppType"] = self.appType!
        }
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.parentId != nil {
            map["ParentId"] = self.parentId!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppType"] as? String {
            self.appType = value
        }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["Name"] as? String {
            self.name = value
        }
        if let value = dict["ParentId"] as? Int64 {
            self.parentId = value
        }
        if let value = dict["Type"] as? String {
            self.type = value
        }
    }
}

public class CreateSparkTemplateResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var succeeded: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.succeeded != nil {
                map["Succeeded"] = self.succeeded!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Succeeded"] as? Bool {
                self.succeeded = value
            }
        }
    }
    public var data: CreateSparkTemplateResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [String: Any?] {
            var model = CreateSparkTemplateResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class CreateSparkTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateSparkTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateSparkTemplateResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteAccountRequest : Tea.TeaModel {
    public var accountName: String?

    public var DBClusterId: String?

    public var engine: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accountName != nil {
            map["AccountName"] = self.accountName!
        }
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.engine != nil {
            map["Engine"] = self.engine!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AccountName"] as? String {
            self.accountName = value
        }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["Engine"] as? String {
            self.engine = value
        }
    }
}

public class DeleteAccountResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteAccountResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteAccountResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteAccountResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteApsDatasoureRequest : Tea.TeaModel {
    public var DBClusterId: String?

    public var datasourceId: Int64?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.datasourceId != nil {
            map["DatasourceId"] = self.datasourceId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["DatasourceId"] as? Int64 {
            self.datasourceId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class DeleteApsDatasoureResponseBody : Tea.TeaModel {
    public var code: String?

    public var data: String?

    public var httpStatusCode: String?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? String {
            self.data = value
        }
        if let value = dict["HttpStatusCode"] as? String {
            self.httpStatusCode = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? String {
            self.success = value
        }
    }
}

public class DeleteApsDatasoureResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteApsDatasoureResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteApsDatasoureResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteApsJobRequest : Tea.TeaModel {
    public var apsJobId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apsJobId != nil {
            map["ApsJobId"] = self.apsJobId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ApsJobId"] as? String {
            self.apsJobId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class DeleteApsJobResponseBody : Tea.TeaModel {
    public var apsJobId: String?

    public var code: String?

    public var errCode: String?

    public var errMessage: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apsJobId != nil {
            map["ApsJobId"] = self.apsJobId!
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.errCode != nil {
            map["ErrCode"] = self.errCode!
        }
        if self.errMessage != nil {
            map["ErrMessage"] = self.errMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ApsJobId"] as? String {
            self.apsJobId = value
        }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["ErrCode"] as? String {
            self.errCode = value
        }
        if let value = dict["ErrMessage"] as? String {
            self.errMessage = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class DeleteApsJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteApsJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteApsJobResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteBackupsRequest : Tea.TeaModel {
    public var backupIds: String?

    public var DBClusterId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.backupIds != nil {
            map["BackupIds"] = self.backupIds!
        }
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["BackupIds"] as? String {
            self.backupIds = value
        }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DeleteBackupsResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteBackupsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteBackupsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteBackupsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteDBClusterRequest : Tea.TeaModel {
    public var DBClusterId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
    }
}

public class DeleteDBClusterResponseBody : Tea.TeaModel {
    public var DBClusterId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteDBClusterResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteDBClusterResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteDBClusterResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteDBResourceGroupRequest : Tea.TeaModel {
    public var DBClusterId: String?

    public var groupName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.groupName != nil {
            map["GroupName"] = self.groupName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["GroupName"] as? String {
            self.groupName = value
        }
    }
}

public class DeleteDBResourceGroupResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteDBResourceGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteDBResourceGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteDBResourceGroupResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteElasticPlanRequest : Tea.TeaModel {
    public var DBClusterId: String?

    public var elasticPlanName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.elasticPlanName != nil {
            map["ElasticPlanName"] = self.elasticPlanName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["ElasticPlanName"] as? String {
            self.elasticPlanName = value
        }
    }
}

public class DeleteElasticPlanResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteElasticPlanResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteElasticPlanResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteElasticPlanResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteLakeStorageRequest : Tea.TeaModel {
    public var DBClusterId: String?

    public var lakeStorageId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.lakeStorageId != nil {
            map["LakeStorageId"] = self.lakeStorageId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["LakeStorageId"] as? String {
            self.lakeStorageId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class DeleteLakeStorageResponseBody : Tea.TeaModel {
    public var code: String?

    public var data: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? String {
            self.data = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class DeleteLakeStorageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteLakeStorageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteLakeStorageResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeletePerformanceViewRequest : Tea.TeaModel {
    public var DBClusterId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var viewName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.viewName != nil {
            map["ViewName"] = self.viewName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["ViewName"] as? String {
            self.viewName = value
        }
    }
}

public class DeletePerformanceViewResponseBody : Tea.TeaModel {
    public var accessDeniedDetail: String?

    public var deleteStatus: Bool?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessDeniedDetail != nil {
            map["AccessDeniedDetail"] = self.accessDeniedDetail!
        }
        if self.deleteStatus != nil {
            map["DeleteStatus"] = self.deleteStatus!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AccessDeniedDetail"] as? String {
            self.accessDeniedDetail = value
        }
        if let value = dict["DeleteStatus"] as? Bool {
            self.deleteStatus = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeletePerformanceViewResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeletePerformanceViewResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeletePerformanceViewResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteSparkTemplateRequest : Tea.TeaModel {
    public var DBClusterId: String?

    public var id: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["Id"] as? Int64 {
            self.id = value
        }
    }
}

public class DeleteSparkTemplateResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var succeeded: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.succeeded != nil {
                map["Succeeded"] = self.succeeded!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Succeeded"] as? Bool {
                self.succeeded = value
            }
        }
    }
    public var data: DeleteSparkTemplateResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [String: Any?] {
            var model = DeleteSparkTemplateResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteSparkTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteSparkTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteSparkTemplateResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteSparkTemplateFileRequest : Tea.TeaModel {
    public var DBClusterId: String?

    public var id: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["Id"] as? Int64 {
            self.id = value
        }
    }
}

public class DeleteSparkTemplateFileResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var succeeded: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.succeeded != nil {
                map["Succeeded"] = self.succeeded!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Succeeded"] as? Bool {
                self.succeeded = value
            }
        }
    }
    public var data: DeleteSparkTemplateFileResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [String: Any?] {
            var model = DeleteSparkTemplateFileResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteSparkTemplateFileResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteSparkTemplateFileResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteSparkTemplateFileResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeAPSADBInstancesRequest : Tea.TeaModel {
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class DescribeAPSADBInstancesResponseBody : Tea.TeaModel {
    public class Items : Tea.TeaModel {
        public var computeResource: String?

        public var DBClusterDescription: String?

        public var DBClusterId: String?

        public var DBClusterStatus: String?

        public var reservedACU: String?

        public var storageResource: Int64?

        public var zoneId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.computeResource != nil {
                map["ComputeResource"] = self.computeResource!
            }
            if self.DBClusterDescription != nil {
                map["DBClusterDescription"] = self.DBClusterDescription!
            }
            if self.DBClusterId != nil {
                map["DBClusterId"] = self.DBClusterId!
            }
            if self.DBClusterStatus != nil {
                map["DBClusterStatus"] = self.DBClusterStatus!
            }
            if self.reservedACU != nil {
                map["ReservedACU"] = self.reservedACU!
            }
            if self.storageResource != nil {
                map["StorageResource"] = self.storageResource!
            }
            if self.zoneId != nil {
                map["ZoneId"] = self.zoneId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ComputeResource"] as? String {
                self.computeResource = value
            }
            if let value = dict["DBClusterDescription"] as? String {
                self.DBClusterDescription = value
            }
            if let value = dict["DBClusterId"] as? String {
                self.DBClusterId = value
            }
            if let value = dict["DBClusterStatus"] as? String {
                self.DBClusterStatus = value
            }
            if let value = dict["ReservedACU"] as? String {
                self.reservedACU = value
            }
            if let value = dict["StorageResource"] as? Int64 {
                self.storageResource = value
            }
            if let value = dict["ZoneId"] as? String {
                self.zoneId = value
            }
        }
    }
    public var code: String?

    public var httpStatusCode: Int32?

    public var items: [DescribeAPSADBInstancesResponseBody.Items]?

    public var message: String?

    public var pageNumber: String?

    public var pageSize: String?

    public var requestId: String?

    public var success: Bool?

    public var totalCount: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.items != nil {
            var tmp : [Any] = []
            for k in self.items! {
                tmp.append(k.toMap())
            }
            map["Items"] = tmp
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["Items"] as? [Any?] {
            var tmp : [DescribeAPSADBInstancesResponseBody.Items] = []
            for v in value {
                if v != nil {
                    var model = DescribeAPSADBInstancesResponseBody.Items()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.items = tmp
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["PageNumber"] as? String {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? String {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
        if let value = dict["TotalCount"] as? String {
            self.totalCount = value
        }
    }
}

public class DescribeAPSADBInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAPSADBInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeAPSADBInstancesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeAbnormalPatternDetectionRequest : Tea.TeaModel {
    public var DBClusterId: String?

    public var endTime: String?

    public var lang: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["Lang"] as? String {
            self.lang = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
    }
}

public class DescribeAbnormalPatternDetectionResponseBody : Tea.TeaModel {
    public class DetectionItems : Tea.TeaModel {
        public class Results : Tea.TeaModel {
            public var accessIp: String?

            public var detail: String?

            public var failedCount: Int64?

            public var patternId: String?

            public var queryCount: Int64?

            public var relatedMetrics: String?

            public var SQLPattern: String?

            public var tables: String?

            public var user: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.accessIp != nil {
                    map["AccessIp"] = self.accessIp!
                }
                if self.detail != nil {
                    map["Detail"] = self.detail!
                }
                if self.failedCount != nil {
                    map["FailedCount"] = self.failedCount!
                }
                if self.patternId != nil {
                    map["PatternId"] = self.patternId!
                }
                if self.queryCount != nil {
                    map["QueryCount"] = self.queryCount!
                }
                if self.relatedMetrics != nil {
                    map["RelatedMetrics"] = self.relatedMetrics!
                }
                if self.SQLPattern != nil {
                    map["SQLPattern"] = self.SQLPattern!
                }
                if self.tables != nil {
                    map["Tables"] = self.tables!
                }
                if self.user != nil {
                    map["User"] = self.user!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AccessIp"] as? String {
                    self.accessIp = value
                }
                if let value = dict["Detail"] as? String {
                    self.detail = value
                }
                if let value = dict["FailedCount"] as? Int64 {
                    self.failedCount = value
                }
                if let value = dict["PatternId"] as? String {
                    self.patternId = value
                }
                if let value = dict["QueryCount"] as? Int64 {
                    self.queryCount = value
                }
                if let value = dict["RelatedMetrics"] as? String {
                    self.relatedMetrics = value
                }
                if let value = dict["SQLPattern"] as? String {
                    self.SQLPattern = value
                }
                if let value = dict["Tables"] as? String {
                    self.tables = value
                }
                if let value = dict["User"] as? String {
                    self.user = value
                }
            }
        }
        public var name: String?

        public var results: [DescribeAbnormalPatternDetectionResponseBody.DetectionItems.Results]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.results != nil {
                var tmp : [Any] = []
                for k in self.results! {
                    tmp.append(k.toMap())
                }
                map["Results"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Name"] as? String {
                self.name = value
            }
            if let value = dict["Results"] as? [Any?] {
                var tmp : [DescribeAbnormalPatternDetectionResponseBody.DetectionItems.Results] = []
                for v in value {
                    if v != nil {
                        var model = DescribeAbnormalPatternDetectionResponseBody.DetectionItems.Results()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.results = tmp
            }
        }
    }
    public var DBClusterId: String?

    public var detectionItems: [DescribeAbnormalPatternDetectionResponseBody.DetectionItems]?

    public var requestId: String?

    public var totalCount: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.detectionItems != nil {
            var tmp : [Any] = []
            for k in self.detectionItems! {
                tmp.append(k.toMap())
            }
            map["DetectionItems"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["DetectionItems"] as? [Any?] {
            var tmp : [DescribeAbnormalPatternDetectionResponseBody.DetectionItems] = []
            for v in value {
                if v != nil {
                    var model = DescribeAbnormalPatternDetectionResponseBody.DetectionItems()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.detectionItems = tmp
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? String {
            self.totalCount = value
        }
    }
}

public class DescribeAbnormalPatternDetectionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAbnormalPatternDetectionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeAbnormalPatternDetectionResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeAccountAllPrivilegesRequest : Tea.TeaModel {
    public var accountName: String?

    public var DBClusterId: String?

    public var marker: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accountName != nil {
            map["AccountName"] = self.accountName!
        }
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.marker != nil {
            map["Marker"] = self.marker!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AccountName"] as? String {
            self.accountName = value
        }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["Marker"] as? String {
            self.marker = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class DescribeAccountAllPrivilegesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Result : Tea.TeaModel {
            public class PrivilegeObject : Tea.TeaModel {
                public var column: String?

                public var database: String?

                public var description_: String?

                public var table: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.column != nil {
                        map["Column"] = self.column!
                    }
                    if self.database != nil {
                        map["Database"] = self.database!
                    }
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.table != nil {
                        map["Table"] = self.table!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Column"] as? String {
                        self.column = value
                    }
                    if let value = dict["Database"] as? String {
                        self.database = value
                    }
                    if let value = dict["Description"] as? String {
                        self.description_ = value
                    }
                    if let value = dict["Table"] as? String {
                        self.table = value
                    }
                }
            }
            public var privilegeObject: DescribeAccountAllPrivilegesResponseBody.Data.Result.PrivilegeObject?

            public var privilegeType: String?

            public var privileges: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.privilegeObject?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.privilegeObject != nil {
                    map["PrivilegeObject"] = self.privilegeObject?.toMap()
                }
                if self.privilegeType != nil {
                    map["PrivilegeType"] = self.privilegeType!
                }
                if self.privileges != nil {
                    map["Privileges"] = self.privileges!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["PrivilegeObject"] as? [String: Any?] {
                    var model = DescribeAccountAllPrivilegesResponseBody.Data.Result.PrivilegeObject()
                    model.fromMap(value)
                    self.privilegeObject = model
                }
                if let value = dict["PrivilegeType"] as? String {
                    self.privilegeType = value
                }
                if let value = dict["Privileges"] as? [String] {
                    self.privileges = value
                }
            }
        }
        public var marker: String?

        public var result: [DescribeAccountAllPrivilegesResponseBody.Data.Result]?

        public var truncated: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.marker != nil {
                map["Marker"] = self.marker!
            }
            if self.result != nil {
                var tmp : [Any] = []
                for k in self.result! {
                    tmp.append(k.toMap())
                }
                map["Result"] = tmp
            }
            if self.truncated != nil {
                map["Truncated"] = self.truncated!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Marker"] as? String {
                self.marker = value
            }
            if let value = dict["Result"] as? [Any?] {
                var tmp : [DescribeAccountAllPrivilegesResponseBody.Data.Result] = []
                for v in value {
                    if v != nil {
                        var model = DescribeAccountAllPrivilegesResponseBody.Data.Result()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.result = tmp
            }
            if let value = dict["Truncated"] as? Bool {
                self.truncated = value
            }
        }
    }
    public var data: DescribeAccountAllPrivilegesResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [String: Any?] {
            var model = DescribeAccountAllPrivilegesResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeAccountAllPrivilegesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAccountAllPrivilegesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeAccountAllPrivilegesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeAccountPrivilegeObjectsRequest : Tea.TeaModel {
    public var accountName: String?

    public var columnPrivilegeObject: String?

    public var DBClusterId: String?

    public var databasePrivilegeObject: String?

    public var pageNumber: String?

    public var pageSize: String?

    public var privilegeType: String?

    public var regionId: String?

    public var tablePrivilegeObject: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accountName != nil {
            map["AccountName"] = self.accountName!
        }
        if self.columnPrivilegeObject != nil {
            map["ColumnPrivilegeObject"] = self.columnPrivilegeObject!
        }
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.databasePrivilegeObject != nil {
            map["DatabasePrivilegeObject"] = self.databasePrivilegeObject!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.privilegeType != nil {
            map["PrivilegeType"] = self.privilegeType!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.tablePrivilegeObject != nil {
            map["TablePrivilegeObject"] = self.tablePrivilegeObject!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AccountName"] as? String {
            self.accountName = value
        }
        if let value = dict["ColumnPrivilegeObject"] as? String {
            self.columnPrivilegeObject = value
        }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["DatabasePrivilegeObject"] as? String {
            self.databasePrivilegeObject = value
        }
        if let value = dict["PageNumber"] as? String {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? String {
            self.pageSize = value
        }
        if let value = dict["PrivilegeType"] as? String {
            self.privilegeType = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["TablePrivilegeObject"] as? String {
            self.tablePrivilegeObject = value
        }
    }
}

public class DescribeAccountPrivilegeObjectsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var column: String?

        public var database: String?

        public var description_: String?

        public var table: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.column != nil {
                map["Column"] = self.column!
            }
            if self.database != nil {
                map["Database"] = self.database!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.table != nil {
                map["Table"] = self.table!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Column"] as? String {
                self.column = value
            }
            if let value = dict["Database"] as? String {
                self.database = value
            }
            if let value = dict["Description"] as? String {
                self.description_ = value
            }
            if let value = dict["Table"] as? String {
                self.table = value
            }
        }
    }
    public var data: [DescribeAccountPrivilegeObjectsResponseBody.Data]?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var requestId: String?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [Any?] {
            var tmp : [DescribeAccountPrivilegeObjectsResponseBody.Data] = []
            for v in value {
                if v != nil {
                    var model = DescribeAccountPrivilegeObjectsResponseBody.Data()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.data = tmp
        }
        if let value = dict["PageNumber"] as? Int64 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int64 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? Int64 {
            self.totalCount = value
        }
    }
}

public class DescribeAccountPrivilegeObjectsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAccountPrivilegeObjectsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeAccountPrivilegeObjectsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeAccountPrivilegesRequest : Tea.TeaModel {
    public var accountName: String?

    public var columnPrivilegeObject: String?

    public var DBClusterId: String?

    public var databasePrivilegeObject: String?

    public var pageNumber: String?

    public var pageSize: String?

    public var privilegeType: String?

    public var regionId: String?

    public var tablePrivilegeObject: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accountName != nil {
            map["AccountName"] = self.accountName!
        }
        if self.columnPrivilegeObject != nil {
            map["ColumnPrivilegeObject"] = self.columnPrivilegeObject!
        }
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.databasePrivilegeObject != nil {
            map["DatabasePrivilegeObject"] = self.databasePrivilegeObject!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.privilegeType != nil {
            map["PrivilegeType"] = self.privilegeType!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.tablePrivilegeObject != nil {
            map["TablePrivilegeObject"] = self.tablePrivilegeObject!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AccountName"] as? String {
            self.accountName = value
        }
        if let value = dict["ColumnPrivilegeObject"] as? String {
            self.columnPrivilegeObject = value
        }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["DatabasePrivilegeObject"] as? String {
            self.databasePrivilegeObject = value
        }
        if let value = dict["PageNumber"] as? String {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? String {
            self.pageSize = value
        }
        if let value = dict["PrivilegeType"] as? String {
            self.privilegeType = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["TablePrivilegeObject"] as? String {
            self.tablePrivilegeObject = value
        }
    }
}

public class DescribeAccountPrivilegesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class PrivilegeObject : Tea.TeaModel {
            public var column: String?

            public var database: String?

            public var description_: String?

            public var table: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.column != nil {
                    map["Column"] = self.column!
                }
                if self.database != nil {
                    map["Database"] = self.database!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.table != nil {
                    map["Table"] = self.table!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Column"] as? String {
                    self.column = value
                }
                if let value = dict["Database"] as? String {
                    self.database = value
                }
                if let value = dict["Description"] as? String {
                    self.description_ = value
                }
                if let value = dict["Table"] as? String {
                    self.table = value
                }
            }
        }
        public var privilegeObject: DescribeAccountPrivilegesResponseBody.Data.PrivilegeObject?

        public var privilegeType: String?

        public var privileges: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.privilegeObject?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.privilegeObject != nil {
                map["PrivilegeObject"] = self.privilegeObject?.toMap()
            }
            if self.privilegeType != nil {
                map["PrivilegeType"] = self.privilegeType!
            }
            if self.privileges != nil {
                map["Privileges"] = self.privileges!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["PrivilegeObject"] as? [String: Any?] {
                var model = DescribeAccountPrivilegesResponseBody.Data.PrivilegeObject()
                model.fromMap(value)
                self.privilegeObject = model
            }
            if let value = dict["PrivilegeType"] as? String {
                self.privilegeType = value
            }
            if let value = dict["Privileges"] as? [String] {
                self.privileges = value
            }
        }
    }
    public var data: [DescribeAccountPrivilegesResponseBody.Data]?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var requestId: String?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [Any?] {
            var tmp : [DescribeAccountPrivilegesResponseBody.Data] = []
            for v in value {
                if v != nil {
                    var model = DescribeAccountPrivilegesResponseBody.Data()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.data = tmp
        }
        if let value = dict["PageNumber"] as? Int64 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int64 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? Int64 {
            self.totalCount = value
        }
    }
}

public class DescribeAccountPrivilegesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAccountPrivilegesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeAccountPrivilegesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeAccountsRequest : Tea.TeaModel {
    public var accountName: String?

    public var DBClusterId: String?

    public var engine: String?

    public var ownerId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accountName != nil {
            map["AccountName"] = self.accountName!
        }
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.engine != nil {
            map["Engine"] = self.engine!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AccountName"] as? String {
            self.accountName = value
        }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["Engine"] as? String {
            self.engine = value
        }
        if let value = dict["OwnerId"] as? String {
            self.ownerId = value
        }
    }
}

public class DescribeAccountsResponseBody : Tea.TeaModel {
    public class AccountList : Tea.TeaModel {
        public class DBAccount : Tea.TeaModel {
            public var accountDescription: String?

            public var accountName: String?

            public var accountStatus: String?

            public var accountType: String?

            public var engine: String?

            public var ramUsers: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.accountDescription != nil {
                    map["AccountDescription"] = self.accountDescription!
                }
                if self.accountName != nil {
                    map["AccountName"] = self.accountName!
                }
                if self.accountStatus != nil {
                    map["AccountStatus"] = self.accountStatus!
                }
                if self.accountType != nil {
                    map["AccountType"] = self.accountType!
                }
                if self.engine != nil {
                    map["Engine"] = self.engine!
                }
                if self.ramUsers != nil {
                    map["RamUsers"] = self.ramUsers!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AccountDescription"] as? String {
                    self.accountDescription = value
                }
                if let value = dict["AccountName"] as? String {
                    self.accountName = value
                }
                if let value = dict["AccountStatus"] as? String {
                    self.accountStatus = value
                }
                if let value = dict["AccountType"] as? String {
                    self.accountType = value
                }
                if let value = dict["Engine"] as? String {
                    self.engine = value
                }
                if let value = dict["RamUsers"] as? String {
                    self.ramUsers = value
                }
            }
        }
        public var DBAccount: [DescribeAccountsResponseBody.AccountList.DBAccount]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.DBAccount != nil {
                var tmp : [Any] = []
                for k in self.DBAccount! {
                    tmp.append(k.toMap())
                }
                map["DBAccount"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DBAccount"] as? [Any?] {
                var tmp : [DescribeAccountsResponseBody.AccountList.DBAccount] = []
                for v in value {
                    if v != nil {
                        var model = DescribeAccountsResponseBody.AccountList.DBAccount()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.DBAccount = tmp
            }
        }
    }
    public var accountList: DescribeAccountsResponseBody.AccountList?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accountList != nil {
            map["AccountList"] = self.accountList?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AccountList"] as? [String: Any?] {
            var model = DescribeAccountsResponseBody.AccountList()
            model.fromMap(value)
            self.accountList = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeAccountsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAccountsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeAccountsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeAdbMySqlColumnsRequest : Tea.TeaModel {
    public var DBClusterId: String?

    public var regionId: String?

    public var schema: String?

    public var tableName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.schema != nil {
            map["Schema"] = self.schema!
        }
        if self.tableName != nil {
            map["TableName"] = self.tableName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["Schema"] as? String {
            self.schema = value
        }
        if let value = dict["TableName"] as? String {
            self.tableName = value
        }
    }
}

public class DescribeAdbMySqlColumnsResponseBody : Tea.TeaModel {
    public class Columns : Tea.TeaModel {
        public var comment: String?

        public var name: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.comment != nil {
                map["Comment"] = self.comment!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Comment"] as? String {
                self.comment = value
            }
            if let value = dict["Name"] as? String {
                self.name = value
            }
            if let value = dict["Type"] as? String {
                self.type = value
            }
        }
    }
    public var columnCount: Int32?

    public var columns: [DescribeAdbMySqlColumnsResponseBody.Columns]?

    public var message: String?

    public var requestId: String?

    public var schema: String?

    public var success: Bool?

    public var tableName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.columnCount != nil {
            map["ColumnCount"] = self.columnCount!
        }
        if self.columns != nil {
            var tmp : [Any] = []
            for k in self.columns! {
                tmp.append(k.toMap())
            }
            map["Columns"] = tmp
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.schema != nil {
            map["Schema"] = self.schema!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.tableName != nil {
            map["TableName"] = self.tableName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ColumnCount"] as? Int32 {
            self.columnCount = value
        }
        if let value = dict["Columns"] as? [Any?] {
            var tmp : [DescribeAdbMySqlColumnsResponseBody.Columns] = []
            for v in value {
                if v != nil {
                    var model = DescribeAdbMySqlColumnsResponseBody.Columns()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.columns = tmp
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Schema"] as? String {
            self.schema = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
        if let value = dict["TableName"] as? String {
            self.tableName = value
        }
    }
}

public class DescribeAdbMySqlColumnsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAdbMySqlColumnsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeAdbMySqlColumnsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeAdbMySqlIndexesRequest : Tea.TeaModel {
    public var DBClusterId: String?

    public var regionId: String?

    public var schema: String?

    public var tableName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.schema != nil {
            map["Schema"] = self.schema!
        }
        if self.tableName != nil {
            map["TableName"] = self.tableName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["Schema"] as? String {
            self.schema = value
        }
        if let value = dict["TableName"] as? String {
            self.tableName = value
        }
    }
}

public class DescribeAdbMySqlIndexesResponseBody : Tea.TeaModel {
    public class Indexes : Tea.TeaModel {
        public var column: String?

        public var name: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.column != nil {
                map["Column"] = self.column!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Column"] as? String {
                self.column = value
            }
            if let value = dict["Name"] as? String {
                self.name = value
            }
            if let value = dict["Type"] as? String {
                self.type = value
            }
        }
    }
    public var indexCount: Int32?

    public var indexes: [DescribeAdbMySqlIndexesResponseBody.Indexes]?

    public var message: String?

    public var requestId: String?

    public var schema: String?

    public var success: Bool?

    public var tableName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.indexCount != nil {
            map["IndexCount"] = self.indexCount!
        }
        if self.indexes != nil {
            var tmp : [Any] = []
            for k in self.indexes! {
                tmp.append(k.toMap())
            }
            map["Indexes"] = tmp
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.schema != nil {
            map["Schema"] = self.schema!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.tableName != nil {
            map["TableName"] = self.tableName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["IndexCount"] as? Int32 {
            self.indexCount = value
        }
        if let value = dict["Indexes"] as? [Any?] {
            var tmp : [DescribeAdbMySqlIndexesResponseBody.Indexes] = []
            for v in value {
                if v != nil {
                    var model = DescribeAdbMySqlIndexesResponseBody.Indexes()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.indexes = tmp
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Schema"] as? String {
            self.schema = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
        if let value = dict["TableName"] as? String {
            self.tableName = value
        }
    }
}

public class DescribeAdbMySqlIndexesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAdbMySqlIndexesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeAdbMySqlIndexesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeAdbMySqlSchemasRequest : Tea.TeaModel {
    public var DBClusterId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class DescribeAdbMySqlSchemasResponseBody : Tea.TeaModel {
    public var message: String?

    public var requestId: String?

    public var schemas: [String]?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.schemas != nil {
            map["Schemas"] = self.schemas!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Schemas"] as? [String] {
            self.schemas = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class DescribeAdbMySqlSchemasResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAdbMySqlSchemasResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeAdbMySqlSchemasResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeAdbMySqlTableMetaRequest : Tea.TeaModel {
    public var DBClusterId: String?

    public var regionId: String?

    public var schema: String?

    public var tableName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.schema != nil {
            map["Schema"] = self.schema!
        }
        if self.tableName != nil {
            map["TableName"] = self.tableName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["Schema"] as? String {
            self.schema = value
        }
        if let value = dict["TableName"] as? String {
            self.tableName = value
        }
    }
}

public class DescribeAdbMySqlTableMetaResponseBody : Tea.TeaModel {
    public class TableMeta : Tea.TeaModel {
        public var createTime: String?

        public var distributeColumn: String?

        public var distributeType: String?

        public var isAllIndex: Bool?

        public var isDictEncode: Bool?

        public var isFullTextDict: Bool?

        public var isHidden: Bool?

        public var partitionColumn: String?

        public var partitionType: String?

        public var primaryKeyColumn: String?

        public var tableEngine: String?

        public var tableName: String?

        public var tableSchema: String?

        public var tableType: String?

        public var updateTime: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.distributeColumn != nil {
                map["DistributeColumn"] = self.distributeColumn!
            }
            if self.distributeType != nil {
                map["DistributeType"] = self.distributeType!
            }
            if self.isAllIndex != nil {
                map["IsAllIndex"] = self.isAllIndex!
            }
            if self.isDictEncode != nil {
                map["IsDictEncode"] = self.isDictEncode!
            }
            if self.isFullTextDict != nil {
                map["IsFullTextDict"] = self.isFullTextDict!
            }
            if self.isHidden != nil {
                map["IsHidden"] = self.isHidden!
            }
            if self.partitionColumn != nil {
                map["PartitionColumn"] = self.partitionColumn!
            }
            if self.partitionType != nil {
                map["PartitionType"] = self.partitionType!
            }
            if self.primaryKeyColumn != nil {
                map["PrimaryKeyColumn"] = self.primaryKeyColumn!
            }
            if self.tableEngine != nil {
                map["TableEngine"] = self.tableEngine!
            }
            if self.tableName != nil {
                map["TableName"] = self.tableName!
            }
            if self.tableSchema != nil {
                map["TableSchema"] = self.tableSchema!
            }
            if self.tableType != nil {
                map["TableType"] = self.tableType!
            }
            if self.updateTime != nil {
                map["UpdateTime"] = self.updateTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["CreateTime"] as? String {
                self.createTime = value
            }
            if let value = dict["DistributeColumn"] as? String {
                self.distributeColumn = value
            }
            if let value = dict["DistributeType"] as? String {
                self.distributeType = value
            }
            if let value = dict["IsAllIndex"] as? Bool {
                self.isAllIndex = value
            }
            if let value = dict["IsDictEncode"] as? Bool {
                self.isDictEncode = value
            }
            if let value = dict["IsFullTextDict"] as? Bool {
                self.isFullTextDict = value
            }
            if let value = dict["IsHidden"] as? Bool {
                self.isHidden = value
            }
            if let value = dict["PartitionColumn"] as? String {
                self.partitionColumn = value
            }
            if let value = dict["PartitionType"] as? String {
                self.partitionType = value
            }
            if let value = dict["PrimaryKeyColumn"] as? String {
                self.primaryKeyColumn = value
            }
            if let value = dict["TableEngine"] as? String {
                self.tableEngine = value
            }
            if let value = dict["TableName"] as? String {
                self.tableName = value
            }
            if let value = dict["TableSchema"] as? String {
                self.tableSchema = value
            }
            if let value = dict["TableType"] as? String {
                self.tableType = value
            }
            if let value = dict["UpdateTime"] as? String {
                self.updateTime = value
            }
        }
    }
    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var tableMeta: DescribeAdbMySqlTableMetaResponseBody.TableMeta?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tableMeta?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.tableMeta != nil {
            map["TableMeta"] = self.tableMeta?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
        if let value = dict["TableMeta"] as? [String: Any?] {
            var model = DescribeAdbMySqlTableMetaResponseBody.TableMeta()
            model.fromMap(value)
            self.tableMeta = model
        }
    }
}

public class DescribeAdbMySqlTableMetaResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAdbMySqlTableMetaResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeAdbMySqlTableMetaResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeAdbMySqlTablesRequest : Tea.TeaModel {
    public var DBClusterId: String?

    public var regionId: String?

    public var schema: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.schema != nil {
            map["Schema"] = self.schema!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["Schema"] as? String {
            self.schema = value
        }
    }
}

public class DescribeAdbMySqlTablesResponseBody : Tea.TeaModel {
    public var message: String?

    public var requestId: String?

    public var schema: String?

    public var success: Bool?

    public var tables: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.schema != nil {
            map["Schema"] = self.schema!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.tables != nil {
            map["Tables"] = self.tables!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Schema"] as? String {
            self.schema = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
        if let value = dict["Tables"] as? [String] {
            self.tables = value
        }
    }
}

public class DescribeAdbMySqlTablesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAdbMySqlTablesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeAdbMySqlTablesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeAdviceServiceEnabledRequest : Tea.TeaModel {
    public var DBClusterId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class DescribeAdviceServiceEnabledResponseBody : Tea.TeaModel {
    public var message: String?

    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? Bool {
            self.result = value
        }
    }
}

public class DescribeAdviceServiceEnabledResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAdviceServiceEnabledResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeAdviceServiceEnabledResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeAllDataSourceRequest : Tea.TeaModel {
    public var DBClusterId: String?

    public var regionId: String?

    public var schemaName: String?

    public var tableName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.schemaName != nil {
            map["SchemaName"] = self.schemaName!
        }
        if self.tableName != nil {
            map["TableName"] = self.tableName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["SchemaName"] as? String {
            self.schemaName = value
        }
        if let value = dict["TableName"] as? String {
            self.tableName = value
        }
    }
}

public class DescribeAllDataSourceResponseBody : Tea.TeaModel {
    public class Columns : Tea.TeaModel {
        public class Column : Tea.TeaModel {
            public var autoIncrementColumn: Bool?

            public var columnName: String?

            public var DBClusterId: String?

            public var primaryKey: Bool?

            public var schemaName: String?

            public var tableName: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.autoIncrementColumn != nil {
                    map["AutoIncrementColumn"] = self.autoIncrementColumn!
                }
                if self.columnName != nil {
                    map["ColumnName"] = self.columnName!
                }
                if self.DBClusterId != nil {
                    map["DBClusterId"] = self.DBClusterId!
                }
                if self.primaryKey != nil {
                    map["PrimaryKey"] = self.primaryKey!
                }
                if self.schemaName != nil {
                    map["SchemaName"] = self.schemaName!
                }
                if self.tableName != nil {
                    map["TableName"] = self.tableName!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AutoIncrementColumn"] as? Bool {
                    self.autoIncrementColumn = value
                }
                if let value = dict["ColumnName"] as? String {
                    self.columnName = value
                }
                if let value = dict["DBClusterId"] as? String {
                    self.DBClusterId = value
                }
                if let value = dict["PrimaryKey"] as? Bool {
                    self.primaryKey = value
                }
                if let value = dict["SchemaName"] as? String {
                    self.schemaName = value
                }
                if let value = dict["TableName"] as? String {
                    self.tableName = value
                }
                if let value = dict["Type"] as? String {
                    self.type = value
                }
            }
        }
        public var column: [DescribeAllDataSourceResponseBody.Columns.Column]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.column != nil {
                var tmp : [Any] = []
                for k in self.column! {
                    tmp.append(k.toMap())
                }
                map["Column"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Column"] as? [Any?] {
                var tmp : [DescribeAllDataSourceResponseBody.Columns.Column] = []
                for v in value {
                    if v != nil {
                        var model = DescribeAllDataSourceResponseBody.Columns.Column()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.column = tmp
            }
        }
    }
    public class Schemas : Tea.TeaModel {
        public class Schema : Tea.TeaModel {
            public var DBClusterId: String?

            public var schemaName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.DBClusterId != nil {
                    map["DBClusterId"] = self.DBClusterId!
                }
                if self.schemaName != nil {
                    map["SchemaName"] = self.schemaName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["DBClusterId"] as? String {
                    self.DBClusterId = value
                }
                if let value = dict["SchemaName"] as? String {
                    self.schemaName = value
                }
            }
        }
        public var schema: [DescribeAllDataSourceResponseBody.Schemas.Schema]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.schema != nil {
                var tmp : [Any] = []
                for k in self.schema! {
                    tmp.append(k.toMap())
                }
                map["Schema"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Schema"] as? [Any?] {
                var tmp : [DescribeAllDataSourceResponseBody.Schemas.Schema] = []
                for v in value {
                    if v != nil {
                        var model = DescribeAllDataSourceResponseBody.Schemas.Schema()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.schema = tmp
            }
        }
    }
    public class Tables : Tea.TeaModel {
        public class Table : Tea.TeaModel {
            public var DBClusterId: String?

            public var schemaName: String?

            public var tableName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.DBClusterId != nil {
                    map["DBClusterId"] = self.DBClusterId!
                }
                if self.schemaName != nil {
                    map["SchemaName"] = self.schemaName!
                }
                if self.tableName != nil {
                    map["TableName"] = self.tableName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["DBClusterId"] as? String {
                    self.DBClusterId = value
                }
                if let value = dict["SchemaName"] as? String {
                    self.schemaName = value
                }
                if let value = dict["TableName"] as? String {
                    self.tableName = value
                }
            }
        }
        public var table: [DescribeAllDataSourceResponseBody.Tables.Table]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.table != nil {
                var tmp : [Any] = []
                for k in self.table! {
                    tmp.append(k.toMap())
                }
                map["Table"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Table"] as? [Any?] {
                var tmp : [DescribeAllDataSourceResponseBody.Tables.Table] = []
                for v in value {
                    if v != nil {
                        var model = DescribeAllDataSourceResponseBody.Tables.Table()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.table = tmp
            }
        }
    }
    public var columns: DescribeAllDataSourceResponseBody.Columns?

    public var requestId: String?

    public var schemas: DescribeAllDataSourceResponseBody.Schemas?

    public var tables: DescribeAllDataSourceResponseBody.Tables?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.columns?.validate()
        try self.schemas?.validate()
        try self.tables?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.columns != nil {
            map["Columns"] = self.columns?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.schemas != nil {
            map["Schemas"] = self.schemas?.toMap()
        }
        if self.tables != nil {
            map["Tables"] = self.tables?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Columns"] as? [String: Any?] {
            var model = DescribeAllDataSourceResponseBody.Columns()
            model.fromMap(value)
            self.columns = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Schemas"] as? [String: Any?] {
            var model = DescribeAllDataSourceResponseBody.Schemas()
            model.fromMap(value)
            self.schemas = model
        }
        if let value = dict["Tables"] as? [String: Any?] {
            var model = DescribeAllDataSourceResponseBody.Tables()
            model.fromMap(value)
            self.tables = model
        }
    }
}

public class DescribeAllDataSourceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAllDataSourceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeAllDataSourceResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeAppliedAdvicesRequest : Tea.TeaModel {
    public var adviceType: String?

    public var DBClusterId: String?

    public var endTime: Int64?

    public var keyword: String?

    public var lang: String?

    public var order: String?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var regionId: String?

    public var schemaTableName: String?

    public var startTime: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.adviceType != nil {
            map["AdviceType"] = self.adviceType!
        }
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.keyword != nil {
            map["Keyword"] = self.keyword!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.order != nil {
            map["Order"] = self.order!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.schemaTableName != nil {
            map["SchemaTableName"] = self.schemaTableName!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AdviceType"] as? String {
            self.adviceType = value
        }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["EndTime"] as? Int64 {
            self.endTime = value
        }
        if let value = dict["Keyword"] as? String {
            self.keyword = value
        }
        if let value = dict["Lang"] as? String {
            self.lang = value
        }
        if let value = dict["Order"] as? String {
            self.order = value
        }
        if let value = dict["PageNumber"] as? Int64 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int64 {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["SchemaTableName"] as? String {
            self.schemaTableName = value
        }
        if let value = dict["StartTime"] as? Int64 {
            self.startTime = value
        }
    }
}

public class DescribeAppliedAdvicesResponseBody : Tea.TeaModel {
    public class Items : Tea.TeaModel {
        public var adviceId: String?

        public var benefit: String?

        public var buildSQL: String?

        public var jobStatus: String?

        public var pageNumber: Int64?

        public var pageSize: Int64?

        public var rollbackSQL: String?

        public var SQL: String?

        public var schemaName: String?

        public var submitStatus: String?

        public var submitTime: String?

        public var tableName: String?

        public var totalCount: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.adviceId != nil {
                map["AdviceId"] = self.adviceId!
            }
            if self.benefit != nil {
                map["Benefit"] = self.benefit!
            }
            if self.buildSQL != nil {
                map["BuildSQL"] = self.buildSQL!
            }
            if self.jobStatus != nil {
                map["JobStatus"] = self.jobStatus!
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.rollbackSQL != nil {
                map["RollbackSQL"] = self.rollbackSQL!
            }
            if self.SQL != nil {
                map["SQL"] = self.SQL!
            }
            if self.schemaName != nil {
                map["SchemaName"] = self.schemaName!
            }
            if self.submitStatus != nil {
                map["SubmitStatus"] = self.submitStatus!
            }
            if self.submitTime != nil {
                map["SubmitTime"] = self.submitTime!
            }
            if self.tableName != nil {
                map["TableName"] = self.tableName!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AdviceId"] as? String {
                self.adviceId = value
            }
            if let value = dict["Benefit"] as? String {
                self.benefit = value
            }
            if let value = dict["BuildSQL"] as? String {
                self.buildSQL = value
            }
            if let value = dict["JobStatus"] as? String {
                self.jobStatus = value
            }
            if let value = dict["PageNumber"] as? Int64 {
                self.pageNumber = value
            }
            if let value = dict["PageSize"] as? Int64 {
                self.pageSize = value
            }
            if let value = dict["RollbackSQL"] as? String {
                self.rollbackSQL = value
            }
            if let value = dict["SQL"] as? String {
                self.SQL = value
            }
            if let value = dict["SchemaName"] as? String {
                self.schemaName = value
            }
            if let value = dict["SubmitStatus"] as? String {
                self.submitStatus = value
            }
            if let value = dict["SubmitTime"] as? String {
                self.submitTime = value
            }
            if let value = dict["TableName"] as? String {
                self.tableName = value
            }
            if let value = dict["TotalCount"] as? Int64 {
                self.totalCount = value
            }
        }
    }
    public var items: [DescribeAppliedAdvicesResponseBody.Items]?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var requestId: String?

    public var schemaTableNames: [String]?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.items != nil {
            var tmp : [Any] = []
            for k in self.items! {
                tmp.append(k.toMap())
            }
            map["Items"] = tmp
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.schemaTableNames != nil {
            map["SchemaTableNames"] = self.schemaTableNames!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Items"] as? [Any?] {
            var tmp : [DescribeAppliedAdvicesResponseBody.Items] = []
            for v in value {
                if v != nil {
                    var model = DescribeAppliedAdvicesResponseBody.Items()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.items = tmp
        }
        if let value = dict["PageNumber"] as? Int64 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int64 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["SchemaTableNames"] as? [String] {
            self.schemaTableNames = value
        }
        if let value = dict["TotalCount"] as? Int64 {
            self.totalCount = value
        }
    }
}

public class DescribeAppliedAdvicesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAppliedAdvicesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeAppliedAdvicesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeApsActionLogsRequest : Tea.TeaModel {
    public var DBClusterId: String?

    public var endTime: String?

    public var keyword: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var stage: String?

    public var startTime: String?

    public var state: String?

    public var workloadId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.keyword != nil {
            map["Keyword"] = self.keyword!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.stage != nil {
            map["Stage"] = self.stage!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.state != nil {
            map["State"] = self.state!
        }
        if self.workloadId != nil {
            map["WorkloadId"] = self.workloadId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["Keyword"] as? String {
            self.keyword = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["Stage"] as? String {
            self.stage = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
        if let value = dict["State"] as? String {
            self.state = value
        }
        if let value = dict["WorkloadId"] as? String {
            self.workloadId = value
        }
    }
}

public class DescribeApsActionLogsResponseBody : Tea.TeaModel {
    public class ActionLogs : Tea.TeaModel {
        public var context: String?

        public var stage: String?

        public var state: String?

        public var time: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.context != nil {
                map["Context"] = self.context!
            }
            if self.stage != nil {
                map["Stage"] = self.stage!
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            if self.time != nil {
                map["Time"] = self.time!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Context"] as? String {
                self.context = value
            }
            if let value = dict["Stage"] as? String {
                self.stage = value
            }
            if let value = dict["State"] as? String {
                self.state = value
            }
            if let value = dict["Time"] as? String {
                self.time = value
            }
        }
    }
    public var accessDeniedDetail: String?

    public var actionLogs: [DescribeApsActionLogsResponseBody.ActionLogs]?

    public var DBClusterId: String?

    public var pageNumber: String?

    public var pageSize: String?

    public var requestId: String?

    public var totalCount: String?

    public var workloadId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessDeniedDetail != nil {
            map["AccessDeniedDetail"] = self.accessDeniedDetail!
        }
        if self.actionLogs != nil {
            var tmp : [Any] = []
            for k in self.actionLogs! {
                tmp.append(k.toMap())
            }
            map["ActionLogs"] = tmp
        }
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        if self.workloadId != nil {
            map["WorkloadId"] = self.workloadId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AccessDeniedDetail"] as? String {
            self.accessDeniedDetail = value
        }
        if let value = dict["ActionLogs"] as? [Any?] {
            var tmp : [DescribeApsActionLogsResponseBody.ActionLogs] = []
            for v in value {
                if v != nil {
                    var model = DescribeApsActionLogsResponseBody.ActionLogs()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.actionLogs = tmp
        }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["PageNumber"] as? String {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? String {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? String {
            self.totalCount = value
        }
        if let value = dict["WorkloadId"] as? String {
            self.workloadId = value
        }
    }
}

public class DescribeApsActionLogsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeApsActionLogsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeApsActionLogsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeApsDatasourceRequest : Tea.TeaModel {
    public var DBClusterId: String?

    public var datasourceId: Int64?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.datasourceId != nil {
            map["DatasourceId"] = self.datasourceId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["DatasourceId"] as? Int64 {
            self.datasourceId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class DescribeApsDatasourceResponseBody : Tea.TeaModel {
    public class ApsDatasource : Tea.TeaModel {
        public class DatabricksInfo : Tea.TeaModel {
            public var accessToken: String?

            public var workspaceURL: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.accessToken != nil {
                    map["accessToken"] = self.accessToken!
                }
                if self.workspaceURL != nil {
                    map["workspaceURL"] = self.workspaceURL!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["accessToken"] as? String {
                    self.accessToken = value
                }
                if let value = dict["workspaceURL"] as? String {
                    self.workspaceURL = value
                }
            }
        }
        public class HiveInfo : Tea.TeaModel {
            public var emrClusterId: String?

            public var metaStoreUri: String?

            public var securityGroup: String?

            public var vswitch: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.emrClusterId != nil {
                    map["EmrClusterId"] = self.emrClusterId!
                }
                if self.metaStoreUri != nil {
                    map["MetaStoreUri"] = self.metaStoreUri!
                }
                if self.securityGroup != nil {
                    map["SecurityGroup"] = self.securityGroup!
                }
                if self.vswitch != nil {
                    map["Vswitch"] = self.vswitch!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["EmrClusterId"] as? String {
                    self.emrClusterId = value
                }
                if let value = dict["MetaStoreUri"] as? String {
                    self.metaStoreUri = value
                }
                if let value = dict["SecurityGroup"] as? String {
                    self.securityGroup = value
                }
                if let value = dict["Vswitch"] as? String {
                    self.vswitch = value
                }
            }
        }
        public class KafkaInfo : Tea.TeaModel {
            public var kafkaClusterId: String?

            public var kafkaTopic: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.kafkaClusterId != nil {
                    map["KafkaClusterId"] = self.kafkaClusterId!
                }
                if self.kafkaTopic != nil {
                    map["KafkaTopic"] = self.kafkaTopic!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["KafkaClusterId"] as? String {
                    self.kafkaClusterId = value
                }
                if let value = dict["KafkaTopic"] as? String {
                    self.kafkaTopic = value
                }
            }
        }
        public class PolarDBMysqlInfo : Tea.TeaModel {
            public var across: Bool?

            public var acrossRole: String?

            public var acrossUid: String?

            public var connectUrl: String?

            public var instanceId: String?

            public var regionId: String?

            public var securityGroup: String?

            public var userName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.across != nil {
                    map["Across"] = self.across!
                }
                if self.acrossRole != nil {
                    map["AcrossRole"] = self.acrossRole!
                }
                if self.acrossUid != nil {
                    map["AcrossUid"] = self.acrossUid!
                }
                if self.connectUrl != nil {
                    map["ConnectUrl"] = self.connectUrl!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.securityGroup != nil {
                    map["SecurityGroup"] = self.securityGroup!
                }
                if self.userName != nil {
                    map["UserName"] = self.userName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Across"] as? Bool {
                    self.across = value
                }
                if let value = dict["AcrossRole"] as? String {
                    self.acrossRole = value
                }
                if let value = dict["AcrossUid"] as? String {
                    self.acrossUid = value
                }
                if let value = dict["ConnectUrl"] as? String {
                    self.connectUrl = value
                }
                if let value = dict["InstanceId"] as? String {
                    self.instanceId = value
                }
                if let value = dict["RegionId"] as? String {
                    self.regionId = value
                }
                if let value = dict["SecurityGroup"] as? String {
                    self.securityGroup = value
                }
                if let value = dict["UserName"] as? String {
                    self.userName = value
                }
            }
        }
        public class RdsMysqlInfo : Tea.TeaModel {
            public var connectUrl: String?

            public var instanceId: String?

            public var regionId: String?

            public var securityGroup: String?

            public var userName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.connectUrl != nil {
                    map["ConnectUrl"] = self.connectUrl!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.securityGroup != nil {
                    map["SecurityGroup"] = self.securityGroup!
                }
                if self.userName != nil {
                    map["UserName"] = self.userName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ConnectUrl"] as? String {
                    self.connectUrl = value
                }
                if let value = dict["InstanceId"] as? String {
                    self.instanceId = value
                }
                if let value = dict["RegionId"] as? String {
                    self.regionId = value
                }
                if let value = dict["SecurityGroup"] as? String {
                    self.securityGroup = value
                }
                if let value = dict["UserName"] as? String {
                    self.userName = value
                }
            }
        }
        public class SlsInfo : Tea.TeaModel {
            public var across: Bool?

            public var acrossRole: String?

            public var acrossUid: String?

            public var project: String?

            public var sourceRegionId: String?

            public var store: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.across != nil {
                    map["Across"] = self.across!
                }
                if self.acrossRole != nil {
                    map["AcrossRole"] = self.acrossRole!
                }
                if self.acrossUid != nil {
                    map["AcrossUid"] = self.acrossUid!
                }
                if self.project != nil {
                    map["Project"] = self.project!
                }
                if self.sourceRegionId != nil {
                    map["SourceRegionId"] = self.sourceRegionId!
                }
                if self.store != nil {
                    map["Store"] = self.store!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Across"] as? Bool {
                    self.across = value
                }
                if let value = dict["AcrossRole"] as? String {
                    self.acrossRole = value
                }
                if let value = dict["AcrossUid"] as? String {
                    self.acrossUid = value
                }
                if let value = dict["Project"] as? String {
                    self.project = value
                }
                if let value = dict["SourceRegionId"] as? String {
                    self.sourceRegionId = value
                }
                if let value = dict["Store"] as? String {
                    self.store = value
                }
            }
        }
        public var createTime: String?

        public var DBClusterId: String?

        public var databricksInfo: DescribeApsDatasourceResponseBody.ApsDatasource.DatabricksInfo?

        public var datasourceDescription: String?

        public var datasourceName: String?

        public var datasourceType: String?

        public var hiveInfo: DescribeApsDatasourceResponseBody.ApsDatasource.HiveInfo?

        public var kafkaInfo: DescribeApsDatasourceResponseBody.ApsDatasource.KafkaInfo?

        public var polarDBMysqlInfo: DescribeApsDatasourceResponseBody.ApsDatasource.PolarDBMysqlInfo?

        public var rdsMysqlInfo: DescribeApsDatasourceResponseBody.ApsDatasource.RdsMysqlInfo?

        public var slsInfo: DescribeApsDatasourceResponseBody.ApsDatasource.SlsInfo?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.databricksInfo?.validate()
            try self.hiveInfo?.validate()
            try self.kafkaInfo?.validate()
            try self.polarDBMysqlInfo?.validate()
            try self.rdsMysqlInfo?.validate()
            try self.slsInfo?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.DBClusterId != nil {
                map["DBClusterId"] = self.DBClusterId!
            }
            if self.databricksInfo != nil {
                map["DatabricksInfo"] = self.databricksInfo?.toMap()
            }
            if self.datasourceDescription != nil {
                map["DatasourceDescription"] = self.datasourceDescription!
            }
            if self.datasourceName != nil {
                map["DatasourceName"] = self.datasourceName!
            }
            if self.datasourceType != nil {
                map["DatasourceType"] = self.datasourceType!
            }
            if self.hiveInfo != nil {
                map["HiveInfo"] = self.hiveInfo?.toMap()
            }
            if self.kafkaInfo != nil {
                map["KafkaInfo"] = self.kafkaInfo?.toMap()
            }
            if self.polarDBMysqlInfo != nil {
                map["PolarDBMysqlInfo"] = self.polarDBMysqlInfo?.toMap()
            }
            if self.rdsMysqlInfo != nil {
                map["RdsMysqlInfo"] = self.rdsMysqlInfo?.toMap()
            }
            if self.slsInfo != nil {
                map["SlsInfo"] = self.slsInfo?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["CreateTime"] as? String {
                self.createTime = value
            }
            if let value = dict["DBClusterId"] as? String {
                self.DBClusterId = value
            }
            if let value = dict["DatabricksInfo"] as? [String: Any?] {
                var model = DescribeApsDatasourceResponseBody.ApsDatasource.DatabricksInfo()
                model.fromMap(value)
                self.databricksInfo = model
            }
            if let value = dict["DatasourceDescription"] as? String {
                self.datasourceDescription = value
            }
            if let value = dict["DatasourceName"] as? String {
                self.datasourceName = value
            }
            if let value = dict["DatasourceType"] as? String {
                self.datasourceType = value
            }
            if let value = dict["HiveInfo"] as? [String: Any?] {
                var model = DescribeApsDatasourceResponseBody.ApsDatasource.HiveInfo()
                model.fromMap(value)
                self.hiveInfo = model
            }
            if let value = dict["KafkaInfo"] as? [String: Any?] {
                var model = DescribeApsDatasourceResponseBody.ApsDatasource.KafkaInfo()
                model.fromMap(value)
                self.kafkaInfo = model
            }
            if let value = dict["PolarDBMysqlInfo"] as? [String: Any?] {
                var model = DescribeApsDatasourceResponseBody.ApsDatasource.PolarDBMysqlInfo()
                model.fromMap(value)
                self.polarDBMysqlInfo = model
            }
            if let value = dict["RdsMysqlInfo"] as? [String: Any?] {
                var model = DescribeApsDatasourceResponseBody.ApsDatasource.RdsMysqlInfo()
                model.fromMap(value)
                self.rdsMysqlInfo = model
            }
            if let value = dict["SlsInfo"] as? [String: Any?] {
                var model = DescribeApsDatasourceResponseBody.ApsDatasource.SlsInfo()
                model.fromMap(value)
                self.slsInfo = model
            }
        }
    }
    public var apsDatasource: DescribeApsDatasourceResponseBody.ApsDatasource?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.apsDatasource?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apsDatasource != nil {
            map["ApsDatasource"] = self.apsDatasource?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ApsDatasource"] as? [String: Any?] {
            var model = DescribeApsDatasourceResponseBody.ApsDatasource()
            model.fromMap(value)
            self.apsDatasource = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeApsDatasourceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeApsDatasourceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeApsDatasourceResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeApsDatasourcesRequest : Tea.TeaModel {
    public var DBClusterId: String?

    public var datasourceName: String?

    public var datasourceType: String?

    public var endTime: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.datasourceName != nil {
            map["DatasourceName"] = self.datasourceName!
        }
        if self.datasourceType != nil {
            map["DatasourceType"] = self.datasourceType!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["DatasourceName"] as? String {
            self.datasourceName = value
        }
        if let value = dict["DatasourceType"] as? String {
            self.datasourceType = value
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
    }
}

public class DescribeApsDatasourcesResponseBody : Tea.TeaModel {
    public class ApsDatasources : Tea.TeaModel {
        public var createTime: String?

        public var datasourceDescription: String?

        public var datasourceId: Int64?

        public var datasourceName: String?

        public var datasourceType: String?

        public var hasJob: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.datasourceDescription != nil {
                map["DatasourceDescription"] = self.datasourceDescription!
            }
            if self.datasourceId != nil {
                map["DatasourceId"] = self.datasourceId!
            }
            if self.datasourceName != nil {
                map["DatasourceName"] = self.datasourceName!
            }
            if self.datasourceType != nil {
                map["DatasourceType"] = self.datasourceType!
            }
            if self.hasJob != nil {
                map["HasJob"] = self.hasJob!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["CreateTime"] as? String {
                self.createTime = value
            }
            if let value = dict["DatasourceDescription"] as? String {
                self.datasourceDescription = value
            }
            if let value = dict["DatasourceId"] as? Int64 {
                self.datasourceId = value
            }
            if let value = dict["DatasourceName"] as? String {
                self.datasourceName = value
            }
            if let value = dict["DatasourceType"] as? String {
                self.datasourceType = value
            }
            if let value = dict["HasJob"] as? Bool {
                self.hasJob = value
            }
        }
    }
    public var apsDatasources: [DescribeApsDatasourcesResponseBody.ApsDatasources]?

    public var pageNumber: String?

    public var pageSize: String?

    public var requestId: String?

    public var totalCount: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apsDatasources != nil {
            var tmp : [Any] = []
            for k in self.apsDatasources! {
                tmp.append(k.toMap())
            }
            map["ApsDatasources"] = tmp
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ApsDatasources"] as? [Any?] {
            var tmp : [DescribeApsDatasourcesResponseBody.ApsDatasources] = []
            for v in value {
                if v != nil {
                    var model = DescribeApsDatasourcesResponseBody.ApsDatasources()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.apsDatasources = tmp
        }
        if let value = dict["PageNumber"] as? String {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? String {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? String {
            self.totalCount = value
        }
    }
}

public class DescribeApsDatasourcesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeApsDatasourcesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeApsDatasourcesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeApsHiveWorkloadRequest : Tea.TeaModel {
    public var DBClusterId: String?

    public var regionId: String?

    public var workloadId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.workloadId != nil {
            map["WorkloadId"] = self.workloadId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["WorkloadId"] as? String {
            self.workloadId = value
        }
    }
}

public class DescribeApsHiveWorkloadResponseBody : Tea.TeaModel {
    public class ApsWorkload : Tea.TeaModel {
        public var advancedConfig: String?

        public var conflictStrategy: String?

        public var createTime: String?

        public var DBClusterId: String?

        public var datasourceId: Int64?

        public var datasourceName: String?

        public var emrClusterId: String?

        public var fullComputeUnit: String?

        public var metaStoreUri: String?

        public var ossLocation: String?

        public var parallelism: Int64?

        public var regionId: String?

        public var resourceGroup: String?

        public var state: String?

        public var syncAllowExpression: String?

        public var syncDenyExpression: String?

        public var targetType: String?

        public var vswitch: String?

        public var workloadId: String?

        public var workloadName: String?

        public var workloadTypeName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.advancedConfig != nil {
                map["AdvancedConfig"] = self.advancedConfig!
            }
            if self.conflictStrategy != nil {
                map["ConflictStrategy"] = self.conflictStrategy!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.DBClusterId != nil {
                map["DBClusterId"] = self.DBClusterId!
            }
            if self.datasourceId != nil {
                map["DatasourceId"] = self.datasourceId!
            }
            if self.datasourceName != nil {
                map["DatasourceName"] = self.datasourceName!
            }
            if self.emrClusterId != nil {
                map["EmrClusterId"] = self.emrClusterId!
            }
            if self.fullComputeUnit != nil {
                map["FullComputeUnit"] = self.fullComputeUnit!
            }
            if self.metaStoreUri != nil {
                map["MetaStoreUri"] = self.metaStoreUri!
            }
            if self.ossLocation != nil {
                map["OssLocation"] = self.ossLocation!
            }
            if self.parallelism != nil {
                map["Parallelism"] = self.parallelism!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.resourceGroup != nil {
                map["ResourceGroup"] = self.resourceGroup!
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            if self.syncAllowExpression != nil {
                map["SyncAllowExpression"] = self.syncAllowExpression!
            }
            if self.syncDenyExpression != nil {
                map["SyncDenyExpression"] = self.syncDenyExpression!
            }
            if self.targetType != nil {
                map["TargetType"] = self.targetType!
            }
            if self.vswitch != nil {
                map["Vswitch"] = self.vswitch!
            }
            if self.workloadId != nil {
                map["WorkloadId"] = self.workloadId!
            }
            if self.workloadName != nil {
                map["WorkloadName"] = self.workloadName!
            }
            if self.workloadTypeName != nil {
                map["WorkloadTypeName"] = self.workloadTypeName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AdvancedConfig"] as? String {
                self.advancedConfig = value
            }
            if let value = dict["ConflictStrategy"] as? String {
                self.conflictStrategy = value
            }
            if let value = dict["CreateTime"] as? String {
                self.createTime = value
            }
            if let value = dict["DBClusterId"] as? String {
                self.DBClusterId = value
            }
            if let value = dict["DatasourceId"] as? Int64 {
                self.datasourceId = value
            }
            if let value = dict["DatasourceName"] as? String {
                self.datasourceName = value
            }
            if let value = dict["EmrClusterId"] as? String {
                self.emrClusterId = value
            }
            if let value = dict["FullComputeUnit"] as? String {
                self.fullComputeUnit = value
            }
            if let value = dict["MetaStoreUri"] as? String {
                self.metaStoreUri = value
            }
            if let value = dict["OssLocation"] as? String {
                self.ossLocation = value
            }
            if let value = dict["Parallelism"] as? Int64 {
                self.parallelism = value
            }
            if let value = dict["RegionId"] as? String {
                self.regionId = value
            }
            if let value = dict["ResourceGroup"] as? String {
                self.resourceGroup = value
            }
            if let value = dict["State"] as? String {
                self.state = value
            }
            if let value = dict["SyncAllowExpression"] as? String {
                self.syncAllowExpression = value
            }
            if let value = dict["SyncDenyExpression"] as? String {
                self.syncDenyExpression = value
            }
            if let value = dict["TargetType"] as? String {
                self.targetType = value
            }
            if let value = dict["Vswitch"] as? String {
                self.vswitch = value
            }
            if let value = dict["WorkloadId"] as? String {
                self.workloadId = value
            }
            if let value = dict["WorkloadName"] as? String {
                self.workloadName = value
            }
            if let value = dict["WorkloadTypeName"] as? String {
                self.workloadTypeName = value
            }
        }
    }
    public var apsWorkload: DescribeApsHiveWorkloadResponseBody.ApsWorkload?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.apsWorkload?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apsWorkload != nil {
            map["ApsWorkload"] = self.apsWorkload?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ApsWorkload"] as? [String: Any?] {
            var model = DescribeApsHiveWorkloadResponseBody.ApsWorkload()
            model.fromMap(value)
            self.apsWorkload = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeApsHiveWorkloadResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeApsHiveWorkloadResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeApsHiveWorkloadResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeApsJobDetailRequest : Tea.TeaModel {
    public var apsJobId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apsJobId != nil {
            map["ApsJobId"] = self.apsJobId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ApsJobId"] as? String {
            self.apsJobId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class DescribeApsJobDetailResponseBody : Tea.TeaModel {
    public class APSJobDetail : Tea.TeaModel {
        public var dbList: String?

        public var destinationEndpointInstanceID: String?

        public var destinationEndpointRegion: String?

        public var partitionList: String?

        public var sourceEndpointInstanceID: String?

        public var sourceEndpointRegion: String?

        public var status: String?

        public var targetTableMode: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dbList != nil {
                map["DbList"] = self.dbList!
            }
            if self.destinationEndpointInstanceID != nil {
                map["DestinationEndpointInstanceID"] = self.destinationEndpointInstanceID!
            }
            if self.destinationEndpointRegion != nil {
                map["DestinationEndpointRegion"] = self.destinationEndpointRegion!
            }
            if self.partitionList != nil {
                map["PartitionList"] = self.partitionList!
            }
            if self.sourceEndpointInstanceID != nil {
                map["SourceEndpointInstanceID"] = self.sourceEndpointInstanceID!
            }
            if self.sourceEndpointRegion != nil {
                map["SourceEndpointRegion"] = self.sourceEndpointRegion!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.targetTableMode != nil {
                map["TargetTableMode"] = self.targetTableMode!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DbList"] as? String {
                self.dbList = value
            }
            if let value = dict["DestinationEndpointInstanceID"] as? String {
                self.destinationEndpointInstanceID = value
            }
            if let value = dict["DestinationEndpointRegion"] as? String {
                self.destinationEndpointRegion = value
            }
            if let value = dict["PartitionList"] as? String {
                self.partitionList = value
            }
            if let value = dict["SourceEndpointInstanceID"] as? String {
                self.sourceEndpointInstanceID = value
            }
            if let value = dict["SourceEndpointRegion"] as? String {
                self.sourceEndpointRegion = value
            }
            if let value = dict["Status"] as? String {
                self.status = value
            }
            if let value = dict["TargetTableMode"] as? String {
                self.targetTableMode = value
            }
        }
    }
    public var APSJobDetail: DescribeApsJobDetailResponseBody.APSJobDetail?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.APSJobDetail?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.APSJobDetail != nil {
            map["APSJobDetail"] = self.APSJobDetail?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["APSJobDetail"] as? [String: Any?] {
            var model = DescribeApsJobDetailResponseBody.APSJobDetail()
            model.fromMap(value)
            self.APSJobDetail = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeApsJobDetailResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeApsJobDetailResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeApsJobDetailResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeApsJobsRequest : Tea.TeaModel {
    public var apsJobName: String?

    public var createTimeEnd: String?

    public var createTimeStart: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apsJobName != nil {
            map["ApsJobName"] = self.apsJobName!
        }
        if self.createTimeEnd != nil {
            map["CreateTimeEnd"] = self.createTimeEnd!
        }
        if self.createTimeStart != nil {
            map["CreateTimeStart"] = self.createTimeStart!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ApsJobName"] as? String {
            self.apsJobName = value
        }
        if let value = dict["CreateTimeEnd"] as? String {
            self.createTimeEnd = value
        }
        if let value = dict["CreateTimeStart"] as? String {
            self.createTimeStart = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class DescribeApsJobsResponseBody : Tea.TeaModel {
    public class APSJobs : Tea.TeaModel {
        public var apsJobId: String?

        public var apsJobName: String?

        public var createTime: String?

        public var delay: Int64?

        public var destinationInstanceID: String?

        public var errMessage: String?

        public var projress: String?

        public var sourceInstanceID: String?

        public var status: String?

        public var subStatus: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.apsJobId != nil {
                map["ApsJobId"] = self.apsJobId!
            }
            if self.apsJobName != nil {
                map["ApsJobName"] = self.apsJobName!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.delay != nil {
                map["Delay"] = self.delay!
            }
            if self.destinationInstanceID != nil {
                map["DestinationInstanceID"] = self.destinationInstanceID!
            }
            if self.errMessage != nil {
                map["ErrMessage"] = self.errMessage!
            }
            if self.projress != nil {
                map["Projress"] = self.projress!
            }
            if self.sourceInstanceID != nil {
                map["SourceInstanceID"] = self.sourceInstanceID!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.subStatus != nil {
                map["SubStatus"] = self.subStatus!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ApsJobId"] as? String {
                self.apsJobId = value
            }
            if let value = dict["ApsJobName"] as? String {
                self.apsJobName = value
            }
            if let value = dict["CreateTime"] as? String {
                self.createTime = value
            }
            if let value = dict["Delay"] as? Int64 {
                self.delay = value
            }
            if let value = dict["DestinationInstanceID"] as? String {
                self.destinationInstanceID = value
            }
            if let value = dict["ErrMessage"] as? String {
                self.errMessage = value
            }
            if let value = dict["Projress"] as? String {
                self.projress = value
            }
            if let value = dict["SourceInstanceID"] as? String {
                self.sourceInstanceID = value
            }
            if let value = dict["Status"] as? String {
                self.status = value
            }
            if let value = dict["SubStatus"] as? String {
                self.subStatus = value
            }
        }
    }
    public var APSJobs: [DescribeApsJobsResponseBody.APSJobs]?

    public var code: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var pageNumber: String?

    public var pageSize: String?

    public var requestId: String?

    public var success: Bool?

    public var totalCount: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.APSJobs != nil {
            var tmp : [Any] = []
            for k in self.APSJobs! {
                tmp.append(k.toMap())
            }
            map["APSJobs"] = tmp
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["APSJobs"] as? [Any?] {
            var tmp : [DescribeApsJobsResponseBody.APSJobs] = []
            for v in value {
                if v != nil {
                    var model = DescribeApsJobsResponseBody.APSJobs()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.APSJobs = tmp
        }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["PageNumber"] as? String {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? String {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
        if let value = dict["TotalCount"] as? String {
            self.totalCount = value
        }
    }
}

public class DescribeApsJobsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeApsJobsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeApsJobsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeApsMigrationWorkloadsRequest : Tea.TeaModel {
    public var DBClusterId: String?

    public var endTime: String?

    public var ossLocation: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var startTime: String?

    public var workloadName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.ossLocation != nil {
            map["OssLocation"] = self.ossLocation!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.workloadName != nil {
            map["WorkloadName"] = self.workloadName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["OssLocation"] as? String {
            self.ossLocation = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
        if let value = dict["WorkloadName"] as? String {
            self.workloadName = value
        }
    }
}

public class DescribeApsMigrationWorkloadsResponseBody : Tea.TeaModel {
    public class MigrationWorkloads : Tea.TeaModel {
        public var acuCount: Int32?

        public var createTime: String?

        public var failedMsg: String?

        public var id: String?

        public var maxRT: String?

        public var modifyTime: String?

        public var name: String?

        public var ossLocation: String?

        public var state: String?

        public var targetType: String?

        public var workloadSubType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.acuCount != nil {
                map["AcuCount"] = self.acuCount!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.failedMsg != nil {
                map["FailedMsg"] = self.failedMsg!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.maxRT != nil {
                map["MaxRT"] = self.maxRT!
            }
            if self.modifyTime != nil {
                map["ModifyTime"] = self.modifyTime!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.ossLocation != nil {
                map["OssLocation"] = self.ossLocation!
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            if self.targetType != nil {
                map["TargetType"] = self.targetType!
            }
            if self.workloadSubType != nil {
                map["WorkloadSubType"] = self.workloadSubType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AcuCount"] as? Int32 {
                self.acuCount = value
            }
            if let value = dict["CreateTime"] as? String {
                self.createTime = value
            }
            if let value = dict["FailedMsg"] as? String {
                self.failedMsg = value
            }
            if let value = dict["Id"] as? String {
                self.id = value
            }
            if let value = dict["MaxRT"] as? String {
                self.maxRT = value
            }
            if let value = dict["ModifyTime"] as? String {
                self.modifyTime = value
            }
            if let value = dict["Name"] as? String {
                self.name = value
            }
            if let value = dict["OssLocation"] as? String {
                self.ossLocation = value
            }
            if let value = dict["State"] as? String {
                self.state = value
            }
            if let value = dict["TargetType"] as? String {
                self.targetType = value
            }
            if let value = dict["WorkloadSubType"] as? String {
                self.workloadSubType = value
            }
        }
    }
    public var migrationWorkloads: [DescribeApsMigrationWorkloadsResponseBody.MigrationWorkloads]?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.migrationWorkloads != nil {
            var tmp : [Any] = []
            for k in self.migrationWorkloads! {
                tmp.append(k.toMap())
            }
            map["MigrationWorkloads"] = tmp
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["MigrationWorkloads"] as? [Any?] {
            var tmp : [DescribeApsMigrationWorkloadsResponseBody.MigrationWorkloads] = []
            for v in value {
                if v != nil {
                    var model = DescribeApsMigrationWorkloadsResponseBody.MigrationWorkloads()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.migrationWorkloads = tmp
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? Int32 {
            self.totalCount = value
        }
    }
}

public class DescribeApsMigrationWorkloadsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeApsMigrationWorkloadsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeApsMigrationWorkloadsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeApsProgressRequest : Tea.TeaModel {
    public var DBClusterId: String?

    public var regionId: String?

    public var workloadId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.workloadId != nil {
            map["WorkloadId"] = self.workloadId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["WorkloadId"] as? String {
            self.workloadId = value
        }
    }
}

public class DescribeApsProgressResponseBody : Tea.TeaModel {
    public class ApsHiveProgress : Tea.TeaModel {
        public var dbName: String?

        public var progress: String?

        public var speed: String?

        public var tbName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dbName != nil {
                map["DbName"] = self.dbName!
            }
            if self.progress != nil {
                map["Progress"] = self.progress!
            }
            if self.speed != nil {
                map["Speed"] = self.speed!
            }
            if self.tbName != nil {
                map["TbName"] = self.tbName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DbName"] as? String {
                self.dbName = value
            }
            if let value = dict["Progress"] as? String {
                self.progress = value
            }
            if let value = dict["Speed"] as? String {
                self.speed = value
            }
            if let value = dict["TbName"] as? String {
                self.tbName = value
            }
        }
    }
    public var apsHiveProgress: [DescribeApsProgressResponseBody.ApsHiveProgress]?

    public var requestId: String?

    public var successPercentage: Int32?

    public var successTableCount: Int32?

    public var totalTableCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apsHiveProgress != nil {
            var tmp : [Any] = []
            for k in self.apsHiveProgress! {
                tmp.append(k.toMap())
            }
            map["ApsHiveProgress"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.successPercentage != nil {
            map["SuccessPercentage"] = self.successPercentage!
        }
        if self.successTableCount != nil {
            map["SuccessTableCount"] = self.successTableCount!
        }
        if self.totalTableCount != nil {
            map["TotalTableCount"] = self.totalTableCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ApsHiveProgress"] as? [Any?] {
            var tmp : [DescribeApsProgressResponseBody.ApsHiveProgress] = []
            for v in value {
                if v != nil {
                    var model = DescribeApsProgressResponseBody.ApsHiveProgress()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.apsHiveProgress = tmp
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["SuccessPercentage"] as? Int32 {
            self.successPercentage = value
        }
        if let value = dict["SuccessTableCount"] as? Int32 {
            self.successTableCount = value
        }
        if let value = dict["TotalTableCount"] as? Int32 {
            self.totalTableCount = value
        }
    }
}

public class DescribeApsProgressResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeApsProgressResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeApsProgressResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeApsResourceGroupsRequest : Tea.TeaModel {
    public var DBClusterId: String?

    public var regionId: String?

    public var workloadId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.workloadId != nil {
            map["WorkloadId"] = self.workloadId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["WorkloadId"] as? String {
            self.workloadId = value
        }
    }
}

public class DescribeApsResourceGroupsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class ResourceGroups : Tea.TeaModel {
            public var available: Bool?

            public var cuOptions: [Int64]?

            public var groupName: String?

            public var groupType: String?

            public var leftComputeResource: Int32?

            public var maxComputeResource: Int32?

            public var minComputeResource: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.available != nil {
                    map["Available"] = self.available!
                }
                if self.cuOptions != nil {
                    map["CuOptions"] = self.cuOptions!
                }
                if self.groupName != nil {
                    map["GroupName"] = self.groupName!
                }
                if self.groupType != nil {
                    map["GroupType"] = self.groupType!
                }
                if self.leftComputeResource != nil {
                    map["LeftComputeResource"] = self.leftComputeResource!
                }
                if self.maxComputeResource != nil {
                    map["MaxComputeResource"] = self.maxComputeResource!
                }
                if self.minComputeResource != nil {
                    map["MinComputeResource"] = self.minComputeResource!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Available"] as? Bool {
                    self.available = value
                }
                if let value = dict["CuOptions"] as? [Int64] {
                    self.cuOptions = value
                }
                if let value = dict["GroupName"] as? String {
                    self.groupName = value
                }
                if let value = dict["GroupType"] as? String {
                    self.groupType = value
                }
                if let value = dict["LeftComputeResource"] as? Int32 {
                    self.leftComputeResource = value
                }
                if let value = dict["MaxComputeResource"] as? Int32 {
                    self.maxComputeResource = value
                }
                if let value = dict["MinComputeResource"] as? Int32 {
                    self.minComputeResource = value
                }
            }
        }
        public var resourceGroups: [DescribeApsResourceGroupsResponseBody.Data.ResourceGroups]?

        public var step: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.resourceGroups != nil {
                var tmp : [Any] = []
                for k in self.resourceGroups! {
                    tmp.append(k.toMap())
                }
                map["ResourceGroups"] = tmp
            }
            if self.step != nil {
                map["Step"] = self.step!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ResourceGroups"] as? [Any?] {
                var tmp : [DescribeApsResourceGroupsResponseBody.Data.ResourceGroups] = []
                for v in value {
                    if v != nil {
                        var model = DescribeApsResourceGroupsResponseBody.Data.ResourceGroups()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.resourceGroups = tmp
            }
            if let value = dict["Step"] as? Int64 {
                self.step = value
            }
        }
    }
    public var data: DescribeApsResourceGroupsResponseBody.Data?

    public var httpStatusCode: Int64?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [String: Any?] {
            var model = DescribeApsResourceGroupsResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["HttpStatusCode"] as? Int64 {
            self.httpStatusCode = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class DescribeApsResourceGroupsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeApsResourceGroupsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeApsResourceGroupsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeAuditLogRecordsRequest : Tea.TeaModel {
    public var DBClusterId: String?

    public var DBName: String?

    public var endTime: String?

    public var hostAddress: String?

    public var order: String?

    public var orderType: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var proxyUser: String?

    public var queryKeyword: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var sqlType: String?

    public var startTime: String?

    public var succeed: String?

    public var user: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.DBName != nil {
            map["DBName"] = self.DBName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.hostAddress != nil {
            map["HostAddress"] = self.hostAddress!
        }
        if self.order != nil {
            map["Order"] = self.order!
        }
        if self.orderType != nil {
            map["OrderType"] = self.orderType!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.proxyUser != nil {
            map["ProxyUser"] = self.proxyUser!
        }
        if self.queryKeyword != nil {
            map["QueryKeyword"] = self.queryKeyword!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.sqlType != nil {
            map["SqlType"] = self.sqlType!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.succeed != nil {
            map["Succeed"] = self.succeed!
        }
        if self.user != nil {
            map["User"] = self.user!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["DBName"] as? String {
            self.DBName = value
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["HostAddress"] as? String {
            self.hostAddress = value
        }
        if let value = dict["Order"] as? String {
            self.order = value
        }
        if let value = dict["OrderType"] as? String {
            self.orderType = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["ProxyUser"] as? String {
            self.proxyUser = value
        }
        if let value = dict["QueryKeyword"] as? String {
            self.queryKeyword = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["SqlType"] as? String {
            self.sqlType = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
        if let value = dict["Succeed"] as? String {
            self.succeed = value
        }
        if let value = dict["User"] as? String {
            self.user = value
        }
    }
}

public class DescribeAuditLogRecordsResponseBody : Tea.TeaModel {
    public class Items : Tea.TeaModel {
        public var connId: String?

        public var DBName: String?

        public var executeTime: String?

        public var hostAddress: String?

        public var processID: String?

        public var SQLText: String?

        public var SQLType: String?

        public var succeed: String?

        public var totalTime: String?

        public var user: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.connId != nil {
                map["ConnId"] = self.connId!
            }
            if self.DBName != nil {
                map["DBName"] = self.DBName!
            }
            if self.executeTime != nil {
                map["ExecuteTime"] = self.executeTime!
            }
            if self.hostAddress != nil {
                map["HostAddress"] = self.hostAddress!
            }
            if self.processID != nil {
                map["ProcessID"] = self.processID!
            }
            if self.SQLText != nil {
                map["SQLText"] = self.SQLText!
            }
            if self.SQLType != nil {
                map["SQLType"] = self.SQLType!
            }
            if self.succeed != nil {
                map["Succeed"] = self.succeed!
            }
            if self.totalTime != nil {
                map["TotalTime"] = self.totalTime!
            }
            if self.user != nil {
                map["User"] = self.user!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ConnId"] as? String {
                self.connId = value
            }
            if let value = dict["DBName"] as? String {
                self.DBName = value
            }
            if let value = dict["ExecuteTime"] as? String {
                self.executeTime = value
            }
            if let value = dict["HostAddress"] as? String {
                self.hostAddress = value
            }
            if let value = dict["ProcessID"] as? String {
                self.processID = value
            }
            if let value = dict["SQLText"] as? String {
                self.SQLText = value
            }
            if let value = dict["SQLType"] as? String {
                self.SQLType = value
            }
            if let value = dict["Succeed"] as? String {
                self.succeed = value
            }
            if let value = dict["TotalTime"] as? String {
                self.totalTime = value
            }
            if let value = dict["User"] as? String {
                self.user = value
            }
        }
    }
    public var DBClusterId: String?

    public var items: [DescribeAuditLogRecordsResponseBody.Items]?

    public var pageNumber: String?

    public var pageSize: String?

    public var requestId: String?

    public var totalCount: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.items != nil {
            var tmp : [Any] = []
            for k in self.items! {
                tmp.append(k.toMap())
            }
            map["Items"] = tmp
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["Items"] as? [Any?] {
            var tmp : [DescribeAuditLogRecordsResponseBody.Items] = []
            for v in value {
                if v != nil {
                    var model = DescribeAuditLogRecordsResponseBody.Items()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.items = tmp
        }
        if let value = dict["PageNumber"] as? String {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? String {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? String {
            self.totalCount = value
        }
    }
}

public class DescribeAuditLogRecordsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAuditLogRecordsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeAuditLogRecordsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeAvailableAdvicesRequest : Tea.TeaModel {
    public var adviceDate: Int64?

    public var adviceType: String?

    public var DBClusterId: String?

    public var keyword: String?

    public var lang: String?

    public var order: String?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var regionId: String?

    public var schemaTableName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.adviceDate != nil {
            map["AdviceDate"] = self.adviceDate!
        }
        if self.adviceType != nil {
            map["AdviceType"] = self.adviceType!
        }
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.keyword != nil {
            map["Keyword"] = self.keyword!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.order != nil {
            map["Order"] = self.order!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.schemaTableName != nil {
            map["SchemaTableName"] = self.schemaTableName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AdviceDate"] as? Int64 {
            self.adviceDate = value
        }
        if let value = dict["AdviceType"] as? String {
            self.adviceType = value
        }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["Keyword"] as? String {
            self.keyword = value
        }
        if let value = dict["Lang"] as? String {
            self.lang = value
        }
        if let value = dict["Order"] as? String {
            self.order = value
        }
        if let value = dict["PageNumber"] as? Int64 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int64 {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["SchemaTableName"] as? String {
            self.schemaTableName = value
        }
    }
}

public class DescribeAvailableAdvicesResponseBody : Tea.TeaModel {
    public class Items : Tea.TeaModel {
        public var adviceDate: String?

        public var adviceId: String?

        public var adviceType: String?

        public var benefit: String?

        public var pageNumber: Int64?

        public var pageSize: Int64?

        public var reason: String?

        public var SQL: String?

        public var schemaName: String?

        public var tableName: String?

        public var totalCount: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.adviceDate != nil {
                map["AdviceDate"] = self.adviceDate!
            }
            if self.adviceId != nil {
                map["AdviceId"] = self.adviceId!
            }
            if self.adviceType != nil {
                map["AdviceType"] = self.adviceType!
            }
            if self.benefit != nil {
                map["Benefit"] = self.benefit!
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.reason != nil {
                map["Reason"] = self.reason!
            }
            if self.SQL != nil {
                map["SQL"] = self.SQL!
            }
            if self.schemaName != nil {
                map["SchemaName"] = self.schemaName!
            }
            if self.tableName != nil {
                map["TableName"] = self.tableName!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AdviceDate"] as? String {
                self.adviceDate = value
            }
            if let value = dict["AdviceId"] as? String {
                self.adviceId = value
            }
            if let value = dict["AdviceType"] as? String {
                self.adviceType = value
            }
            if let value = dict["Benefit"] as? String {
                self.benefit = value
            }
            if let value = dict["PageNumber"] as? Int64 {
                self.pageNumber = value
            }
            if let value = dict["PageSize"] as? Int64 {
                self.pageSize = value
            }
            if let value = dict["Reason"] as? String {
                self.reason = value
            }
            if let value = dict["SQL"] as? String {
                self.SQL = value
            }
            if let value = dict["SchemaName"] as? String {
                self.schemaName = value
            }
            if let value = dict["TableName"] as? String {
                self.tableName = value
            }
            if let value = dict["TotalCount"] as? Int64 {
                self.totalCount = value
            }
        }
    }
    public var items: [DescribeAvailableAdvicesResponseBody.Items]?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var requestId: String?

    public var schemaTableNames: [String]?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.items != nil {
            var tmp : [Any] = []
            for k in self.items! {
                tmp.append(k.toMap())
            }
            map["Items"] = tmp
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.schemaTableNames != nil {
            map["SchemaTableNames"] = self.schemaTableNames!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Items"] as? [Any?] {
            var tmp : [DescribeAvailableAdvicesResponseBody.Items] = []
            for v in value {
                if v != nil {
                    var model = DescribeAvailableAdvicesResponseBody.Items()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.items = tmp
        }
        if let value = dict["PageNumber"] as? Int64 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int64 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["SchemaTableNames"] as? [String] {
            self.schemaTableNames = value
        }
        if let value = dict["TotalCount"] as? Int64 {
            self.totalCount = value
        }
    }
}

public class DescribeAvailableAdvicesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAvailableAdvicesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeAvailableAdvicesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeBackupPolicyRequest : Tea.TeaModel {
    public var DBClusterId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DescribeBackupPolicyResponseBody : Tea.TeaModel {
    public var backupRetentionPeriod: Int32?

    public var enableBackupLog: String?

    public var logBackupRetentionPeriod: Int32?

    public var preferredBackupPeriod: String?

    public var preferredBackupTime: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.backupRetentionPeriod != nil {
            map["BackupRetentionPeriod"] = self.backupRetentionPeriod!
        }
        if self.enableBackupLog != nil {
            map["EnableBackupLog"] = self.enableBackupLog!
        }
        if self.logBackupRetentionPeriod != nil {
            map["LogBackupRetentionPeriod"] = self.logBackupRetentionPeriod!
        }
        if self.preferredBackupPeriod != nil {
            map["PreferredBackupPeriod"] = self.preferredBackupPeriod!
        }
        if self.preferredBackupTime != nil {
            map["PreferredBackupTime"] = self.preferredBackupTime!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["BackupRetentionPeriod"] as? Int32 {
            self.backupRetentionPeriod = value
        }
        if let value = dict["EnableBackupLog"] as? String {
            self.enableBackupLog = value
        }
        if let value = dict["LogBackupRetentionPeriod"] as? Int32 {
            self.logBackupRetentionPeriod = value
        }
        if let value = dict["PreferredBackupPeriod"] as? String {
            self.preferredBackupPeriod = value
        }
        if let value = dict["PreferredBackupTime"] as? String {
            self.preferredBackupTime = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeBackupPolicyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeBackupPolicyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeBackupPolicyResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeBackupsRequest : Tea.TeaModel {
    public var backupId: String?

    public var DBClusterId: String?

    public var endTime: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var remote: Bool?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.backupId != nil {
            map["BackupId"] = self.backupId!
        }
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.remote != nil {
            map["Remote"] = self.remote!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["BackupId"] as? String {
            self.backupId = value
        }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["Remote"] as? Bool {
            self.remote = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
    }
}

public class DescribeBackupsResponseBody : Tea.TeaModel {
    public class Items : Tea.TeaModel {
        public class Backup : Tea.TeaModel {
            public var backupEndTime: String?

            public var backupExpiredTime: String?

            public var backupId: String?

            public var backupMethod: String?

            public var backupRegion: String?

            public var backupSize: Int32?

            public var backupStartTime: String?

            public var backupType: String?

            public var DBClusterId: String?

            public var parentBackupId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.backupEndTime != nil {
                    map["BackupEndTime"] = self.backupEndTime!
                }
                if self.backupExpiredTime != nil {
                    map["BackupExpiredTime"] = self.backupExpiredTime!
                }
                if self.backupId != nil {
                    map["BackupId"] = self.backupId!
                }
                if self.backupMethod != nil {
                    map["BackupMethod"] = self.backupMethod!
                }
                if self.backupRegion != nil {
                    map["BackupRegion"] = self.backupRegion!
                }
                if self.backupSize != nil {
                    map["BackupSize"] = self.backupSize!
                }
                if self.backupStartTime != nil {
                    map["BackupStartTime"] = self.backupStartTime!
                }
                if self.backupType != nil {
                    map["BackupType"] = self.backupType!
                }
                if self.DBClusterId != nil {
                    map["DBClusterId"] = self.DBClusterId!
                }
                if self.parentBackupId != nil {
                    map["ParentBackupId"] = self.parentBackupId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["BackupEndTime"] as? String {
                    self.backupEndTime = value
                }
                if let value = dict["BackupExpiredTime"] as? String {
                    self.backupExpiredTime = value
                }
                if let value = dict["BackupId"] as? String {
                    self.backupId = value
                }
                if let value = dict["BackupMethod"] as? String {
                    self.backupMethod = value
                }
                if let value = dict["BackupRegion"] as? String {
                    self.backupRegion = value
                }
                if let value = dict["BackupSize"] as? Int32 {
                    self.backupSize = value
                }
                if let value = dict["BackupStartTime"] as? String {
                    self.backupStartTime = value
                }
                if let value = dict["BackupType"] as? String {
                    self.backupType = value
                }
                if let value = dict["DBClusterId"] as? String {
                    self.DBClusterId = value
                }
                if let value = dict["ParentBackupId"] as? String {
                    self.parentBackupId = value
                }
            }
        }
        public var backup: [DescribeBackupsResponseBody.Items.Backup]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.backup != nil {
                var tmp : [Any] = []
                for k in self.backup! {
                    tmp.append(k.toMap())
                }
                map["Backup"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Backup"] as? [Any?] {
                var tmp : [DescribeBackupsResponseBody.Items.Backup] = []
                for v in value {
                    if v != nil {
                        var model = DescribeBackupsResponseBody.Items.Backup()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.backup = tmp
            }
        }
    }
    public var freeBackupSize: Int64?

    public var items: DescribeBackupsResponseBody.Items?

    public var pageNumber: String?

    public var pageSize: String?

    public var requestId: String?

    public var totalBackupSize: Int64?

    public var totalCount: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.items?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.freeBackupSize != nil {
            map["FreeBackupSize"] = self.freeBackupSize!
        }
        if self.items != nil {
            map["Items"] = self.items?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalBackupSize != nil {
            map["TotalBackupSize"] = self.totalBackupSize!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["FreeBackupSize"] as? Int64 {
            self.freeBackupSize = value
        }
        if let value = dict["Items"] as? [String: Any?] {
            var model = DescribeBackupsResponseBody.Items()
            model.fromMap(value)
            self.items = model
        }
        if let value = dict["PageNumber"] as? String {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? String {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalBackupSize"] as? Int64 {
            self.totalBackupSize = value
        }
        if let value = dict["TotalCount"] as? String {
            self.totalCount = value
        }
    }
}

public class DescribeBackupsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeBackupsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeBackupsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeBadSqlDetectionRequest : Tea.TeaModel {
    public var DBClusterId: String?

    public var endTime: String?

    public var lang: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["Lang"] as? String {
            self.lang = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
    }
}

public class DescribeBadSqlDetectionResponseBody : Tea.TeaModel {
    public class DetectionItems : Tea.TeaModel {
        public class Results : Tea.TeaModel {
            public class DiagnosisResults : Tea.TeaModel {
                public var code: String?

                public var detail: String?

                public var operatorId: String?

                public var stageId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.code != nil {
                        map["Code"] = self.code!
                    }
                    if self.detail != nil {
                        map["Detail"] = self.detail!
                    }
                    if self.operatorId != nil {
                        map["OperatorId"] = self.operatorId!
                    }
                    if self.stageId != nil {
                        map["StageId"] = self.stageId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Code"] as? String {
                        self.code = value
                    }
                    if let value = dict["Detail"] as? String {
                        self.detail = value
                    }
                    if let value = dict["OperatorId"] as? String {
                        self.operatorId = value
                    }
                    if let value = dict["StageId"] as? String {
                        self.stageId = value
                    }
                }
            }
            public var cost: Int64?

            public var diagnosisResults: [DescribeBadSqlDetectionResponseBody.DetectionItems.Results.DiagnosisResults]?

            public var operatorCost: Int64?

            public var outputDataSize: Int64?

            public var patternId: String?

            public var peakMemory: Int64?

            public var processId: String?

            public var SQL: String?

            public var scanSize: Int64?

            public var startTime: String?

            public var totalStages: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cost != nil {
                    map["Cost"] = self.cost!
                }
                if self.diagnosisResults != nil {
                    var tmp : [Any] = []
                    for k in self.diagnosisResults! {
                        tmp.append(k.toMap())
                    }
                    map["DiagnosisResults"] = tmp
                }
                if self.operatorCost != nil {
                    map["OperatorCost"] = self.operatorCost!
                }
                if self.outputDataSize != nil {
                    map["OutputDataSize"] = self.outputDataSize!
                }
                if self.patternId != nil {
                    map["PatternId"] = self.patternId!
                }
                if self.peakMemory != nil {
                    map["PeakMemory"] = self.peakMemory!
                }
                if self.processId != nil {
                    map["ProcessId"] = self.processId!
                }
                if self.SQL != nil {
                    map["SQL"] = self.SQL!
                }
                if self.scanSize != nil {
                    map["ScanSize"] = self.scanSize!
                }
                if self.startTime != nil {
                    map["StartTime"] = self.startTime!
                }
                if self.totalStages != nil {
                    map["TotalStages"] = self.totalStages!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Cost"] as? Int64 {
                    self.cost = value
                }
                if let value = dict["DiagnosisResults"] as? [Any?] {
                    var tmp : [DescribeBadSqlDetectionResponseBody.DetectionItems.Results.DiagnosisResults] = []
                    for v in value {
                        if v != nil {
                            var model = DescribeBadSqlDetectionResponseBody.DetectionItems.Results.DiagnosisResults()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.diagnosisResults = tmp
                }
                if let value = dict["OperatorCost"] as? Int64 {
                    self.operatorCost = value
                }
                if let value = dict["OutputDataSize"] as? Int64 {
                    self.outputDataSize = value
                }
                if let value = dict["PatternId"] as? String {
                    self.patternId = value
                }
                if let value = dict["PeakMemory"] as? Int64 {
                    self.peakMemory = value
                }
                if let value = dict["ProcessId"] as? String {
                    self.processId = value
                }
                if let value = dict["SQL"] as? String {
                    self.SQL = value
                }
                if let value = dict["ScanSize"] as? Int64 {
                    self.scanSize = value
                }
                if let value = dict["StartTime"] as? String {
                    self.startTime = value
                }
                if let value = dict["TotalStages"] as? Int32 {
                    self.totalStages = value
                }
            }
        }
        public var message: String?

        public var name: String?

        public var results: [DescribeBadSqlDetectionResponseBody.DetectionItems.Results]?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.results != nil {
                var tmp : [Any] = []
                for k in self.results! {
                    tmp.append(k.toMap())
                }
                map["Results"] = tmp
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Message"] as? String {
                self.message = value
            }
            if let value = dict["Name"] as? String {
                self.name = value
            }
            if let value = dict["Results"] as? [Any?] {
                var tmp : [DescribeBadSqlDetectionResponseBody.DetectionItems.Results] = []
                for v in value {
                    if v != nil {
                        var model = DescribeBadSqlDetectionResponseBody.DetectionItems.Results()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.results = tmp
            }
            if let value = dict["Status"] as? String {
                self.status = value
            }
        }
    }
    public var accessDeniedDetail: String?

    public var DBClusterId: String?

    public var detectionItems: [DescribeBadSqlDetectionResponseBody.DetectionItems]?

    public var requestId: String?

    public var totalCount: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessDeniedDetail != nil {
            map["AccessDeniedDetail"] = self.accessDeniedDetail!
        }
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.detectionItems != nil {
            var tmp : [Any] = []
            for k in self.detectionItems! {
                tmp.append(k.toMap())
            }
            map["DetectionItems"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AccessDeniedDetail"] as? String {
            self.accessDeniedDetail = value
        }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["DetectionItems"] as? [Any?] {
            var tmp : [DescribeBadSqlDetectionResponseBody.DetectionItems] = []
            for v in value {
                if v != nil {
                    var model = DescribeBadSqlDetectionResponseBody.DetectionItems()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.detectionItems = tmp
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? String {
            self.totalCount = value
        }
    }
}

public class DescribeBadSqlDetectionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeBadSqlDetectionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeBadSqlDetectionResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeClusterAccessWhiteListRequest : Tea.TeaModel {
    public var DBClusterId: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
    }
}

public class DescribeClusterAccessWhiteListResponseBody : Tea.TeaModel {
    public class Items : Tea.TeaModel {
        public class IPArray : Tea.TeaModel {
            public var DBClusterIPArrayAttribute: String?

            public var DBClusterIPArrayName: String?

            public var securityIPList: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.DBClusterIPArrayAttribute != nil {
                    map["DBClusterIPArrayAttribute"] = self.DBClusterIPArrayAttribute!
                }
                if self.DBClusterIPArrayName != nil {
                    map["DBClusterIPArrayName"] = self.DBClusterIPArrayName!
                }
                if self.securityIPList != nil {
                    map["SecurityIPList"] = self.securityIPList!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["DBClusterIPArrayAttribute"] as? String {
                    self.DBClusterIPArrayAttribute = value
                }
                if let value = dict["DBClusterIPArrayName"] as? String {
                    self.DBClusterIPArrayName = value
                }
                if let value = dict["SecurityIPList"] as? String {
                    self.securityIPList = value
                }
            }
        }
        public var IPArray: [DescribeClusterAccessWhiteListResponseBody.Items.IPArray]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.IPArray != nil {
                var tmp : [Any] = []
                for k in self.IPArray! {
                    tmp.append(k.toMap())
                }
                map["IPArray"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["IPArray"] as? [Any?] {
                var tmp : [DescribeClusterAccessWhiteListResponseBody.Items.IPArray] = []
                for v in value {
                    if v != nil {
                        var model = DescribeClusterAccessWhiteListResponseBody.Items.IPArray()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.IPArray = tmp
            }
        }
    }
    public var items: DescribeClusterAccessWhiteListResponseBody.Items?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.items?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.items != nil {
            map["Items"] = self.items?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Items"] as? [String: Any?] {
            var model = DescribeClusterAccessWhiteListResponseBody.Items()
            model.fromMap(value)
            self.items = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeClusterAccessWhiteListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeClusterAccessWhiteListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeClusterAccessWhiteListResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeClusterNetInfoRequest : Tea.TeaModel {
    public var DBClusterId: String?

    public var engine: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.engine != nil {
            map["Engine"] = self.engine!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["Engine"] as? String {
            self.engine = value
        }
    }
}

public class DescribeClusterNetInfoResponseBody : Tea.TeaModel {
    public class Items : Tea.TeaModel {
        public class Address : Tea.TeaModel {
            public class Ports : Tea.TeaModel {
                public class Ports : Tea.TeaModel {
                    public var port: String?

                    public var protocol_: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.port != nil {
                            map["Port"] = self.port!
                        }
                        if self.protocol_ != nil {
                            map["Protocol"] = self.protocol_!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Port"] as? String {
                            self.port = value
                        }
                        if let value = dict["Protocol"] as? String {
                            self.protocol_ = value
                        }
                    }
                }
                public var ports: [DescribeClusterNetInfoResponseBody.Items.Address.Ports.Ports]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.ports != nil {
                        var tmp : [Any] = []
                        for k in self.ports! {
                            tmp.append(k.toMap())
                        }
                        map["ports"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["ports"] as? [Any?] {
                        var tmp : [DescribeClusterNetInfoResponseBody.Items.Address.Ports.Ports] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeClusterNetInfoResponseBody.Items.Address.Ports.Ports()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.ports = tmp
                    }
                }
            }
            public var connectionString: String?

            public var connectionStringPrefix: String?

            public var IPAddress: String?

            public var netType: String?

            public var port: String?

            public var ports: DescribeClusterNetInfoResponseBody.Items.Address.Ports?

            public var VPCId: String?

            public var vSwitchId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.ports?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.connectionString != nil {
                    map["ConnectionString"] = self.connectionString!
                }
                if self.connectionStringPrefix != nil {
                    map["ConnectionStringPrefix"] = self.connectionStringPrefix!
                }
                if self.IPAddress != nil {
                    map["IPAddress"] = self.IPAddress!
                }
                if self.netType != nil {
                    map["NetType"] = self.netType!
                }
                if self.port != nil {
                    map["Port"] = self.port!
                }
                if self.ports != nil {
                    map["Ports"] = self.ports?.toMap()
                }
                if self.VPCId != nil {
                    map["VPCId"] = self.VPCId!
                }
                if self.vSwitchId != nil {
                    map["VSwitchId"] = self.vSwitchId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ConnectionString"] as? String {
                    self.connectionString = value
                }
                if let value = dict["ConnectionStringPrefix"] as? String {
                    self.connectionStringPrefix = value
                }
                if let value = dict["IPAddress"] as? String {
                    self.IPAddress = value
                }
                if let value = dict["NetType"] as? String {
                    self.netType = value
                }
                if let value = dict["Port"] as? String {
                    self.port = value
                }
                if let value = dict["Ports"] as? [String: Any?] {
                    var model = DescribeClusterNetInfoResponseBody.Items.Address.Ports()
                    model.fromMap(value)
                    self.ports = model
                }
                if let value = dict["VPCId"] as? String {
                    self.VPCId = value
                }
                if let value = dict["VSwitchId"] as? String {
                    self.vSwitchId = value
                }
            }
        }
        public var address: [DescribeClusterNetInfoResponseBody.Items.Address]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.address != nil {
                var tmp : [Any] = []
                for k in self.address! {
                    tmp.append(k.toMap())
                }
                map["Address"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Address"] as? [Any?] {
                var tmp : [DescribeClusterNetInfoResponseBody.Items.Address] = []
                for v in value {
                    if v != nil {
                        var model = DescribeClusterNetInfoResponseBody.Items.Address()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.address = tmp
            }
        }
    }
    public var clusterNetworkType: String?

    public var items: DescribeClusterNetInfoResponseBody.Items?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.items?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterNetworkType != nil {
            map["ClusterNetworkType"] = self.clusterNetworkType!
        }
        if self.items != nil {
            map["Items"] = self.items?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClusterNetworkType"] as? String {
            self.clusterNetworkType = value
        }
        if let value = dict["Items"] as? [String: Any?] {
            var model = DescribeClusterNetInfoResponseBody.Items()
            model.fromMap(value)
            self.items = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeClusterNetInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeClusterNetInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeClusterNetInfoResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeClusterResourceDetailRequest : Tea.TeaModel {
    public var DBClusterId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
    }
}

public class DescribeClusterResourceDetailResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class ResourceGroupList : Tea.TeaModel {
            public var clusterMode: String?

            public var clusterSizeResource: String?

            public var enableSpot: Bool?

            public var maxClusterCount: Int32?

            public var maxComputeResource: String?

            public var minClusterCount: Int32?

            public var minComputeResource: String?

            public var poolId: Int64?

            public var poolName: String?

            public var poolType: String?

            public var poolUsers: String?

            public var runningClusterCount: Int32?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.clusterMode != nil {
                    map["ClusterMode"] = self.clusterMode!
                }
                if self.clusterSizeResource != nil {
                    map["ClusterSizeResource"] = self.clusterSizeResource!
                }
                if self.enableSpot != nil {
                    map["EnableSpot"] = self.enableSpot!
                }
                if self.maxClusterCount != nil {
                    map["MaxClusterCount"] = self.maxClusterCount!
                }
                if self.maxComputeResource != nil {
                    map["MaxComputeResource"] = self.maxComputeResource!
                }
                if self.minClusterCount != nil {
                    map["MinClusterCount"] = self.minClusterCount!
                }
                if self.minComputeResource != nil {
                    map["MinComputeResource"] = self.minComputeResource!
                }
                if self.poolId != nil {
                    map["PoolId"] = self.poolId!
                }
                if self.poolName != nil {
                    map["PoolName"] = self.poolName!
                }
                if self.poolType != nil {
                    map["PoolType"] = self.poolType!
                }
                if self.poolUsers != nil {
                    map["PoolUsers"] = self.poolUsers!
                }
                if self.runningClusterCount != nil {
                    map["RunningClusterCount"] = self.runningClusterCount!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ClusterMode"] as? String {
                    self.clusterMode = value
                }
                if let value = dict["ClusterSizeResource"] as? String {
                    self.clusterSizeResource = value
                }
                if let value = dict["EnableSpot"] as? Bool {
                    self.enableSpot = value
                }
                if let value = dict["MaxClusterCount"] as? Int32 {
                    self.maxClusterCount = value
                }
                if let value = dict["MaxComputeResource"] as? String {
                    self.maxComputeResource = value
                }
                if let value = dict["MinClusterCount"] as? Int32 {
                    self.minClusterCount = value
                }
                if let value = dict["MinComputeResource"] as? String {
                    self.minComputeResource = value
                }
                if let value = dict["PoolId"] as? Int64 {
                    self.poolId = value
                }
                if let value = dict["PoolName"] as? String {
                    self.poolName = value
                }
                if let value = dict["PoolType"] as? String {
                    self.poolType = value
                }
                if let value = dict["PoolUsers"] as? String {
                    self.poolUsers = value
                }
                if let value = dict["RunningClusterCount"] as? Int32 {
                    self.runningClusterCount = value
                }
                if let value = dict["Status"] as? String {
                    self.status = value
                }
            }
        }
        public var computeResource: String?

        public var DBClusterId: String?

        public var freeComputeResource: String?

        public var resourceGroupList: [DescribeClusterResourceDetailResponseBody.Data.ResourceGroupList]?

        public var storageResource: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.computeResource != nil {
                map["ComputeResource"] = self.computeResource!
            }
            if self.DBClusterId != nil {
                map["DBClusterId"] = self.DBClusterId!
            }
            if self.freeComputeResource != nil {
                map["FreeComputeResource"] = self.freeComputeResource!
            }
            if self.resourceGroupList != nil {
                var tmp : [Any] = []
                for k in self.resourceGroupList! {
                    tmp.append(k.toMap())
                }
                map["ResourceGroupList"] = tmp
            }
            if self.storageResource != nil {
                map["StorageResource"] = self.storageResource!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ComputeResource"] as? String {
                self.computeResource = value
            }
            if let value = dict["DBClusterId"] as? String {
                self.DBClusterId = value
            }
            if let value = dict["FreeComputeResource"] as? String {
                self.freeComputeResource = value
            }
            if let value = dict["ResourceGroupList"] as? [Any?] {
                var tmp : [DescribeClusterResourceDetailResponseBody.Data.ResourceGroupList] = []
                for v in value {
                    if v != nil {
                        var model = DescribeClusterResourceDetailResponseBody.Data.ResourceGroupList()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.resourceGroupList = tmp
            }
            if let value = dict["StorageResource"] as? String {
                self.storageResource = value
            }
        }
    }
    public var code: Int32?

    public var data: DescribeClusterResourceDetailResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? Int32 {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = DescribeClusterResourceDetailResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeClusterResourceDetailResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeClusterResourceDetailResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeClusterResourceDetailResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeClusterResourceUsageRequest : Tea.TeaModel {
    public var DBClusterId: String?

    public var endTime: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
    }
}

public class DescribeClusterResourceUsageResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class AcuInfo : Tea.TeaModel {
            public var name: String?

            public var values: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.values != nil {
                    map["Values"] = self.values!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Name"] as? String {
                    self.name = value
                }
                if let value = dict["Values"] as? [String] {
                    self.values = value
                }
            }
        }
        public var acuInfo: [DescribeClusterResourceUsageResponseBody.Data.AcuInfo]?

        public var DBClusterId: String?

        public var endTime: String?

        public var startTime: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.acuInfo != nil {
                var tmp : [Any] = []
                for k in self.acuInfo! {
                    tmp.append(k.toMap())
                }
                map["AcuInfo"] = tmp
            }
            if self.DBClusterId != nil {
                map["DBClusterId"] = self.DBClusterId!
            }
            if self.endTime != nil {
                map["EndTime"] = self.endTime!
            }
            if self.startTime != nil {
                map["StartTime"] = self.startTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AcuInfo"] as? [Any?] {
                var tmp : [DescribeClusterResourceUsageResponseBody.Data.AcuInfo] = []
                for v in value {
                    if v != nil {
                        var model = DescribeClusterResourceUsageResponseBody.Data.AcuInfo()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.acuInfo = tmp
            }
            if let value = dict["DBClusterId"] as? String {
                self.DBClusterId = value
            }
            if let value = dict["EndTime"] as? String {
                self.endTime = value
            }
            if let value = dict["StartTime"] as? String {
                self.startTime = value
            }
        }
    }
    public var code: Int32?

    public var data: DescribeClusterResourceUsageResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? Int32 {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = DescribeClusterResourceUsageResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeClusterResourceUsageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeClusterResourceUsageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeClusterResourceUsageResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeColumnsRequest : Tea.TeaModel {
    public var DBClusterId: String?

    public var regionId: String?

    public var schemaName: String?

    public var tableName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.schemaName != nil {
            map["SchemaName"] = self.schemaName!
        }
        if self.tableName != nil {
            map["TableName"] = self.tableName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["SchemaName"] as? String {
            self.schemaName = value
        }
        if let value = dict["TableName"] as? String {
            self.tableName = value
        }
    }
}

public class DescribeColumnsResponseBody : Tea.TeaModel {
    public class Items : Tea.TeaModel {
        public class Column : Tea.TeaModel {
            public var autoIncrementColumn: Bool?

            public var columnName: String?

            public var DBClusterId: String?

            public var primaryKey: Bool?

            public var schemaName: String?

            public var tableName: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.autoIncrementColumn != nil {
                    map["AutoIncrementColumn"] = self.autoIncrementColumn!
                }
                if self.columnName != nil {
                    map["ColumnName"] = self.columnName!
                }
                if self.DBClusterId != nil {
                    map["DBClusterId"] = self.DBClusterId!
                }
                if self.primaryKey != nil {
                    map["PrimaryKey"] = self.primaryKey!
                }
                if self.schemaName != nil {
                    map["SchemaName"] = self.schemaName!
                }
                if self.tableName != nil {
                    map["TableName"] = self.tableName!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AutoIncrementColumn"] as? Bool {
                    self.autoIncrementColumn = value
                }
                if let value = dict["ColumnName"] as? String {
                    self.columnName = value
                }
                if let value = dict["DBClusterId"] as? String {
                    self.DBClusterId = value
                }
                if let value = dict["PrimaryKey"] as? Bool {
                    self.primaryKey = value
                }
                if let value = dict["SchemaName"] as? String {
                    self.schemaName = value
                }
                if let value = dict["TableName"] as? String {
                    self.tableName = value
                }
                if let value = dict["Type"] as? String {
                    self.type = value
                }
            }
        }
        public var column: [DescribeColumnsResponseBody.Items.Column]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.column != nil {
                var tmp : [Any] = []
                for k in self.column! {
                    tmp.append(k.toMap())
                }
                map["Column"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Column"] as? [Any?] {
                var tmp : [DescribeColumnsResponseBody.Items.Column] = []
                for v in value {
                    if v != nil {
                        var model = DescribeColumnsResponseBody.Items.Column()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.column = tmp
            }
        }
    }
    public var items: DescribeColumnsResponseBody.Items?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.items?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.items != nil {
            map["Items"] = self.items?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Items"] as? [String: Any?] {
            var model = DescribeColumnsResponseBody.Items()
            model.fromMap(value)
            self.items = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeColumnsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeColumnsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeColumnsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeCompactionServiceSwitchRequest : Tea.TeaModel {
    public var DBClusterId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
    }
}

public class DescribeCompactionServiceSwitchResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var enableCompactionService: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.enableCompactionService != nil {
                map["EnableCompactionService"] = self.enableCompactionService!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["EnableCompactionService"] as? Bool {
                self.enableCompactionService = value
            }
        }
    }
    public var data: DescribeCompactionServiceSwitchResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [String: Any?] {
            var model = DescribeCompactionServiceSwitchResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeCompactionServiceSwitchResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeCompactionServiceSwitchResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeCompactionServiceSwitchResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeComputeResourceUsageRequest : Tea.TeaModel {
    public var DBClusterId: String?

    public var endTime: String?

    public var resourceGroupName: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.resourceGroupName != nil {
            map["ResourceGroupName"] = self.resourceGroupName!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["ResourceGroupName"] as? String {
            self.resourceGroupName = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
    }
}

public class DescribeComputeResourceUsageResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class AcuInfo : Tea.TeaModel {
            public var name: String?

            public var values: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.values != nil {
                    map["Values"] = self.values!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Name"] as? String {
                    self.name = value
                }
                if let value = dict["Values"] as? [String] {
                    self.values = value
                }
            }
        }
        public var acuInfo: [DescribeComputeResourceUsageResponseBody.Data.AcuInfo]?

        public var DBClusterId: String?

        public var endTime: String?

        public var resourceGroupName: String?

        public var resourceGroupType: String?

        public var startTime: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.acuInfo != nil {
                var tmp : [Any] = []
                for k in self.acuInfo! {
                    tmp.append(k.toMap())
                }
                map["AcuInfo"] = tmp
            }
            if self.DBClusterId != nil {
                map["DBClusterId"] = self.DBClusterId!
            }
            if self.endTime != nil {
                map["EndTime"] = self.endTime!
            }
            if self.resourceGroupName != nil {
                map["ResourceGroupName"] = self.resourceGroupName!
            }
            if self.resourceGroupType != nil {
                map["ResourceGroupType"] = self.resourceGroupType!
            }
            if self.startTime != nil {
                map["StartTime"] = self.startTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AcuInfo"] as? [Any?] {
                var tmp : [DescribeComputeResourceUsageResponseBody.Data.AcuInfo] = []
                for v in value {
                    if v != nil {
                        var model = DescribeComputeResourceUsageResponseBody.Data.AcuInfo()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.acuInfo = tmp
            }
            if let value = dict["DBClusterId"] as? String {
                self.DBClusterId = value
            }
            if let value = dict["EndTime"] as? String {
                self.endTime = value
            }
            if let value = dict["ResourceGroupName"] as? String {
                self.resourceGroupName = value
            }
            if let value = dict["ResourceGroupType"] as? String {
                self.resourceGroupType = value
            }
            if let value = dict["StartTime"] as? String {
                self.startTime = value
            }
        }
    }
    public var code: Int32?

    public var data: DescribeComputeResourceUsageResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? Int32 {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = DescribeComputeResourceUsageResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeComputeResourceUsageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeComputeResourceUsageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeComputeResourceUsageResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeControllerDetectionRequest : Tea.TeaModel {
    public var DBClusterId: String?

    public var endTime: String?

    public var lang: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["Lang"] as? String {
            self.lang = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
    }
}

public class DescribeControllerDetectionResponseBody : Tea.TeaModel {
    public class DetectionItems : Tea.TeaModel {
        public var message: String?

        public var name: String?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Message"] as? String {
                self.message = value
            }
            if let value = dict["Name"] as? String {
                self.name = value
            }
            if let value = dict["Status"] as? String {
                self.status = value
            }
        }
    }
    public var DBClusterId: String?

    public var detectionItems: [DescribeControllerDetectionResponseBody.DetectionItems]?

    public var requestId: String?

    public var totalCount: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.detectionItems != nil {
            var tmp : [Any] = []
            for k in self.detectionItems! {
                tmp.append(k.toMap())
            }
            map["DetectionItems"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["DetectionItems"] as? [Any?] {
            var tmp : [DescribeControllerDetectionResponseBody.DetectionItems] = []
            for v in value {
                if v != nil {
                    var model = DescribeControllerDetectionResponseBody.DetectionItems()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.detectionItems = tmp
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? String {
            self.totalCount = value
        }
    }
}

public class DescribeControllerDetectionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeControllerDetectionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeControllerDetectionResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeDBClusterAttributeRequest : Tea.TeaModel {
    public var DBClusterId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
    }
}

public class DescribeDBClusterAttributeResponseBody : Tea.TeaModel {
    public class Items : Tea.TeaModel {
        public class DBCluster : Tea.TeaModel {
            public class Tags : Tea.TeaModel {
                public class Tag : Tea.TeaModel {
                    public var key: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.key != nil {
                            map["Key"] = self.key!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Key"] as? String {
                            self.key = value
                        }
                        if let value = dict["Value"] as? String {
                            self.value = value
                        }
                    }
                }
                public var tag: [DescribeDBClusterAttributeResponseBody.Items.DBCluster.Tags.Tag]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.tag != nil {
                        var tmp : [Any] = []
                        for k in self.tag! {
                            tmp.append(k.toMap())
                        }
                        map["Tag"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Tag"] as? [Any?] {
                        var tmp : [DescribeDBClusterAttributeResponseBody.Items.DBCluster.Tags.Tag] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeDBClusterAttributeResponseBody.Items.DBCluster.Tags.Tag()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.tag = tmp
                    }
                }
            }
            public class TaskInfo : Tea.TeaModel {
                public class StepList : Tea.TeaModel {
                    public class StepList : Tea.TeaModel {
                        public var endTime: String?

                        public var startTime: String?

                        public var stepDesc: String?

                        public var stepName: String?

                        public var stepProgress: String?

                        public var stepStatus: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.endTime != nil {
                                map["EndTime"] = self.endTime!
                            }
                            if self.startTime != nil {
                                map["StartTime"] = self.startTime!
                            }
                            if self.stepDesc != nil {
                                map["StepDesc"] = self.stepDesc!
                            }
                            if self.stepName != nil {
                                map["StepName"] = self.stepName!
                            }
                            if self.stepProgress != nil {
                                map["StepProgress"] = self.stepProgress!
                            }
                            if self.stepStatus != nil {
                                map["StepStatus"] = self.stepStatus!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any?]?) -> Void {
                            guard let dict else { return }
                            if let value = dict["EndTime"] as? String {
                                self.endTime = value
                            }
                            if let value = dict["StartTime"] as? String {
                                self.startTime = value
                            }
                            if let value = dict["StepDesc"] as? String {
                                self.stepDesc = value
                            }
                            if let value = dict["StepName"] as? String {
                                self.stepName = value
                            }
                            if let value = dict["StepProgress"] as? String {
                                self.stepProgress = value
                            }
                            if let value = dict["StepStatus"] as? String {
                                self.stepStatus = value
                            }
                        }
                    }
                    public var stepList: [DescribeDBClusterAttributeResponseBody.Items.DBCluster.TaskInfo.StepList.StepList]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.stepList != nil {
                            var tmp : [Any] = []
                            for k in self.stepList! {
                                tmp.append(k.toMap())
                            }
                            map["StepList"] = tmp
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["StepList"] as? [Any?] {
                            var tmp : [DescribeDBClusterAttributeResponseBody.Items.DBCluster.TaskInfo.StepList.StepList] = []
                            for v in value {
                                if v != nil {
                                    var model = DescribeDBClusterAttributeResponseBody.Items.DBCluster.TaskInfo.StepList.StepList()
                                    if v != nil {
                                        model.fromMap(v as? [String: Any?])
                                    }
                                    tmp.append(model)
                                }
                            }
                            self.stepList = tmp
                        }
                    }
                }
                public var name: String?

                public var progress: String?

                public var status: String?

                public var stepList: DescribeDBClusterAttributeResponseBody.Items.DBCluster.TaskInfo.StepList?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.stepList?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.progress != nil {
                        map["Progress"] = self.progress!
                    }
                    if self.status != nil {
                        map["Status"] = self.status!
                    }
                    if self.stepList != nil {
                        map["StepList"] = self.stepList?.toMap()
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Name"] as? String {
                        self.name = value
                    }
                    if let value = dict["Progress"] as? String {
                        self.progress = value
                    }
                    if let value = dict["Status"] as? String {
                        self.status = value
                    }
                    if let value = dict["StepList"] as? [String: Any?] {
                        var model = DescribeDBClusterAttributeResponseBody.Items.DBCluster.TaskInfo.StepList()
                        model.fromMap(value)
                        self.stepList = model
                    }
                }
            }
            public var AINodeNumber: Int32?

            public var AINodeSpec: String?

            public var clickhouseEngineCacheSize: Int32?

            public var clickhouseEngineEnabled: Bool?

            public var commodityCode: String?

            public var computeResource: String?

            public var computeResourceTotal: String?

            public var connectionString: String?

            public var creationTime: String?

            public var DBClusterDescription: String?

            public var DBClusterId: String?

            public var DBClusterNetworkType: String?

            public var DBClusterStatus: String?

            public var DBClusterType: String?

            public var DBVersion: String?

            public var diskEncryption: Bool?

            public var engine: String?

            public var engineVersion: String?

            public var expireTime: String?

            public var expired: String?

            public var kmsId: String?

            public var lockMode: String?

            public var lockReason: String?

            public var maintainTime: String?

            public var mode: String?

            public var payType: String?

            public var port: Int32?

            public var productForm: String?

            public var productVersion: String?

            public var regionId: String?

            public var reservedACU: String?

            public var reservedNodeCount: Int32?

            public var reservedNodeSize: String?

            public var resourceGroupId: String?

            public var secondaryVSwitchId: String?

            public var secondaryZoneId: String?

            public var storageResource: String?

            public var storageResourceTotal: String?

            public var supportedFeatures: [String: String]?

            public var tags: DescribeDBClusterAttributeResponseBody.Items.DBCluster.Tags?

            public var taskInfo: DescribeDBClusterAttributeResponseBody.Items.DBCluster.TaskInfo?

            public var userENIStatus: Bool?

            public var userENIVSwitchOptions: String?

            public var userENIVpcId: String?

            public var userENIZoneOptions: String?

            public var VPCId: String?

            public var vSwitchId: String?

            public var zoneId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.tags?.validate()
                try self.taskInfo?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.AINodeNumber != nil {
                    map["AINodeNumber"] = self.AINodeNumber!
                }
                if self.AINodeSpec != nil {
                    map["AINodeSpec"] = self.AINodeSpec!
                }
                if self.clickhouseEngineCacheSize != nil {
                    map["ClickhouseEngineCacheSize"] = self.clickhouseEngineCacheSize!
                }
                if self.clickhouseEngineEnabled != nil {
                    map["ClickhouseEngineEnabled"] = self.clickhouseEngineEnabled!
                }
                if self.commodityCode != nil {
                    map["CommodityCode"] = self.commodityCode!
                }
                if self.computeResource != nil {
                    map["ComputeResource"] = self.computeResource!
                }
                if self.computeResourceTotal != nil {
                    map["ComputeResourceTotal"] = self.computeResourceTotal!
                }
                if self.connectionString != nil {
                    map["ConnectionString"] = self.connectionString!
                }
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.DBClusterDescription != nil {
                    map["DBClusterDescription"] = self.DBClusterDescription!
                }
                if self.DBClusterId != nil {
                    map["DBClusterId"] = self.DBClusterId!
                }
                if self.DBClusterNetworkType != nil {
                    map["DBClusterNetworkType"] = self.DBClusterNetworkType!
                }
                if self.DBClusterStatus != nil {
                    map["DBClusterStatus"] = self.DBClusterStatus!
                }
                if self.DBClusterType != nil {
                    map["DBClusterType"] = self.DBClusterType!
                }
                if self.DBVersion != nil {
                    map["DBVersion"] = self.DBVersion!
                }
                if self.diskEncryption != nil {
                    map["DiskEncryption"] = self.diskEncryption!
                }
                if self.engine != nil {
                    map["Engine"] = self.engine!
                }
                if self.engineVersion != nil {
                    map["EngineVersion"] = self.engineVersion!
                }
                if self.expireTime != nil {
                    map["ExpireTime"] = self.expireTime!
                }
                if self.expired != nil {
                    map["Expired"] = self.expired!
                }
                if self.kmsId != nil {
                    map["KmsId"] = self.kmsId!
                }
                if self.lockMode != nil {
                    map["LockMode"] = self.lockMode!
                }
                if self.lockReason != nil {
                    map["LockReason"] = self.lockReason!
                }
                if self.maintainTime != nil {
                    map["MaintainTime"] = self.maintainTime!
                }
                if self.mode != nil {
                    map["Mode"] = self.mode!
                }
                if self.payType != nil {
                    map["PayType"] = self.payType!
                }
                if self.port != nil {
                    map["Port"] = self.port!
                }
                if self.productForm != nil {
                    map["ProductForm"] = self.productForm!
                }
                if self.productVersion != nil {
                    map["ProductVersion"] = self.productVersion!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.reservedACU != nil {
                    map["ReservedACU"] = self.reservedACU!
                }
                if self.reservedNodeCount != nil {
                    map["ReservedNodeCount"] = self.reservedNodeCount!
                }
                if self.reservedNodeSize != nil {
                    map["ReservedNodeSize"] = self.reservedNodeSize!
                }
                if self.resourceGroupId != nil {
                    map["ResourceGroupId"] = self.resourceGroupId!
                }
                if self.secondaryVSwitchId != nil {
                    map["SecondaryVSwitchId"] = self.secondaryVSwitchId!
                }
                if self.secondaryZoneId != nil {
                    map["SecondaryZoneId"] = self.secondaryZoneId!
                }
                if self.storageResource != nil {
                    map["StorageResource"] = self.storageResource!
                }
                if self.storageResourceTotal != nil {
                    map["StorageResourceTotal"] = self.storageResourceTotal!
                }
                if self.supportedFeatures != nil {
                    map["SupportedFeatures"] = self.supportedFeatures!
                }
                if self.tags != nil {
                    map["Tags"] = self.tags?.toMap()
                }
                if self.taskInfo != nil {
                    map["TaskInfo"] = self.taskInfo?.toMap()
                }
                if self.userENIStatus != nil {
                    map["UserENIStatus"] = self.userENIStatus!
                }
                if self.userENIVSwitchOptions != nil {
                    map["UserENIVSwitchOptions"] = self.userENIVSwitchOptions!
                }
                if self.userENIVpcId != nil {
                    map["UserENIVpcId"] = self.userENIVpcId!
                }
                if self.userENIZoneOptions != nil {
                    map["UserENIZoneOptions"] = self.userENIZoneOptions!
                }
                if self.VPCId != nil {
                    map["VPCId"] = self.VPCId!
                }
                if self.vSwitchId != nil {
                    map["VSwitchId"] = self.vSwitchId!
                }
                if self.zoneId != nil {
                    map["ZoneId"] = self.zoneId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AINodeNumber"] as? Int32 {
                    self.AINodeNumber = value
                }
                if let value = dict["AINodeSpec"] as? String {
                    self.AINodeSpec = value
                }
                if let value = dict["ClickhouseEngineCacheSize"] as? Int32 {
                    self.clickhouseEngineCacheSize = value
                }
                if let value = dict["ClickhouseEngineEnabled"] as? Bool {
                    self.clickhouseEngineEnabled = value
                }
                if let value = dict["CommodityCode"] as? String {
                    self.commodityCode = value
                }
                if let value = dict["ComputeResource"] as? String {
                    self.computeResource = value
                }
                if let value = dict["ComputeResourceTotal"] as? String {
                    self.computeResourceTotal = value
                }
                if let value = dict["ConnectionString"] as? String {
                    self.connectionString = value
                }
                if let value = dict["CreationTime"] as? String {
                    self.creationTime = value
                }
                if let value = dict["DBClusterDescription"] as? String {
                    self.DBClusterDescription = value
                }
                if let value = dict["DBClusterId"] as? String {
                    self.DBClusterId = value
                }
                if let value = dict["DBClusterNetworkType"] as? String {
                    self.DBClusterNetworkType = value
                }
                if let value = dict["DBClusterStatus"] as? String {
                    self.DBClusterStatus = value
                }
                if let value = dict["DBClusterType"] as? String {
                    self.DBClusterType = value
                }
                if let value = dict["DBVersion"] as? String {
                    self.DBVersion = value
                }
                if let value = dict["DiskEncryption"] as? Bool {
                    self.diskEncryption = value
                }
                if let value = dict["Engine"] as? String {
                    self.engine = value
                }
                if let value = dict["EngineVersion"] as? String {
                    self.engineVersion = value
                }
                if let value = dict["ExpireTime"] as? String {
                    self.expireTime = value
                }
                if let value = dict["Expired"] as? String {
                    self.expired = value
                }
                if let value = dict["KmsId"] as? String {
                    self.kmsId = value
                }
                if let value = dict["LockMode"] as? String {
                    self.lockMode = value
                }
                if let value = dict["LockReason"] as? String {
                    self.lockReason = value
                }
                if let value = dict["MaintainTime"] as? String {
                    self.maintainTime = value
                }
                if let value = dict["Mode"] as? String {
                    self.mode = value
                }
                if let value = dict["PayType"] as? String {
                    self.payType = value
                }
                if let value = dict["Port"] as? Int32 {
                    self.port = value
                }
                if let value = dict["ProductForm"] as? String {
                    self.productForm = value
                }
                if let value = dict["ProductVersion"] as? String {
                    self.productVersion = value
                }
                if let value = dict["RegionId"] as? String {
                    self.regionId = value
                }
                if let value = dict["ReservedACU"] as? String {
                    self.reservedACU = value
                }
                if let value = dict["ReservedNodeCount"] as? Int32 {
                    self.reservedNodeCount = value
                }
                if let value = dict["ReservedNodeSize"] as? String {
                    self.reservedNodeSize = value
                }
                if let value = dict["ResourceGroupId"] as? String {
                    self.resourceGroupId = value
                }
                if let value = dict["SecondaryVSwitchId"] as? String {
                    self.secondaryVSwitchId = value
                }
                if let value = dict["SecondaryZoneId"] as? String {
                    self.secondaryZoneId = value
                }
                if let value = dict["StorageResource"] as? String {
                    self.storageResource = value
                }
                if let value = dict["StorageResourceTotal"] as? String {
                    self.storageResourceTotal = value
                }
                if let value = dict["SupportedFeatures"] as? [String: String] {
                    self.supportedFeatures = value
                }
                if let value = dict["Tags"] as? [String: Any?] {
                    var model = DescribeDBClusterAttributeResponseBody.Items.DBCluster.Tags()
                    model.fromMap(value)
                    self.tags = model
                }
                if let value = dict["TaskInfo"] as? [String: Any?] {
                    var model = DescribeDBClusterAttributeResponseBody.Items.DBCluster.TaskInfo()
                    model.fromMap(value)
                    self.taskInfo = model
                }
                if let value = dict["UserENIStatus"] as? Bool {
                    self.userENIStatus = value
                }
                if let value = dict["UserENIVSwitchOptions"] as? String {
                    self.userENIVSwitchOptions = value
                }
                if let value = dict["UserENIVpcId"] as? String {
                    self.userENIVpcId = value
                }
                if let value = dict["UserENIZoneOptions"] as? String {
                    self.userENIZoneOptions = value
                }
                if let value = dict["VPCId"] as? String {
                    self.VPCId = value
                }
                if let value = dict["VSwitchId"] as? String {
                    self.vSwitchId = value
                }
                if let value = dict["ZoneId"] as? String {
                    self.zoneId = value
                }
            }
        }
        public var DBCluster: [DescribeDBClusterAttributeResponseBody.Items.DBCluster]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.DBCluster != nil {
                var tmp : [Any] = []
                for k in self.DBCluster! {
                    tmp.append(k.toMap())
                }
                map["DBCluster"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DBCluster"] as? [Any?] {
                var tmp : [DescribeDBClusterAttributeResponseBody.Items.DBCluster] = []
                for v in value {
                    if v != nil {
                        var model = DescribeDBClusterAttributeResponseBody.Items.DBCluster()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.DBCluster = tmp
            }
        }
    }
    public var items: DescribeDBClusterAttributeResponseBody.Items?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.items?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.items != nil {
            map["Items"] = self.items?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Items"] as? [String: Any?] {
            var model = DescribeDBClusterAttributeResponseBody.Items()
            model.fromMap(value)
            self.items = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeDBClusterAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDBClusterAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeDBClusterAttributeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeDBClusterHealthStatusRequest : Tea.TeaModel {
    public var DBClusterId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class DescribeDBClusterHealthStatusResponseBody : Tea.TeaModel {
    public class CS : Tea.TeaModel {
        public var activeCount: Int64?

        public var expectedCount: Int64?

        public var riskCount: Int64?

        public var status: String?

        public var unavailableCount: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.activeCount != nil {
                map["ActiveCount"] = self.activeCount!
            }
            if self.expectedCount != nil {
                map["ExpectedCount"] = self.expectedCount!
            }
            if self.riskCount != nil {
                map["RiskCount"] = self.riskCount!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.unavailableCount != nil {
                map["UnavailableCount"] = self.unavailableCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ActiveCount"] as? Int64 {
                self.activeCount = value
            }
            if let value = dict["ExpectedCount"] as? Int64 {
                self.expectedCount = value
            }
            if let value = dict["RiskCount"] as? Int64 {
                self.riskCount = value
            }
            if let value = dict["Status"] as? String {
                self.status = value
            }
            if let value = dict["UnavailableCount"] as? Int64 {
                self.unavailableCount = value
            }
        }
    }
    public class Executor : Tea.TeaModel {
        public var activeCount: Int64?

        public var expectedCount: Int64?

        public var riskCount: Int64?

        public var status: String?

        public var unavailableCount: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.activeCount != nil {
                map["ActiveCount"] = self.activeCount!
            }
            if self.expectedCount != nil {
                map["ExpectedCount"] = self.expectedCount!
            }
            if self.riskCount != nil {
                map["RiskCount"] = self.riskCount!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.unavailableCount != nil {
                map["UnavailableCount"] = self.unavailableCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ActiveCount"] as? Int64 {
                self.activeCount = value
            }
            if let value = dict["ExpectedCount"] as? Int64 {
                self.expectedCount = value
            }
            if let value = dict["RiskCount"] as? Int64 {
                self.riskCount = value
            }
            if let value = dict["Status"] as? String {
                self.status = value
            }
            if let value = dict["UnavailableCount"] as? Int64 {
                self.unavailableCount = value
            }
        }
    }
    public class Worker : Tea.TeaModel {
        public var activeCount: Int64?

        public var expectedCount: Int64?

        public var riskCount: Int64?

        public var status: String?

        public var unavailableCount: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.activeCount != nil {
                map["ActiveCount"] = self.activeCount!
            }
            if self.expectedCount != nil {
                map["ExpectedCount"] = self.expectedCount!
            }
            if self.riskCount != nil {
                map["RiskCount"] = self.riskCount!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.unavailableCount != nil {
                map["UnavailableCount"] = self.unavailableCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ActiveCount"] as? Int64 {
                self.activeCount = value
            }
            if let value = dict["ExpectedCount"] as? Int64 {
                self.expectedCount = value
            }
            if let value = dict["RiskCount"] as? Int64 {
                self.riskCount = value
            }
            if let value = dict["Status"] as? String {
                self.status = value
            }
            if let value = dict["UnavailableCount"] as? Int64 {
                self.unavailableCount = value
            }
        }
    }
    public var accessDeniedDetail: String?

    public var CS: DescribeDBClusterHealthStatusResponseBody.CS?

    public var executor: DescribeDBClusterHealthStatusResponseBody.Executor?

    public var instanceStatus: String?

    public var requestId: String?

    public var worker: DescribeDBClusterHealthStatusResponseBody.Worker?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.CS?.validate()
        try self.executor?.validate()
        try self.worker?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessDeniedDetail != nil {
            map["AccessDeniedDetail"] = self.accessDeniedDetail!
        }
        if self.CS != nil {
            map["CS"] = self.CS?.toMap()
        }
        if self.executor != nil {
            map["Executor"] = self.executor?.toMap()
        }
        if self.instanceStatus != nil {
            map["InstanceStatus"] = self.instanceStatus!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.worker != nil {
            map["Worker"] = self.worker?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AccessDeniedDetail"] as? String {
            self.accessDeniedDetail = value
        }
        if let value = dict["CS"] as? [String: Any?] {
            var model = DescribeDBClusterHealthStatusResponseBody.CS()
            model.fromMap(value)
            self.CS = model
        }
        if let value = dict["Executor"] as? [String: Any?] {
            var model = DescribeDBClusterHealthStatusResponseBody.Executor()
            model.fromMap(value)
            self.executor = model
        }
        if let value = dict["InstanceStatus"] as? String {
            self.instanceStatus = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Worker"] as? [String: Any?] {
            var model = DescribeDBClusterHealthStatusResponseBody.Worker()
            model.fromMap(value)
            self.worker = model
        }
    }
}

public class DescribeDBClusterHealthStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDBClusterHealthStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeDBClusterHealthStatusResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeDBClusterPerformanceRequest : Tea.TeaModel {
    public var DBClusterId: String?

    public var endTime: String?

    public var key: String?

    public var regionId: String?

    public var resourcePools: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.key != nil {
            map["Key"] = self.key!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourcePools != nil {
            map["ResourcePools"] = self.resourcePools!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["Key"] as? String {
            self.key = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourcePools"] as? String {
            self.resourcePools = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
    }
}

public class DescribeDBClusterPerformanceResponseBody : Tea.TeaModel {
    public class Performances : Tea.TeaModel {
        public class Series : Tea.TeaModel {
            public var name: String?

            public var tags: String?

            public var translateKey: String?

            public var values: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.tags != nil {
                    map["Tags"] = self.tags!
                }
                if self.translateKey != nil {
                    map["TranslateKey"] = self.translateKey!
                }
                if self.values != nil {
                    map["Values"] = self.values!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Name"] as? String {
                    self.name = value
                }
                if let value = dict["Tags"] as? String {
                    self.tags = value
                }
                if let value = dict["TranslateKey"] as? String {
                    self.translateKey = value
                }
                if let value = dict["Values"] as? [String] {
                    self.values = value
                }
            }
        }
        public var key: String?

        public var series: [DescribeDBClusterPerformanceResponseBody.Performances.Series]?

        public var unit: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.series != nil {
                var tmp : [Any] = []
                for k in self.series! {
                    tmp.append(k.toMap())
                }
                map["Series"] = tmp
            }
            if self.unit != nil {
                map["Unit"] = self.unit!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Series"] as? [Any?] {
                var tmp : [DescribeDBClusterPerformanceResponseBody.Performances.Series] = []
                for v in value {
                    if v != nil {
                        var model = DescribeDBClusterPerformanceResponseBody.Performances.Series()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.series = tmp
            }
            if let value = dict["Unit"] as? String {
                self.unit = value
            }
        }
    }
    public var DBClusterId: String?

    public var endTime: String?

    public var performances: [DescribeDBClusterPerformanceResponseBody.Performances]?

    public var requestId: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.performances != nil {
            var tmp : [Any] = []
            for k in self.performances! {
                tmp.append(k.toMap())
            }
            map["Performances"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["Performances"] as? [Any?] {
            var tmp : [DescribeDBClusterPerformanceResponseBody.Performances] = []
            for v in value {
                if v != nil {
                    var model = DescribeDBClusterPerformanceResponseBody.Performances()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.performances = tmp
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
    }
}

public class DescribeDBClusterPerformanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDBClusterPerformanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeDBClusterPerformanceResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeDBClusterSpaceSummaryRequest : Tea.TeaModel {
    public var DBClusterId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DescribeDBClusterSpaceSummaryResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class ColdData : Tea.TeaModel {
            public var dataSize: Int64?

            public var indexSize: Int64?

            public var otherSize: Int64?

            public var primaryKeyIndexSize: Int64?

            public var totalSize: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dataSize != nil {
                    map["DataSize"] = self.dataSize!
                }
                if self.indexSize != nil {
                    map["IndexSize"] = self.indexSize!
                }
                if self.otherSize != nil {
                    map["OtherSize"] = self.otherSize!
                }
                if self.primaryKeyIndexSize != nil {
                    map["PrimaryKeyIndexSize"] = self.primaryKeyIndexSize!
                }
                if self.totalSize != nil {
                    map["TotalSize"] = self.totalSize!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["DataSize"] as? Int64 {
                    self.dataSize = value
                }
                if let value = dict["IndexSize"] as? Int64 {
                    self.indexSize = value
                }
                if let value = dict["OtherSize"] as? Int64 {
                    self.otherSize = value
                }
                if let value = dict["PrimaryKeyIndexSize"] as? Int64 {
                    self.primaryKeyIndexSize = value
                }
                if let value = dict["TotalSize"] as? Int64 {
                    self.totalSize = value
                }
            }
        }
        public class DataGrowth : Tea.TeaModel {
            public var dayGrowth: Int64?

            public var weekGrowth: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dayGrowth != nil {
                    map["DayGrowth"] = self.dayGrowth!
                }
                if self.weekGrowth != nil {
                    map["WeekGrowth"] = self.weekGrowth!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["DayGrowth"] as? Int64 {
                    self.dayGrowth = value
                }
                if let value = dict["WeekGrowth"] as? Int64 {
                    self.weekGrowth = value
                }
            }
        }
        public class HotData : Tea.TeaModel {
            public var dataSize: Int64?

            public var indexSize: Int64?

            public var otherSize: Int64?

            public var primaryKeyIndexSize: Int64?

            public var totalSize: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dataSize != nil {
                    map["DataSize"] = self.dataSize!
                }
                if self.indexSize != nil {
                    map["IndexSize"] = self.indexSize!
                }
                if self.otherSize != nil {
                    map["OtherSize"] = self.otherSize!
                }
                if self.primaryKeyIndexSize != nil {
                    map["PrimaryKeyIndexSize"] = self.primaryKeyIndexSize!
                }
                if self.totalSize != nil {
                    map["TotalSize"] = self.totalSize!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["DataSize"] as? Int64 {
                    self.dataSize = value
                }
                if let value = dict["IndexSize"] as? Int64 {
                    self.indexSize = value
                }
                if let value = dict["OtherSize"] as? Int64 {
                    self.otherSize = value
                }
                if let value = dict["PrimaryKeyIndexSize"] as? Int64 {
                    self.primaryKeyIndexSize = value
                }
                if let value = dict["TotalSize"] as? Int64 {
                    self.totalSize = value
                }
            }
        }
        public var coldData: DescribeDBClusterSpaceSummaryResponseBody.Data.ColdData?

        public var dataGrowth: DescribeDBClusterSpaceSummaryResponseBody.Data.DataGrowth?

        public var hotData: DescribeDBClusterSpaceSummaryResponseBody.Data.HotData?

        public var totalSize: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.coldData?.validate()
            try self.dataGrowth?.validate()
            try self.hotData?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.coldData != nil {
                map["ColdData"] = self.coldData?.toMap()
            }
            if self.dataGrowth != nil {
                map["DataGrowth"] = self.dataGrowth?.toMap()
            }
            if self.hotData != nil {
                map["HotData"] = self.hotData?.toMap()
            }
            if self.totalSize != nil {
                map["TotalSize"] = self.totalSize!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ColdData"] as? [String: Any?] {
                var model = DescribeDBClusterSpaceSummaryResponseBody.Data.ColdData()
                model.fromMap(value)
                self.coldData = model
            }
            if let value = dict["DataGrowth"] as? [String: Any?] {
                var model = DescribeDBClusterSpaceSummaryResponseBody.Data.DataGrowth()
                model.fromMap(value)
                self.dataGrowth = model
            }
            if let value = dict["HotData"] as? [String: Any?] {
                var model = DescribeDBClusterSpaceSummaryResponseBody.Data.HotData()
                model.fromMap(value)
                self.hotData = model
            }
            if let value = dict["TotalSize"] as? String {
                self.totalSize = value
            }
        }
    }
    public var data: DescribeDBClusterSpaceSummaryResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [String: Any?] {
            var model = DescribeDBClusterSpaceSummaryResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeDBClusterSpaceSummaryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDBClusterSpaceSummaryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeDBClusterSpaceSummaryResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeDBClusterStatusRequest : Tea.TeaModel {
    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class DescribeDBClusterStatusResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var status: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Status"] as? [String] {
            self.status = value
        }
    }
}

public class DescribeDBClusterStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDBClusterStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeDBClusterStatusResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeDBClustersRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var DBClusterDescription: String?

    public var DBClusterIds: String?

    public var DBClusterStatus: String?

    public var DBClusterVersion: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var productVersion: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var tag: [DescribeDBClustersRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBClusterDescription != nil {
            map["DBClusterDescription"] = self.DBClusterDescription!
        }
        if self.DBClusterIds != nil {
            map["DBClusterIds"] = self.DBClusterIds!
        }
        if self.DBClusterStatus != nil {
            map["DBClusterStatus"] = self.DBClusterStatus!
        }
        if self.DBClusterVersion != nil {
            map["DBClusterVersion"] = self.DBClusterVersion!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.productVersion != nil {
            map["ProductVersion"] = self.productVersion!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBClusterDescription"] as? String {
            self.DBClusterDescription = value
        }
        if let value = dict["DBClusterIds"] as? String {
            self.DBClusterIds = value
        }
        if let value = dict["DBClusterStatus"] as? String {
            self.DBClusterStatus = value
        }
        if let value = dict["DBClusterVersion"] as? String {
            self.DBClusterVersion = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["ProductVersion"] as? String {
            self.productVersion = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["Tag"] as? [Any?] {
            var tmp : [DescribeDBClustersRequest.Tag] = []
            for v in value {
                if v != nil {
                    var model = DescribeDBClustersRequest.Tag()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tag = tmp
        }
    }
}

public class DescribeDBClustersResponseBody : Tea.TeaModel {
    public class Items : Tea.TeaModel {
        public class DBCluster : Tea.TeaModel {
            public class Tags : Tea.TeaModel {
                public class Tag : Tea.TeaModel {
                    public var key: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.key != nil {
                            map["Key"] = self.key!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Key"] as? String {
                            self.key = value
                        }
                        if let value = dict["Value"] as? String {
                            self.value = value
                        }
                    }
                }
                public var tag: [DescribeDBClustersResponseBody.Items.DBCluster.Tags.Tag]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.tag != nil {
                        var tmp : [Any] = []
                        for k in self.tag! {
                            tmp.append(k.toMap())
                        }
                        map["Tag"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Tag"] as? [Any?] {
                        var tmp : [DescribeDBClustersResponseBody.Items.DBCluster.Tags.Tag] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeDBClustersResponseBody.Items.DBCluster.Tags.Tag()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.tag = tmp
                    }
                }
            }
            public class TaskInfo : Tea.TeaModel {
                public class StepList : Tea.TeaModel {
                    public class StepList : Tea.TeaModel {
                        public var endTime: String?

                        public var startTime: String?

                        public var stepDesc: String?

                        public var stepName: String?

                        public var stepProgress: String?

                        public var stepStatus: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.endTime != nil {
                                map["EndTime"] = self.endTime!
                            }
                            if self.startTime != nil {
                                map["StartTime"] = self.startTime!
                            }
                            if self.stepDesc != nil {
                                map["StepDesc"] = self.stepDesc!
                            }
                            if self.stepName != nil {
                                map["StepName"] = self.stepName!
                            }
                            if self.stepProgress != nil {
                                map["StepProgress"] = self.stepProgress!
                            }
                            if self.stepStatus != nil {
                                map["StepStatus"] = self.stepStatus!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any?]?) -> Void {
                            guard let dict else { return }
                            if let value = dict["EndTime"] as? String {
                                self.endTime = value
                            }
                            if let value = dict["StartTime"] as? String {
                                self.startTime = value
                            }
                            if let value = dict["StepDesc"] as? String {
                                self.stepDesc = value
                            }
                            if let value = dict["StepName"] as? String {
                                self.stepName = value
                            }
                            if let value = dict["StepProgress"] as? String {
                                self.stepProgress = value
                            }
                            if let value = dict["StepStatus"] as? String {
                                self.stepStatus = value
                            }
                        }
                    }
                    public var stepList: [DescribeDBClustersResponseBody.Items.DBCluster.TaskInfo.StepList.StepList]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.stepList != nil {
                            var tmp : [Any] = []
                            for k in self.stepList! {
                                tmp.append(k.toMap())
                            }
                            map["StepList"] = tmp
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["StepList"] as? [Any?] {
                            var tmp : [DescribeDBClustersResponseBody.Items.DBCluster.TaskInfo.StepList.StepList] = []
                            for v in value {
                                if v != nil {
                                    var model = DescribeDBClustersResponseBody.Items.DBCluster.TaskInfo.StepList.StepList()
                                    if v != nil {
                                        model.fromMap(v as? [String: Any?])
                                    }
                                    tmp.append(model)
                                }
                            }
                            self.stepList = tmp
                        }
                    }
                }
                public var name: String?

                public var progress: String?

                public var status: String?

                public var stepList: DescribeDBClustersResponseBody.Items.DBCluster.TaskInfo.StepList?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.stepList?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.progress != nil {
                        map["Progress"] = self.progress!
                    }
                    if self.status != nil {
                        map["Status"] = self.status!
                    }
                    if self.stepList != nil {
                        map["StepList"] = self.stepList?.toMap()
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Name"] as? String {
                        self.name = value
                    }
                    if let value = dict["Progress"] as? String {
                        self.progress = value
                    }
                    if let value = dict["Status"] as? String {
                        self.status = value
                    }
                    if let value = dict["StepList"] as? [String: Any?] {
                        var model = DescribeDBClustersResponseBody.Items.DBCluster.TaskInfo.StepList()
                        model.fromMap(value)
                        self.stepList = model
                    }
                }
            }
            public var category: String?

            public var commodityCode: String?

            public var computeResource: String?

            public var connectionString: String?

            public var createTime: String?

            public var DBClusterDescription: String?

            public var DBClusterId: String?

            public var DBClusterNetworkType: String?

            public var DBClusterStatus: String?

            public var DBClusterType: String?

            public var DBNodeClass: String?

            public var DBNodeCount: Int64?

            public var DBNodeStorage: Int64?

            public var DBVersion: String?

            public var diskType: String?

            public var dtsJobId: String?

            public var elasticIOResource: Int32?

            public var engine: String?

            public var executorCount: String?

            public var expireTime: String?

            public var expired: String?

            public var innerIp: String?

            public var innerPort: String?

            public var lockMode: String?

            public var lockReason: String?

            public var mode: String?

            public var payType: String?

            public var port: String?

            public var productForm: String?

            public var productVersion: String?

            public var rdsInstanceId: String?

            public var regionId: String?

            public var reservedACU: String?

            public var reservedNodeCount: Int32?

            public var reservedNodeSize: String?

            public var resourceGroupId: String?

            public var storageResource: String?

            public var tags: DescribeDBClustersResponseBody.Items.DBCluster.Tags?

            public var taskInfo: DescribeDBClustersResponseBody.Items.DBCluster.TaskInfo?

            public var VPCCloudInstanceId: String?

            public var VPCId: String?

            public var vSwitchId: String?

            public var zoneId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.tags?.validate()
                try self.taskInfo?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.category != nil {
                    map["Category"] = self.category!
                }
                if self.commodityCode != nil {
                    map["CommodityCode"] = self.commodityCode!
                }
                if self.computeResource != nil {
                    map["ComputeResource"] = self.computeResource!
                }
                if self.connectionString != nil {
                    map["ConnectionString"] = self.connectionString!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.DBClusterDescription != nil {
                    map["DBClusterDescription"] = self.DBClusterDescription!
                }
                if self.DBClusterId != nil {
                    map["DBClusterId"] = self.DBClusterId!
                }
                if self.DBClusterNetworkType != nil {
                    map["DBClusterNetworkType"] = self.DBClusterNetworkType!
                }
                if self.DBClusterStatus != nil {
                    map["DBClusterStatus"] = self.DBClusterStatus!
                }
                if self.DBClusterType != nil {
                    map["DBClusterType"] = self.DBClusterType!
                }
                if self.DBNodeClass != nil {
                    map["DBNodeClass"] = self.DBNodeClass!
                }
                if self.DBNodeCount != nil {
                    map["DBNodeCount"] = self.DBNodeCount!
                }
                if self.DBNodeStorage != nil {
                    map["DBNodeStorage"] = self.DBNodeStorage!
                }
                if self.DBVersion != nil {
                    map["DBVersion"] = self.DBVersion!
                }
                if self.diskType != nil {
                    map["DiskType"] = self.diskType!
                }
                if self.dtsJobId != nil {
                    map["DtsJobId"] = self.dtsJobId!
                }
                if self.elasticIOResource != nil {
                    map["ElasticIOResource"] = self.elasticIOResource!
                }
                if self.engine != nil {
                    map["Engine"] = self.engine!
                }
                if self.executorCount != nil {
                    map["ExecutorCount"] = self.executorCount!
                }
                if self.expireTime != nil {
                    map["ExpireTime"] = self.expireTime!
                }
                if self.expired != nil {
                    map["Expired"] = self.expired!
                }
                if self.innerIp != nil {
                    map["InnerIp"] = self.innerIp!
                }
                if self.innerPort != nil {
                    map["InnerPort"] = self.innerPort!
                }
                if self.lockMode != nil {
                    map["LockMode"] = self.lockMode!
                }
                if self.lockReason != nil {
                    map["LockReason"] = self.lockReason!
                }
                if self.mode != nil {
                    map["Mode"] = self.mode!
                }
                if self.payType != nil {
                    map["PayType"] = self.payType!
                }
                if self.port != nil {
                    map["Port"] = self.port!
                }
                if self.productForm != nil {
                    map["ProductForm"] = self.productForm!
                }
                if self.productVersion != nil {
                    map["ProductVersion"] = self.productVersion!
                }
                if self.rdsInstanceId != nil {
                    map["RdsInstanceId"] = self.rdsInstanceId!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.reservedACU != nil {
                    map["ReservedACU"] = self.reservedACU!
                }
                if self.reservedNodeCount != nil {
                    map["ReservedNodeCount"] = self.reservedNodeCount!
                }
                if self.reservedNodeSize != nil {
                    map["ReservedNodeSize"] = self.reservedNodeSize!
                }
                if self.resourceGroupId != nil {
                    map["ResourceGroupId"] = self.resourceGroupId!
                }
                if self.storageResource != nil {
                    map["StorageResource"] = self.storageResource!
                }
                if self.tags != nil {
                    map["Tags"] = self.tags?.toMap()
                }
                if self.taskInfo != nil {
                    map["TaskInfo"] = self.taskInfo?.toMap()
                }
                if self.VPCCloudInstanceId != nil {
                    map["VPCCloudInstanceId"] = self.VPCCloudInstanceId!
                }
                if self.VPCId != nil {
                    map["VPCId"] = self.VPCId!
                }
                if self.vSwitchId != nil {
                    map["VSwitchId"] = self.vSwitchId!
                }
                if self.zoneId != nil {
                    map["ZoneId"] = self.zoneId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Category"] as? String {
                    self.category = value
                }
                if let value = dict["CommodityCode"] as? String {
                    self.commodityCode = value
                }
                if let value = dict["ComputeResource"] as? String {
                    self.computeResource = value
                }
                if let value = dict["ConnectionString"] as? String {
                    self.connectionString = value
                }
                if let value = dict["CreateTime"] as? String {
                    self.createTime = value
                }
                if let value = dict["DBClusterDescription"] as? String {
                    self.DBClusterDescription = value
                }
                if let value = dict["DBClusterId"] as? String {
                    self.DBClusterId = value
                }
                if let value = dict["DBClusterNetworkType"] as? String {
                    self.DBClusterNetworkType = value
                }
                if let value = dict["DBClusterStatus"] as? String {
                    self.DBClusterStatus = value
                }
                if let value = dict["DBClusterType"] as? String {
                    self.DBClusterType = value
                }
                if let value = dict["DBNodeClass"] as? String {
                    self.DBNodeClass = value
                }
                if let value = dict["DBNodeCount"] as? Int64 {
                    self.DBNodeCount = value
                }
                if let value = dict["DBNodeStorage"] as? Int64 {
                    self.DBNodeStorage = value
                }
                if let value = dict["DBVersion"] as? String {
                    self.DBVersion = value
                }
                if let value = dict["DiskType"] as? String {
                    self.diskType = value
                }
                if let value = dict["DtsJobId"] as? String {
                    self.dtsJobId = value
                }
                if let value = dict["ElasticIOResource"] as? Int32 {
                    self.elasticIOResource = value
                }
                if let value = dict["Engine"] as? String {
                    self.engine = value
                }
                if let value = dict["ExecutorCount"] as? String {
                    self.executorCount = value
                }
                if let value = dict["ExpireTime"] as? String {
                    self.expireTime = value
                }
                if let value = dict["Expired"] as? String {
                    self.expired = value
                }
                if let value = dict["InnerIp"] as? String {
                    self.innerIp = value
                }
                if let value = dict["InnerPort"] as? String {
                    self.innerPort = value
                }
                if let value = dict["LockMode"] as? String {
                    self.lockMode = value
                }
                if let value = dict["LockReason"] as? String {
                    self.lockReason = value
                }
                if let value = dict["Mode"] as? String {
                    self.mode = value
                }
                if let value = dict["PayType"] as? String {
                    self.payType = value
                }
                if let value = dict["Port"] as? String {
                    self.port = value
                }
                if let value = dict["ProductForm"] as? String {
                    self.productForm = value
                }
                if let value = dict["ProductVersion"] as? String {
                    self.productVersion = value
                }
                if let value = dict["RdsInstanceId"] as? String {
                    self.rdsInstanceId = value
                }
                if let value = dict["RegionId"] as? String {
                    self.regionId = value
                }
                if let value = dict["ReservedACU"] as? String {
                    self.reservedACU = value
                }
                if let value = dict["ReservedNodeCount"] as? Int32 {
                    self.reservedNodeCount = value
                }
                if let value = dict["ReservedNodeSize"] as? String {
                    self.reservedNodeSize = value
                }
                if let value = dict["ResourceGroupId"] as? String {
                    self.resourceGroupId = value
                }
                if let value = dict["StorageResource"] as? String {
                    self.storageResource = value
                }
                if let value = dict["Tags"] as? [String: Any?] {
                    var model = DescribeDBClustersResponseBody.Items.DBCluster.Tags()
                    model.fromMap(value)
                    self.tags = model
                }
                if let value = dict["TaskInfo"] as? [String: Any?] {
                    var model = DescribeDBClustersResponseBody.Items.DBCluster.TaskInfo()
                    model.fromMap(value)
                    self.taskInfo = model
                }
                if let value = dict["VPCCloudInstanceId"] as? String {
                    self.VPCCloudInstanceId = value
                }
                if let value = dict["VPCId"] as? String {
                    self.VPCId = value
                }
                if let value = dict["VSwitchId"] as? String {
                    self.vSwitchId = value
                }
                if let value = dict["ZoneId"] as? String {
                    self.zoneId = value
                }
            }
        }
        public var DBCluster: [DescribeDBClustersResponseBody.Items.DBCluster]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.DBCluster != nil {
                var tmp : [Any] = []
                for k in self.DBCluster! {
                    tmp.append(k.toMap())
                }
                map["DBCluster"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DBCluster"] as? [Any?] {
                var tmp : [DescribeDBClustersResponseBody.Items.DBCluster] = []
                for v in value {
                    if v != nil {
                        var model = DescribeDBClustersResponseBody.Items.DBCluster()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.DBCluster = tmp
            }
        }
    }
    public var items: DescribeDBClustersResponseBody.Items?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.items?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.items != nil {
            map["Items"] = self.items?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Items"] as? [String: Any?] {
            var model = DescribeDBClustersResponseBody.Items()
            model.fromMap(value)
            self.items = model
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? Int32 {
            self.totalCount = value
        }
    }
}

public class DescribeDBClustersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDBClustersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeDBClustersResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeDBResourceGroupRequest : Tea.TeaModel {
    public var DBClusterId: String?

    public var groupName: String?

    public var groupType: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.groupName != nil {
            map["GroupName"] = self.groupName!
        }
        if self.groupType != nil {
            map["GroupType"] = self.groupType!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["GroupName"] as? String {
            self.groupName = value
        }
        if let value = dict["GroupType"] as? String {
            self.groupType = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
    }
}

public class DescribeDBResourceGroupResponseBody : Tea.TeaModel {
    public class GroupsInfo : Tea.TeaModel {
        public class RayConfig : Tea.TeaModel {
            public class WorkerGroups : Tea.TeaModel {
                public var allocateUnit: String?

                public var groupName: String?

                public var maxWorkerQuantity: Int32?

                public var minWorkerQuantity: Int32?

                public var workerDiskCapacity: String?

                public var workerSpecName: String?

                public var workerSpecType: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.allocateUnit != nil {
                        map["AllocateUnit"] = self.allocateUnit!
                    }
                    if self.groupName != nil {
                        map["GroupName"] = self.groupName!
                    }
                    if self.maxWorkerQuantity != nil {
                        map["MaxWorkerQuantity"] = self.maxWorkerQuantity!
                    }
                    if self.minWorkerQuantity != nil {
                        map["MinWorkerQuantity"] = self.minWorkerQuantity!
                    }
                    if self.workerDiskCapacity != nil {
                        map["WorkerDiskCapacity"] = self.workerDiskCapacity!
                    }
                    if self.workerSpecName != nil {
                        map["WorkerSpecName"] = self.workerSpecName!
                    }
                    if self.workerSpecType != nil {
                        map["WorkerSpecType"] = self.workerSpecType!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["AllocateUnit"] as? String {
                        self.allocateUnit = value
                    }
                    if let value = dict["GroupName"] as? String {
                        self.groupName = value
                    }
                    if let value = dict["MaxWorkerQuantity"] as? Int32 {
                        self.maxWorkerQuantity = value
                    }
                    if let value = dict["MinWorkerQuantity"] as? Int32 {
                        self.minWorkerQuantity = value
                    }
                    if let value = dict["WorkerDiskCapacity"] as? String {
                        self.workerDiskCapacity = value
                    }
                    if let value = dict["WorkerSpecName"] as? String {
                        self.workerSpecName = value
                    }
                    if let value = dict["WorkerSpecType"] as? String {
                        self.workerSpecType = value
                    }
                }
            }
            public var category: String?

            public var headSpec: String?

            public var rayClusterAddress: String?

            public var rayDashboardAddress: String?

            public var rayGrafanaAddress: String?

            public var workerGroups: [DescribeDBResourceGroupResponseBody.GroupsInfo.RayConfig.WorkerGroups]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.category != nil {
                    map["Category"] = self.category!
                }
                if self.headSpec != nil {
                    map["HeadSpec"] = self.headSpec!
                }
                if self.rayClusterAddress != nil {
                    map["RayClusterAddress"] = self.rayClusterAddress!
                }
                if self.rayDashboardAddress != nil {
                    map["RayDashboardAddress"] = self.rayDashboardAddress!
                }
                if self.rayGrafanaAddress != nil {
                    map["RayGrafanaAddress"] = self.rayGrafanaAddress!
                }
                if self.workerGroups != nil {
                    var tmp : [Any] = []
                    for k in self.workerGroups! {
                        tmp.append(k.toMap())
                    }
                    map["WorkerGroups"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Category"] as? String {
                    self.category = value
                }
                if let value = dict["HeadSpec"] as? String {
                    self.headSpec = value
                }
                if let value = dict["RayClusterAddress"] as? String {
                    self.rayClusterAddress = value
                }
                if let value = dict["RayDashboardAddress"] as? String {
                    self.rayDashboardAddress = value
                }
                if let value = dict["RayGrafanaAddress"] as? String {
                    self.rayGrafanaAddress = value
                }
                if let value = dict["WorkerGroups"] as? [Any?] {
                    var tmp : [DescribeDBResourceGroupResponseBody.GroupsInfo.RayConfig.WorkerGroups] = []
                    for v in value {
                        if v != nil {
                            var model = DescribeDBResourceGroupResponseBody.GroupsInfo.RayConfig.WorkerGroups()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.workerGroups = tmp
                }
            }
        }
        public class Rules : Tea.TeaModel {
            public var groupName: String?

            public var queryTime: String?

            public var targetGroupName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.groupName != nil {
                    map["GroupName"] = self.groupName!
                }
                if self.queryTime != nil {
                    map["QueryTime"] = self.queryTime!
                }
                if self.targetGroupName != nil {
                    map["TargetGroupName"] = self.targetGroupName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["GroupName"] as? String {
                    self.groupName = value
                }
                if let value = dict["QueryTime"] as? String {
                    self.queryTime = value
                }
                if let value = dict["TargetGroupName"] as? String {
                    self.targetGroupName = value
                }
            }
        }
        public var autoStopInterval: String?

        public var clusterMode: String?

        public var clusterSizeResource: String?

        public var createTime: String?

        public var elasticMinComputeResource: String?

        public var enableSpot: String?

        public var engine: String?

        public var engineParams: [String: Any]?

        public var groupName: String?

        public var groupType: String?

        public var groupUsers: String?

        public var maxClusterCount: Int32?

        public var maxComputeResource: String?

        public var maxGpuQuantity: Int32?

        public var message: String?

        public var minClusterCount: Int32?

        public var minComputeResource: String?

        public var minGpuQuantity: Int32?

        public var rayConfig: DescribeDBResourceGroupResponseBody.GroupsInfo.RayConfig?

        public var rules: [DescribeDBResourceGroupResponseBody.GroupsInfo.Rules]?

        public var runningClusterCount: Int32?

        public var specName: String?

        public var status: String?

        public var targetResourceGroupName: String?

        public var updateTime: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.rayConfig?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.autoStopInterval != nil {
                map["AutoStopInterval"] = self.autoStopInterval!
            }
            if self.clusterMode != nil {
                map["ClusterMode"] = self.clusterMode!
            }
            if self.clusterSizeResource != nil {
                map["ClusterSizeResource"] = self.clusterSizeResource!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.elasticMinComputeResource != nil {
                map["ElasticMinComputeResource"] = self.elasticMinComputeResource!
            }
            if self.enableSpot != nil {
                map["EnableSpot"] = self.enableSpot!
            }
            if self.engine != nil {
                map["Engine"] = self.engine!
            }
            if self.engineParams != nil {
                map["EngineParams"] = self.engineParams!
            }
            if self.groupName != nil {
                map["GroupName"] = self.groupName!
            }
            if self.groupType != nil {
                map["GroupType"] = self.groupType!
            }
            if self.groupUsers != nil {
                map["GroupUsers"] = self.groupUsers!
            }
            if self.maxClusterCount != nil {
                map["MaxClusterCount"] = self.maxClusterCount!
            }
            if self.maxComputeResource != nil {
                map["MaxComputeResource"] = self.maxComputeResource!
            }
            if self.maxGpuQuantity != nil {
                map["MaxGpuQuantity"] = self.maxGpuQuantity!
            }
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.minClusterCount != nil {
                map["MinClusterCount"] = self.minClusterCount!
            }
            if self.minComputeResource != nil {
                map["MinComputeResource"] = self.minComputeResource!
            }
            if self.minGpuQuantity != nil {
                map["MinGpuQuantity"] = self.minGpuQuantity!
            }
            if self.rayConfig != nil {
                map["RayConfig"] = self.rayConfig?.toMap()
            }
            if self.rules != nil {
                var tmp : [Any] = []
                for k in self.rules! {
                    tmp.append(k.toMap())
                }
                map["Rules"] = tmp
            }
            if self.runningClusterCount != nil {
                map["RunningClusterCount"] = self.runningClusterCount!
            }
            if self.specName != nil {
                map["SpecName"] = self.specName!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.targetResourceGroupName != nil {
                map["TargetResourceGroupName"] = self.targetResourceGroupName!
            }
            if self.updateTime != nil {
                map["UpdateTime"] = self.updateTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AutoStopInterval"] as? String {
                self.autoStopInterval = value
            }
            if let value = dict["ClusterMode"] as? String {
                self.clusterMode = value
            }
            if let value = dict["ClusterSizeResource"] as? String {
                self.clusterSizeResource = value
            }
            if let value = dict["CreateTime"] as? String {
                self.createTime = value
            }
            if let value = dict["ElasticMinComputeResource"] as? String {
                self.elasticMinComputeResource = value
            }
            if let value = dict["EnableSpot"] as? String {
                self.enableSpot = value
            }
            if let value = dict["Engine"] as? String {
                self.engine = value
            }
            if let value = dict["EngineParams"] as? [String: Any] {
                self.engineParams = value
            }
            if let value = dict["GroupName"] as? String {
                self.groupName = value
            }
            if let value = dict["GroupType"] as? String {
                self.groupType = value
            }
            if let value = dict["GroupUsers"] as? String {
                self.groupUsers = value
            }
            if let value = dict["MaxClusterCount"] as? Int32 {
                self.maxClusterCount = value
            }
            if let value = dict["MaxComputeResource"] as? String {
                self.maxComputeResource = value
            }
            if let value = dict["MaxGpuQuantity"] as? Int32 {
                self.maxGpuQuantity = value
            }
            if let value = dict["Message"] as? String {
                self.message = value
            }
            if let value = dict["MinClusterCount"] as? Int32 {
                self.minClusterCount = value
            }
            if let value = dict["MinComputeResource"] as? String {
                self.minComputeResource = value
            }
            if let value = dict["MinGpuQuantity"] as? Int32 {
                self.minGpuQuantity = value
            }
            if let value = dict["RayConfig"] as? [String: Any?] {
                var model = DescribeDBResourceGroupResponseBody.GroupsInfo.RayConfig()
                model.fromMap(value)
                self.rayConfig = model
            }
            if let value = dict["Rules"] as? [Any?] {
                var tmp : [DescribeDBResourceGroupResponseBody.GroupsInfo.Rules] = []
                for v in value {
                    if v != nil {
                        var model = DescribeDBResourceGroupResponseBody.GroupsInfo.Rules()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.rules = tmp
            }
            if let value = dict["RunningClusterCount"] as? Int32 {
                self.runningClusterCount = value
            }
            if let value = dict["SpecName"] as? String {
                self.specName = value
            }
            if let value = dict["Status"] as? String {
                self.status = value
            }
            if let value = dict["TargetResourceGroupName"] as? String {
                self.targetResourceGroupName = value
            }
            if let value = dict["UpdateTime"] as? String {
                self.updateTime = value
            }
        }
    }
    public var groupsInfo: [DescribeDBResourceGroupResponseBody.GroupsInfo]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupsInfo != nil {
            var tmp : [Any] = []
            for k in self.groupsInfo! {
                tmp.append(k.toMap())
            }
            map["GroupsInfo"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["GroupsInfo"] as? [Any?] {
            var tmp : [DescribeDBResourceGroupResponseBody.GroupsInfo] = []
            for v in value {
                if v != nil {
                    var model = DescribeDBResourceGroupResponseBody.GroupsInfo()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.groupsInfo = tmp
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeDBResourceGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDBResourceGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeDBResourceGroupResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeDiagnosisDimensionsRequest : Tea.TeaModel {
    public var DBClusterId: String?

    public var endTime: String?

    public var lang: String?

    public var queryCondition: String?

    public var regionId: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.queryCondition != nil {
            map["QueryCondition"] = self.queryCondition!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["Lang"] as? String {
            self.lang = value
        }
        if let value = dict["QueryCondition"] as? String {
            self.queryCondition = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
    }
}

public class DescribeDiagnosisDimensionsResponseBody : Tea.TeaModel {
    public var clientIps: [String]?

    public var databases: [String]?

    public var requestId: String?

    public var resourceGroups: [String]?

    public var userNames: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientIps != nil {
            map["ClientIps"] = self.clientIps!
        }
        if self.databases != nil {
            map["Databases"] = self.databases!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resourceGroups != nil {
            map["ResourceGroups"] = self.resourceGroups!
        }
        if self.userNames != nil {
            map["UserNames"] = self.userNames!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientIps"] as? [String] {
            self.clientIps = value
        }
        if let value = dict["Databases"] as? [String] {
            self.databases = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["ResourceGroups"] as? [String] {
            self.resourceGroups = value
        }
        if let value = dict["UserNames"] as? [String] {
            self.userNames = value
        }
    }
}

public class DescribeDiagnosisDimensionsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDiagnosisDimensionsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeDiagnosisDimensionsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeDiagnosisRecordsRequest : Tea.TeaModel {
    public var clientIp: String?

    public var DBClusterId: String?

    public var database: String?

    public var endTime: String?

    public var keyword: String?

    public var lang: String?

    public var maxPeakMemory: Int64?

    public var maxScanSize: Int64?

    public var minPeakMemory: Int64?

    public var minScanSize: Int64?

    public var order: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var patternId: String?

    public var queryCondition: String?

    public var regionId: String?

    public var resourceGroup: String?

    public var startTime: String?

    public var userName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientIp != nil {
            map["ClientIp"] = self.clientIp!
        }
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.database != nil {
            map["Database"] = self.database!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.keyword != nil {
            map["Keyword"] = self.keyword!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.maxPeakMemory != nil {
            map["MaxPeakMemory"] = self.maxPeakMemory!
        }
        if self.maxScanSize != nil {
            map["MaxScanSize"] = self.maxScanSize!
        }
        if self.minPeakMemory != nil {
            map["MinPeakMemory"] = self.minPeakMemory!
        }
        if self.minScanSize != nil {
            map["MinScanSize"] = self.minScanSize!
        }
        if self.order != nil {
            map["Order"] = self.order!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.patternId != nil {
            map["PatternId"] = self.patternId!
        }
        if self.queryCondition != nil {
            map["QueryCondition"] = self.queryCondition!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroup != nil {
            map["ResourceGroup"] = self.resourceGroup!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.userName != nil {
            map["UserName"] = self.userName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientIp"] as? String {
            self.clientIp = value
        }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["Database"] as? String {
            self.database = value
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["Keyword"] as? String {
            self.keyword = value
        }
        if let value = dict["Lang"] as? String {
            self.lang = value
        }
        if let value = dict["MaxPeakMemory"] as? Int64 {
            self.maxPeakMemory = value
        }
        if let value = dict["MaxScanSize"] as? Int64 {
            self.maxScanSize = value
        }
        if let value = dict["MinPeakMemory"] as? Int64 {
            self.minPeakMemory = value
        }
        if let value = dict["MinScanSize"] as? Int64 {
            self.minScanSize = value
        }
        if let value = dict["Order"] as? String {
            self.order = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["PatternId"] as? String {
            self.patternId = value
        }
        if let value = dict["QueryCondition"] as? String {
            self.queryCondition = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroup"] as? String {
            self.resourceGroup = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
        if let value = dict["UserName"] as? String {
            self.userName = value
        }
    }
}

public class DescribeDiagnosisRecordsResponseBody : Tea.TeaModel {
    public class Querys : Tea.TeaModel {
        public class QueryProperties : Tea.TeaModel {
            public var name: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Name"] as? String {
                    self.name = value
                }
                if let value = dict["Value"] as? String {
                    self.value = value
                }
            }
        }
        public var clientIp: String?

        public var cost: Int64?

        public var database: String?

        public var etlWriteRows: Int64?

        public var executionTime: Int64?

        public var outputDataSize: Int64?

        public var outputRows: Int64?

        public var patternId: String?

        public var peakMemory: Int64?

        public var processId: String?

        public var queryProperties: [DescribeDiagnosisRecordsResponseBody.Querys.QueryProperties]?

        public var queueTime: Int64?

        public var rcHost: String?

        public var resourceCostRank: Int32?

        public var resourceGroup: String?

        public var SQL: String?

        public var SQLTruncated: Bool?

        public var SQLTruncatedThreshold: Int64?

        public var scanRows: Int64?

        public var scanSize: Int64?

        public var startTime: Int64?

        public var status: String?

        public var totalPlanningTime: Int64?

        public var totalStages: Int32?

        public var userName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.clientIp != nil {
                map["ClientIp"] = self.clientIp!
            }
            if self.cost != nil {
                map["Cost"] = self.cost!
            }
            if self.database != nil {
                map["Database"] = self.database!
            }
            if self.etlWriteRows != nil {
                map["EtlWriteRows"] = self.etlWriteRows!
            }
            if self.executionTime != nil {
                map["ExecutionTime"] = self.executionTime!
            }
            if self.outputDataSize != nil {
                map["OutputDataSize"] = self.outputDataSize!
            }
            if self.outputRows != nil {
                map["OutputRows"] = self.outputRows!
            }
            if self.patternId != nil {
                map["PatternId"] = self.patternId!
            }
            if self.peakMemory != nil {
                map["PeakMemory"] = self.peakMemory!
            }
            if self.processId != nil {
                map["ProcessId"] = self.processId!
            }
            if self.queryProperties != nil {
                var tmp : [Any] = []
                for k in self.queryProperties! {
                    tmp.append(k.toMap())
                }
                map["QueryProperties"] = tmp
            }
            if self.queueTime != nil {
                map["QueueTime"] = self.queueTime!
            }
            if self.rcHost != nil {
                map["RcHost"] = self.rcHost!
            }
            if self.resourceCostRank != nil {
                map["ResourceCostRank"] = self.resourceCostRank!
            }
            if self.resourceGroup != nil {
                map["ResourceGroup"] = self.resourceGroup!
            }
            if self.SQL != nil {
                map["SQL"] = self.SQL!
            }
            if self.SQLTruncated != nil {
                map["SQLTruncated"] = self.SQLTruncated!
            }
            if self.SQLTruncatedThreshold != nil {
                map["SQLTruncatedThreshold"] = self.SQLTruncatedThreshold!
            }
            if self.scanRows != nil {
                map["ScanRows"] = self.scanRows!
            }
            if self.scanSize != nil {
                map["ScanSize"] = self.scanSize!
            }
            if self.startTime != nil {
                map["StartTime"] = self.startTime!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.totalPlanningTime != nil {
                map["TotalPlanningTime"] = self.totalPlanningTime!
            }
            if self.totalStages != nil {
                map["TotalStages"] = self.totalStages!
            }
            if self.userName != nil {
                map["UserName"] = self.userName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ClientIp"] as? String {
                self.clientIp = value
            }
            if let value = dict["Cost"] as? Int64 {
                self.cost = value
            }
            if let value = dict["Database"] as? String {
                self.database = value
            }
            if let value = dict["EtlWriteRows"] as? Int64 {
                self.etlWriteRows = value
            }
            if let value = dict["ExecutionTime"] as? Int64 {
                self.executionTime = value
            }
            if let value = dict["OutputDataSize"] as? Int64 {
                self.outputDataSize = value
            }
            if let value = dict["OutputRows"] as? Int64 {
                self.outputRows = value
            }
            if let value = dict["PatternId"] as? String {
                self.patternId = value
            }
            if let value = dict["PeakMemory"] as? Int64 {
                self.peakMemory = value
            }
            if let value = dict["ProcessId"] as? String {
                self.processId = value
            }
            if let value = dict["QueryProperties"] as? [Any?] {
                var tmp : [DescribeDiagnosisRecordsResponseBody.Querys.QueryProperties] = []
                for v in value {
                    if v != nil {
                        var model = DescribeDiagnosisRecordsResponseBody.Querys.QueryProperties()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.queryProperties = tmp
            }
            if let value = dict["QueueTime"] as? Int64 {
                self.queueTime = value
            }
            if let value = dict["RcHost"] as? String {
                self.rcHost = value
            }
            if let value = dict["ResourceCostRank"] as? Int32 {
                self.resourceCostRank = value
            }
            if let value = dict["ResourceGroup"] as? String {
                self.resourceGroup = value
            }
            if let value = dict["SQL"] as? String {
                self.SQL = value
            }
            if let value = dict["SQLTruncated"] as? Bool {
                self.SQLTruncated = value
            }
            if let value = dict["SQLTruncatedThreshold"] as? Int64 {
                self.SQLTruncatedThreshold = value
            }
            if let value = dict["ScanRows"] as? Int64 {
                self.scanRows = value
            }
            if let value = dict["ScanSize"] as? Int64 {
                self.scanSize = value
            }
            if let value = dict["StartTime"] as? Int64 {
                self.startTime = value
            }
            if let value = dict["Status"] as? String {
                self.status = value
            }
            if let value = dict["TotalPlanningTime"] as? Int64 {
                self.totalPlanningTime = value
            }
            if let value = dict["TotalStages"] as? Int32 {
                self.totalStages = value
            }
            if let value = dict["UserName"] as? String {
                self.userName = value
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var querys: [DescribeDiagnosisRecordsResponseBody.Querys]?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.querys != nil {
            var tmp : [Any] = []
            for k in self.querys! {
                tmp.append(k.toMap())
            }
            map["Querys"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["Querys"] as? [Any?] {
            var tmp : [DescribeDiagnosisRecordsResponseBody.Querys] = []
            for v in value {
                if v != nil {
                    var model = DescribeDiagnosisRecordsResponseBody.Querys()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.querys = tmp
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? Int32 {
            self.totalCount = value
        }
    }
}

public class DescribeDiagnosisRecordsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDiagnosisRecordsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeDiagnosisRecordsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeDiagnosisSQLInfoRequest : Tea.TeaModel {
    public var DBClusterId: String?

    public var lang: String?

    public var processId: String?

    public var processRcHost: String?

    public var processStartTime: Int64?

    public var processState: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.processId != nil {
            map["ProcessId"] = self.processId!
        }
        if self.processRcHost != nil {
            map["ProcessRcHost"] = self.processRcHost!
        }
        if self.processStartTime != nil {
            map["ProcessStartTime"] = self.processStartTime!
        }
        if self.processState != nil {
            map["ProcessState"] = self.processState!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["Lang"] as? String {
            self.lang = value
        }
        if let value = dict["ProcessId"] as? String {
            self.processId = value
        }
        if let value = dict["ProcessRcHost"] as? String {
            self.processRcHost = value
        }
        if let value = dict["ProcessStartTime"] as? Int64 {
            self.processStartTime = value
        }
        if let value = dict["ProcessState"] as? String {
            self.processState = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class DescribeDiagnosisSQLInfoResponseBody : Tea.TeaModel {
    public class StageInfos : Tea.TeaModel {
        public var executionType: String?

        public var inputDataSize: Int64?

        public var inputRows: Int64?

        public var operatorCost: Int64?

        public var outputDataSize: Int64?

        public var outputRows: Int64?

        public var peakMemory: Int64?

        public var progress: Double?

        public var stageId: String?

        public var state: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.executionType != nil {
                map["ExecutionType"] = self.executionType!
            }
            if self.inputDataSize != nil {
                map["InputDataSize"] = self.inputDataSize!
            }
            if self.inputRows != nil {
                map["InputRows"] = self.inputRows!
            }
            if self.operatorCost != nil {
                map["OperatorCost"] = self.operatorCost!
            }
            if self.outputDataSize != nil {
                map["OutputDataSize"] = self.outputDataSize!
            }
            if self.outputRows != nil {
                map["OutputRows"] = self.outputRows!
            }
            if self.peakMemory != nil {
                map["PeakMemory"] = self.peakMemory!
            }
            if self.progress != nil {
                map["Progress"] = self.progress!
            }
            if self.stageId != nil {
                map["StageId"] = self.stageId!
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ExecutionType"] as? String {
                self.executionType = value
            }
            if let value = dict["InputDataSize"] as? Int64 {
                self.inputDataSize = value
            }
            if let value = dict["InputRows"] as? Int64 {
                self.inputRows = value
            }
            if let value = dict["OperatorCost"] as? Int64 {
                self.operatorCost = value
            }
            if let value = dict["OutputDataSize"] as? Int64 {
                self.outputDataSize = value
            }
            if let value = dict["OutputRows"] as? Int64 {
                self.outputRows = value
            }
            if let value = dict["PeakMemory"] as? Int64 {
                self.peakMemory = value
            }
            if let value = dict["Progress"] as? Double {
                self.progress = value
            }
            if let value = dict["StageId"] as? String {
                self.stageId = value
            }
            if let value = dict["State"] as? String {
                self.state = value
            }
        }
    }
    public var diagnosisSQLInfo: String?

    public var requestId: String?

    public var stageInfos: [DescribeDiagnosisSQLInfoResponseBody.StageInfos]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.diagnosisSQLInfo != nil {
            map["DiagnosisSQLInfo"] = self.diagnosisSQLInfo!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.stageInfos != nil {
            var tmp : [Any] = []
            for k in self.stageInfos! {
                tmp.append(k.toMap())
            }
            map["StageInfos"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DiagnosisSQLInfo"] as? String {
            self.diagnosisSQLInfo = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["StageInfos"] as? [Any?] {
            var tmp : [DescribeDiagnosisSQLInfoResponseBody.StageInfos] = []
            for v in value {
                if v != nil {
                    var model = DescribeDiagnosisSQLInfoResponseBody.StageInfos()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.stageInfos = tmp
        }
    }
}

public class DescribeDiagnosisSQLInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDiagnosisSQLInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeDiagnosisSQLInfoResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeDownloadRecordsRequest : Tea.TeaModel {
    public var DBClusterId: String?

    public var lang: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["Lang"] as? String {
            self.lang = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class DescribeDownloadRecordsResponseBody : Tea.TeaModel {
    public class Records : Tea.TeaModel {
        public var downloadId: Int64?

        public var exceptionMsg: String?

        public var fileName: String?

        public var status: String?

        public var url: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.downloadId != nil {
                map["DownloadId"] = self.downloadId!
            }
            if self.exceptionMsg != nil {
                map["ExceptionMsg"] = self.exceptionMsg!
            }
            if self.fileName != nil {
                map["FileName"] = self.fileName!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.url != nil {
                map["Url"] = self.url!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DownloadId"] as? Int64 {
                self.downloadId = value
            }
            if let value = dict["ExceptionMsg"] as? String {
                self.exceptionMsg = value
            }
            if let value = dict["FileName"] as? String {
                self.fileName = value
            }
            if let value = dict["Status"] as? String {
                self.status = value
            }
            if let value = dict["Url"] as? String {
                self.url = value
            }
        }
    }
    public var accessDeniedDetail: String?

    public var records: [DescribeDownloadRecordsResponseBody.Records]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessDeniedDetail != nil {
            map["AccessDeniedDetail"] = self.accessDeniedDetail!
        }
        if self.records != nil {
            var tmp : [Any] = []
            for k in self.records! {
                tmp.append(k.toMap())
            }
            map["Records"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AccessDeniedDetail"] as? String {
            self.accessDeniedDetail = value
        }
        if let value = dict["Records"] as? [Any?] {
            var tmp : [DescribeDownloadRecordsResponseBody.Records] = []
            for v in value {
                if v != nil {
                    var model = DescribeDownloadRecordsResponseBody.Records()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.records = tmp
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeDownloadRecordsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDownloadRecordsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeDownloadRecordsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeElasticPlanAttributeRequest : Tea.TeaModel {
    public var DBClusterId: String?

    public var elasticPlanName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.elasticPlanName != nil {
            map["ElasticPlanName"] = self.elasticPlanName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["ElasticPlanName"] as? String {
            self.elasticPlanName = value
        }
    }
}

public class DescribeElasticPlanAttributeResponseBody : Tea.TeaModel {
    public class ElasticPlan : Tea.TeaModel {
        public var autoScale: Bool?

        public var cronExpression: String?

        public var elasticPlanName: String?

        public var enabled: Bool?

        public var endTime: String?

        public var resourceGroupName: String?

        public var startTime: String?

        public var targetSize: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.autoScale != nil {
                map["AutoScale"] = self.autoScale!
            }
            if self.cronExpression != nil {
                map["CronExpression"] = self.cronExpression!
            }
            if self.elasticPlanName != nil {
                map["ElasticPlanName"] = self.elasticPlanName!
            }
            if self.enabled != nil {
                map["Enabled"] = self.enabled!
            }
            if self.endTime != nil {
                map["EndTime"] = self.endTime!
            }
            if self.resourceGroupName != nil {
                map["ResourceGroupName"] = self.resourceGroupName!
            }
            if self.startTime != nil {
                map["StartTime"] = self.startTime!
            }
            if self.targetSize != nil {
                map["TargetSize"] = self.targetSize!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AutoScale"] as? Bool {
                self.autoScale = value
            }
            if let value = dict["CronExpression"] as? String {
                self.cronExpression = value
            }
            if let value = dict["ElasticPlanName"] as? String {
                self.elasticPlanName = value
            }
            if let value = dict["Enabled"] as? Bool {
                self.enabled = value
            }
            if let value = dict["EndTime"] as? String {
                self.endTime = value
            }
            if let value = dict["ResourceGroupName"] as? String {
                self.resourceGroupName = value
            }
            if let value = dict["StartTime"] as? String {
                self.startTime = value
            }
            if let value = dict["TargetSize"] as? String {
                self.targetSize = value
            }
            if let value = dict["Type"] as? String {
                self.type = value
            }
        }
    }
    public var elasticPlan: DescribeElasticPlanAttributeResponseBody.ElasticPlan?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.elasticPlan?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.elasticPlan != nil {
            map["ElasticPlan"] = self.elasticPlan?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ElasticPlan"] as? [String: Any?] {
            var model = DescribeElasticPlanAttributeResponseBody.ElasticPlan()
            model.fromMap(value)
            self.elasticPlan = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeElasticPlanAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeElasticPlanAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeElasticPlanAttributeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeElasticPlanJobsRequest : Tea.TeaModel {
    public var DBClusterId: String?

    public var elasticPlanName: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var resourceGroupName: String?

    public var startTime: String?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.elasticPlanName != nil {
            map["ElasticPlanName"] = self.elasticPlanName!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.resourceGroupName != nil {
            map["ResourceGroupName"] = self.resourceGroupName!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["ElasticPlanName"] as? String {
            self.elasticPlanName = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["ResourceGroupName"] as? String {
            self.resourceGroupName = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
        if let value = dict["Status"] as? String {
            self.status = value
        }
    }
}

public class DescribeElasticPlanJobsResponseBody : Tea.TeaModel {
    public class Jobs : Tea.TeaModel {
        public var elasticAcu: String?

        public var elasticPlanName: String?

        public var endTime: String?

        public var instanceSize: Int32?

        public var reserveAcu: String?

        public var resourceGroupName: String?

        public var startTime: String?

        public var status: String?

        public var targetSize: String?

        public var totalAcu: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.elasticAcu != nil {
                map["ElasticAcu"] = self.elasticAcu!
            }
            if self.elasticPlanName != nil {
                map["ElasticPlanName"] = self.elasticPlanName!
            }
            if self.endTime != nil {
                map["EndTime"] = self.endTime!
            }
            if self.instanceSize != nil {
                map["InstanceSize"] = self.instanceSize!
            }
            if self.reserveAcu != nil {
                map["ReserveAcu"] = self.reserveAcu!
            }
            if self.resourceGroupName != nil {
                map["ResourceGroupName"] = self.resourceGroupName!
            }
            if self.startTime != nil {
                map["StartTime"] = self.startTime!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.targetSize != nil {
                map["TargetSize"] = self.targetSize!
            }
            if self.totalAcu != nil {
                map["TotalAcu"] = self.totalAcu!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ElasticAcu"] as? String {
                self.elasticAcu = value
            }
            if let value = dict["ElasticPlanName"] as? String {
                self.elasticPlanName = value
            }
            if let value = dict["EndTime"] as? String {
                self.endTime = value
            }
            if let value = dict["InstanceSize"] as? Int32 {
                self.instanceSize = value
            }
            if let value = dict["ReserveAcu"] as? String {
                self.reserveAcu = value
            }
            if let value = dict["ResourceGroupName"] as? String {
                self.resourceGroupName = value
            }
            if let value = dict["StartTime"] as? String {
                self.startTime = value
            }
            if let value = dict["Status"] as? String {
                self.status = value
            }
            if let value = dict["TargetSize"] as? String {
                self.targetSize = value
            }
            if let value = dict["TotalAcu"] as? String {
                self.totalAcu = value
            }
            if let value = dict["Type"] as? String {
                self.type = value
            }
        }
    }
    public var jobs: [DescribeElasticPlanJobsResponseBody.Jobs]?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobs != nil {
            var tmp : [Any] = []
            for k in self.jobs! {
                tmp.append(k.toMap())
            }
            map["Jobs"] = tmp
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Jobs"] as? [Any?] {
            var tmp : [DescribeElasticPlanJobsResponseBody.Jobs] = []
            for v in value {
                if v != nil {
                    var model = DescribeElasticPlanJobsResponseBody.Jobs()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.jobs = tmp
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? Int32 {
            self.totalCount = value
        }
    }
}

public class DescribeElasticPlanJobsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeElasticPlanJobsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeElasticPlanJobsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeElasticPlanSpecificationsRequest : Tea.TeaModel {
    public var DBClusterId: String?

    public var resourceGroupName: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.resourceGroupName != nil {
            map["ResourceGroupName"] = self.resourceGroupName!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["ResourceGroupName"] as? String {
            self.resourceGroupName = value
        }
        if let value = dict["Type"] as? String {
            self.type = value
        }
    }
}

public class DescribeElasticPlanSpecificationsResponseBody : Tea.TeaModel {
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var specifications: [String]?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.specifications != nil {
            map["Specifications"] = self.specifications!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Specifications"] as? [String] {
            self.specifications = value
        }
        if let value = dict["TotalCount"] as? Int32 {
            self.totalCount = value
        }
    }
}

public class DescribeElasticPlanSpecificationsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeElasticPlanSpecificationsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeElasticPlanSpecificationsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeElasticPlansRequest : Tea.TeaModel {
    public var DBClusterId: String?

    public var elasticPlanName: String?

    public var enabled: Bool?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var resourceGroupName: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.elasticPlanName != nil {
            map["ElasticPlanName"] = self.elasticPlanName!
        }
        if self.enabled != nil {
            map["Enabled"] = self.enabled!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.resourceGroupName != nil {
            map["ResourceGroupName"] = self.resourceGroupName!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["ElasticPlanName"] as? String {
            self.elasticPlanName = value
        }
        if let value = dict["Enabled"] as? Bool {
            self.enabled = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["ResourceGroupName"] as? String {
            self.resourceGroupName = value
        }
        if let value = dict["Type"] as? String {
            self.type = value
        }
    }
}

public class DescribeElasticPlansResponseBody : Tea.TeaModel {
    public class ElasticPlans : Tea.TeaModel {
        public var autoScale: Bool?

        public var elasticPlanName: String?

        public var enabled: Bool?

        public var nextScheduleTime: String?

        public var resourceGroupName: String?

        public var targetSize: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.autoScale != nil {
                map["AutoScale"] = self.autoScale!
            }
            if self.elasticPlanName != nil {
                map["ElasticPlanName"] = self.elasticPlanName!
            }
            if self.enabled != nil {
                map["Enabled"] = self.enabled!
            }
            if self.nextScheduleTime != nil {
                map["NextScheduleTime"] = self.nextScheduleTime!
            }
            if self.resourceGroupName != nil {
                map["ResourceGroupName"] = self.resourceGroupName!
            }
            if self.targetSize != nil {
                map["TargetSize"] = self.targetSize!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AutoScale"] as? Bool {
                self.autoScale = value
            }
            if let value = dict["ElasticPlanName"] as? String {
                self.elasticPlanName = value
            }
            if let value = dict["Enabled"] as? Bool {
                self.enabled = value
            }
            if let value = dict["NextScheduleTime"] as? String {
                self.nextScheduleTime = value
            }
            if let value = dict["ResourceGroupName"] as? String {
                self.resourceGroupName = value
            }
            if let value = dict["TargetSize"] as? String {
                self.targetSize = value
            }
            if let value = dict["Type"] as? String {
                self.type = value
            }
        }
    }
    public var elasticPlans: [DescribeElasticPlansResponseBody.ElasticPlans]?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.elasticPlans != nil {
            var tmp : [Any] = []
            for k in self.elasticPlans! {
                tmp.append(k.toMap())
            }
            map["ElasticPlans"] = tmp
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ElasticPlans"] as? [Any?] {
            var tmp : [DescribeElasticPlansResponseBody.ElasticPlans] = []
            for v in value {
                if v != nil {
                    var model = DescribeElasticPlansResponseBody.ElasticPlans()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.elasticPlans = tmp
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? Int32 {
            self.totalCount = value
        }
    }
}

public class DescribeElasticPlansResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeElasticPlansResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeElasticPlansResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeEnabledPrivilegesRequest : Tea.TeaModel {
    public var accountName: String?

    public var DBClusterId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accountName != nil {
            map["AccountName"] = self.accountName!
        }
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AccountName"] as? String {
            self.accountName = value
        }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class DescribeEnabledPrivilegesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Privileges : Tea.TeaModel {
            public var description_: String?

            public var key: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.key != nil {
                    map["Key"] = self.key!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Description"] as? String {
                    self.description_ = value
                }
                if let value = dict["Key"] as? String {
                    self.key = value
                }
            }
        }
        public var description_: String?

        public var privileges: [DescribeEnabledPrivilegesResponseBody.Data.Privileges]?

        public var scope: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.privileges != nil {
                var tmp : [Any] = []
                for k in self.privileges! {
                    tmp.append(k.toMap())
                }
                map["Privileges"] = tmp
            }
            if self.scope != nil {
                map["Scope"] = self.scope!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Description"] as? String {
                self.description_ = value
            }
            if let value = dict["Privileges"] as? [Any?] {
                var tmp : [DescribeEnabledPrivilegesResponseBody.Data.Privileges] = []
                for v in value {
                    if v != nil {
                        var model = DescribeEnabledPrivilegesResponseBody.Data.Privileges()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.privileges = tmp
            }
            if let value = dict["Scope"] as? String {
                self.scope = value
            }
        }
    }
    public var data: [DescribeEnabledPrivilegesResponseBody.Data]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [Any?] {
            var tmp : [DescribeEnabledPrivilegesResponseBody.Data] = []
            for v in value {
                if v != nil {
                    var model = DescribeEnabledPrivilegesResponseBody.Data()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.data = tmp
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeEnabledPrivilegesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeEnabledPrivilegesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeEnabledPrivilegesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeEssdCacheConfigRequest : Tea.TeaModel {
    public var DBClusterId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
    }
}

public class DescribeEssdCacheConfigResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var enableEssdCache: Bool?

        public var essdCacheSize: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.enableEssdCache != nil {
                map["EnableEssdCache"] = self.enableEssdCache!
            }
            if self.essdCacheSize != nil {
                map["EssdCacheSize"] = self.essdCacheSize!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["EnableEssdCache"] as? Bool {
                self.enableEssdCache = value
            }
            if let value = dict["EssdCacheSize"] as? Int32 {
                self.essdCacheSize = value
            }
        }
    }
    public var data: DescribeEssdCacheConfigResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [String: Any?] {
            var model = DescribeEssdCacheConfigResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeEssdCacheConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeEssdCacheConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeEssdCacheConfigResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeExcessivePrimaryKeysRequest : Tea.TeaModel {
    public var DBClusterId: String?

    public var endTime: String?

    public var lang: String?

    public var order: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.order != nil {
            map["Order"] = self.order!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["Lang"] as? String {
            self.lang = value
        }
        if let value = dict["Order"] as? String {
            self.order = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
    }
}

public class DescribeExcessivePrimaryKeysResponseBody : Tea.TeaModel {
    public class DetectionItems : Tea.TeaModel {
        public var message: String?

        public var name: String?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Message"] as? String {
                self.message = value
            }
            if let value = dict["Name"] as? String {
                self.name = value
            }
            if let value = dict["Status"] as? String {
                self.status = value
            }
        }
    }
    public class Tables : Tea.TeaModel {
        public var columnCount: Int32?

        public var primaryKeyColumns: String?

        public var primaryKeyCount: Int32?

        public var primaryKeyIndexSize: Int64?

        public var schemaName: String?

        public var spaceRatio: Double?

        public var tableName: String?

        public var totalSize: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.columnCount != nil {
                map["ColumnCount"] = self.columnCount!
            }
            if self.primaryKeyColumns != nil {
                map["PrimaryKeyColumns"] = self.primaryKeyColumns!
            }
            if self.primaryKeyCount != nil {
                map["PrimaryKeyCount"] = self.primaryKeyCount!
            }
            if self.primaryKeyIndexSize != nil {
                map["PrimaryKeyIndexSize"] = self.primaryKeyIndexSize!
            }
            if self.schemaName != nil {
                map["SchemaName"] = self.schemaName!
            }
            if self.spaceRatio != nil {
                map["SpaceRatio"] = self.spaceRatio!
            }
            if self.tableName != nil {
                map["TableName"] = self.tableName!
            }
            if self.totalSize != nil {
                map["TotalSize"] = self.totalSize!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ColumnCount"] as? Int32 {
                self.columnCount = value
            }
            if let value = dict["PrimaryKeyColumns"] as? String {
                self.primaryKeyColumns = value
            }
            if let value = dict["PrimaryKeyCount"] as? Int32 {
                self.primaryKeyCount = value
            }
            if let value = dict["PrimaryKeyIndexSize"] as? Int64 {
                self.primaryKeyIndexSize = value
            }
            if let value = dict["SchemaName"] as? String {
                self.schemaName = value
            }
            if let value = dict["SpaceRatio"] as? Double {
                self.spaceRatio = value
            }
            if let value = dict["TableName"] as? String {
                self.tableName = value
            }
            if let value = dict["TotalSize"] as? Int64 {
                self.totalSize = value
            }
        }
    }
    public var accessDeniedDetail: String?

    public var DBClusterId: String?

    public var detectionItems: [DescribeExcessivePrimaryKeysResponseBody.DetectionItems]?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var tables: [DescribeExcessivePrimaryKeysResponseBody.Tables]?

    public var totalCount: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessDeniedDetail != nil {
            map["AccessDeniedDetail"] = self.accessDeniedDetail!
        }
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.detectionItems != nil {
            var tmp : [Any] = []
            for k in self.detectionItems! {
                tmp.append(k.toMap())
            }
            map["DetectionItems"] = tmp
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.tables != nil {
            var tmp : [Any] = []
            for k in self.tables! {
                tmp.append(k.toMap())
            }
            map["Tables"] = tmp
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AccessDeniedDetail"] as? String {
            self.accessDeniedDetail = value
        }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["DetectionItems"] as? [Any?] {
            var tmp : [DescribeExcessivePrimaryKeysResponseBody.DetectionItems] = []
            for v in value {
                if v != nil {
                    var model = DescribeExcessivePrimaryKeysResponseBody.DetectionItems()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.detectionItems = tmp
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Tables"] as? [Any?] {
            var tmp : [DescribeExcessivePrimaryKeysResponseBody.Tables] = []
            for v in value {
                if v != nil {
                    var model = DescribeExcessivePrimaryKeysResponseBody.Tables()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tables = tmp
        }
        if let value = dict["TotalCount"] as? String {
            self.totalCount = value
        }
    }
}

public class DescribeExcessivePrimaryKeysResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeExcessivePrimaryKeysResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeExcessivePrimaryKeysResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeExecutorDetectionRequest : Tea.TeaModel {
    public var DBClusterId: String?

    public var endTime: String?

    public var lang: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["Lang"] as? String {
            self.lang = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
    }
}

public class DescribeExecutorDetectionResponseBody : Tea.TeaModel {
    public class DetectionItems : Tea.TeaModel {
        public class Results : Tea.TeaModel {
            public class OperatorAgg : Tea.TeaModel {
                public class SearchResults : Tea.TeaModel {
                    public var avgValue: Double?

                    public var maxValue: Int64?

                    public var operatorCount: Int64?

                    public var operatorName: String?

                    public var totalValue: Int64?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.avgValue != nil {
                            map["AvgValue"] = self.avgValue!
                        }
                        if self.maxValue != nil {
                            map["MaxValue"] = self.maxValue!
                        }
                        if self.operatorCount != nil {
                            map["OperatorCount"] = self.operatorCount!
                        }
                        if self.operatorName != nil {
                            map["OperatorName"] = self.operatorName!
                        }
                        if self.totalValue != nil {
                            map["TotalValue"] = self.totalValue!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["AvgValue"] as? Double {
                            self.avgValue = value
                        }
                        if let value = dict["MaxValue"] as? Int64 {
                            self.maxValue = value
                        }
                        if let value = dict["OperatorCount"] as? Int64 {
                            self.operatorCount = value
                        }
                        if let value = dict["OperatorName"] as? String {
                            self.operatorName = value
                        }
                        if let value = dict["TotalValue"] as? Int64 {
                            self.totalValue = value
                        }
                    }
                }
                public var metricName: String?

                public var searchResults: [DescribeExecutorDetectionResponseBody.DetectionItems.Results.OperatorAgg.SearchResults]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.metricName != nil {
                        map["MetricName"] = self.metricName!
                    }
                    if self.searchResults != nil {
                        var tmp : [Any] = []
                        for k in self.searchResults! {
                            tmp.append(k.toMap())
                        }
                        map["SearchResults"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["MetricName"] as? String {
                        self.metricName = value
                    }
                    if let value = dict["SearchResults"] as? [Any?] {
                        var tmp : [DescribeExecutorDetectionResponseBody.DetectionItems.Results.OperatorAgg.SearchResults] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeExecutorDetectionResponseBody.DetectionItems.Results.OperatorAgg.SearchResults()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.searchResults = tmp
                    }
                }
            }
            public class OperatorDetails : Tea.TeaModel {
                public class SearchResults : Tea.TeaModel {
                    public var inputRows: Int64?

                    public var inputSize: Int64?

                    public var operatorCost: Double?

                    public var operatorInfo: String?

                    public var operatorName: String?

                    public var outputRows: Int64?

                    public var outputSize: Int64?

                    public var peakMemory: Int64?

                    public var processId: String?

                    public var stageId: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.inputRows != nil {
                            map["InputRows"] = self.inputRows!
                        }
                        if self.inputSize != nil {
                            map["InputSize"] = self.inputSize!
                        }
                        if self.operatorCost != nil {
                            map["OperatorCost"] = self.operatorCost!
                        }
                        if self.operatorInfo != nil {
                            map["OperatorInfo"] = self.operatorInfo!
                        }
                        if self.operatorName != nil {
                            map["OperatorName"] = self.operatorName!
                        }
                        if self.outputRows != nil {
                            map["OutputRows"] = self.outputRows!
                        }
                        if self.outputSize != nil {
                            map["OutputSize"] = self.outputSize!
                        }
                        if self.peakMemory != nil {
                            map["PeakMemory"] = self.peakMemory!
                        }
                        if self.processId != nil {
                            map["ProcessId"] = self.processId!
                        }
                        if self.stageId != nil {
                            map["StageId"] = self.stageId!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["InputRows"] as? Int64 {
                            self.inputRows = value
                        }
                        if let value = dict["InputSize"] as? Int64 {
                            self.inputSize = value
                        }
                        if let value = dict["OperatorCost"] as? Double {
                            self.operatorCost = value
                        }
                        if let value = dict["OperatorInfo"] as? String {
                            self.operatorInfo = value
                        }
                        if let value = dict["OperatorName"] as? String {
                            self.operatorName = value
                        }
                        if let value = dict["OutputRows"] as? Int64 {
                            self.outputRows = value
                        }
                        if let value = dict["OutputSize"] as? Int64 {
                            self.outputSize = value
                        }
                        if let value = dict["PeakMemory"] as? Int64 {
                            self.peakMemory = value
                        }
                        if let value = dict["ProcessId"] as? String {
                            self.processId = value
                        }
                        if let value = dict["StageId"] as? String {
                            self.stageId = value
                        }
                    }
                }
                public var metricName: String?

                public var searchResults: [DescribeExecutorDetectionResponseBody.DetectionItems.Results.OperatorDetails.SearchResults]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.metricName != nil {
                        map["MetricName"] = self.metricName!
                    }
                    if self.searchResults != nil {
                        var tmp : [Any] = []
                        for k in self.searchResults! {
                            tmp.append(k.toMap())
                        }
                        map["SearchResults"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["MetricName"] as? String {
                        self.metricName = value
                    }
                    if let value = dict["SearchResults"] as? [Any?] {
                        var tmp : [DescribeExecutorDetectionResponseBody.DetectionItems.Results.OperatorDetails.SearchResults] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeExecutorDetectionResponseBody.DetectionItems.Results.OperatorDetails.SearchResults()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.searchResults = tmp
                    }
                }
            }
            public var operatorAgg: [DescribeExecutorDetectionResponseBody.DetectionItems.Results.OperatorAgg]?

            public var operatorDetails: [DescribeExecutorDetectionResponseBody.DetectionItems.Results.OperatorDetails]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.operatorAgg != nil {
                    var tmp : [Any] = []
                    for k in self.operatorAgg! {
                        tmp.append(k.toMap())
                    }
                    map["OperatorAgg"] = tmp
                }
                if self.operatorDetails != nil {
                    var tmp : [Any] = []
                    for k in self.operatorDetails! {
                        tmp.append(k.toMap())
                    }
                    map["OperatorDetails"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["OperatorAgg"] as? [Any?] {
                    var tmp : [DescribeExecutorDetectionResponseBody.DetectionItems.Results.OperatorAgg] = []
                    for v in value {
                        if v != nil {
                            var model = DescribeExecutorDetectionResponseBody.DetectionItems.Results.OperatorAgg()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.operatorAgg = tmp
                }
                if let value = dict["OperatorDetails"] as? [Any?] {
                    var tmp : [DescribeExecutorDetectionResponseBody.DetectionItems.Results.OperatorDetails] = []
                    for v in value {
                        if v != nil {
                            var model = DescribeExecutorDetectionResponseBody.DetectionItems.Results.OperatorDetails()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.operatorDetails = tmp
                }
            }
        }
        public var message: String?

        public var name: String?

        public var results: DescribeExecutorDetectionResponseBody.DetectionItems.Results?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.results?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.results != nil {
                map["Results"] = self.results?.toMap()
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Message"] as? String {
                self.message = value
            }
            if let value = dict["Name"] as? String {
                self.name = value
            }
            if let value = dict["Results"] as? [String: Any?] {
                var model = DescribeExecutorDetectionResponseBody.DetectionItems.Results()
                model.fromMap(value)
                self.results = model
            }
            if let value = dict["Status"] as? String {
                self.status = value
            }
        }
    }
    public var DBClusterId: String?

    public var detectionItems: [DescribeExecutorDetectionResponseBody.DetectionItems]?

    public var requestId: String?

    public var totalCount: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.detectionItems != nil {
            var tmp : [Any] = []
            for k in self.detectionItems! {
                tmp.append(k.toMap())
            }
            map["DetectionItems"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["DetectionItems"] as? [Any?] {
            var tmp : [DescribeExecutorDetectionResponseBody.DetectionItems] = []
            for v in value {
                if v != nil {
                    var model = DescribeExecutorDetectionResponseBody.DetectionItems()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.detectionItems = tmp
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? String {
            self.totalCount = value
        }
    }
}

public class DescribeExecutorDetectionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeExecutorDetectionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeExecutorDetectionResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeInclinedNodesRequest : Tea.TeaModel {
    public var DBClusterId: String?

    public var lang: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["Lang"] as? String {
            self.lang = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DescribeInclinedNodesResponseBody : Tea.TeaModel {
    public class Items : Tea.TeaModel {
        public var diskUsageRatio: String?

        public var node: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.diskUsageRatio != nil {
                map["DiskUsageRatio"] = self.diskUsageRatio!
            }
            if self.node != nil {
                map["Node"] = self.node!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DiskUsageRatio"] as? String {
                self.diskUsageRatio = value
            }
            if let value = dict["Node"] as? String {
                self.node = value
            }
        }
    }
    public var items: [DescribeInclinedNodesResponseBody.Items]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.items != nil {
            var tmp : [Any] = []
            for k in self.items! {
                tmp.append(k.toMap())
            }
            map["Items"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Items"] as? [Any?] {
            var tmp : [DescribeInclinedNodesResponseBody.Items] = []
            for v in value {
                if v != nil {
                    var model = DescribeInclinedNodesResponseBody.Items()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.items = tmp
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeInclinedNodesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeInclinedNodesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeInclinedNodesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeInclinedTablesRequest : Tea.TeaModel {
    public var DBClusterId: String?

    public var lang: String?

    public var order: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var tableType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.order != nil {
            map["Order"] = self.order!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.tableType != nil {
            map["TableType"] = self.tableType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["Lang"] as? String {
            self.lang = value
        }
        if let value = dict["Order"] as? String {
            self.order = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["TableType"] as? String {
            self.tableType = value
        }
    }
}

public class DescribeInclinedTablesResponseBody : Tea.TeaModel {
    public class DetectionItems : Tea.TeaModel {
        public var message: String?

        public var name: String?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Message"] as? String {
                self.message = value
            }
            if let value = dict["Name"] as? String {
                self.name = value
            }
            if let value = dict["Status"] as? String {
                self.status = value
            }
        }
    }
    public class Items : Tea.TeaModel {
        public class Table : Tea.TeaModel {
            public var isIncline: Bool?

            public var name: String?

            public var rowCount: Int64?

            public var schema: String?

            public var size: Int64?

            public var spaceRatio: Double?

            public var totalSize: Int64?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.isIncline != nil {
                    map["IsIncline"] = self.isIncline!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.rowCount != nil {
                    map["RowCount"] = self.rowCount!
                }
                if self.schema != nil {
                    map["Schema"] = self.schema!
                }
                if self.size != nil {
                    map["Size"] = self.size!
                }
                if self.spaceRatio != nil {
                    map["SpaceRatio"] = self.spaceRatio!
                }
                if self.totalSize != nil {
                    map["TotalSize"] = self.totalSize!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["IsIncline"] as? Bool {
                    self.isIncline = value
                }
                if let value = dict["Name"] as? String {
                    self.name = value
                }
                if let value = dict["RowCount"] as? Int64 {
                    self.rowCount = value
                }
                if let value = dict["Schema"] as? String {
                    self.schema = value
                }
                if let value = dict["Size"] as? Int64 {
                    self.size = value
                }
                if let value = dict["SpaceRatio"] as? Double {
                    self.spaceRatio = value
                }
                if let value = dict["TotalSize"] as? Int64 {
                    self.totalSize = value
                }
                if let value = dict["Type"] as? String {
                    self.type = value
                }
            }
        }
        public var table: [DescribeInclinedTablesResponseBody.Items.Table]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.table != nil {
                var tmp : [Any] = []
                for k in self.table! {
                    tmp.append(k.toMap())
                }
                map["Table"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Table"] as? [Any?] {
                var tmp : [DescribeInclinedTablesResponseBody.Items.Table] = []
                for v in value {
                    if v != nil {
                        var model = DescribeInclinedTablesResponseBody.Items.Table()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.table = tmp
            }
        }
    }
    public var accessDeniedDetail: String?

    public var detectionItems: [DescribeInclinedTablesResponseBody.DetectionItems]?

    public var items: DescribeInclinedTablesResponseBody.Items?

    public var pageNumber: String?

    public var pageSize: String?

    public var requestId: String?

    public var totalCount: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.items?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessDeniedDetail != nil {
            map["AccessDeniedDetail"] = self.accessDeniedDetail!
        }
        if self.detectionItems != nil {
            var tmp : [Any] = []
            for k in self.detectionItems! {
                tmp.append(k.toMap())
            }
            map["DetectionItems"] = tmp
        }
        if self.items != nil {
            map["Items"] = self.items?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AccessDeniedDetail"] as? String {
            self.accessDeniedDetail = value
        }
        if let value = dict["DetectionItems"] as? [Any?] {
            var tmp : [DescribeInclinedTablesResponseBody.DetectionItems] = []
            for v in value {
                if v != nil {
                    var model = DescribeInclinedTablesResponseBody.DetectionItems()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.detectionItems = tmp
        }
        if let value = dict["Items"] as? [String: Any?] {
            var model = DescribeInclinedTablesResponseBody.Items()
            model.fromMap(value)
            self.items = model
        }
        if let value = dict["PageNumber"] as? String {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? String {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? String {
            self.totalCount = value
        }
    }
}

public class DescribeInclinedTablesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeInclinedTablesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeInclinedTablesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeJobResourceUsageRequest : Tea.TeaModel {
    public var DBClusterId: String?

    public var endTime: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
    }
}

public class DescribeJobResourceUsageResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class JobAcuUsage : Tea.TeaModel {
            public class AcuUsageDetail : Tea.TeaModel {
                public var elasticAcuNumber: Double?

                public var reservedAcuNumber: Double?

                public var spotAcuNumber: Double?

                public var spotAcuPercentage: Double?

                public var totalAcuNumber: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.elasticAcuNumber != nil {
                        map["ElasticAcuNumber"] = self.elasticAcuNumber!
                    }
                    if self.reservedAcuNumber != nil {
                        map["ReservedAcuNumber"] = self.reservedAcuNumber!
                    }
                    if self.spotAcuNumber != nil {
                        map["SpotAcuNumber"] = self.spotAcuNumber!
                    }
                    if self.spotAcuPercentage != nil {
                        map["SpotAcuPercentage"] = self.spotAcuPercentage!
                    }
                    if self.totalAcuNumber != nil {
                        map["TotalAcuNumber"] = self.totalAcuNumber!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["ElasticAcuNumber"] as? Double {
                        self.elasticAcuNumber = value
                    }
                    if let value = dict["ReservedAcuNumber"] as? Double {
                        self.reservedAcuNumber = value
                    }
                    if let value = dict["SpotAcuNumber"] as? Double {
                        self.spotAcuNumber = value
                    }
                    if let value = dict["SpotAcuPercentage"] as? Double {
                        self.spotAcuPercentage = value
                    }
                    if let value = dict["TotalAcuNumber"] as? Double {
                        self.totalAcuNumber = value
                    }
                }
            }
            public var acuUsageDetail: DescribeJobResourceUsageResponseBody.Data.JobAcuUsage.AcuUsageDetail?

            public var jobEndTime: String?

            public var jobId: String?

            public var jobStartTime: String?

            public var resourceGroupName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.acuUsageDetail?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.acuUsageDetail != nil {
                    map["AcuUsageDetail"] = self.acuUsageDetail?.toMap()
                }
                if self.jobEndTime != nil {
                    map["JobEndTime"] = self.jobEndTime!
                }
                if self.jobId != nil {
                    map["JobId"] = self.jobId!
                }
                if self.jobStartTime != nil {
                    map["JobStartTime"] = self.jobStartTime!
                }
                if self.resourceGroupName != nil {
                    map["ResourceGroupName"] = self.resourceGroupName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AcuUsageDetail"] as? [String: Any?] {
                    var model = DescribeJobResourceUsageResponseBody.Data.JobAcuUsage.AcuUsageDetail()
                    model.fromMap(value)
                    self.acuUsageDetail = model
                }
                if let value = dict["JobEndTime"] as? String {
                    self.jobEndTime = value
                }
                if let value = dict["JobId"] as? String {
                    self.jobId = value
                }
                if let value = dict["JobStartTime"] as? String {
                    self.jobStartTime = value
                }
                if let value = dict["ResourceGroupName"] as? String {
                    self.resourceGroupName = value
                }
            }
        }
        public var DBClusterId: String?

        public var endTime: String?

        public var jobAcuUsage: [DescribeJobResourceUsageResponseBody.Data.JobAcuUsage]?

        public var startTime: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.DBClusterId != nil {
                map["DBClusterId"] = self.DBClusterId!
            }
            if self.endTime != nil {
                map["EndTime"] = self.endTime!
            }
            if self.jobAcuUsage != nil {
                var tmp : [Any] = []
                for k in self.jobAcuUsage! {
                    tmp.append(k.toMap())
                }
                map["JobAcuUsage"] = tmp
            }
            if self.startTime != nil {
                map["StartTime"] = self.startTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DBClusterId"] as? String {
                self.DBClusterId = value
            }
            if let value = dict["EndTime"] as? String {
                self.endTime = value
            }
            if let value = dict["JobAcuUsage"] as? [Any?] {
                var tmp : [DescribeJobResourceUsageResponseBody.Data.JobAcuUsage] = []
                for v in value {
                    if v != nil {
                        var model = DescribeJobResourceUsageResponseBody.Data.JobAcuUsage()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.jobAcuUsage = tmp
            }
            if let value = dict["StartTime"] as? String {
                self.startTime = value
            }
        }
    }
    public var code: Int32?

    public var data: DescribeJobResourceUsageResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? Int32 {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = DescribeJobResourceUsageResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeJobResourceUsageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeJobResourceUsageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeJobResourceUsageResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeKernelVersionRequest : Tea.TeaModel {
    public var DBClusterId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DescribeKernelVersionResponseBody : Tea.TeaModel {
    public class AvailableKernelVersions : Tea.TeaModel {
        public var expireDate: String?

        public var kernelVersion: String?

        public var releaseDate: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.expireDate != nil {
                map["ExpireDate"] = self.expireDate!
            }
            if self.kernelVersion != nil {
                map["KernelVersion"] = self.kernelVersion!
            }
            if self.releaseDate != nil {
                map["ReleaseDate"] = self.releaseDate!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ExpireDate"] as? String {
                self.expireDate = value
            }
            if let value = dict["KernelVersion"] as? String {
                self.kernelVersion = value
            }
            if let value = dict["ReleaseDate"] as? String {
                self.releaseDate = value
            }
        }
    }
    public var availableKernelVersions: [DescribeKernelVersionResponseBody.AvailableKernelVersions]?

    public var expireDate: String?

    public var kernelVersion: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.availableKernelVersions != nil {
            var tmp : [Any] = []
            for k in self.availableKernelVersions! {
                tmp.append(k.toMap())
            }
            map["AvailableKernelVersions"] = tmp
        }
        if self.expireDate != nil {
            map["ExpireDate"] = self.expireDate!
        }
        if self.kernelVersion != nil {
            map["KernelVersion"] = self.kernelVersion!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AvailableKernelVersions"] as? [Any?] {
            var tmp : [DescribeKernelVersionResponseBody.AvailableKernelVersions] = []
            for v in value {
                if v != nil {
                    var model = DescribeKernelVersionResponseBody.AvailableKernelVersions()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.availableKernelVersions = tmp
        }
        if let value = dict["ExpireDate"] as? String {
            self.expireDate = value
        }
        if let value = dict["KernelVersion"] as? String {
            self.kernelVersion = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeKernelVersionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeKernelVersionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeKernelVersionResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeLLMAnswerRequest : Tea.TeaModel {
    public var DBClusterId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var query: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.query != nil {
            map["Query"] = self.query!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["Query"] as? String {
            self.query = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DescribeLLMAnswerResponseBody : Tea.TeaModel {
    public var content: String?

    public var requestId: String?

    public var sessionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.content != nil {
            map["Content"] = self.content!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.sessionId != nil {
            map["SessionId"] = self.sessionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Content"] as? String {
            self.content = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["SessionId"] as? String {
            self.sessionId = value
        }
    }
}

public class DescribeLLMAnswerResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLLMAnswerResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeLLMAnswerResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeLLMSimilarQuestionsRequest : Tea.TeaModel {
    public var DBClusterId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var query: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.query != nil {
            map["Query"] = self.query!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["Query"] as? String {
            self.query = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DescribeLLMSimilarQuestionsResponseBody : Tea.TeaModel {
    public class Items : Tea.TeaModel {
        public var answer: String?

        public var id: String?

        public var score: Double?

        public var source: String?

        public var summary: String?

        public var title: String?

        public var url: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.answer != nil {
                map["Answer"] = self.answer!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.score != nil {
                map["Score"] = self.score!
            }
            if self.source != nil {
                map["Source"] = self.source!
            }
            if self.summary != nil {
                map["Summary"] = self.summary!
            }
            if self.title != nil {
                map["Title"] = self.title!
            }
            if self.url != nil {
                map["Url"] = self.url!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Answer"] as? String {
                self.answer = value
            }
            if let value = dict["Id"] as? String {
                self.id = value
            }
            if let value = dict["Score"] as? Double {
                self.score = value
            }
            if let value = dict["Source"] as? String {
                self.source = value
            }
            if let value = dict["Summary"] as? String {
                self.summary = value
            }
            if let value = dict["Title"] as? String {
                self.title = value
            }
            if let value = dict["Url"] as? String {
                self.url = value
            }
        }
    }
    public var items: [DescribeLLMSimilarQuestionsResponseBody.Items]?

    public var requestId: String?

    public var sessionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.items != nil {
            var tmp : [Any] = []
            for k in self.items! {
                tmp.append(k.toMap())
            }
            map["Items"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.sessionId != nil {
            map["SessionId"] = self.sessionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Items"] as? [Any?] {
            var tmp : [DescribeLLMSimilarQuestionsResponseBody.Items] = []
            for v in value {
                if v != nil {
                    var model = DescribeLLMSimilarQuestionsResponseBody.Items()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.items = tmp
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["SessionId"] as? String {
            self.sessionId = value
        }
    }
}

public class DescribeLLMSimilarQuestionsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLLMSimilarQuestionsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeLLMSimilarQuestionsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeLakeCacheSizeRequest : Tea.TeaModel {
    public var DBClusterId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
    }
}

public class DescribeLakeCacheSizeResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var capacity: Int64?

        public var DBClusterId: String?

        public var dataSize: Int64?

        public var enableLakeCache: Bool?

        public var instances: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.capacity != nil {
                map["Capacity"] = self.capacity!
            }
            if self.DBClusterId != nil {
                map["DBClusterId"] = self.DBClusterId!
            }
            if self.dataSize != nil {
                map["DataSize"] = self.dataSize!
            }
            if self.enableLakeCache != nil {
                map["EnableLakeCache"] = self.enableLakeCache!
            }
            if self.instances != nil {
                map["Instances"] = self.instances!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Capacity"] as? Int64 {
                self.capacity = value
            }
            if let value = dict["DBClusterId"] as? String {
                self.DBClusterId = value
            }
            if let value = dict["DataSize"] as? Int64 {
                self.dataSize = value
            }
            if let value = dict["EnableLakeCache"] as? Bool {
                self.enableLakeCache = value
            }
            if let value = dict["Instances"] as? [String] {
                self.instances = value
            }
        }
    }
    public var code: Int32?

    public var data: DescribeLakeCacheSizeResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? Int32 {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = DescribeLakeCacheSizeResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeLakeCacheSizeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLakeCacheSizeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeLakeCacheSizeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeOperatorPermissionRequest : Tea.TeaModel {
    public var DBClusterId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DescribeOperatorPermissionResponseBody : Tea.TeaModel {
    public var createdTime: String?

    public var DBClusterId: String?

    public var expiredTime: String?

    public var privileges: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.createdTime != nil {
            map["CreatedTime"] = self.createdTime!
        }
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.expiredTime != nil {
            map["ExpiredTime"] = self.expiredTime!
        }
        if self.privileges != nil {
            map["Privileges"] = self.privileges!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CreatedTime"] as? String {
            self.createdTime = value
        }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["ExpiredTime"] as? String {
            self.expiredTime = value
        }
        if let value = dict["Privileges"] as? String {
            self.privileges = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeOperatorPermissionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeOperatorPermissionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeOperatorPermissionResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeOversizeNonPartitionTableInfosRequest : Tea.TeaModel {
    public var DBClusterId: String?

    public var endTime: String?

    public var lang: String?

    public var order: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.order != nil {
            map["Order"] = self.order!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["Lang"] as? String {
            self.lang = value
        }
        if let value = dict["Order"] as? String {
            self.order = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
    }
}

public class DescribeOversizeNonPartitionTableInfosResponseBody : Tea.TeaModel {
    public class DetectionItems : Tea.TeaModel {
        public var message: String?

        public var name: String?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Message"] as? String {
                self.message = value
            }
            if let value = dict["Name"] as? String {
                self.name = value
            }
            if let value = dict["Status"] as? String {
                self.status = value
            }
        }
    }
    public class Tables : Tea.TeaModel {
        public var dataSize: Int64?

        public var indexSize: Int64?

        public var localDataSize: Int64?

        public var primaryKeySize: Int64?

        public var remoteDataSize: Int64?

        public var rowCount: Int64?

        public var schemaName: String?

        public var spaceRatio: Double?

        public var tableName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dataSize != nil {
                map["DataSize"] = self.dataSize!
            }
            if self.indexSize != nil {
                map["IndexSize"] = self.indexSize!
            }
            if self.localDataSize != nil {
                map["LocalDataSize"] = self.localDataSize!
            }
            if self.primaryKeySize != nil {
                map["PrimaryKeySize"] = self.primaryKeySize!
            }
            if self.remoteDataSize != nil {
                map["RemoteDataSize"] = self.remoteDataSize!
            }
            if self.rowCount != nil {
                map["RowCount"] = self.rowCount!
            }
            if self.schemaName != nil {
                map["SchemaName"] = self.schemaName!
            }
            if self.spaceRatio != nil {
                map["SpaceRatio"] = self.spaceRatio!
            }
            if self.tableName != nil {
                map["TableName"] = self.tableName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DataSize"] as? Int64 {
                self.dataSize = value
            }
            if let value = dict["IndexSize"] as? Int64 {
                self.indexSize = value
            }
            if let value = dict["LocalDataSize"] as? Int64 {
                self.localDataSize = value
            }
            if let value = dict["PrimaryKeySize"] as? Int64 {
                self.primaryKeySize = value
            }
            if let value = dict["RemoteDataSize"] as? Int64 {
                self.remoteDataSize = value
            }
            if let value = dict["RowCount"] as? Int64 {
                self.rowCount = value
            }
            if let value = dict["SchemaName"] as? String {
                self.schemaName = value
            }
            if let value = dict["SpaceRatio"] as? Double {
                self.spaceRatio = value
            }
            if let value = dict["TableName"] as? String {
                self.tableName = value
            }
        }
    }
    public var DBClusterId: String?

    public var detectionItems: [DescribeOversizeNonPartitionTableInfosResponseBody.DetectionItems]?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var tables: [DescribeOversizeNonPartitionTableInfosResponseBody.Tables]?

    public var totalCount: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.detectionItems != nil {
            var tmp : [Any] = []
            for k in self.detectionItems! {
                tmp.append(k.toMap())
            }
            map["DetectionItems"] = tmp
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.tables != nil {
            var tmp : [Any] = []
            for k in self.tables! {
                tmp.append(k.toMap())
            }
            map["Tables"] = tmp
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["DetectionItems"] as? [Any?] {
            var tmp : [DescribeOversizeNonPartitionTableInfosResponseBody.DetectionItems] = []
            for v in value {
                if v != nil {
                    var model = DescribeOversizeNonPartitionTableInfosResponseBody.DetectionItems()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.detectionItems = tmp
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Tables"] as? [Any?] {
            var tmp : [DescribeOversizeNonPartitionTableInfosResponseBody.Tables] = []
            for v in value {
                if v != nil {
                    var model = DescribeOversizeNonPartitionTableInfosResponseBody.Tables()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tables = tmp
        }
        if let value = dict["TotalCount"] as? String {
            self.totalCount = value
        }
    }
}

public class DescribeOversizeNonPartitionTableInfosResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeOversizeNonPartitionTableInfosResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeOversizeNonPartitionTableInfosResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribePatternPerformanceRequest : Tea.TeaModel {
    public var DBClusterId: String?

    public var endTime: String?

    public var patternId: String?

    public var regionId: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.patternId != nil {
            map["PatternId"] = self.patternId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["PatternId"] as? String {
            self.patternId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
    }
}

public class DescribePatternPerformanceResponseBody : Tea.TeaModel {
    public class Performances : Tea.TeaModel {
        public class Series : Tea.TeaModel {
            public var name: String?

            public var values: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.values != nil {
                    map["Values"] = self.values!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Name"] as? String {
                    self.name = value
                }
                if let value = dict["Values"] as? [String] {
                    self.values = value
                }
            }
        }
        public var key: String?

        public var series: [DescribePatternPerformanceResponseBody.Performances.Series]?

        public var unit: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.series != nil {
                var tmp : [Any] = []
                for k in self.series! {
                    tmp.append(k.toMap())
                }
                map["Series"] = tmp
            }
            if self.unit != nil {
                map["Unit"] = self.unit!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Series"] as? [Any?] {
                var tmp : [DescribePatternPerformanceResponseBody.Performances.Series] = []
                for v in value {
                    if v != nil {
                        var model = DescribePatternPerformanceResponseBody.Performances.Series()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.series = tmp
            }
            if let value = dict["Unit"] as? String {
                self.unit = value
            }
        }
    }
    public var accessIp: String?

    public var endTime: String?

    public var failedCount: Int64?

    public var performances: [DescribePatternPerformanceResponseBody.Performances]?

    public var queryCount: Int64?

    public var requestId: String?

    public var SQLPattern: String?

    public var startTime: String?

    public var tables: String?

    public var user: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessIp != nil {
            map["AccessIp"] = self.accessIp!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.failedCount != nil {
            map["FailedCount"] = self.failedCount!
        }
        if self.performances != nil {
            var tmp : [Any] = []
            for k in self.performances! {
                tmp.append(k.toMap())
            }
            map["Performances"] = tmp
        }
        if self.queryCount != nil {
            map["QueryCount"] = self.queryCount!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.SQLPattern != nil {
            map["SQLPattern"] = self.SQLPattern!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.tables != nil {
            map["Tables"] = self.tables!
        }
        if self.user != nil {
            map["User"] = self.user!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AccessIp"] as? String {
            self.accessIp = value
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["FailedCount"] as? Int64 {
            self.failedCount = value
        }
        if let value = dict["Performances"] as? [Any?] {
            var tmp : [DescribePatternPerformanceResponseBody.Performances] = []
            for v in value {
                if v != nil {
                    var model = DescribePatternPerformanceResponseBody.Performances()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.performances = tmp
        }
        if let value = dict["QueryCount"] as? Int64 {
            self.queryCount = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["SQLPattern"] as? String {
            self.SQLPattern = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
        if let value = dict["Tables"] as? String {
            self.tables = value
        }
        if let value = dict["User"] as? String {
            self.user = value
        }
    }
}

public class DescribePatternPerformanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribePatternPerformanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribePatternPerformanceResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribePerformanceViewAttributeRequest : Tea.TeaModel {
    public var DBClusterId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var viewName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.viewName != nil {
            map["ViewName"] = self.viewName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["ViewName"] as? String {
            self.viewName = value
        }
    }
}

public class DescribePerformanceViewAttributeResponseBody : Tea.TeaModel {
    public class ViewDetail : Tea.TeaModel {
        public class Categories : Tea.TeaModel {
            public class Keys : Tea.TeaModel {
                public var enableAutoMc: Bool?

                public var engine: [String]?

                public var groupType: [String]?

                public var keyName: String?

                public var selected: Bool?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.enableAutoMc != nil {
                        map["EnableAutoMc"] = self.enableAutoMc!
                    }
                    if self.engine != nil {
                        map["Engine"] = self.engine!
                    }
                    if self.groupType != nil {
                        map["GroupType"] = self.groupType!
                    }
                    if self.keyName != nil {
                        map["KeyName"] = self.keyName!
                    }
                    if self.selected != nil {
                        map["Selected"] = self.selected!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["EnableAutoMc"] as? Bool {
                        self.enableAutoMc = value
                    }
                    if let value = dict["Engine"] as? [String] {
                        self.engine = value
                    }
                    if let value = dict["GroupType"] as? [String] {
                        self.groupType = value
                    }
                    if let value = dict["KeyName"] as? String {
                        self.keyName = value
                    }
                    if let value = dict["Selected"] as? Bool {
                        self.selected = value
                    }
                }
            }
            public var category: String?

            public var keys: [DescribePerformanceViewAttributeResponseBody.ViewDetail.Categories.Keys]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.category != nil {
                    map["Category"] = self.category!
                }
                if self.keys != nil {
                    var tmp : [Any] = []
                    for k in self.keys! {
                        tmp.append(k.toMap())
                    }
                    map["Keys"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Category"] as? String {
                    self.category = value
                }
                if let value = dict["Keys"] as? [Any?] {
                    var tmp : [DescribePerformanceViewAttributeResponseBody.ViewDetail.Categories.Keys] = []
                    for v in value {
                        if v != nil {
                            var model = DescribePerformanceViewAttributeResponseBody.ViewDetail.Categories.Keys()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.keys = tmp
                }
            }
        }
        public var categories: [DescribePerformanceViewAttributeResponseBody.ViewDetail.Categories]?

        public var chartLinked: Bool?

        public var chartsPerLine: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.categories != nil {
                var tmp : [Any] = []
                for k in self.categories! {
                    tmp.append(k.toMap())
                }
                map["Categories"] = tmp
            }
            if self.chartLinked != nil {
                map["ChartLinked"] = self.chartLinked!
            }
            if self.chartsPerLine != nil {
                map["ChartsPerLine"] = self.chartsPerLine!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Categories"] as? [Any?] {
                var tmp : [DescribePerformanceViewAttributeResponseBody.ViewDetail.Categories] = []
                for v in value {
                    if v != nil {
                        var model = DescribePerformanceViewAttributeResponseBody.ViewDetail.Categories()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.categories = tmp
            }
            if let value = dict["ChartLinked"] as? Bool {
                self.chartLinked = value
            }
            if let value = dict["ChartsPerLine"] as? Int32 {
                self.chartsPerLine = value
            }
        }
    }
    public var accessDeniedDetail: String?

    public var createFromViewType: String?

    public var DBClusterId: String?

    public var fillOriginViewKeys: Bool?

    public var requestId: String?

    public var viewDetail: DescribePerformanceViewAttributeResponseBody.ViewDetail?

    public var viewName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.viewDetail?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessDeniedDetail != nil {
            map["AccessDeniedDetail"] = self.accessDeniedDetail!
        }
        if self.createFromViewType != nil {
            map["CreateFromViewType"] = self.createFromViewType!
        }
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.fillOriginViewKeys != nil {
            map["FillOriginViewKeys"] = self.fillOriginViewKeys!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.viewDetail != nil {
            map["ViewDetail"] = self.viewDetail?.toMap()
        }
        if self.viewName != nil {
            map["ViewName"] = self.viewName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AccessDeniedDetail"] as? String {
            self.accessDeniedDetail = value
        }
        if let value = dict["CreateFromViewType"] as? String {
            self.createFromViewType = value
        }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["FillOriginViewKeys"] as? Bool {
            self.fillOriginViewKeys = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["ViewDetail"] as? [String: Any?] {
            var model = DescribePerformanceViewAttributeResponseBody.ViewDetail()
            model.fromMap(value)
            self.viewDetail = model
        }
        if let value = dict["ViewName"] as? String {
            self.viewName = value
        }
    }
}

public class DescribePerformanceViewAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribePerformanceViewAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribePerformanceViewAttributeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribePerformanceViewsRequest : Tea.TeaModel {
    public var DBClusterId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DescribePerformanceViewsResponseBody : Tea.TeaModel {
    public class Views : Tea.TeaModel {
        public var createTime: String?

        public var updateTime: String?

        public var viewName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.updateTime != nil {
                map["UpdateTime"] = self.updateTime!
            }
            if self.viewName != nil {
                map["ViewName"] = self.viewName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["CreateTime"] as? String {
                self.createTime = value
            }
            if let value = dict["UpdateTime"] as? String {
                self.updateTime = value
            }
            if let value = dict["ViewName"] as? String {
                self.viewName = value
            }
        }
    }
    public var accessDeniedDetail: String?

    public var requestId: String?

    public var views: [DescribePerformanceViewsResponseBody.Views]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessDeniedDetail != nil {
            map["AccessDeniedDetail"] = self.accessDeniedDetail!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.views != nil {
            var tmp : [Any] = []
            for k in self.views! {
                tmp.append(k.toMap())
            }
            map["Views"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AccessDeniedDetail"] as? String {
            self.accessDeniedDetail = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Views"] as? [Any?] {
            var tmp : [DescribePerformanceViewsResponseBody.Views] = []
            for v in value {
                if v != nil {
                    var model = DescribePerformanceViewsResponseBody.Views()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.views = tmp
        }
    }
}

public class DescribePerformanceViewsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribePerformanceViewsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribePerformanceViewsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeRegionsRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AcceptLanguage"] as? String {
            self.acceptLanguage = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class DescribeRegionsResponseBody : Tea.TeaModel {
    public class Regions : Tea.TeaModel {
        public class Region : Tea.TeaModel {
            public class Zones : Tea.TeaModel {
                public class Zone : Tea.TeaModel {
                    public var localName: String?

                    public var vpcEnabled: Bool?

                    public var zoneId: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.localName != nil {
                            map["LocalName"] = self.localName!
                        }
                        if self.vpcEnabled != nil {
                            map["VpcEnabled"] = self.vpcEnabled!
                        }
                        if self.zoneId != nil {
                            map["ZoneId"] = self.zoneId!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["LocalName"] as? String {
                            self.localName = value
                        }
                        if let value = dict["VpcEnabled"] as? Bool {
                            self.vpcEnabled = value
                        }
                        if let value = dict["ZoneId"] as? String {
                            self.zoneId = value
                        }
                    }
                }
                public var zone: [DescribeRegionsResponseBody.Regions.Region.Zones.Zone]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.zone != nil {
                        var tmp : [Any] = []
                        for k in self.zone! {
                            tmp.append(k.toMap())
                        }
                        map["Zone"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Zone"] as? [Any?] {
                        var tmp : [DescribeRegionsResponseBody.Regions.Region.Zones.Zone] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeRegionsResponseBody.Regions.Region.Zones.Zone()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.zone = tmp
                    }
                }
            }
            public var localName: String?

            public var regionEndpoint: String?

            public var regionId: String?

            public var zones: DescribeRegionsResponseBody.Regions.Region.Zones?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.zones?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.localName != nil {
                    map["LocalName"] = self.localName!
                }
                if self.regionEndpoint != nil {
                    map["RegionEndpoint"] = self.regionEndpoint!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.zones != nil {
                    map["Zones"] = self.zones?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["LocalName"] as? String {
                    self.localName = value
                }
                if let value = dict["RegionEndpoint"] as? String {
                    self.regionEndpoint = value
                }
                if let value = dict["RegionId"] as? String {
                    self.regionId = value
                }
                if let value = dict["Zones"] as? [String: Any?] {
                    var model = DescribeRegionsResponseBody.Regions.Region.Zones()
                    model.fromMap(value)
                    self.zones = model
                }
            }
        }
        public var region: [DescribeRegionsResponseBody.Regions.Region]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.region != nil {
                var tmp : [Any] = []
                for k in self.region! {
                    tmp.append(k.toMap())
                }
                map["Region"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Region"] as? [Any?] {
                var tmp : [DescribeRegionsResponseBody.Regions.Region] = []
                for v in value {
                    if v != nil {
                        var model = DescribeRegionsResponseBody.Regions.Region()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.region = tmp
            }
        }
    }
    public var regions: DescribeRegionsResponseBody.Regions?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.regions?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.regions != nil {
            map["Regions"] = self.regions?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Regions"] as? [String: Any?] {
            var model = DescribeRegionsResponseBody.Regions()
            model.fromMap(value)
            self.regions = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeRegionsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeRegionsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeRegionsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeResourceGroupSpecRequest : Tea.TeaModel {
    public var DBClusterId: String?

    public var regionId: String?

    public var resourceGroupType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupType != nil {
            map["ResourceGroupType"] = self.resourceGroupType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroupType"] as? String {
            self.resourceGroupType = value
        }
    }
}

public class DescribeResourceGroupSpecResponseBody : Tea.TeaModel {
    public class Specs : Tea.TeaModel {
        public var allocateUnits: [String]?

        public var maxQuantity: Int32?

        public var name: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.allocateUnits != nil {
                map["AllocateUnits"] = self.allocateUnits!
            }
            if self.maxQuantity != nil {
                map["MaxQuantity"] = self.maxQuantity!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AllocateUnits"] as? [String] {
                self.allocateUnits = value
            }
            if let value = dict["MaxQuantity"] as? Int32 {
                self.maxQuantity = value
            }
            if let value = dict["Name"] as? String {
                self.name = value
            }
            if let value = dict["Type"] as? String {
                self.type = value
            }
        }
    }
    public var requestId: String?

    public var specs: [DescribeResourceGroupSpecResponseBody.Specs]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.specs != nil {
            var tmp : [Any] = []
            for k in self.specs! {
                tmp.append(k.toMap())
            }
            map["Specs"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Specs"] as? [Any?] {
            var tmp : [DescribeResourceGroupSpecResponseBody.Specs] = []
            for v in value {
                if v != nil {
                    var model = DescribeResourceGroupSpecResponseBody.Specs()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.specs = tmp
        }
    }
}

public class DescribeResourceGroupSpecResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeResourceGroupSpecResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeResourceGroupSpecResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeSQLPatternsRequest : Tea.TeaModel {
    public var DBClusterId: String?

    public var endTime: String?

    public var keyword: String?

    public var lang: String?

    public var order: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var startTime: String?

    public var userName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.keyword != nil {
            map["Keyword"] = self.keyword!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.order != nil {
            map["Order"] = self.order!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.userName != nil {
            map["UserName"] = self.userName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["Keyword"] as? String {
            self.keyword = value
        }
        if let value = dict["Lang"] as? String {
            self.lang = value
        }
        if let value = dict["Order"] as? String {
            self.order = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
        if let value = dict["UserName"] as? String {
            self.userName = value
        }
    }
}

public class DescribeSQLPatternsResponseBody : Tea.TeaModel {
    public class PatternDetails : Tea.TeaModel {
        public var accessIp: String?

        public var averageExecutionTime: Double?

        public var averageOperatorCost: Double?

        public var averagePeakMemory: Double?

        public var averageQueryTime: Double?

        public var averageScanCost: Double?

        public var averageScanSize: Double?

        public var blockable: Bool?

        public var failedCount: Int64?

        public var maxExecutionTime: Int64?

        public var maxOperatorCost: Double?

        public var maxPeakMemory: Int64?

        public var maxQueryTime: Int64?

        public var maxScanCost: Double?

        public var maxScanSize: Int64?

        public var operatorCostPercentage: Double?

        public var operatorCostSum: Double?

        public var patternCreationTime: String?

        public var patternId: String?

        public var peakMemoryPercentage: Double?

        public var peakMemorySum: Double?

        public var queryCount: Int64?

        public var queryTimePercentage: Double?

        public var queryTimeSum: Double?

        public var SQLPattern: String?

        public var scanCostPercentage: Double?

        public var scanCostSum: Double?

        public var scanSizePercentage: Double?

        public var scanSizeSum: Double?

        public var tables: String?

        public var user: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accessIp != nil {
                map["AccessIp"] = self.accessIp!
            }
            if self.averageExecutionTime != nil {
                map["AverageExecutionTime"] = self.averageExecutionTime!
            }
            if self.averageOperatorCost != nil {
                map["AverageOperatorCost"] = self.averageOperatorCost!
            }
            if self.averagePeakMemory != nil {
                map["AveragePeakMemory"] = self.averagePeakMemory!
            }
            if self.averageQueryTime != nil {
                map["AverageQueryTime"] = self.averageQueryTime!
            }
            if self.averageScanCost != nil {
                map["AverageScanCost"] = self.averageScanCost!
            }
            if self.averageScanSize != nil {
                map["AverageScanSize"] = self.averageScanSize!
            }
            if self.blockable != nil {
                map["Blockable"] = self.blockable!
            }
            if self.failedCount != nil {
                map["FailedCount"] = self.failedCount!
            }
            if self.maxExecutionTime != nil {
                map["MaxExecutionTime"] = self.maxExecutionTime!
            }
            if self.maxOperatorCost != nil {
                map["MaxOperatorCost"] = self.maxOperatorCost!
            }
            if self.maxPeakMemory != nil {
                map["MaxPeakMemory"] = self.maxPeakMemory!
            }
            if self.maxQueryTime != nil {
                map["MaxQueryTime"] = self.maxQueryTime!
            }
            if self.maxScanCost != nil {
                map["MaxScanCost"] = self.maxScanCost!
            }
            if self.maxScanSize != nil {
                map["MaxScanSize"] = self.maxScanSize!
            }
            if self.operatorCostPercentage != nil {
                map["OperatorCostPercentage"] = self.operatorCostPercentage!
            }
            if self.operatorCostSum != nil {
                map["OperatorCostSum"] = self.operatorCostSum!
            }
            if self.patternCreationTime != nil {
                map["PatternCreationTime"] = self.patternCreationTime!
            }
            if self.patternId != nil {
                map["PatternId"] = self.patternId!
            }
            if self.peakMemoryPercentage != nil {
                map["PeakMemoryPercentage"] = self.peakMemoryPercentage!
            }
            if self.peakMemorySum != nil {
                map["PeakMemorySum"] = self.peakMemorySum!
            }
            if self.queryCount != nil {
                map["QueryCount"] = self.queryCount!
            }
            if self.queryTimePercentage != nil {
                map["QueryTimePercentage"] = self.queryTimePercentage!
            }
            if self.queryTimeSum != nil {
                map["QueryTimeSum"] = self.queryTimeSum!
            }
            if self.SQLPattern != nil {
                map["SQLPattern"] = self.SQLPattern!
            }
            if self.scanCostPercentage != nil {
                map["ScanCostPercentage"] = self.scanCostPercentage!
            }
            if self.scanCostSum != nil {
                map["ScanCostSum"] = self.scanCostSum!
            }
            if self.scanSizePercentage != nil {
                map["ScanSizePercentage"] = self.scanSizePercentage!
            }
            if self.scanSizeSum != nil {
                map["ScanSizeSum"] = self.scanSizeSum!
            }
            if self.tables != nil {
                map["Tables"] = self.tables!
            }
            if self.user != nil {
                map["User"] = self.user!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AccessIp"] as? String {
                self.accessIp = value
            }
            if let value = dict["AverageExecutionTime"] as? Double {
                self.averageExecutionTime = value
            }
            if let value = dict["AverageOperatorCost"] as? Double {
                self.averageOperatorCost = value
            }
            if let value = dict["AveragePeakMemory"] as? Double {
                self.averagePeakMemory = value
            }
            if let value = dict["AverageQueryTime"] as? Double {
                self.averageQueryTime = value
            }
            if let value = dict["AverageScanCost"] as? Double {
                self.averageScanCost = value
            }
            if let value = dict["AverageScanSize"] as? Double {
                self.averageScanSize = value
            }
            if let value = dict["Blockable"] as? Bool {
                self.blockable = value
            }
            if let value = dict["FailedCount"] as? Int64 {
                self.failedCount = value
            }
            if let value = dict["MaxExecutionTime"] as? Int64 {
                self.maxExecutionTime = value
            }
            if let value = dict["MaxOperatorCost"] as? Double {
                self.maxOperatorCost = value
            }
            if let value = dict["MaxPeakMemory"] as? Int64 {
                self.maxPeakMemory = value
            }
            if let value = dict["MaxQueryTime"] as? Int64 {
                self.maxQueryTime = value
            }
            if let value = dict["MaxScanCost"] as? Double {
                self.maxScanCost = value
            }
            if let value = dict["MaxScanSize"] as? Int64 {
                self.maxScanSize = value
            }
            if let value = dict["OperatorCostPercentage"] as? Double {
                self.operatorCostPercentage = value
            }
            if let value = dict["OperatorCostSum"] as? Double {
                self.operatorCostSum = value
            }
            if let value = dict["PatternCreationTime"] as? String {
                self.patternCreationTime = value
            }
            if let value = dict["PatternId"] as? String {
                self.patternId = value
            }
            if let value = dict["PeakMemoryPercentage"] as? Double {
                self.peakMemoryPercentage = value
            }
            if let value = dict["PeakMemorySum"] as? Double {
                self.peakMemorySum = value
            }
            if let value = dict["QueryCount"] as? Int64 {
                self.queryCount = value
            }
            if let value = dict["QueryTimePercentage"] as? Double {
                self.queryTimePercentage = value
            }
            if let value = dict["QueryTimeSum"] as? Double {
                self.queryTimeSum = value
            }
            if let value = dict["SQLPattern"] as? String {
                self.SQLPattern = value
            }
            if let value = dict["ScanCostPercentage"] as? Double {
                self.scanCostPercentage = value
            }
            if let value = dict["ScanCostSum"] as? Double {
                self.scanCostSum = value
            }
            if let value = dict["ScanSizePercentage"] as? Double {
                self.scanSizePercentage = value
            }
            if let value = dict["ScanSizeSum"] as? Double {
                self.scanSizeSum = value
            }
            if let value = dict["Tables"] as? String {
                self.tables = value
            }
            if let value = dict["User"] as? String {
                self.user = value
            }
        }
    }
    public var accessDeniedDetail: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var patternDetails: [DescribeSQLPatternsResponseBody.PatternDetails]?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessDeniedDetail != nil {
            map["AccessDeniedDetail"] = self.accessDeniedDetail!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.patternDetails != nil {
            var tmp : [Any] = []
            for k in self.patternDetails! {
                tmp.append(k.toMap())
            }
            map["PatternDetails"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AccessDeniedDetail"] as? String {
            self.accessDeniedDetail = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["PatternDetails"] as? [Any?] {
            var tmp : [DescribeSQLPatternsResponseBody.PatternDetails] = []
            for v in value {
                if v != nil {
                    var model = DescribeSQLPatternsResponseBody.PatternDetails()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.patternDetails = tmp
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? Int32 {
            self.totalCount = value
        }
    }
}

public class DescribeSQLPatternsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSQLPatternsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeSQLPatternsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeSQLWebSocketDomainRequest : Tea.TeaModel {
    public var DBClusterId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class DescribeSQLWebSocketDomainResponseBody : Tea.TeaModel {
    public var code: Int64?

    public var domain: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.domain != nil {
            map["Domain"] = self.domain!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? Int64 {
            self.code = value
        }
        if let value = dict["Domain"] as? String {
            self.domain = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class DescribeSQLWebSocketDomainResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSQLWebSocketDomainResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeSQLWebSocketDomainResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeSchemasRequest : Tea.TeaModel {
    public var DBClusterId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class DescribeSchemasResponseBody : Tea.TeaModel {
    public class Items : Tea.TeaModel {
        public class Schema : Tea.TeaModel {
            public var DBClusterId: String?

            public var schemaName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.DBClusterId != nil {
                    map["DBClusterId"] = self.DBClusterId!
                }
                if self.schemaName != nil {
                    map["SchemaName"] = self.schemaName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["DBClusterId"] as? String {
                    self.DBClusterId = value
                }
                if let value = dict["SchemaName"] as? String {
                    self.schemaName = value
                }
            }
        }
        public var schema: [DescribeSchemasResponseBody.Items.Schema]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.schema != nil {
                var tmp : [Any] = []
                for k in self.schema! {
                    tmp.append(k.toMap())
                }
                map["Schema"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Schema"] as? [Any?] {
                var tmp : [DescribeSchemasResponseBody.Items.Schema] = []
                for v in value {
                    if v != nil {
                        var model = DescribeSchemasResponseBody.Items.Schema()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.schema = tmp
            }
        }
    }
    public var items: DescribeSchemasResponseBody.Items?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.items?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.items != nil {
            map["Items"] = self.items?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Items"] as? [String: Any?] {
            var model = DescribeSchemasResponseBody.Items()
            model.fromMap(value)
            self.items = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeSchemasResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSchemasResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeSchemasResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeSparkAppDiagnosisInfoRequest : Tea.TeaModel {
    public var appId: String?

    public var DBClusterId: String?

    public var language: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.language != nil {
            map["Language"] = self.language!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["Language"] as? String {
            self.language = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class DescribeSparkAppDiagnosisInfoResponseBody : Tea.TeaModel {
    public var accessDeniedDetail: String?

    public var appId: String?

    public var cpuUtilization: Double?

    public var diagnosisInfoList: [Adb4MysqlSparkDiagnosisInfo]?

    public var durationInMillis: Int64?

    public var JVMGcCostInMillis: Int64?

    public var peakMemoryInByte: Int64?

    public var requestId: String?

    public var shuffleReadInByte: Int64?

    public var shuffleWriteInByte: Int64?

    public var spillInByte: Int64?

    public var startedTime: Int64?

    public var state: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessDeniedDetail != nil {
            map["AccessDeniedDetail"] = self.accessDeniedDetail!
        }
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.cpuUtilization != nil {
            map["CpuUtilization"] = self.cpuUtilization!
        }
        if self.diagnosisInfoList != nil {
            var tmp : [Any] = []
            for k in self.diagnosisInfoList! {
                tmp.append(k.toMap())
            }
            map["DiagnosisInfoList"] = tmp
        }
        if self.durationInMillis != nil {
            map["DurationInMillis"] = self.durationInMillis!
        }
        if self.JVMGcCostInMillis != nil {
            map["JVMGcCostInMillis"] = self.JVMGcCostInMillis!
        }
        if self.peakMemoryInByte != nil {
            map["PeakMemoryInByte"] = self.peakMemoryInByte!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.shuffleReadInByte != nil {
            map["ShuffleReadInByte"] = self.shuffleReadInByte!
        }
        if self.shuffleWriteInByte != nil {
            map["ShuffleWriteInByte"] = self.shuffleWriteInByte!
        }
        if self.spillInByte != nil {
            map["SpillInByte"] = self.spillInByte!
        }
        if self.startedTime != nil {
            map["StartedTime"] = self.startedTime!
        }
        if self.state != nil {
            map["State"] = self.state!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AccessDeniedDetail"] as? String {
            self.accessDeniedDetail = value
        }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["CpuUtilization"] as? Double {
            self.cpuUtilization = value
        }
        if let value = dict["DiagnosisInfoList"] as? [Any?] {
            var tmp : [Adb4MysqlSparkDiagnosisInfo] = []
            for v in value {
                if v != nil {
                    var model = Adb4MysqlSparkDiagnosisInfo()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.diagnosisInfoList = tmp
        }
        if let value = dict["DurationInMillis"] as? Int64 {
            self.durationInMillis = value
        }
        if let value = dict["JVMGcCostInMillis"] as? Int64 {
            self.JVMGcCostInMillis = value
        }
        if let value = dict["PeakMemoryInByte"] as? Int64 {
            self.peakMemoryInByte = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["ShuffleReadInByte"] as? Int64 {
            self.shuffleReadInByte = value
        }
        if let value = dict["ShuffleWriteInByte"] as? Int64 {
            self.shuffleWriteInByte = value
        }
        if let value = dict["SpillInByte"] as? Int64 {
            self.spillInByte = value
        }
        if let value = dict["StartedTime"] as? Int64 {
            self.startedTime = value
        }
        if let value = dict["State"] as? String {
            self.state = value
        }
    }
}

public class DescribeSparkAppDiagnosisInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSparkAppDiagnosisInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeSparkAppDiagnosisInfoResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeSparkAppTypeRequest : Tea.TeaModel {
    public var appId: String?

    public var DBClusterId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class DescribeSparkAppTypeResponseBody : Tea.TeaModel {
    public var accessDeniedDetail: String?

    public var requestId: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessDeniedDetail != nil {
            map["AccessDeniedDetail"] = self.accessDeniedDetail!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AccessDeniedDetail"] as? String {
            self.accessDeniedDetail = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Type"] as? String {
            self.type = value
        }
    }
}

public class DescribeSparkAppTypeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSparkAppTypeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeSparkAppTypeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeSparkCodeLogRequest : Tea.TeaModel {
    public var DBClusterId: String?

    public var jobId: Int64?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["JobId"] as? Int64 {
            self.jobId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class DescribeSparkCodeLogResponseBody : Tea.TeaModel {
    public var log: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.log != nil {
            map["Log"] = self.log!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Log"] as? String {
            self.log = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class DescribeSparkCodeLogResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSparkCodeLogResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeSparkCodeLogResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeSparkCodeOutputRequest : Tea.TeaModel {
    public var DBClusterId: String?

    public var jobId: Int64?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["JobId"] as? Int64 {
            self.jobId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class DescribeSparkCodeOutputResponseBody : Tea.TeaModel {
    public var message: String?

    public var output: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.output != nil {
            map["Output"] = self.output!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["Output"] as? String {
            self.output = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class DescribeSparkCodeOutputResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSparkCodeOutputResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeSparkCodeOutputResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeSparkCodeWebUiRequest : Tea.TeaModel {
    public var DBClusterId: String?

    public var jobId: Int64?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["JobId"] as? Int64 {
            self.jobId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class DescribeSparkCodeWebUiResponseBody : Tea.TeaModel {
    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var url: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.url != nil {
            map["Url"] = self.url!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
        if let value = dict["Url"] as? String {
            self.url = value
        }
    }
}

public class DescribeSparkCodeWebUiResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSparkCodeWebUiResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeSparkCodeWebUiResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeSparkSQLDiagnosisAttributeRequest : Tea.TeaModel {
    public var appId: String?

    public var DBClusterId: String?

    public var innerQueryId: Int64?

    public var language: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.innerQueryId != nil {
            map["InnerQueryId"] = self.innerQueryId!
        }
        if self.language != nil {
            map["Language"] = self.language!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["InnerQueryId"] as? Int64 {
            self.innerQueryId = value
        }
        if let value = dict["Language"] as? String {
            self.language = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class DescribeSparkSQLDiagnosisAttributeResponseBody : Tea.TeaModel {
    public class OperatorListSortedByMetrics : Tea.TeaModel {
        public var operatorListSortedByExclusiveTime: [SparkOperatorInfo]?

        public var operatorListSortedByMaxMemory: [SparkOperatorInfo]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.operatorListSortedByExclusiveTime != nil {
                var tmp : [Any] = []
                for k in self.operatorListSortedByExclusiveTime! {
                    tmp.append(k.toMap())
                }
                map["OperatorListSortedByExclusiveTime"] = tmp
            }
            if self.operatorListSortedByMaxMemory != nil {
                var tmp : [Any] = []
                for k in self.operatorListSortedByMaxMemory! {
                    tmp.append(k.toMap())
                }
                map["OperatorListSortedByMaxMemory"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["OperatorListSortedByExclusiveTime"] as? [Any?] {
                var tmp : [SparkOperatorInfo] = []
                for v in value {
                    if v != nil {
                        var model = SparkOperatorInfo()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.operatorListSortedByExclusiveTime = tmp
            }
            if let value = dict["OperatorListSortedByMaxMemory"] as? [Any?] {
                var tmp : [SparkOperatorInfo] = []
                for v in value {
                    if v != nil {
                        var model = SparkOperatorInfo()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.operatorListSortedByMaxMemory = tmp
            }
        }
    }
    public var accessDeniedDetail: String?

    public var appId: String?

    public var diagnosisInfos: [Adb4MysqlSparkDiagnosisInfo]?

    public var elapsedTime: Int64?

    public var innerQueryId: Int64?

    public var operatorListSortedByMetrics: DescribeSparkSQLDiagnosisAttributeResponseBody.OperatorListSortedByMetrics?

    public var requestId: String?

    public var root: OperatorNode?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.operatorListSortedByMetrics?.validate()
        try self.root?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessDeniedDetail != nil {
            map["AccessDeniedDetail"] = self.accessDeniedDetail!
        }
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.diagnosisInfos != nil {
            var tmp : [Any] = []
            for k in self.diagnosisInfos! {
                tmp.append(k.toMap())
            }
            map["DiagnosisInfos"] = tmp
        }
        if self.elapsedTime != nil {
            map["ElapsedTime"] = self.elapsedTime!
        }
        if self.innerQueryId != nil {
            map["InnerQueryId"] = self.innerQueryId!
        }
        if self.operatorListSortedByMetrics != nil {
            map["OperatorListSortedByMetrics"] = self.operatorListSortedByMetrics?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.root != nil {
            map["Root"] = self.root?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AccessDeniedDetail"] as? String {
            self.accessDeniedDetail = value
        }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["DiagnosisInfos"] as? [Any?] {
            var tmp : [Adb4MysqlSparkDiagnosisInfo] = []
            for v in value {
                if v != nil {
                    var model = Adb4MysqlSparkDiagnosisInfo()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.diagnosisInfos = tmp
        }
        if let value = dict["ElapsedTime"] as? Int64 {
            self.elapsedTime = value
        }
        if let value = dict["InnerQueryId"] as? Int64 {
            self.innerQueryId = value
        }
        if let value = dict["OperatorListSortedByMetrics"] as? [String: Any?] {
            var model = DescribeSparkSQLDiagnosisAttributeResponseBody.OperatorListSortedByMetrics()
            model.fromMap(value)
            self.operatorListSortedByMetrics = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Root"] as? [String: Any?] {
            var model = OperatorNode()
            model.fromMap(value)
            self.root = model
        }
    }
}

public class DescribeSparkSQLDiagnosisAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSparkSQLDiagnosisAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeSparkSQLDiagnosisAttributeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeSparkSQLDiagnosisListRequest : Tea.TeaModel {
    public var DBClusterId: String?

    public var maxStartTime: String?

    public var minStartTime: String?

    public var order: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var statementId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.maxStartTime != nil {
            map["MaxStartTime"] = self.maxStartTime!
        }
        if self.minStartTime != nil {
            map["MinStartTime"] = self.minStartTime!
        }
        if self.order != nil {
            map["Order"] = self.order!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.statementId != nil {
            map["StatementId"] = self.statementId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["MaxStartTime"] as? String {
            self.maxStartTime = value
        }
        if let value = dict["MinStartTime"] as? String {
            self.minStartTime = value
        }
        if let value = dict["Order"] as? String {
            self.order = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["StatementId"] as? Int64 {
            self.statementId = value
        }
    }
}

public class DescribeSparkSQLDiagnosisListResponseBody : Tea.TeaModel {
    public class SQLDiagnosisList : Tea.TeaModel {
        public var appId: String?

        public var elapsedTime: Int64?

        public var innerQueryId: Int64?

        public var maxExclusiveTime: Int64?

        public var peakMemory: Int64?

        public var SQL: String?

        public var scanRowCount: Int64?

        public var startTime: String?

        public var state: String?

        public var statementId: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appId != nil {
                map["AppId"] = self.appId!
            }
            if self.elapsedTime != nil {
                map["ElapsedTime"] = self.elapsedTime!
            }
            if self.innerQueryId != nil {
                map["InnerQueryId"] = self.innerQueryId!
            }
            if self.maxExclusiveTime != nil {
                map["MaxExclusiveTime"] = self.maxExclusiveTime!
            }
            if self.peakMemory != nil {
                map["PeakMemory"] = self.peakMemory!
            }
            if self.SQL != nil {
                map["SQL"] = self.SQL!
            }
            if self.scanRowCount != nil {
                map["ScanRowCount"] = self.scanRowCount!
            }
            if self.startTime != nil {
                map["StartTime"] = self.startTime!
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            if self.statementId != nil {
                map["StatementId"] = self.statementId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AppId"] as? String {
                self.appId = value
            }
            if let value = dict["ElapsedTime"] as? Int64 {
                self.elapsedTime = value
            }
            if let value = dict["InnerQueryId"] as? Int64 {
                self.innerQueryId = value
            }
            if let value = dict["MaxExclusiveTime"] as? Int64 {
                self.maxExclusiveTime = value
            }
            if let value = dict["PeakMemory"] as? Int64 {
                self.peakMemory = value
            }
            if let value = dict["SQL"] as? String {
                self.SQL = value
            }
            if let value = dict["ScanRowCount"] as? Int64 {
                self.scanRowCount = value
            }
            if let value = dict["StartTime"] as? String {
                self.startTime = value
            }
            if let value = dict["State"] as? String {
                self.state = value
            }
            if let value = dict["StatementId"] as? Int64 {
                self.statementId = value
            }
        }
    }
    public var accessDeniedDetail: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var SQLDiagnosisList: [DescribeSparkSQLDiagnosisListResponseBody.SQLDiagnosisList]?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessDeniedDetail != nil {
            map["AccessDeniedDetail"] = self.accessDeniedDetail!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.SQLDiagnosisList != nil {
            var tmp : [Any] = []
            for k in self.SQLDiagnosisList! {
                tmp.append(k.toMap())
            }
            map["SQLDiagnosisList"] = tmp
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AccessDeniedDetail"] as? String {
            self.accessDeniedDetail = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["SQLDiagnosisList"] as? [Any?] {
            var tmp : [DescribeSparkSQLDiagnosisListResponseBody.SQLDiagnosisList] = []
            for v in value {
                if v != nil {
                    var model = DescribeSparkSQLDiagnosisListResponseBody.SQLDiagnosisList()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.SQLDiagnosisList = tmp
        }
        if let value = dict["TotalCount"] as? Int32 {
            self.totalCount = value
        }
    }
}

public class DescribeSparkSQLDiagnosisListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSparkSQLDiagnosisListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeSparkSQLDiagnosisListResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeSqlPatternRequest : Tea.TeaModel {
    public var DBClusterId: String?

    public var order: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var sqlPattern: String?

    public var startTime: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.order != nil {
            map["Order"] = self.order!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.sqlPattern != nil {
            map["SqlPattern"] = self.sqlPattern!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["Order"] as? String {
            self.order = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["SqlPattern"] as? String {
            self.sqlPattern = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
        if let value = dict["Type"] as? String {
            self.type = value
        }
    }
}

public class DescribeSqlPatternResponseBody : Tea.TeaModel {
    public class Items : Tea.TeaModel {
        public var accessIP: String?

        public var avgCpuTime: String?

        public var avgPeakMemory: String?

        public var avgScanSize: String?

        public var avgStageCount: String?

        public var avgTaskCount: String?

        public var instanceName: String?

        public var maxCpuTime: String?

        public var maxPeakMemory: String?

        public var maxScanSize: String?

        public var maxStageCount: String?

        public var maxTaskCount: String?

        public var pattern: String?

        public var queryCount: String?

        public var reportDate: String?

        public var user: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accessIP != nil {
                map["AccessIP"] = self.accessIP!
            }
            if self.avgCpuTime != nil {
                map["AvgCpuTime"] = self.avgCpuTime!
            }
            if self.avgPeakMemory != nil {
                map["AvgPeakMemory"] = self.avgPeakMemory!
            }
            if self.avgScanSize != nil {
                map["AvgScanSize"] = self.avgScanSize!
            }
            if self.avgStageCount != nil {
                map["AvgStageCount"] = self.avgStageCount!
            }
            if self.avgTaskCount != nil {
                map["AvgTaskCount"] = self.avgTaskCount!
            }
            if self.instanceName != nil {
                map["InstanceName"] = self.instanceName!
            }
            if self.maxCpuTime != nil {
                map["MaxCpuTime"] = self.maxCpuTime!
            }
            if self.maxPeakMemory != nil {
                map["MaxPeakMemory"] = self.maxPeakMemory!
            }
            if self.maxScanSize != nil {
                map["MaxScanSize"] = self.maxScanSize!
            }
            if self.maxStageCount != nil {
                map["MaxStageCount"] = self.maxStageCount!
            }
            if self.maxTaskCount != nil {
                map["MaxTaskCount"] = self.maxTaskCount!
            }
            if self.pattern != nil {
                map["Pattern"] = self.pattern!
            }
            if self.queryCount != nil {
                map["QueryCount"] = self.queryCount!
            }
            if self.reportDate != nil {
                map["ReportDate"] = self.reportDate!
            }
            if self.user != nil {
                map["User"] = self.user!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AccessIP"] as? String {
                self.accessIP = value
            }
            if let value = dict["AvgCpuTime"] as? String {
                self.avgCpuTime = value
            }
            if let value = dict["AvgPeakMemory"] as? String {
                self.avgPeakMemory = value
            }
            if let value = dict["AvgScanSize"] as? String {
                self.avgScanSize = value
            }
            if let value = dict["AvgStageCount"] as? String {
                self.avgStageCount = value
            }
            if let value = dict["AvgTaskCount"] as? String {
                self.avgTaskCount = value
            }
            if let value = dict["InstanceName"] as? String {
                self.instanceName = value
            }
            if let value = dict["MaxCpuTime"] as? String {
                self.maxCpuTime = value
            }
            if let value = dict["MaxPeakMemory"] as? String {
                self.maxPeakMemory = value
            }
            if let value = dict["MaxScanSize"] as? String {
                self.maxScanSize = value
            }
            if let value = dict["MaxStageCount"] as? String {
                self.maxStageCount = value
            }
            if let value = dict["MaxTaskCount"] as? String {
                self.maxTaskCount = value
            }
            if let value = dict["Pattern"] as? String {
                self.pattern = value
            }
            if let value = dict["QueryCount"] as? String {
                self.queryCount = value
            }
            if let value = dict["ReportDate"] as? String {
                self.reportDate = value
            }
            if let value = dict["User"] as? String {
                self.user = value
            }
        }
    }
    public var items: [DescribeSqlPatternResponseBody.Items]?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.items != nil {
            var tmp : [Any] = []
            for k in self.items! {
                tmp.append(k.toMap())
            }
            map["Items"] = tmp
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Items"] as? [Any?] {
            var tmp : [DescribeSqlPatternResponseBody.Items] = []
            for v in value {
                if v != nil {
                    var model = DescribeSqlPatternResponseBody.Items()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.items = tmp
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? Int32 {
            self.totalCount = value
        }
    }
}

public class DescribeSqlPatternResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSqlPatternResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeSqlPatternResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeStorageResourceUsageRequest : Tea.TeaModel {
    public var DBClusterId: String?

    public var endTime: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
    }
}

public class DescribeStorageResourceUsageResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class AcuInfo : Tea.TeaModel {
            public var name: String?

            public var values: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.values != nil {
                    map["Values"] = self.values!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Name"] as? String {
                    self.name = value
                }
                if let value = dict["Values"] as? [String] {
                    self.values = value
                }
            }
        }
        public var acuInfo: [DescribeStorageResourceUsageResponseBody.Data.AcuInfo]?

        public var DBClusterId: String?

        public var endTime: String?

        public var startTime: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.acuInfo != nil {
                var tmp : [Any] = []
                for k in self.acuInfo! {
                    tmp.append(k.toMap())
                }
                map["AcuInfo"] = tmp
            }
            if self.DBClusterId != nil {
                map["DBClusterId"] = self.DBClusterId!
            }
            if self.endTime != nil {
                map["EndTime"] = self.endTime!
            }
            if self.startTime != nil {
                map["StartTime"] = self.startTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AcuInfo"] as? [Any?] {
                var tmp : [DescribeStorageResourceUsageResponseBody.Data.AcuInfo] = []
                for v in value {
                    if v != nil {
                        var model = DescribeStorageResourceUsageResponseBody.Data.AcuInfo()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.acuInfo = tmp
            }
            if let value = dict["DBClusterId"] as? String {
                self.DBClusterId = value
            }
            if let value = dict["EndTime"] as? String {
                self.endTime = value
            }
            if let value = dict["StartTime"] as? String {
                self.startTime = value
            }
        }
    }
    public var code: Int32?

    public var data: DescribeStorageResourceUsageResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? Int32 {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = DescribeStorageResourceUsageResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeStorageResourceUsageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeStorageResourceUsageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeStorageResourceUsageResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeTableAccessCountRequest : Tea.TeaModel {
    public var DBClusterId: String?

    public var order: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var startTime: String?

    public var tableName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.order != nil {
            map["Order"] = self.order!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.tableName != nil {
            map["TableName"] = self.tableName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["Order"] as? String {
            self.order = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
        if let value = dict["TableName"] as? String {
            self.tableName = value
        }
    }
}

public class DescribeTableAccessCountResponseBody : Tea.TeaModel {
    public class Items : Tea.TeaModel {
        public var accessCount: String?

        public var instanceName: String?

        public var reportDate: String?

        public var tableName: String?

        public var tableSchema: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accessCount != nil {
                map["AccessCount"] = self.accessCount!
            }
            if self.instanceName != nil {
                map["InstanceName"] = self.instanceName!
            }
            if self.reportDate != nil {
                map["ReportDate"] = self.reportDate!
            }
            if self.tableName != nil {
                map["TableName"] = self.tableName!
            }
            if self.tableSchema != nil {
                map["TableSchema"] = self.tableSchema!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AccessCount"] as? String {
                self.accessCount = value
            }
            if let value = dict["InstanceName"] as? String {
                self.instanceName = value
            }
            if let value = dict["ReportDate"] as? String {
                self.reportDate = value
            }
            if let value = dict["TableName"] as? String {
                self.tableName = value
            }
            if let value = dict["TableSchema"] as? String {
                self.tableSchema = value
            }
        }
    }
    public var items: [DescribeTableAccessCountResponseBody.Items]?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.items != nil {
            var tmp : [Any] = []
            for k in self.items! {
                tmp.append(k.toMap())
            }
            map["Items"] = tmp
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Items"] as? [Any?] {
            var tmp : [DescribeTableAccessCountResponseBody.Items] = []
            for v in value {
                if v != nil {
                    var model = DescribeTableAccessCountResponseBody.Items()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.items = tmp
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? Int32 {
            self.totalCount = value
        }
    }
}

public class DescribeTableAccessCountResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeTableAccessCountResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeTableAccessCountResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeTableDetailRequest : Tea.TeaModel {
    public var DBClusterId: String?

    public var regionId: String?

    public var schemaName: String?

    public var tableName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.schemaName != nil {
            map["SchemaName"] = self.schemaName!
        }
        if self.tableName != nil {
            map["TableName"] = self.tableName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["SchemaName"] as? String {
            self.schemaName = value
        }
        if let value = dict["TableName"] as? String {
            self.tableName = value
        }
    }
}

public class DescribeTableDetailResponseBody : Tea.TeaModel {
    public class Items : Tea.TeaModel {
        public class Shard : Tea.TeaModel {
            public var id: Int32?

            public var size: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.size != nil {
                    map["Size"] = self.size!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Id"] as? Int32 {
                    self.id = value
                }
                if let value = dict["Size"] as? Int64 {
                    self.size = value
                }
            }
        }
        public var shard: [DescribeTableDetailResponseBody.Items.Shard]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.shard != nil {
                var tmp : [Any] = []
                for k in self.shard! {
                    tmp.append(k.toMap())
                }
                map["Shard"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Shard"] as? [Any?] {
                var tmp : [DescribeTableDetailResponseBody.Items.Shard] = []
                for v in value {
                    if v != nil {
                        var model = DescribeTableDetailResponseBody.Items.Shard()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.shard = tmp
            }
        }
    }
    public var accessDeniedDetail: String?

    public var avgSize: String?

    public var items: DescribeTableDetailResponseBody.Items?

    public var pageNumber: String?

    public var pageSize: String?

    public var requestId: String?

    public var totalCount: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.items?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessDeniedDetail != nil {
            map["AccessDeniedDetail"] = self.accessDeniedDetail!
        }
        if self.avgSize != nil {
            map["AvgSize"] = self.avgSize!
        }
        if self.items != nil {
            map["Items"] = self.items?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AccessDeniedDetail"] as? String {
            self.accessDeniedDetail = value
        }
        if let value = dict["AvgSize"] as? String {
            self.avgSize = value
        }
        if let value = dict["Items"] as? [String: Any?] {
            var model = DescribeTableDetailResponseBody.Items()
            model.fromMap(value)
            self.items = model
        }
        if let value = dict["PageNumber"] as? String {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? String {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? String {
            self.totalCount = value
        }
    }
}

public class DescribeTableDetailResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeTableDetailResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeTableDetailResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeTablePartitionDiagnoseRequest : Tea.TeaModel {
    public var DBClusterId: String?

    public var lang: String?

    public var order: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.order != nil {
            map["Order"] = self.order!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["Lang"] as? String {
            self.lang = value
        }
        if let value = dict["Order"] as? String {
            self.order = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class DescribeTablePartitionDiagnoseResponseBody : Tea.TeaModel {
    public class DetectionItems : Tea.TeaModel {
        public var message: String?

        public var name: String?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Message"] as? String {
                self.message = value
            }
            if let value = dict["Name"] as? String {
                self.name = value
            }
            if let value = dict["Status"] as? String {
                self.status = value
            }
        }
    }
    public class Items : Tea.TeaModel {
        public var partitionDetail: String?

        public var partitionNumber: Int32?

        public var schemaName: String?

        public var spaceRatio: Double?

        public var tableName: String?

        public var totalSize: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.partitionDetail != nil {
                map["PartitionDetail"] = self.partitionDetail!
            }
            if self.partitionNumber != nil {
                map["PartitionNumber"] = self.partitionNumber!
            }
            if self.schemaName != nil {
                map["SchemaName"] = self.schemaName!
            }
            if self.spaceRatio != nil {
                map["SpaceRatio"] = self.spaceRatio!
            }
            if self.tableName != nil {
                map["TableName"] = self.tableName!
            }
            if self.totalSize != nil {
                map["TotalSize"] = self.totalSize!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["PartitionDetail"] as? String {
                self.partitionDetail = value
            }
            if let value = dict["PartitionNumber"] as? Int32 {
                self.partitionNumber = value
            }
            if let value = dict["SchemaName"] as? String {
                self.schemaName = value
            }
            if let value = dict["SpaceRatio"] as? Double {
                self.spaceRatio = value
            }
            if let value = dict["TableName"] as? String {
                self.tableName = value
            }
            if let value = dict["TotalSize"] as? Int64 {
                self.totalSize = value
            }
        }
    }
    public var accessDeniedDetail: String?

    public var DBClusterId: String?

    public var detectionItems: [DescribeTablePartitionDiagnoseResponseBody.DetectionItems]?

    public var items: [DescribeTablePartitionDiagnoseResponseBody.Items]?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var suggestMaxRecordsPerPartition: Int64?

    public var suggestMinRecordsPerPartition: Int64?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessDeniedDetail != nil {
            map["AccessDeniedDetail"] = self.accessDeniedDetail!
        }
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.detectionItems != nil {
            var tmp : [Any] = []
            for k in self.detectionItems! {
                tmp.append(k.toMap())
            }
            map["DetectionItems"] = tmp
        }
        if self.items != nil {
            var tmp : [Any] = []
            for k in self.items! {
                tmp.append(k.toMap())
            }
            map["Items"] = tmp
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.suggestMaxRecordsPerPartition != nil {
            map["SuggestMaxRecordsPerPartition"] = self.suggestMaxRecordsPerPartition!
        }
        if self.suggestMinRecordsPerPartition != nil {
            map["SuggestMinRecordsPerPartition"] = self.suggestMinRecordsPerPartition!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AccessDeniedDetail"] as? String {
            self.accessDeniedDetail = value
        }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["DetectionItems"] as? [Any?] {
            var tmp : [DescribeTablePartitionDiagnoseResponseBody.DetectionItems] = []
            for v in value {
                if v != nil {
                    var model = DescribeTablePartitionDiagnoseResponseBody.DetectionItems()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.detectionItems = tmp
        }
        if let value = dict["Items"] as? [Any?] {
            var tmp : [DescribeTablePartitionDiagnoseResponseBody.Items] = []
            for v in value {
                if v != nil {
                    var model = DescribeTablePartitionDiagnoseResponseBody.Items()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.items = tmp
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["SuggestMaxRecordsPerPartition"] as? Int64 {
            self.suggestMaxRecordsPerPartition = value
        }
        if let value = dict["SuggestMinRecordsPerPartition"] as? Int64 {
            self.suggestMinRecordsPerPartition = value
        }
        if let value = dict["TotalCount"] as? Int32 {
            self.totalCount = value
        }
    }
}

public class DescribeTablePartitionDiagnoseResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeTablePartitionDiagnoseResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeTablePartitionDiagnoseResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeTableStatisticsRequest : Tea.TeaModel {
    public var DBClusterId: String?

    public var keyword: String?

    public var order: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var schemaName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.keyword != nil {
            map["Keyword"] = self.keyword!
        }
        if self.order != nil {
            map["Order"] = self.order!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.schemaName != nil {
            map["SchemaName"] = self.schemaName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["Keyword"] as? String {
            self.keyword = value
        }
        if let value = dict["Order"] as? String {
            self.order = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["SchemaName"] as? String {
            self.schemaName = value
        }
    }
}

public class DescribeTableStatisticsResponseBody : Tea.TeaModel {
    public class Items : Tea.TeaModel {
        public class TableStatisticRecords : Tea.TeaModel {
            public var coldDataSize: Int64?

            public var dataSize: Int64?

            public var hotDataSize: Int64?

            public var indexSize: Int64?

            public var otherSize: Int64?

            public var partitionCount: Int64?

            public var primaryKeyIndexSize: Int64?

            public var rowCount: Int64?

            public var schemaName: String?

            public var spaceRatio: Double?

            public var tableName: String?

            public var totalSize: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.coldDataSize != nil {
                    map["ColdDataSize"] = self.coldDataSize!
                }
                if self.dataSize != nil {
                    map["DataSize"] = self.dataSize!
                }
                if self.hotDataSize != nil {
                    map["HotDataSize"] = self.hotDataSize!
                }
                if self.indexSize != nil {
                    map["IndexSize"] = self.indexSize!
                }
                if self.otherSize != nil {
                    map["OtherSize"] = self.otherSize!
                }
                if self.partitionCount != nil {
                    map["PartitionCount"] = self.partitionCount!
                }
                if self.primaryKeyIndexSize != nil {
                    map["PrimaryKeyIndexSize"] = self.primaryKeyIndexSize!
                }
                if self.rowCount != nil {
                    map["RowCount"] = self.rowCount!
                }
                if self.schemaName != nil {
                    map["SchemaName"] = self.schemaName!
                }
                if self.spaceRatio != nil {
                    map["SpaceRatio"] = self.spaceRatio!
                }
                if self.tableName != nil {
                    map["TableName"] = self.tableName!
                }
                if self.totalSize != nil {
                    map["TotalSize"] = self.totalSize!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ColdDataSize"] as? Int64 {
                    self.coldDataSize = value
                }
                if let value = dict["DataSize"] as? Int64 {
                    self.dataSize = value
                }
                if let value = dict["HotDataSize"] as? Int64 {
                    self.hotDataSize = value
                }
                if let value = dict["IndexSize"] as? Int64 {
                    self.indexSize = value
                }
                if let value = dict["OtherSize"] as? Int64 {
                    self.otherSize = value
                }
                if let value = dict["PartitionCount"] as? Int64 {
                    self.partitionCount = value
                }
                if let value = dict["PrimaryKeyIndexSize"] as? Int64 {
                    self.primaryKeyIndexSize = value
                }
                if let value = dict["RowCount"] as? Int64 {
                    self.rowCount = value
                }
                if let value = dict["SchemaName"] as? String {
                    self.schemaName = value
                }
                if let value = dict["SpaceRatio"] as? Double {
                    self.spaceRatio = value
                }
                if let value = dict["TableName"] as? String {
                    self.tableName = value
                }
                if let value = dict["TotalSize"] as? Int64 {
                    self.totalSize = value
                }
            }
        }
        public var tableStatisticRecords: [DescribeTableStatisticsResponseBody.Items.TableStatisticRecords]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tableStatisticRecords != nil {
                var tmp : [Any] = []
                for k in self.tableStatisticRecords! {
                    tmp.append(k.toMap())
                }
                map["TableStatisticRecords"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["TableStatisticRecords"] as? [Any?] {
                var tmp : [DescribeTableStatisticsResponseBody.Items.TableStatisticRecords] = []
                for v in value {
                    if v != nil {
                        var model = DescribeTableStatisticsResponseBody.Items.TableStatisticRecords()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.tableStatisticRecords = tmp
            }
        }
    }
    public var DBClusterId: String?

    public var items: DescribeTableStatisticsResponseBody.Items?

    public var pageNumber: String?

    public var pageSize: String?

    public var requestId: String?

    public var schemaNames: String?

    public var totalCount: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.items?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.items != nil {
            map["Items"] = self.items?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.schemaNames != nil {
            map["SchemaNames"] = self.schemaNames!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["Items"] as? [String: Any?] {
            var model = DescribeTableStatisticsResponseBody.Items()
            model.fromMap(value)
            self.items = model
        }
        if let value = dict["PageNumber"] as? String {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? String {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["SchemaNames"] as? String {
            self.schemaNames = value
        }
        if let value = dict["TotalCount"] as? String {
            self.totalCount = value
        }
    }
}

public class DescribeTableStatisticsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeTableStatisticsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeTableStatisticsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeTablesRequest : Tea.TeaModel {
    public var DBClusterId: String?

    public var regionId: String?

    public var schemaName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.schemaName != nil {
            map["SchemaName"] = self.schemaName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["SchemaName"] as? String {
            self.schemaName = value
        }
    }
}

public class DescribeTablesResponseBody : Tea.TeaModel {
    public class Items : Tea.TeaModel {
        public class Table : Tea.TeaModel {
            public var DBClusterId: String?

            public var schemaName: String?

            public var tableName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.DBClusterId != nil {
                    map["DBClusterId"] = self.DBClusterId!
                }
                if self.schemaName != nil {
                    map["SchemaName"] = self.schemaName!
                }
                if self.tableName != nil {
                    map["TableName"] = self.tableName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["DBClusterId"] as? String {
                    self.DBClusterId = value
                }
                if let value = dict["SchemaName"] as? String {
                    self.schemaName = value
                }
                if let value = dict["TableName"] as? String {
                    self.tableName = value
                }
            }
        }
        public var table: [DescribeTablesResponseBody.Items.Table]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.table != nil {
                var tmp : [Any] = []
                for k in self.table! {
                    tmp.append(k.toMap())
                }
                map["Table"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Table"] as? [Any?] {
                var tmp : [DescribeTablesResponseBody.Items.Table] = []
                for v in value {
                    if v != nil {
                        var model = DescribeTablesResponseBody.Items.Table()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.table = tmp
            }
        }
    }
    public var items: DescribeTablesResponseBody.Items?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.items?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.items != nil {
            map["Items"] = self.items?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Items"] as? [String: Any?] {
            var model = DescribeTablesResponseBody.Items()
            model.fromMap(value)
            self.items = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DescribeTablesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeTablesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeTablesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeUserQuotaRequest : Tea.TeaModel {
    public var DBClusterId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class DescribeUserQuotaResponseBody : Tea.TeaModel {
    public var elasticACU: String?

    public var requestId: String?

    public var reserverdCompteACU: String?

    public var reserverdStorageACU: String?

    public var resourceGroupCount: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.elasticACU != nil {
            map["ElasticACU"] = self.elasticACU!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.reserverdCompteACU != nil {
            map["ReserverdCompteACU"] = self.reserverdCompteACU!
        }
        if self.reserverdStorageACU != nil {
            map["ReserverdStorageACU"] = self.reserverdStorageACU!
        }
        if self.resourceGroupCount != nil {
            map["ResourceGroupCount"] = self.resourceGroupCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ElasticACU"] as? String {
            self.elasticACU = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["ReserverdCompteACU"] as? String {
            self.reserverdCompteACU = value
        }
        if let value = dict["ReserverdStorageACU"] as? String {
            self.reserverdStorageACU = value
        }
        if let value = dict["ResourceGroupCount"] as? String {
            self.resourceGroupCount = value
        }
    }
}

public class DescribeUserQuotaResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeUserQuotaResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeUserQuotaResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeWorkerDetectionRequest : Tea.TeaModel {
    public var DBClusterId: String?

    public var endTime: String?

    public var lang: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["Lang"] as? String {
            self.lang = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
    }
}

public class DescribeWorkerDetectionResponseBody : Tea.TeaModel {
    public class DetectionItems : Tea.TeaModel {
        public class Results : Tea.TeaModel {
            public class OperatorAgg : Tea.TeaModel {
                public class SearchResults : Tea.TeaModel {
                    public var avgValue: Double?

                    public var maxValue: Int64?

                    public var operatorCount: Int64?

                    public var operatorName: String?

                    public var totalValue: Int64?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.avgValue != nil {
                            map["AvgValue"] = self.avgValue!
                        }
                        if self.maxValue != nil {
                            map["MaxValue"] = self.maxValue!
                        }
                        if self.operatorCount != nil {
                            map["OperatorCount"] = self.operatorCount!
                        }
                        if self.operatorName != nil {
                            map["OperatorName"] = self.operatorName!
                        }
                        if self.totalValue != nil {
                            map["TotalValue"] = self.totalValue!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["AvgValue"] as? Double {
                            self.avgValue = value
                        }
                        if let value = dict["MaxValue"] as? Int64 {
                            self.maxValue = value
                        }
                        if let value = dict["OperatorCount"] as? Int64 {
                            self.operatorCount = value
                        }
                        if let value = dict["OperatorName"] as? String {
                            self.operatorName = value
                        }
                        if let value = dict["TotalValue"] as? Int64 {
                            self.totalValue = value
                        }
                    }
                }
                public var metricName: String?

                public var searchResults: [DescribeWorkerDetectionResponseBody.DetectionItems.Results.OperatorAgg.SearchResults]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.metricName != nil {
                        map["MetricName"] = self.metricName!
                    }
                    if self.searchResults != nil {
                        var tmp : [Any] = []
                        for k in self.searchResults! {
                            tmp.append(k.toMap())
                        }
                        map["SearchResults"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["MetricName"] as? String {
                        self.metricName = value
                    }
                    if let value = dict["SearchResults"] as? [Any?] {
                        var tmp : [DescribeWorkerDetectionResponseBody.DetectionItems.Results.OperatorAgg.SearchResults] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeWorkerDetectionResponseBody.DetectionItems.Results.OperatorAgg.SearchResults()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.searchResults = tmp
                    }
                }
            }
            public class OperatorDetails : Tea.TeaModel {
                public class SearchResults : Tea.TeaModel {
                    public var inputRows: Int64?

                    public var inputSize: Int64?

                    public var operatorCost: Int64?

                    public var operatorInfo: String?

                    public var operatorName: String?

                    public var outputRows: Int64?

                    public var outputSize: Int64?

                    public var peakMemory: Int64?

                    public var processId: String?

                    public var stageId: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.inputRows != nil {
                            map["InputRows"] = self.inputRows!
                        }
                        if self.inputSize != nil {
                            map["InputSize"] = self.inputSize!
                        }
                        if self.operatorCost != nil {
                            map["OperatorCost"] = self.operatorCost!
                        }
                        if self.operatorInfo != nil {
                            map["OperatorInfo"] = self.operatorInfo!
                        }
                        if self.operatorName != nil {
                            map["OperatorName"] = self.operatorName!
                        }
                        if self.outputRows != nil {
                            map["OutputRows"] = self.outputRows!
                        }
                        if self.outputSize != nil {
                            map["OutputSize"] = self.outputSize!
                        }
                        if self.peakMemory != nil {
                            map["PeakMemory"] = self.peakMemory!
                        }
                        if self.processId != nil {
                            map["ProcessId"] = self.processId!
                        }
                        if self.stageId != nil {
                            map["StageId"] = self.stageId!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["InputRows"] as? Int64 {
                            self.inputRows = value
                        }
                        if let value = dict["InputSize"] as? Int64 {
                            self.inputSize = value
                        }
                        if let value = dict["OperatorCost"] as? Int64 {
                            self.operatorCost = value
                        }
                        if let value = dict["OperatorInfo"] as? String {
                            self.operatorInfo = value
                        }
                        if let value = dict["OperatorName"] as? String {
                            self.operatorName = value
                        }
                        if let value = dict["OutputRows"] as? Int64 {
                            self.outputRows = value
                        }
                        if let value = dict["OutputSize"] as? Int64 {
                            self.outputSize = value
                        }
                        if let value = dict["PeakMemory"] as? Int64 {
                            self.peakMemory = value
                        }
                        if let value = dict["ProcessId"] as? String {
                            self.processId = value
                        }
                        if let value = dict["StageId"] as? String {
                            self.stageId = value
                        }
                    }
                }
                public var metricName: String?

                public var searchResults: [DescribeWorkerDetectionResponseBody.DetectionItems.Results.OperatorDetails.SearchResults]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.metricName != nil {
                        map["MetricName"] = self.metricName!
                    }
                    if self.searchResults != nil {
                        var tmp : [Any] = []
                        for k in self.searchResults! {
                            tmp.append(k.toMap())
                        }
                        map["SearchResults"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["MetricName"] as? String {
                        self.metricName = value
                    }
                    if let value = dict["SearchResults"] as? [Any?] {
                        var tmp : [DescribeWorkerDetectionResponseBody.DetectionItems.Results.OperatorDetails.SearchResults] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeWorkerDetectionResponseBody.DetectionItems.Results.OperatorDetails.SearchResults()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.searchResults = tmp
                    }
                }
            }
            public class PartitionedTables : Tea.TeaModel {
                public var DDL: String?

                public var partitionCount: String?

                public var partitionIds: String?

                public var schemaName: String?

                public var tableName: String?

                public var totalDataSize: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.DDL != nil {
                        map["DDL"] = self.DDL!
                    }
                    if self.partitionCount != nil {
                        map["PartitionCount"] = self.partitionCount!
                    }
                    if self.partitionIds != nil {
                        map["PartitionIds"] = self.partitionIds!
                    }
                    if self.schemaName != nil {
                        map["SchemaName"] = self.schemaName!
                    }
                    if self.tableName != nil {
                        map["TableName"] = self.tableName!
                    }
                    if self.totalDataSize != nil {
                        map["TotalDataSize"] = self.totalDataSize!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["DDL"] as? String {
                        self.DDL = value
                    }
                    if let value = dict["PartitionCount"] as? String {
                        self.partitionCount = value
                    }
                    if let value = dict["PartitionIds"] as? String {
                        self.partitionIds = value
                    }
                    if let value = dict["SchemaName"] as? String {
                        self.schemaName = value
                    }
                    if let value = dict["TableName"] as? String {
                        self.tableName = value
                    }
                    if let value = dict["TotalDataSize"] as? Int64 {
                        self.totalDataSize = value
                    }
                }
            }
            public class SkewedTables : Tea.TeaModel {
                public var DDL: String?

                public var partitionCount: Int32?

                public var schemaName: String?

                public var shardSkewedRows: String?

                public var tableName: String?

                public var totalDataSize: Int64?

                public var totalLocalDataSize: String?

                public var totalPkSize: Int64?

                public var totalRemoteDataSize: Int64?

                public var totalRowCount: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.DDL != nil {
                        map["DDL"] = self.DDL!
                    }
                    if self.partitionCount != nil {
                        map["PartitionCount"] = self.partitionCount!
                    }
                    if self.schemaName != nil {
                        map["SchemaName"] = self.schemaName!
                    }
                    if self.shardSkewedRows != nil {
                        map["ShardSkewedRows"] = self.shardSkewedRows!
                    }
                    if self.tableName != nil {
                        map["TableName"] = self.tableName!
                    }
                    if self.totalDataSize != nil {
                        map["TotalDataSize"] = self.totalDataSize!
                    }
                    if self.totalLocalDataSize != nil {
                        map["TotalLocalDataSize"] = self.totalLocalDataSize!
                    }
                    if self.totalPkSize != nil {
                        map["TotalPkSize"] = self.totalPkSize!
                    }
                    if self.totalRemoteDataSize != nil {
                        map["TotalRemoteDataSize"] = self.totalRemoteDataSize!
                    }
                    if self.totalRowCount != nil {
                        map["TotalRowCount"] = self.totalRowCount!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["DDL"] as? String {
                        self.DDL = value
                    }
                    if let value = dict["PartitionCount"] as? Int32 {
                        self.partitionCount = value
                    }
                    if let value = dict["SchemaName"] as? String {
                        self.schemaName = value
                    }
                    if let value = dict["ShardSkewedRows"] as? String {
                        self.shardSkewedRows = value
                    }
                    if let value = dict["TableName"] as? String {
                        self.tableName = value
                    }
                    if let value = dict["TotalDataSize"] as? Int64 {
                        self.totalDataSize = value
                    }
                    if let value = dict["TotalLocalDataSize"] as? String {
                        self.totalLocalDataSize = value
                    }
                    if let value = dict["TotalPkSize"] as? Int64 {
                        self.totalPkSize = value
                    }
                    if let value = dict["TotalRemoteDataSize"] as? Int64 {
                        self.totalRemoteDataSize = value
                    }
                    if let value = dict["TotalRowCount"] as? Int64 {
                        self.totalRowCount = value
                    }
                }
            }
            public class TopAccessTables : Tea.TeaModel {
                public class SearchResults : Tea.TeaModel {
                    public var accessCount: Int64?

                    public var avgScanCost: Double?

                    public var avgScanSize: Double?

                    public var maxScanCost: Int64?

                    public var maxScanSize: Int64?

                    public var tableName: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.accessCount != nil {
                            map["AccessCount"] = self.accessCount!
                        }
                        if self.avgScanCost != nil {
                            map["AvgScanCost"] = self.avgScanCost!
                        }
                        if self.avgScanSize != nil {
                            map["AvgScanSize"] = self.avgScanSize!
                        }
                        if self.maxScanCost != nil {
                            map["MaxScanCost"] = self.maxScanCost!
                        }
                        if self.maxScanSize != nil {
                            map["MaxScanSize"] = self.maxScanSize!
                        }
                        if self.tableName != nil {
                            map["TableName"] = self.tableName!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["AccessCount"] as? Int64 {
                            self.accessCount = value
                        }
                        if let value = dict["AvgScanCost"] as? Double {
                            self.avgScanCost = value
                        }
                        if let value = dict["AvgScanSize"] as? Double {
                            self.avgScanSize = value
                        }
                        if let value = dict["MaxScanCost"] as? Int64 {
                            self.maxScanCost = value
                        }
                        if let value = dict["MaxScanSize"] as? Int64 {
                            self.maxScanSize = value
                        }
                        if let value = dict["TableName"] as? String {
                            self.tableName = value
                        }
                    }
                }
                public var metricName: String?

                public var searchResults: [DescribeWorkerDetectionResponseBody.DetectionItems.Results.TopAccessTables.SearchResults]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.metricName != nil {
                        map["MetricName"] = self.metricName!
                    }
                    if self.searchResults != nil {
                        var tmp : [Any] = []
                        for k in self.searchResults! {
                            tmp.append(k.toMap())
                        }
                        map["SearchResults"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["MetricName"] as? String {
                        self.metricName = value
                    }
                    if let value = dict["SearchResults"] as? [Any?] {
                        var tmp : [DescribeWorkerDetectionResponseBody.DetectionItems.Results.TopAccessTables.SearchResults] = []
                        for v in value {
                            if v != nil {
                                var model = DescribeWorkerDetectionResponseBody.DetectionItems.Results.TopAccessTables.SearchResults()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.searchResults = tmp
                    }
                }
            }
            public var operatorAgg: [DescribeWorkerDetectionResponseBody.DetectionItems.Results.OperatorAgg]?

            public var operatorDetails: [DescribeWorkerDetectionResponseBody.DetectionItems.Results.OperatorDetails]?

            public var partitionedTables: [DescribeWorkerDetectionResponseBody.DetectionItems.Results.PartitionedTables]?

            public var skewedTables: [DescribeWorkerDetectionResponseBody.DetectionItems.Results.SkewedTables]?

            public var topAccessTables: [DescribeWorkerDetectionResponseBody.DetectionItems.Results.TopAccessTables]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.operatorAgg != nil {
                    var tmp : [Any] = []
                    for k in self.operatorAgg! {
                        tmp.append(k.toMap())
                    }
                    map["OperatorAgg"] = tmp
                }
                if self.operatorDetails != nil {
                    var tmp : [Any] = []
                    for k in self.operatorDetails! {
                        tmp.append(k.toMap())
                    }
                    map["OperatorDetails"] = tmp
                }
                if self.partitionedTables != nil {
                    var tmp : [Any] = []
                    for k in self.partitionedTables! {
                        tmp.append(k.toMap())
                    }
                    map["PartitionedTables"] = tmp
                }
                if self.skewedTables != nil {
                    var tmp : [Any] = []
                    for k in self.skewedTables! {
                        tmp.append(k.toMap())
                    }
                    map["SkewedTables"] = tmp
                }
                if self.topAccessTables != nil {
                    var tmp : [Any] = []
                    for k in self.topAccessTables! {
                        tmp.append(k.toMap())
                    }
                    map["TopAccessTables"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["OperatorAgg"] as? [Any?] {
                    var tmp : [DescribeWorkerDetectionResponseBody.DetectionItems.Results.OperatorAgg] = []
                    for v in value {
                        if v != nil {
                            var model = DescribeWorkerDetectionResponseBody.DetectionItems.Results.OperatorAgg()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.operatorAgg = tmp
                }
                if let value = dict["OperatorDetails"] as? [Any?] {
                    var tmp : [DescribeWorkerDetectionResponseBody.DetectionItems.Results.OperatorDetails] = []
                    for v in value {
                        if v != nil {
                            var model = DescribeWorkerDetectionResponseBody.DetectionItems.Results.OperatorDetails()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.operatorDetails = tmp
                }
                if let value = dict["PartitionedTables"] as? [Any?] {
                    var tmp : [DescribeWorkerDetectionResponseBody.DetectionItems.Results.PartitionedTables] = []
                    for v in value {
                        if v != nil {
                            var model = DescribeWorkerDetectionResponseBody.DetectionItems.Results.PartitionedTables()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.partitionedTables = tmp
                }
                if let value = dict["SkewedTables"] as? [Any?] {
                    var tmp : [DescribeWorkerDetectionResponseBody.DetectionItems.Results.SkewedTables] = []
                    for v in value {
                        if v != nil {
                            var model = DescribeWorkerDetectionResponseBody.DetectionItems.Results.SkewedTables()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.skewedTables = tmp
                }
                if let value = dict["TopAccessTables"] as? [Any?] {
                    var tmp : [DescribeWorkerDetectionResponseBody.DetectionItems.Results.TopAccessTables] = []
                    for v in value {
                        if v != nil {
                            var model = DescribeWorkerDetectionResponseBody.DetectionItems.Results.TopAccessTables()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.topAccessTables = tmp
                }
            }
        }
        public var message: String?

        public var name: String?

        public var results: DescribeWorkerDetectionResponseBody.DetectionItems.Results?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.results?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.results != nil {
                map["Results"] = self.results?.toMap()
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Message"] as? String {
                self.message = value
            }
            if let value = dict["Name"] as? String {
                self.name = value
            }
            if let value = dict["Results"] as? [String: Any?] {
                var model = DescribeWorkerDetectionResponseBody.DetectionItems.Results()
                model.fromMap(value)
                self.results = model
            }
            if let value = dict["Status"] as? String {
                self.status = value
            }
        }
    }
    public var DBClusterId: String?

    public var detectionItems: [DescribeWorkerDetectionResponseBody.DetectionItems]?

    public var requestId: String?

    public var totalCount: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.detectionItems != nil {
            var tmp : [Any] = []
            for k in self.detectionItems! {
                tmp.append(k.toMap())
            }
            map["DetectionItems"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["DetectionItems"] as? [Any?] {
            var tmp : [DescribeWorkerDetectionResponseBody.DetectionItems] = []
            for v in value {
                if v != nil {
                    var model = DescribeWorkerDetectionResponseBody.DetectionItems()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.detectionItems = tmp
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? String {
            self.totalCount = value
        }
    }
}

public class DescribeWorkerDetectionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeWorkerDetectionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeWorkerDetectionResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DetachUserENIRequest : Tea.TeaModel {
    public var DBClusterId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
    }
}

public class DetachUserENIResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DetachUserENIResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DetachUserENIResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DetachUserENIResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DisableAdviceServiceRequest : Tea.TeaModel {
    public var DBClusterId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class DisableAdviceServiceResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DisableAdviceServiceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DisableAdviceServiceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DisableAdviceServiceResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DisableElasticPlanRequest : Tea.TeaModel {
    public var DBClusterId: String?

    public var elasticPlanName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.elasticPlanName != nil {
            map["ElasticPlanName"] = self.elasticPlanName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["ElasticPlanName"] as? String {
            self.elasticPlanName = value
        }
    }
}

public class DisableElasticPlanResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DisableElasticPlanResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DisableElasticPlanResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DisableElasticPlanResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DownloadDiagnosisRecordsRequest : Tea.TeaModel {
    public var clientIp: String?

    public var DBClusterId: String?

    public var database: String?

    public var endTime: String?

    public var keyword: String?

    public var lang: String?

    public var maxPeakMemory: Int64?

    public var maxScanSize: Int64?

    public var minPeakMemory: Int64?

    public var minScanSize: Int64?

    public var queryCondition: String?

    public var regionId: String?

    public var resourceGroup: String?

    public var startTime: String?

    public var userName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientIp != nil {
            map["ClientIp"] = self.clientIp!
        }
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.database != nil {
            map["Database"] = self.database!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.keyword != nil {
            map["Keyword"] = self.keyword!
        }
        if self.lang != nil {
            map["Lang"] = self.lang!
        }
        if self.maxPeakMemory != nil {
            map["MaxPeakMemory"] = self.maxPeakMemory!
        }
        if self.maxScanSize != nil {
            map["MaxScanSize"] = self.maxScanSize!
        }
        if self.minPeakMemory != nil {
            map["MinPeakMemory"] = self.minPeakMemory!
        }
        if self.minScanSize != nil {
            map["MinScanSize"] = self.minScanSize!
        }
        if self.queryCondition != nil {
            map["QueryCondition"] = self.queryCondition!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroup != nil {
            map["ResourceGroup"] = self.resourceGroup!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.userName != nil {
            map["UserName"] = self.userName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientIp"] as? String {
            self.clientIp = value
        }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["Database"] as? String {
            self.database = value
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["Keyword"] as? String {
            self.keyword = value
        }
        if let value = dict["Lang"] as? String {
            self.lang = value
        }
        if let value = dict["MaxPeakMemory"] as? Int64 {
            self.maxPeakMemory = value
        }
        if let value = dict["MaxScanSize"] as? Int64 {
            self.maxScanSize = value
        }
        if let value = dict["MinPeakMemory"] as? Int64 {
            self.minPeakMemory = value
        }
        if let value = dict["MinScanSize"] as? Int64 {
            self.minScanSize = value
        }
        if let value = dict["QueryCondition"] as? String {
            self.queryCondition = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroup"] as? String {
            self.resourceGroup = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
        if let value = dict["UserName"] as? String {
            self.userName = value
        }
    }
}

public class DownloadDiagnosisRecordsResponseBody : Tea.TeaModel {
    public var downloadId: Int32?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.downloadId != nil {
            map["DownloadId"] = self.downloadId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DownloadId"] as? Int32 {
            self.downloadId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DownloadDiagnosisRecordsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DownloadDiagnosisRecordsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DownloadDiagnosisRecordsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DownloadInstanceCACertificateRequest : Tea.TeaModel {
    public var DBClusterId: String?

    public var engine: String?

    public var ownerId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.engine != nil {
            map["Engine"] = self.engine!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["Engine"] as? String {
            self.engine = value
        }
        if let value = dict["OwnerId"] as? String {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class DownloadInstanceCACertificateResponseBody : Tea.TeaModel {
    public var downloadUrl: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.downloadUrl != nil {
            map["DownloadUrl"] = self.downloadUrl!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DownloadUrl"] as? String {
            self.downloadUrl = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DownloadInstanceCACertificateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DownloadInstanceCACertificateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DownloadInstanceCACertificateResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class EnableAdviceServiceRequest : Tea.TeaModel {
    public var DBClusterId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class EnableAdviceServiceResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class EnableAdviceServiceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: EnableAdviceServiceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = EnableAdviceServiceResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class EnableElasticPlanRequest : Tea.TeaModel {
    public var DBClusterId: String?

    public var elasticPlanName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.elasticPlanName != nil {
            map["ElasticPlanName"] = self.elasticPlanName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["ElasticPlanName"] as? String {
            self.elasticPlanName = value
        }
    }
}

public class EnableElasticPlanResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class EnableElasticPlanResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: EnableElasticPlanResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = EnableElasticPlanResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ExecuteSparkReplStatementRequest : Tea.TeaModel {
    public var appId: String?

    public var code: String?

    public var codeType: String?

    public var sessionId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.codeType != nil {
            map["CodeType"] = self.codeType!
        }
        if self.sessionId != nil {
            map["SessionId"] = self.sessionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["CodeType"] as? String {
            self.codeType = value
        }
        if let value = dict["SessionId"] as? Int64 {
            self.sessionId = value
        }
    }
}

public class ExecuteSparkReplStatementResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var aliyunUid: Int64?

        public var code: String?

        public var codeState: String?

        public var codeType: String?

        public var columns: [String]?

        public var endTime: Int64?

        public var error: String?

        public var output: String?

        public var outputType: String?

        public var startTime: Int64?

        public var statementId: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.aliyunUid != nil {
                map["AliyunUid"] = self.aliyunUid!
            }
            if self.code != nil {
                map["Code"] = self.code!
            }
            if self.codeState != nil {
                map["CodeState"] = self.codeState!
            }
            if self.codeType != nil {
                map["CodeType"] = self.codeType!
            }
            if self.columns != nil {
                map["Columns"] = self.columns!
            }
            if self.endTime != nil {
                map["EndTime"] = self.endTime!
            }
            if self.error != nil {
                map["Error"] = self.error!
            }
            if self.output != nil {
                map["Output"] = self.output!
            }
            if self.outputType != nil {
                map["OutputType"] = self.outputType!
            }
            if self.startTime != nil {
                map["StartTime"] = self.startTime!
            }
            if self.statementId != nil {
                map["StatementId"] = self.statementId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AliyunUid"] as? Int64 {
                self.aliyunUid = value
            }
            if let value = dict["Code"] as? String {
                self.code = value
            }
            if let value = dict["CodeState"] as? String {
                self.codeState = value
            }
            if let value = dict["CodeType"] as? String {
                self.codeType = value
            }
            if let value = dict["Columns"] as? [String] {
                self.columns = value
            }
            if let value = dict["EndTime"] as? Int64 {
                self.endTime = value
            }
            if let value = dict["Error"] as? String {
                self.error = value
            }
            if let value = dict["Output"] as? String {
                self.output = value
            }
            if let value = dict["OutputType"] as? String {
                self.outputType = value
            }
            if let value = dict["StartTime"] as? Int64 {
                self.startTime = value
            }
            if let value = dict["StatementId"] as? Int64 {
                self.statementId = value
            }
        }
    }
    public var data: ExecuteSparkReplStatementResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [String: Any?] {
            var model = ExecuteSparkReplStatementResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ExecuteSparkReplStatementResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ExecuteSparkReplStatementResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ExecuteSparkReplStatementResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ExecuteSparkWarehouseBatchSQLRequest : Tea.TeaModel {
    public var agency: String?

    public var DBClusterId: String?

    public var executeResultLimit: Int64?

    public var executeTimeLimitInSeconds: Int64?

    public var query: String?

    public var resourceGroupName: String?

    public var runtimeConfig: String?

    public var schema: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.agency != nil {
            map["Agency"] = self.agency!
        }
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.executeResultLimit != nil {
            map["ExecuteResultLimit"] = self.executeResultLimit!
        }
        if self.executeTimeLimitInSeconds != nil {
            map["ExecuteTimeLimitInSeconds"] = self.executeTimeLimitInSeconds!
        }
        if self.query != nil {
            map["Query"] = self.query!
        }
        if self.resourceGroupName != nil {
            map["ResourceGroupName"] = self.resourceGroupName!
        }
        if self.runtimeConfig != nil {
            map["RuntimeConfig"] = self.runtimeConfig!
        }
        if self.schema != nil {
            map["Schema"] = self.schema!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Agency"] as? String {
            self.agency = value
        }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["ExecuteResultLimit"] as? Int64 {
            self.executeResultLimit = value
        }
        if let value = dict["ExecuteTimeLimitInSeconds"] as? Int64 {
            self.executeTimeLimitInSeconds = value
        }
        if let value = dict["Query"] as? String {
            self.query = value
        }
        if let value = dict["ResourceGroupName"] as? String {
            self.resourceGroupName = value
        }
        if let value = dict["RuntimeConfig"] as? String {
            self.runtimeConfig = value
        }
        if let value = dict["Schema"] as? String {
            self.schema = value
        }
    }
}

public class ExecuteSparkWarehouseBatchSQLResponseBody : Tea.TeaModel {
    public var data: SparkBatchSQL?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [String: Any?] {
            var model = SparkBatchSQL()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ExecuteSparkWarehouseBatchSQLResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ExecuteSparkWarehouseBatchSQLResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ExecuteSparkWarehouseBatchSQLResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ExistRunningSQLEngineRequest : Tea.TeaModel {
    public var DBClusterId: String?

    public var resourceGroupName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.resourceGroupName != nil {
            map["ResourceGroupName"] = self.resourceGroupName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["ResourceGroupName"] as? String {
            self.resourceGroupName = value
        }
    }
}

public class ExistRunningSQLEngineResponseBody : Tea.TeaModel {
    public var data: Bool?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? Bool {
            self.data = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ExistRunningSQLEngineResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ExistRunningSQLEngineResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ExistRunningSQLEngineResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetApsManagedDatabasesRequest : Tea.TeaModel {
    public var DBClusterId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class GetApsManagedDatabasesResponseBody : Tea.TeaModel {
    public var data: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? String {
            self.data = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class GetApsManagedDatabasesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetApsManagedDatabasesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetApsManagedDatabasesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetCreateTableSQLRequest : Tea.TeaModel {
    public var DBClusterId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var schemaName: String?

    public var tableName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.schemaName != nil {
            map["SchemaName"] = self.schemaName!
        }
        if self.tableName != nil {
            map["TableName"] = self.tableName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["SchemaName"] as? String {
            self.schemaName = value
        }
        if let value = dict["TableName"] as? String {
            self.tableName = value
        }
    }
}

public class GetCreateTableSQLResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var SQL: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.SQL != nil {
            map["SQL"] = self.SQL!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["SQL"] as? String {
            self.SQL = value
        }
    }
}

public class GetCreateTableSQLResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetCreateTableSQLResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetCreateTableSQLResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetDatabaseObjectsRequest : Tea.TeaModel {
    public var DBClusterId: String?

    public var filterOwner: String?

    public var filterSchemaName: String?

    public var orderBy: String?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.filterOwner != nil {
            map["FilterOwner"] = self.filterOwner!
        }
        if self.filterSchemaName != nil {
            map["FilterSchemaName"] = self.filterSchemaName!
        }
        if self.orderBy != nil {
            map["OrderBy"] = self.orderBy!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["FilterOwner"] as? String {
            self.filterOwner = value
        }
        if let value = dict["FilterSchemaName"] as? String {
            self.filterSchemaName = value
        }
        if let value = dict["OrderBy"] as? String {
            self.orderBy = value
        }
        if let value = dict["PageNumber"] as? Int64 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int64 {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class GetDatabaseObjectsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var databaseSummaryModels: [DatabaseSummaryModel]?

        public var pageNumber: Int64?

        public var pageSize: Int64?

        public var totalCount: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.databaseSummaryModels != nil {
                var tmp : [Any] = []
                for k in self.databaseSummaryModels! {
                    tmp.append(k.toMap())
                }
                map["DatabaseSummaryModels"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DatabaseSummaryModels"] as? [Any?] {
                var tmp : [DatabaseSummaryModel] = []
                for v in value {
                    if v != nil {
                        var model = DatabaseSummaryModel()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.databaseSummaryModels = tmp
            }
            if let value = dict["PageNumber"] as? Int64 {
                self.pageNumber = value
            }
            if let value = dict["PageSize"] as? Int64 {
                self.pageSize = value
            }
            if let value = dict["TotalCount"] as? Int64 {
                self.totalCount = value
            }
        }
    }
    public var data: GetDatabaseObjectsResponseBody.Data?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var requestId: String?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [String: Any?] {
            var model = GetDatabaseObjectsResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["PageNumber"] as? Int64 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int64 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? Int64 {
            self.totalCount = value
        }
    }
}

public class GetDatabaseObjectsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetDatabaseObjectsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetDatabaseObjectsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetLakeStorageRequest : Tea.TeaModel {
    public var DBClusterId: String?

    public var lakeStorageId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.lakeStorageId != nil {
            map["LakeStorageId"] = self.lakeStorageId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["LakeStorageId"] as? String {
            self.lakeStorageId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class GetLakeStorageResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Permissions : Tea.TeaModel {
            public var account: String?

            public var read: Bool?

            public var type: String?

            public var write: Bool?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.account != nil {
                    map["Account"] = self.account!
                }
                if self.read != nil {
                    map["Read"] = self.read!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.write != nil {
                    map["Write"] = self.write!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Account"] as? String {
                    self.account = value
                }
                if let value = dict["Read"] as? Bool {
                    self.read = value
                }
                if let value = dict["Type"] as? String {
                    self.type = value
                }
                if let value = dict["Write"] as? Bool {
                    self.write = value
                }
            }
        }
        public var createTime: String?

        public var creatorUid: String?

        public var DBClusterId: String?

        public var description_: String?

        public var fileSize: String?

        public var lakeStorageId: String?

        public var operatorUid: String?

        public var ownerUid: String?

        public var partitionCount: String?

        public var permissions: [GetLakeStorageResponseBody.Data.Permissions]?

        public var regionId: String?

        public var rowCount: Int64?

        public var tableCount: Int32?

        public var updateTime: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.creatorUid != nil {
                map["CreatorUid"] = self.creatorUid!
            }
            if self.DBClusterId != nil {
                map["DBClusterId"] = self.DBClusterId!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.fileSize != nil {
                map["FileSize"] = self.fileSize!
            }
            if self.lakeStorageId != nil {
                map["LakeStorageId"] = self.lakeStorageId!
            }
            if self.operatorUid != nil {
                map["OperatorUid"] = self.operatorUid!
            }
            if self.ownerUid != nil {
                map["OwnerUid"] = self.ownerUid!
            }
            if self.partitionCount != nil {
                map["PartitionCount"] = self.partitionCount!
            }
            if self.permissions != nil {
                var tmp : [Any] = []
                for k in self.permissions! {
                    tmp.append(k.toMap())
                }
                map["Permissions"] = tmp
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.rowCount != nil {
                map["RowCount"] = self.rowCount!
            }
            if self.tableCount != nil {
                map["TableCount"] = self.tableCount!
            }
            if self.updateTime != nil {
                map["UpdateTime"] = self.updateTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["CreateTime"] as? String {
                self.createTime = value
            }
            if let value = dict["CreatorUid"] as? String {
                self.creatorUid = value
            }
            if let value = dict["DBClusterId"] as? String {
                self.DBClusterId = value
            }
            if let value = dict["Description"] as? String {
                self.description_ = value
            }
            if let value = dict["FileSize"] as? String {
                self.fileSize = value
            }
            if let value = dict["LakeStorageId"] as? String {
                self.lakeStorageId = value
            }
            if let value = dict["OperatorUid"] as? String {
                self.operatorUid = value
            }
            if let value = dict["OwnerUid"] as? String {
                self.ownerUid = value
            }
            if let value = dict["PartitionCount"] as? String {
                self.partitionCount = value
            }
            if let value = dict["Permissions"] as? [Any?] {
                var tmp : [GetLakeStorageResponseBody.Data.Permissions] = []
                for v in value {
                    if v != nil {
                        var model = GetLakeStorageResponseBody.Data.Permissions()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.permissions = tmp
            }
            if let value = dict["RegionId"] as? String {
                self.regionId = value
            }
            if let value = dict["RowCount"] as? Int64 {
                self.rowCount = value
            }
            if let value = dict["TableCount"] as? Int32 {
                self.tableCount = value
            }
            if let value = dict["UpdateTime"] as? String {
                self.updateTime = value
            }
        }
    }
    public var code: String?

    public var data: GetLakeStorageResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = GetLakeStorageResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class GetLakeStorageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetLakeStorageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetLakeStorageResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetSparkAppAttemptLogRequest : Tea.TeaModel {
    public var attemptId: String?

    public var logLength: Int64?

    public var pageNumber: Int32?

    public var pageSize: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.attemptId != nil {
            map["AttemptId"] = self.attemptId!
        }
        if self.logLength != nil {
            map["LogLength"] = self.logLength!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AttemptId"] as? String {
            self.attemptId = value
        }
        if let value = dict["LogLength"] as? Int64 {
            self.logLength = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? String {
            self.pageSize = value
        }
    }
}

public class GetSparkAppAttemptLogResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var appId: String?

        public var DBClusterId: String?

        public var logContent: String?

        public var logSize: Int32?

        public var message: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appId != nil {
                map["AppId"] = self.appId!
            }
            if self.DBClusterId != nil {
                map["DBClusterId"] = self.DBClusterId!
            }
            if self.logContent != nil {
                map["LogContent"] = self.logContent!
            }
            if self.logSize != nil {
                map["LogSize"] = self.logSize!
            }
            if self.message != nil {
                map["Message"] = self.message!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AppId"] as? String {
                self.appId = value
            }
            if let value = dict["DBClusterId"] as? String {
                self.DBClusterId = value
            }
            if let value = dict["LogContent"] as? String {
                self.logContent = value
            }
            if let value = dict["LogSize"] as? Int32 {
                self.logSize = value
            }
            if let value = dict["Message"] as? String {
                self.message = value
            }
        }
    }
    public var data: GetSparkAppAttemptLogResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [String: Any?] {
            var model = GetSparkAppAttemptLogResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class GetSparkAppAttemptLogResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetSparkAppAttemptLogResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetSparkAppAttemptLogResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetSparkAppInfoRequest : Tea.TeaModel {
    public var appId: String?

    public var DBClusterId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
    }
}

public class GetSparkAppInfoResponseBody : Tea.TeaModel {
    public var data: SparkAppInfo?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [String: Any?] {
            var model = SparkAppInfo()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class GetSparkAppInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetSparkAppInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetSparkAppInfoResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetSparkAppLogRequest : Tea.TeaModel {
    public var appId: String?

    public var DBClusterId: String?

    public var logLength: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.logLength != nil {
            map["LogLength"] = self.logLength!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["LogLength"] as? Int64 {
            self.logLength = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
    }
}

public class GetSparkAppLogResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var DBClusterId: String?

        public var logContent: String?

        public var logSize: Int32?

        public var message: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.DBClusterId != nil {
                map["DBClusterId"] = self.DBClusterId!
            }
            if self.logContent != nil {
                map["LogContent"] = self.logContent!
            }
            if self.logSize != nil {
                map["LogSize"] = self.logSize!
            }
            if self.message != nil {
                map["Message"] = self.message!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DBClusterId"] as? String {
                self.DBClusterId = value
            }
            if let value = dict["LogContent"] as? String {
                self.logContent = value
            }
            if let value = dict["LogSize"] as? Int32 {
                self.logSize = value
            }
            if let value = dict["Message"] as? String {
                self.message = value
            }
        }
    }
    public var data: GetSparkAppLogResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [String: Any?] {
            var model = GetSparkAppLogResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class GetSparkAppLogResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetSparkAppLogResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetSparkAppLogResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetSparkAppMetricsRequest : Tea.TeaModel {
    public var appId: String?

    public var DBClusterId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
    }
}

public class GetSparkAppMetricsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class ScanMetrics : Tea.TeaModel {
            public var outputRowsCount: Int64?

            public var totalReadFileSizeInByte: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.outputRowsCount != nil {
                    map["OutputRowsCount"] = self.outputRowsCount!
                }
                if self.totalReadFileSizeInByte != nil {
                    map["TotalReadFileSizeInByte"] = self.totalReadFileSizeInByte!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["OutputRowsCount"] as? Int64 {
                    self.outputRowsCount = value
                }
                if let value = dict["TotalReadFileSizeInByte"] as? Int64 {
                    self.totalReadFileSizeInByte = value
                }
            }
        }
        public var appId: String?

        public var attemptId: String?

        public var eventLogPath: String?

        public var finished: Bool?

        public var scanMetrics: GetSparkAppMetricsResponseBody.Data.ScanMetrics?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.scanMetrics?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appId != nil {
                map["AppId"] = self.appId!
            }
            if self.attemptId != nil {
                map["AttemptId"] = self.attemptId!
            }
            if self.eventLogPath != nil {
                map["EventLogPath"] = self.eventLogPath!
            }
            if self.finished != nil {
                map["Finished"] = self.finished!
            }
            if self.scanMetrics != nil {
                map["ScanMetrics"] = self.scanMetrics?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AppId"] as? String {
                self.appId = value
            }
            if let value = dict["AttemptId"] as? String {
                self.attemptId = value
            }
            if let value = dict["EventLogPath"] as? String {
                self.eventLogPath = value
            }
            if let value = dict["Finished"] as? Bool {
                self.finished = value
            }
            if let value = dict["ScanMetrics"] as? [String: Any?] {
                var model = GetSparkAppMetricsResponseBody.Data.ScanMetrics()
                model.fromMap(value)
                self.scanMetrics = model
            }
        }
    }
    public var data: GetSparkAppMetricsResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [String: Any?] {
            var model = GetSparkAppMetricsResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class GetSparkAppMetricsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetSparkAppMetricsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetSparkAppMetricsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetSparkAppStateRequest : Tea.TeaModel {
    public var appId: String?

    public var DBClusterId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
    }
}

public class GetSparkAppStateResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var appId: String?

        public var appName: String?

        public var DBClusterId: String?

        public var message: String?

        public var state: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appId != nil {
                map["AppId"] = self.appId!
            }
            if self.appName != nil {
                map["AppName"] = self.appName!
            }
            if self.DBClusterId != nil {
                map["DBClusterId"] = self.DBClusterId!
            }
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AppId"] as? String {
                self.appId = value
            }
            if let value = dict["AppName"] as? String {
                self.appName = value
            }
            if let value = dict["DBClusterId"] as? String {
                self.DBClusterId = value
            }
            if let value = dict["Message"] as? String {
                self.message = value
            }
            if let value = dict["State"] as? String {
                self.state = value
            }
        }
    }
    public var data: GetSparkAppStateResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [String: Any?] {
            var model = GetSparkAppStateResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class GetSparkAppStateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetSparkAppStateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetSparkAppStateResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetSparkAppWebUiAddressRequest : Tea.TeaModel {
    public var appId: String?

    public var DBClusterId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
    }
}

public class GetSparkAppWebUiAddressResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var appId: String?

        public var DBClusterId: String?

        public var expirationTimeInMillis: Int64?

        public var webUiAddress: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appId != nil {
                map["AppId"] = self.appId!
            }
            if self.DBClusterId != nil {
                map["DBClusterId"] = self.DBClusterId!
            }
            if self.expirationTimeInMillis != nil {
                map["ExpirationTimeInMillis"] = self.expirationTimeInMillis!
            }
            if self.webUiAddress != nil {
                map["WebUiAddress"] = self.webUiAddress!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AppId"] as? String {
                self.appId = value
            }
            if let value = dict["DBClusterId"] as? String {
                self.DBClusterId = value
            }
            if let value = dict["ExpirationTimeInMillis"] as? Int64 {
                self.expirationTimeInMillis = value
            }
            if let value = dict["WebUiAddress"] as? String {
                self.webUiAddress = value
            }
        }
    }
    public var data: GetSparkAppWebUiAddressResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [String: Any?] {
            var model = GetSparkAppWebUiAddressResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class GetSparkAppWebUiAddressResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetSparkAppWebUiAddressResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetSparkAppWebUiAddressResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetSparkConfigLogPathRequest : Tea.TeaModel {
    public var DBClusterId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
    }
}

public class GetSparkConfigLogPathResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var defaultLogPath: String?

        public var isLogPathExists: Bool?

        public var modifiedTimestamp: String?

        public var modifiedUid: String?

        public var recordedLogPath: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.defaultLogPath != nil {
                map["DefaultLogPath"] = self.defaultLogPath!
            }
            if self.isLogPathExists != nil {
                map["IsLogPathExists"] = self.isLogPathExists!
            }
            if self.modifiedTimestamp != nil {
                map["ModifiedTimestamp"] = self.modifiedTimestamp!
            }
            if self.modifiedUid != nil {
                map["ModifiedUid"] = self.modifiedUid!
            }
            if self.recordedLogPath != nil {
                map["RecordedLogPath"] = self.recordedLogPath!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DefaultLogPath"] as? String {
                self.defaultLogPath = value
            }
            if let value = dict["IsLogPathExists"] as? Bool {
                self.isLogPathExists = value
            }
            if let value = dict["ModifiedTimestamp"] as? String {
                self.modifiedTimestamp = value
            }
            if let value = dict["ModifiedUid"] as? String {
                self.modifiedUid = value
            }
            if let value = dict["RecordedLogPath"] as? String {
                self.recordedLogPath = value
            }
        }
    }
    public var data: GetSparkConfigLogPathResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [String: Any?] {
            var model = GetSparkConfigLogPathResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class GetSparkConfigLogPathResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetSparkConfigLogPathResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetSparkConfigLogPathResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetSparkLogAnalyzeTaskRequest : Tea.TeaModel {
    public var taskId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["TaskId"] as? Int64 {
            self.taskId = value
        }
    }
}

public class GetSparkLogAnalyzeTaskResponseBody : Tea.TeaModel {
    public var data: SparkAnalyzeLogTask?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [String: Any?] {
            var model = SparkAnalyzeLogTask()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class GetSparkLogAnalyzeTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetSparkLogAnalyzeTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetSparkLogAnalyzeTaskResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetSparkReplSessionRequest : Tea.TeaModel {
    public var appId: String?

    public var sessionId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.sessionId != nil {
            map["SessionId"] = self.sessionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["SessionId"] as? Int64 {
            self.sessionId = value
        }
    }
}

public class GetSparkReplSessionResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var active: String?

        public var aliyunUid: String?

        public var attemptId: String?

        public var error: String?

        public var sessionId: Int64?

        public var state: String?

        public var webUiAddress: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.active != nil {
                map["Active"] = self.active!
            }
            if self.aliyunUid != nil {
                map["AliyunUid"] = self.aliyunUid!
            }
            if self.attemptId != nil {
                map["AttemptId"] = self.attemptId!
            }
            if self.error != nil {
                map["Error"] = self.error!
            }
            if self.sessionId != nil {
                map["SessionId"] = self.sessionId!
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            if self.webUiAddress != nil {
                map["WebUiAddress"] = self.webUiAddress!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Active"] as? String {
                self.active = value
            }
            if let value = dict["AliyunUid"] as? String {
                self.aliyunUid = value
            }
            if let value = dict["AttemptId"] as? String {
                self.attemptId = value
            }
            if let value = dict["Error"] as? String {
                self.error = value
            }
            if let value = dict["SessionId"] as? Int64 {
                self.sessionId = value
            }
            if let value = dict["State"] as? String {
                self.state = value
            }
            if let value = dict["WebUiAddress"] as? String {
                self.webUiAddress = value
            }
        }
    }
    public var data: GetSparkReplSessionResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [String: Any?] {
            var model = GetSparkReplSessionResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class GetSparkReplSessionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetSparkReplSessionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetSparkReplSessionResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetSparkReplStatementRequest : Tea.TeaModel {
    public var appId: String?

    public var sessionId: Int64?

    public var statementId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.sessionId != nil {
            map["SessionId"] = self.sessionId!
        }
        if self.statementId != nil {
            map["StatementId"] = self.statementId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["SessionId"] as? Int64 {
            self.sessionId = value
        }
        if let value = dict["StatementId"] as? Int64 {
            self.statementId = value
        }
    }
}

public class GetSparkReplStatementResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var aliyunUid: Int64?

        public var code: String?

        public var codeState: String?

        public var codeType: String?

        public var columns: [String]?

        public var endTime: Int64?

        public var error: String?

        public var output: String?

        public var outputType: String?

        public var startTime: Int64?

        public var statementId: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.aliyunUid != nil {
                map["AliyunUid"] = self.aliyunUid!
            }
            if self.code != nil {
                map["Code"] = self.code!
            }
            if self.codeState != nil {
                map["CodeState"] = self.codeState!
            }
            if self.codeType != nil {
                map["CodeType"] = self.codeType!
            }
            if self.columns != nil {
                map["Columns"] = self.columns!
            }
            if self.endTime != nil {
                map["EndTime"] = self.endTime!
            }
            if self.error != nil {
                map["Error"] = self.error!
            }
            if self.output != nil {
                map["Output"] = self.output!
            }
            if self.outputType != nil {
                map["OutputType"] = self.outputType!
            }
            if self.startTime != nil {
                map["StartTime"] = self.startTime!
            }
            if self.statementId != nil {
                map["StatementId"] = self.statementId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AliyunUid"] as? Int64 {
                self.aliyunUid = value
            }
            if let value = dict["Code"] as? String {
                self.code = value
            }
            if let value = dict["CodeState"] as? String {
                self.codeState = value
            }
            if let value = dict["CodeType"] as? String {
                self.codeType = value
            }
            if let value = dict["Columns"] as? [String] {
                self.columns = value
            }
            if let value = dict["EndTime"] as? Int64 {
                self.endTime = value
            }
            if let value = dict["Error"] as? String {
                self.error = value
            }
            if let value = dict["Output"] as? String {
                self.output = value
            }
            if let value = dict["OutputType"] as? String {
                self.outputType = value
            }
            if let value = dict["StartTime"] as? Int64 {
                self.startTime = value
            }
            if let value = dict["StatementId"] as? Int64 {
                self.statementId = value
            }
        }
    }
    public var data: GetSparkReplStatementResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [String: Any?] {
            var model = GetSparkReplStatementResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class GetSparkReplStatementResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetSparkReplStatementResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetSparkReplStatementResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetSparkSQLEngineStateRequest : Tea.TeaModel {
    public var DBClusterId: String?

    public var resourceGroupName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.resourceGroupName != nil {
            map["ResourceGroupName"] = self.resourceGroupName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["ResourceGroupName"] as? String {
            self.resourceGroupName = value
        }
    }
}

public class GetSparkSQLEngineStateResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var appId: String?

        public var config: String?

        public var jars: String?

        public var maxExecutor: String?

        public var minExecutor: String?

        public var slotNum: String?

        public var state: String?

        public var submittedTimeInMillis: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appId != nil {
                map["AppId"] = self.appId!
            }
            if self.config != nil {
                map["Config"] = self.config!
            }
            if self.jars != nil {
                map["Jars"] = self.jars!
            }
            if self.maxExecutor != nil {
                map["MaxExecutor"] = self.maxExecutor!
            }
            if self.minExecutor != nil {
                map["MinExecutor"] = self.minExecutor!
            }
            if self.slotNum != nil {
                map["SlotNum"] = self.slotNum!
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            if self.submittedTimeInMillis != nil {
                map["SubmittedTimeInMillis"] = self.submittedTimeInMillis!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AppId"] as? String {
                self.appId = value
            }
            if let value = dict["Config"] as? String {
                self.config = value
            }
            if let value = dict["Jars"] as? String {
                self.jars = value
            }
            if let value = dict["MaxExecutor"] as? String {
                self.maxExecutor = value
            }
            if let value = dict["MinExecutor"] as? String {
                self.minExecutor = value
            }
            if let value = dict["SlotNum"] as? String {
                self.slotNum = value
            }
            if let value = dict["State"] as? String {
                self.state = value
            }
            if let value = dict["SubmittedTimeInMillis"] as? String {
                self.submittedTimeInMillis = value
            }
        }
    }
    public var data: GetSparkSQLEngineStateResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [String: Any?] {
            var model = GetSparkSQLEngineStateResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class GetSparkSQLEngineStateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetSparkSQLEngineStateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetSparkSQLEngineStateResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetSparkTemplateFileContentRequest : Tea.TeaModel {
    public var DBClusterId: String?

    public var id: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["Id"] as? Int64 {
            self.id = value
        }
    }
}

public class GetSparkTemplateFileContentResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var appType: String?

        public var content: String?

        public var id: Int64?

        public var resourceGroupName: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appType != nil {
                map["AppType"] = self.appType!
            }
            if self.content != nil {
                map["Content"] = self.content!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.resourceGroupName != nil {
                map["ResourceGroupName"] = self.resourceGroupName!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AppType"] as? String {
                self.appType = value
            }
            if let value = dict["Content"] as? String {
                self.content = value
            }
            if let value = dict["Id"] as? Int64 {
                self.id = value
            }
            if let value = dict["ResourceGroupName"] as? String {
                self.resourceGroupName = value
            }
            if let value = dict["Type"] as? String {
                self.type = value
            }
        }
    }
    public var data: GetSparkTemplateFileContentResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [String: Any?] {
            var model = GetSparkTemplateFileContentResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class GetSparkTemplateFileContentResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetSparkTemplateFileContentResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetSparkTemplateFileContentResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetSparkTemplateFolderTreeRequest : Tea.TeaModel {
    public var DBClusterId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
    }
}

public class GetSparkTemplateFolderTreeResponseBody : Tea.TeaModel {
    public var data: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? String {
            self.data = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class GetSparkTemplateFolderTreeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetSparkTemplateFolderTreeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetSparkTemplateFolderTreeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetSparkTemplateFullTreeRequest : Tea.TeaModel {
    public var DBClusterId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
    }
}

public class GetSparkTemplateFullTreeResponseBody : Tea.TeaModel {
    public var data: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? String {
            self.data = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class GetSparkTemplateFullTreeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetSparkTemplateFullTreeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetSparkTemplateFullTreeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetSparkWarehouseBatchSQLRequest : Tea.TeaModel {
    public var agency: String?

    public var DBClusterId: String?

    public var queryId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.agency != nil {
            map["Agency"] = self.agency!
        }
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.queryId != nil {
            map["QueryId"] = self.queryId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Agency"] as? String {
            self.agency = value
        }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["QueryId"] as? String {
            self.queryId = value
        }
    }
}

public class GetSparkWarehouseBatchSQLResponseBody : Tea.TeaModel {
    public var data: SparkBatchSQL?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [String: Any?] {
            var model = SparkBatchSQL()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class GetSparkWarehouseBatchSQLResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetSparkWarehouseBatchSQLResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetSparkWarehouseBatchSQLResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetTableRequest : Tea.TeaModel {
    public var DBClusterId: String?

    public var dbName: String?

    public var regionId: String?

    public var tableName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.dbName != nil {
            map["DbName"] = self.dbName!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.tableName != nil {
            map["TableName"] = self.tableName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["DbName"] as? String {
            self.dbName = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["TableName"] as? String {
            self.tableName = value
        }
    }
}

public class GetTableResponseBody : Tea.TeaModel {
    public var code: Int64?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var table: TableModel?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.table?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.table != nil {
            map["Table"] = self.table?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? Int64 {
            self.code = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
        if let value = dict["Table"] as? [String: Any?] {
            var model = TableModel()
            model.fromMap(value)
            self.table = model
        }
    }
}

public class GetTableResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetTableResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetTableResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetTableColumnsRequest : Tea.TeaModel {
    public var columnName: String?

    public var DBClusterId: String?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var regionId: String?

    public var schemaName: String?

    public var tableName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.columnName != nil {
            map["ColumnName"] = self.columnName!
        }
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.schemaName != nil {
            map["SchemaName"] = self.schemaName!
        }
        if self.tableName != nil {
            map["TableName"] = self.tableName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ColumnName"] as? String {
            self.columnName = value
        }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["PageNumber"] as? Int64 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int64 {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["SchemaName"] as? String {
            self.schemaName = value
        }
        if let value = dict["TableName"] as? String {
            self.tableName = value
        }
    }
}

public class GetTableColumnsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var pageNumber: Int64?

        public var pageSize: Int64?

        public var table: TableDetailModel?

        public var totalCount: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.table?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.table != nil {
                map["Table"] = self.table?.toMap()
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["PageNumber"] as? Int64 {
                self.pageNumber = value
            }
            if let value = dict["PageSize"] as? Int64 {
                self.pageSize = value
            }
            if let value = dict["Table"] as? [String: Any?] {
                var model = TableDetailModel()
                model.fromMap(value)
                self.table = model
            }
            if let value = dict["TotalCount"] as? Int64 {
                self.totalCount = value
            }
        }
    }
    public var data: GetTableColumnsResponseBody.Data?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var requestId: String?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [String: Any?] {
            var model = GetTableColumnsResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["PageNumber"] as? Int64 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int64 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? Int64 {
            self.totalCount = value
        }
    }
}

public class GetTableColumnsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetTableColumnsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetTableColumnsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetTableDDLRequest : Tea.TeaModel {
    public var DBClusterId: String?

    public var regionId: String?

    public var schemaName: String?

    public var tableName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.schemaName != nil {
            map["SchemaName"] = self.schemaName!
        }
        if self.tableName != nil {
            map["TableName"] = self.tableName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["SchemaName"] as? String {
            self.schemaName = value
        }
        if let value = dict["TableName"] as? String {
            self.tableName = value
        }
    }
}

public class GetTableDDLResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var SQL: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.SQL != nil {
            map["SQL"] = self.SQL!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["SQL"] as? String {
            self.SQL = value
        }
    }
}

public class GetTableDDLResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetTableDDLResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetTableDDLResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetTableObjectsRequest : Tea.TeaModel {
    public var DBClusterId: String?

    public var filterDescription: String?

    public var filterOwner: String?

    public var filterTblName: String?

    public var filterTblType: String?

    public var orderBy: String?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var regionId: String?

    public var schemaName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.filterDescription != nil {
            map["FilterDescription"] = self.filterDescription!
        }
        if self.filterOwner != nil {
            map["FilterOwner"] = self.filterOwner!
        }
        if self.filterTblName != nil {
            map["FilterTblName"] = self.filterTblName!
        }
        if self.filterTblType != nil {
            map["FilterTblType"] = self.filterTblType!
        }
        if self.orderBy != nil {
            map["OrderBy"] = self.orderBy!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.schemaName != nil {
            map["SchemaName"] = self.schemaName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["FilterDescription"] as? String {
            self.filterDescription = value
        }
        if let value = dict["FilterOwner"] as? String {
            self.filterOwner = value
        }
        if let value = dict["FilterTblName"] as? String {
            self.filterTblName = value
        }
        if let value = dict["FilterTblType"] as? String {
            self.filterTblType = value
        }
        if let value = dict["OrderBy"] as? String {
            self.orderBy = value
        }
        if let value = dict["PageNumber"] as? Int64 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int64 {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["SchemaName"] as? String {
            self.schemaName = value
        }
    }
}

public class GetTableObjectsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var pageNumber: Int64?

        public var pageSize: Int64?

        public var tableSummaryModels: [TableSummaryModel]?

        public var totalCount: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.tableSummaryModels != nil {
                var tmp : [Any] = []
                for k in self.tableSummaryModels! {
                    tmp.append(k.toMap())
                }
                map["TableSummaryModels"] = tmp
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["PageNumber"] as? Int64 {
                self.pageNumber = value
            }
            if let value = dict["PageSize"] as? Int64 {
                self.pageSize = value
            }
            if let value = dict["TableSummaryModels"] as? [Any?] {
                var tmp : [TableSummaryModel] = []
                for v in value {
                    if v != nil {
                        var model = TableSummaryModel()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.tableSummaryModels = tmp
            }
            if let value = dict["TotalCount"] as? Int64 {
                self.totalCount = value
            }
        }
    }
    public var data: GetTableObjectsResponseBody.Data?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var requestId: String?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [String: Any?] {
            var model = GetTableObjectsResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["PageNumber"] as? Int64 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int64 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? Int64 {
            self.totalCount = value
        }
    }
}

public class GetTableObjectsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetTableObjectsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetTableObjectsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetViewDDLRequest : Tea.TeaModel {
    public var DBClusterId: String?

    public var regionId: String?

    public var schemaName: String?

    public var viewName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.schemaName != nil {
            map["SchemaName"] = self.schemaName!
        }
        if self.viewName != nil {
            map["ViewName"] = self.viewName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["SchemaName"] as? String {
            self.schemaName = value
        }
        if let value = dict["ViewName"] as? String {
            self.viewName = value
        }
    }
}

public class GetViewDDLResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var SQL: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.SQL != nil {
            map["SQL"] = self.SQL!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["SQL"] as? String {
            self.SQL = value
        }
    }
}

public class GetViewDDLResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetViewDDLResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetViewDDLResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetViewObjectsRequest : Tea.TeaModel {
    public var DBClusterId: String?

    public var filterOwner: String?

    public var filterViewName: String?

    public var filterViewType: String?

    public var orderBy: String?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var regionId: String?

    public var schemaName: String?

    public var showMvBaseTable: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.filterOwner != nil {
            map["FilterOwner"] = self.filterOwner!
        }
        if self.filterViewName != nil {
            map["FilterViewName"] = self.filterViewName!
        }
        if self.filterViewType != nil {
            map["FilterViewType"] = self.filterViewType!
        }
        if self.orderBy != nil {
            map["OrderBy"] = self.orderBy!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.schemaName != nil {
            map["SchemaName"] = self.schemaName!
        }
        if self.showMvBaseTable != nil {
            map["ShowMvBaseTable"] = self.showMvBaseTable!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["FilterOwner"] as? String {
            self.filterOwner = value
        }
        if let value = dict["FilterViewName"] as? String {
            self.filterViewName = value
        }
        if let value = dict["FilterViewType"] as? String {
            self.filterViewType = value
        }
        if let value = dict["OrderBy"] as? String {
            self.orderBy = value
        }
        if let value = dict["PageNumber"] as? Int64 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int64 {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["SchemaName"] as? String {
            self.schemaName = value
        }
        if let value = dict["ShowMvBaseTable"] as? Bool {
            self.showMvBaseTable = value
        }
    }
}

public class GetViewObjectsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var pageNumber: Int64?

        public var pageSize: Int64?

        public var tableSummaryModels: [TableSummaryModel]?

        public var totalCount: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.tableSummaryModels != nil {
                var tmp : [Any] = []
                for k in self.tableSummaryModels! {
                    tmp.append(k.toMap())
                }
                map["TableSummaryModels"] = tmp
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["PageNumber"] as? Int64 {
                self.pageNumber = value
            }
            if let value = dict["PageSize"] as? Int64 {
                self.pageSize = value
            }
            if let value = dict["TableSummaryModels"] as? [Any?] {
                var tmp : [TableSummaryModel] = []
                for v in value {
                    if v != nil {
                        var model = TableSummaryModel()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.tableSummaryModels = tmp
            }
            if let value = dict["TotalCount"] as? Int64 {
                self.totalCount = value
            }
        }
    }
    public var data: GetViewObjectsResponseBody.Data?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var requestId: String?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [String: Any?] {
            var model = GetViewObjectsResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["PageNumber"] as? Int64 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int64 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? Int64 {
            self.totalCount = value
        }
    }
}

public class GetViewObjectsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetViewObjectsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetViewObjectsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GrantOperatorPermissionRequest : Tea.TeaModel {
    public var DBClusterId: String?

    public var expiredTime: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var privileges: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.expiredTime != nil {
            map["ExpiredTime"] = self.expiredTime!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.privileges != nil {
            map["Privileges"] = self.privileges!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["ExpiredTime"] as? String {
            self.expiredTime = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["Privileges"] as? String {
            self.privileges = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class GrantOperatorPermissionResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class GrantOperatorPermissionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GrantOperatorPermissionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GrantOperatorPermissionResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class KillProcessRequest : Tea.TeaModel {
    public var DBClusterId: String?

    public var processId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.processId != nil {
            map["ProcessId"] = self.processId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["ProcessId"] as? String {
            self.processId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class KillProcessResponseBody : Tea.TeaModel {
    public var accessDeniedDetail: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessDeniedDetail != nil {
            map["AccessDeniedDetail"] = self.accessDeniedDetail!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AccessDeniedDetail"] as? String {
            self.accessDeniedDetail = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class KillProcessResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: KillProcessResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = KillProcessResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class KillSparkAppRequest : Tea.TeaModel {
    public var appId: String?

    public var DBClusterId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
    }
}

public class KillSparkAppResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var appId: String?

        public var appName: String?

        public var DBClusterId: String?

        public var message: String?

        public var state: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appId != nil {
                map["AppId"] = self.appId!
            }
            if self.appName != nil {
                map["AppName"] = self.appName!
            }
            if self.DBClusterId != nil {
                map["DBClusterId"] = self.DBClusterId!
            }
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AppId"] as? String {
                self.appId = value
            }
            if let value = dict["AppName"] as? String {
                self.appName = value
            }
            if let value = dict["DBClusterId"] as? String {
                self.DBClusterId = value
            }
            if let value = dict["Message"] as? String {
                self.message = value
            }
            if let value = dict["State"] as? String {
                self.state = value
            }
        }
    }
    public var data: KillSparkAppResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [String: Any?] {
            var model = KillSparkAppResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class KillSparkAppResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: KillSparkAppResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = KillSparkAppResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class KillSparkLogAnalyzeTaskRequest : Tea.TeaModel {
    public var taskId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["TaskId"] as? Int64 {
            self.taskId = value
        }
    }
}

public class KillSparkLogAnalyzeTaskResponseBody : Tea.TeaModel {
    public var data: SparkAnalyzeLogTask?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [String: Any?] {
            var model = SparkAnalyzeLogTask()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class KillSparkLogAnalyzeTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: KillSparkLogAnalyzeTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = KillSparkLogAnalyzeTaskResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class KillSparkSQLEngineRequest : Tea.TeaModel {
    public var DBClusterId: String?

    public var resourceGroupName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.resourceGroupName != nil {
            map["ResourceGroupName"] = self.resourceGroupName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["ResourceGroupName"] as? String {
            self.resourceGroupName = value
        }
    }
}

public class KillSparkSQLEngineResponseBody : Tea.TeaModel {
    public var data: Bool?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? Bool {
            self.data = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class KillSparkSQLEngineResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: KillSparkSQLEngineResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = KillSparkSQLEngineResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListApsLifecycleStrategyRequest : Tea.TeaModel {
    public var DBClusterId: String?

    public var endTime: String?

    public var pageNumber: String?

    public var pageSize: String?

    public var regionId: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["PageNumber"] as? String {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? String {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
    }
}

public class ListApsLifecycleStrategyResponseBody : Tea.TeaModel {
    public class Items : Tea.TeaModel {
        public class OperationTables : Tea.TeaModel {
            public var databaseName: String?

            public var processAll: String?

            public var tableNames: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.databaseName != nil {
                    map["DatabaseName"] = self.databaseName!
                }
                if self.processAll != nil {
                    map["ProcessAll"] = self.processAll!
                }
                if self.tableNames != nil {
                    map["TableNames"] = self.tableNames!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["DatabaseName"] as? String {
                    self.databaseName = value
                }
                if let value = dict["ProcessAll"] as? String {
                    self.processAll = value
                }
                if let value = dict["TableNames"] as? [String] {
                    self.tableNames = value
                }
            }
        }
        public var apsJobId: String?

        public var createdTime: String?

        public var DBClusterId: String?

        public var modifiedTime: String?

        public var operationTables: [ListApsLifecycleStrategyResponseBody.Items.OperationTables]?

        public var status: String?

        public var strategyDatabases: Int64?

        public var strategyDesc: String?

        public var strategyName: String?

        public var strategyTables: Int64?

        public var strategyType: String?

        public var strategyValue: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.apsJobId != nil {
                map["ApsJobId"] = self.apsJobId!
            }
            if self.createdTime != nil {
                map["CreatedTime"] = self.createdTime!
            }
            if self.DBClusterId != nil {
                map["DBClusterId"] = self.DBClusterId!
            }
            if self.modifiedTime != nil {
                map["ModifiedTime"] = self.modifiedTime!
            }
            if self.operationTables != nil {
                var tmp : [Any] = []
                for k in self.operationTables! {
                    tmp.append(k.toMap())
                }
                map["OperationTables"] = tmp
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.strategyDatabases != nil {
                map["StrategyDatabases"] = self.strategyDatabases!
            }
            if self.strategyDesc != nil {
                map["StrategyDesc"] = self.strategyDesc!
            }
            if self.strategyName != nil {
                map["StrategyName"] = self.strategyName!
            }
            if self.strategyTables != nil {
                map["StrategyTables"] = self.strategyTables!
            }
            if self.strategyType != nil {
                map["StrategyType"] = self.strategyType!
            }
            if self.strategyValue != nil {
                map["StrategyValue"] = self.strategyValue!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ApsJobId"] as? String {
                self.apsJobId = value
            }
            if let value = dict["CreatedTime"] as? String {
                self.createdTime = value
            }
            if let value = dict["DBClusterId"] as? String {
                self.DBClusterId = value
            }
            if let value = dict["ModifiedTime"] as? String {
                self.modifiedTime = value
            }
            if let value = dict["OperationTables"] as? [Any?] {
                var tmp : [ListApsLifecycleStrategyResponseBody.Items.OperationTables] = []
                for v in value {
                    if v != nil {
                        var model = ListApsLifecycleStrategyResponseBody.Items.OperationTables()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.operationTables = tmp
            }
            if let value = dict["Status"] as? String {
                self.status = value
            }
            if let value = dict["StrategyDatabases"] as? Int64 {
                self.strategyDatabases = value
            }
            if let value = dict["StrategyDesc"] as? String {
                self.strategyDesc = value
            }
            if let value = dict["StrategyName"] as? String {
                self.strategyName = value
            }
            if let value = dict["StrategyTables"] as? Int64 {
                self.strategyTables = value
            }
            if let value = dict["StrategyType"] as? String {
                self.strategyType = value
            }
            if let value = dict["StrategyValue"] as? String {
                self.strategyValue = value
            }
        }
    }
    public var code: String?

    public var httpStatusCode: Int32?

    public var items: [ListApsLifecycleStrategyResponseBody.Items]?

    public var message: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var success: Bool?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.items != nil {
            var tmp : [Any] = []
            for k in self.items! {
                tmp.append(k.toMap())
            }
            map["Items"] = tmp
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["Items"] as? [Any?] {
            var tmp : [ListApsLifecycleStrategyResponseBody.Items] = []
            for v in value {
                if v != nil {
                    var model = ListApsLifecycleStrategyResponseBody.Items()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.items = tmp
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
        if let value = dict["TotalCount"] as? Int64 {
            self.totalCount = value
        }
    }
}

public class ListApsLifecycleStrategyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListApsLifecycleStrategyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListApsLifecycleStrategyResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListApsOptimizationStrategyRequest : Tea.TeaModel {
    public var DBClusterId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class ListApsOptimizationStrategyResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var DBClusterId: String?

        public var status: String?

        public var strategyDesc: String?

        public var strategyName: String?

        public var strategyType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.DBClusterId != nil {
                map["DBClusterId"] = self.DBClusterId!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.strategyDesc != nil {
                map["StrategyDesc"] = self.strategyDesc!
            }
            if self.strategyName != nil {
                map["StrategyName"] = self.strategyName!
            }
            if self.strategyType != nil {
                map["StrategyType"] = self.strategyType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DBClusterId"] as? String {
                self.DBClusterId = value
            }
            if let value = dict["Status"] as? String {
                self.status = value
            }
            if let value = dict["StrategyDesc"] as? String {
                self.strategyDesc = value
            }
            if let value = dict["StrategyName"] as? String {
                self.strategyName = value
            }
            if let value = dict["StrategyType"] as? String {
                self.strategyType = value
            }
        }
    }
    public var code: String?

    public var data: [ListApsOptimizationStrategyResponseBody.Data]?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? [Any?] {
            var tmp : [ListApsOptimizationStrategyResponseBody.Data] = []
            for v in value {
                if v != nil {
                    var model = ListApsOptimizationStrategyResponseBody.Data()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.data = tmp
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class ListApsOptimizationStrategyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListApsOptimizationStrategyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListApsOptimizationStrategyResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListApsOptimizationTasksRequest : Tea.TeaModel {
    public var DBClusterId: String?

    public var endTime: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var startTime: String?

    public var strategyType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.strategyType != nil {
            map["StrategyType"] = self.strategyType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
        if let value = dict["StrategyType"] as? String {
            self.strategyType = value
        }
    }
}

public class ListApsOptimizationTasksResponseBody : Tea.TeaModel {
    public class Items : Tea.TeaModel {
        public var computeUnit: String?

        public var createdTime: String?

        public var DBClusterId: String?

        public var modifiedTime: String?

        public var strategyType: String?

        public var taskDesc: String?

        public var taskDuration: Int64?

        public var taskId: String?

        public var taskMessage: String?

        public var taskStatus: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.computeUnit != nil {
                map["ComputeUnit"] = self.computeUnit!
            }
            if self.createdTime != nil {
                map["CreatedTime"] = self.createdTime!
            }
            if self.DBClusterId != nil {
                map["DBClusterId"] = self.DBClusterId!
            }
            if self.modifiedTime != nil {
                map["ModifiedTime"] = self.modifiedTime!
            }
            if self.strategyType != nil {
                map["StrategyType"] = self.strategyType!
            }
            if self.taskDesc != nil {
                map["TaskDesc"] = self.taskDesc!
            }
            if self.taskDuration != nil {
                map["TaskDuration"] = self.taskDuration!
            }
            if self.taskId != nil {
                map["TaskId"] = self.taskId!
            }
            if self.taskMessage != nil {
                map["TaskMessage"] = self.taskMessage!
            }
            if self.taskStatus != nil {
                map["TaskStatus"] = self.taskStatus!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ComputeUnit"] as? String {
                self.computeUnit = value
            }
            if let value = dict["CreatedTime"] as? String {
                self.createdTime = value
            }
            if let value = dict["DBClusterId"] as? String {
                self.DBClusterId = value
            }
            if let value = dict["ModifiedTime"] as? String {
                self.modifiedTime = value
            }
            if let value = dict["StrategyType"] as? String {
                self.strategyType = value
            }
            if let value = dict["TaskDesc"] as? String {
                self.taskDesc = value
            }
            if let value = dict["TaskDuration"] as? Int64 {
                self.taskDuration = value
            }
            if let value = dict["TaskId"] as? String {
                self.taskId = value
            }
            if let value = dict["TaskMessage"] as? String {
                self.taskMessage = value
            }
            if let value = dict["TaskStatus"] as? String {
                self.taskStatus = value
            }
        }
    }
    public var code: String?

    public var httpStatusCode: Int32?

    public var items: [ListApsOptimizationTasksResponseBody.Items]?

    public var message: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var success: Bool?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.items != nil {
            var tmp : [Any] = []
            for k in self.items! {
                tmp.append(k.toMap())
            }
            map["Items"] = tmp
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["Items"] as? [Any?] {
            var tmp : [ListApsOptimizationTasksResponseBody.Items] = []
            for v in value {
                if v != nil {
                    var model = ListApsOptimizationTasksResponseBody.Items()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.items = tmp
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
        if let value = dict["TotalCount"] as? Int64 {
            self.totalCount = value
        }
    }
}

public class ListApsOptimizationTasksResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListApsOptimizationTasksResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListApsOptimizationTasksResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListLakeStoragesRequest : Tea.TeaModel {
    public var DBClusterId: String?

    public var filter: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.filter != nil {
            map["Filter"] = self.filter!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["Filter"] as? String {
            self.filter = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class ListLakeStoragesResponseBody : Tea.TeaModel {
    public class Items : Tea.TeaModel {
        public class Permissions : Tea.TeaModel {
            public var account: String?

            public var read: Bool?

            public var type: String?

            public var write: Bool?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.account != nil {
                    map["Account"] = self.account!
                }
                if self.read != nil {
                    map["Read"] = self.read!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.write != nil {
                    map["Write"] = self.write!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Account"] as? String {
                    self.account = value
                }
                if let value = dict["Read"] as? Bool {
                    self.read = value
                }
                if let value = dict["Type"] as? String {
                    self.type = value
                }
                if let value = dict["Write"] as? Bool {
                    self.write = value
                }
            }
        }
        public var createTime: String?

        public var creatorUid: String?

        public var DBClusterId: String?

        public var description_: String?

        public var fileSize: String?

        public var lakeStorageId: String?

        public var operatorUid: String?

        public var ownerUid: String?

        public var permissions: [ListLakeStoragesResponseBody.Items.Permissions]?

        public var regionId: String?

        public var tableCount: Int32?

        public var totalRows: Int64?

        public var totalStorage: String?

        public var updateTime: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.creatorUid != nil {
                map["CreatorUid"] = self.creatorUid!
            }
            if self.DBClusterId != nil {
                map["DBClusterId"] = self.DBClusterId!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.fileSize != nil {
                map["FileSize"] = self.fileSize!
            }
            if self.lakeStorageId != nil {
                map["LakeStorageId"] = self.lakeStorageId!
            }
            if self.operatorUid != nil {
                map["OperatorUid"] = self.operatorUid!
            }
            if self.ownerUid != nil {
                map["OwnerUid"] = self.ownerUid!
            }
            if self.permissions != nil {
                var tmp : [Any] = []
                for k in self.permissions! {
                    tmp.append(k.toMap())
                }
                map["Permissions"] = tmp
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.tableCount != nil {
                map["TableCount"] = self.tableCount!
            }
            if self.totalRows != nil {
                map["TotalRows"] = self.totalRows!
            }
            if self.totalStorage != nil {
                map["TotalStorage"] = self.totalStorage!
            }
            if self.updateTime != nil {
                map["UpdateTime"] = self.updateTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["CreateTime"] as? String {
                self.createTime = value
            }
            if let value = dict["CreatorUid"] as? String {
                self.creatorUid = value
            }
            if let value = dict["DBClusterId"] as? String {
                self.DBClusterId = value
            }
            if let value = dict["Description"] as? String {
                self.description_ = value
            }
            if let value = dict["FileSize"] as? String {
                self.fileSize = value
            }
            if let value = dict["LakeStorageId"] as? String {
                self.lakeStorageId = value
            }
            if let value = dict["OperatorUid"] as? String {
                self.operatorUid = value
            }
            if let value = dict["OwnerUid"] as? String {
                self.ownerUid = value
            }
            if let value = dict["Permissions"] as? [Any?] {
                var tmp : [ListLakeStoragesResponseBody.Items.Permissions] = []
                for v in value {
                    if v != nil {
                        var model = ListLakeStoragesResponseBody.Items.Permissions()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.permissions = tmp
            }
            if let value = dict["RegionId"] as? String {
                self.regionId = value
            }
            if let value = dict["TableCount"] as? Int32 {
                self.tableCount = value
            }
            if let value = dict["TotalRows"] as? Int64 {
                self.totalRows = value
            }
            if let value = dict["TotalStorage"] as? String {
                self.totalStorage = value
            }
            if let value = dict["UpdateTime"] as? String {
                self.updateTime = value
            }
        }
    }
    public var code: String?

    public var httpStatusCode: Int32?

    public var items: [ListLakeStoragesResponseBody.Items]?

    public var message: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var success: Bool?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.items != nil {
            var tmp : [Any] = []
            for k in self.items! {
                tmp.append(k.toMap())
            }
            map["Items"] = tmp
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["Items"] as? [Any?] {
            var tmp : [ListLakeStoragesResponseBody.Items] = []
            for v in value {
                if v != nil {
                    var model = ListLakeStoragesResponseBody.Items()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.items = tmp
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
        if let value = dict["TotalCount"] as? Int32 {
            self.totalCount = value
        }
    }
}

public class ListLakeStoragesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListLakeStoragesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListLakeStoragesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListResultExportJobHistoryRequest : Tea.TeaModel {
    public class Order : Tea.TeaModel {
        public var field: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.field != nil {
                map["Field"] = self.field!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Field"] as? String {
                self.field = value
            }
            if let value = dict["Type"] as? String {
                self.type = value
            }
        }
    }
    public var DBClusterId: String?

    public var databaseUser: String?

    public var endTime: String?

    public var order: ListResultExportJobHistoryRequest.Order?

    public var pageNumber: String?

    public var pageSize: String?

    public var regionId: String?

    public var resourceGroup: String?

    public var startTime: String?

    public var statusList: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.order?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.databaseUser != nil {
            map["DatabaseUser"] = self.databaseUser!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.order != nil {
            map["Order"] = self.order?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroup != nil {
            map["ResourceGroup"] = self.resourceGroup!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.statusList != nil {
            map["StatusList"] = self.statusList!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["DatabaseUser"] as? String {
            self.databaseUser = value
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["Order"] as? [String: Any?] {
            var model = ListResultExportJobHistoryRequest.Order()
            model.fromMap(value)
            self.order = model
        }
        if let value = dict["PageNumber"] as? String {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? String {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroup"] as? String {
            self.resourceGroup = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
        if let value = dict["StatusList"] as? [String] {
            self.statusList = value
        }
    }
}

public class ListResultExportJobHistoryShrinkRequest : Tea.TeaModel {
    public var DBClusterId: String?

    public var databaseUser: String?

    public var endTime: String?

    public var orderShrink: String?

    public var pageNumber: String?

    public var pageSize: String?

    public var regionId: String?

    public var resourceGroup: String?

    public var startTime: String?

    public var statusListShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.databaseUser != nil {
            map["DatabaseUser"] = self.databaseUser!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.orderShrink != nil {
            map["Order"] = self.orderShrink!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroup != nil {
            map["ResourceGroup"] = self.resourceGroup!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.statusListShrink != nil {
            map["StatusList"] = self.statusListShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["DatabaseUser"] as? String {
            self.databaseUser = value
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["Order"] as? String {
            self.orderShrink = value
        }
        if let value = dict["PageNumber"] as? String {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? String {
            self.pageSize = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroup"] as? String {
            self.resourceGroup = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
        if let value = dict["StatusList"] as? String {
            self.statusListShrink = value
        }
    }
}

public class ListResultExportJobHistoryResponseBody : Tea.TeaModel {
    public class Items : Tea.TeaModel {
        public var aliUid: String?

        public var createTime: String?

        public var DBClusterId: String?

        public var databaseUser: String?

        public var endTime: String?

        public var engine: String?

        public var exportJobId: String?

        public var exportPath: String?

        public var exportRows: String?

        public var exportType: String?

        public var isExpired: Bool?

        public var message: String?

        public var processId: String?

        public var progress: String?

        public var resourceGroup: String?

        public var schema: String?

        public var sql: String?

        public var startTime: String?

        public var status: String?

        public var timeCost: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.aliUid != nil {
                map["AliUid"] = self.aliUid!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.DBClusterId != nil {
                map["DBClusterId"] = self.DBClusterId!
            }
            if self.databaseUser != nil {
                map["DatabaseUser"] = self.databaseUser!
            }
            if self.endTime != nil {
                map["EndTime"] = self.endTime!
            }
            if self.engine != nil {
                map["Engine"] = self.engine!
            }
            if self.exportJobId != nil {
                map["ExportJobId"] = self.exportJobId!
            }
            if self.exportPath != nil {
                map["ExportPath"] = self.exportPath!
            }
            if self.exportRows != nil {
                map["ExportRows"] = self.exportRows!
            }
            if self.exportType != nil {
                map["ExportType"] = self.exportType!
            }
            if self.isExpired != nil {
                map["IsExpired"] = self.isExpired!
            }
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.processId != nil {
                map["ProcessId"] = self.processId!
            }
            if self.progress != nil {
                map["Progress"] = self.progress!
            }
            if self.resourceGroup != nil {
                map["ResourceGroup"] = self.resourceGroup!
            }
            if self.schema != nil {
                map["Schema"] = self.schema!
            }
            if self.sql != nil {
                map["Sql"] = self.sql!
            }
            if self.startTime != nil {
                map["StartTime"] = self.startTime!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.timeCost != nil {
                map["TimeCost"] = self.timeCost!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AliUid"] as? String {
                self.aliUid = value
            }
            if let value = dict["CreateTime"] as? String {
                self.createTime = value
            }
            if let value = dict["DBClusterId"] as? String {
                self.DBClusterId = value
            }
            if let value = dict["DatabaseUser"] as? String {
                self.databaseUser = value
            }
            if let value = dict["EndTime"] as? String {
                self.endTime = value
            }
            if let value = dict["Engine"] as? String {
                self.engine = value
            }
            if let value = dict["ExportJobId"] as? String {
                self.exportJobId = value
            }
            if let value = dict["ExportPath"] as? String {
                self.exportPath = value
            }
            if let value = dict["ExportRows"] as? String {
                self.exportRows = value
            }
            if let value = dict["ExportType"] as? String {
                self.exportType = value
            }
            if let value = dict["IsExpired"] as? Bool {
                self.isExpired = value
            }
            if let value = dict["Message"] as? String {
                self.message = value
            }
            if let value = dict["ProcessId"] as? String {
                self.processId = value
            }
            if let value = dict["Progress"] as? String {
                self.progress = value
            }
            if let value = dict["ResourceGroup"] as? String {
                self.resourceGroup = value
            }
            if let value = dict["Schema"] as? String {
                self.schema = value
            }
            if let value = dict["Sql"] as? String {
                self.sql = value
            }
            if let value = dict["StartTime"] as? String {
                self.startTime = value
            }
            if let value = dict["Status"] as? String {
                self.status = value
            }
            if let value = dict["TimeCost"] as? Int64 {
                self.timeCost = value
            }
        }
    }
    public var code: String?

    public var httpStatusCode: Int32?

    public var items: [ListResultExportJobHistoryResponseBody.Items]?

    public var message: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var success: Bool?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.items != nil {
            var tmp : [Any] = []
            for k in self.items! {
                tmp.append(k.toMap())
            }
            map["Items"] = tmp
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["Items"] as? [Any?] {
            var tmp : [ListResultExportJobHistoryResponseBody.Items] = []
            for v in value {
                if v != nil {
                    var model = ListResultExportJobHistoryResponseBody.Items()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.items = tmp
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["PageNumber"] as? Int32 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
        if let value = dict["TotalCount"] as? Int64 {
            self.totalCount = value
        }
    }
}

public class ListResultExportJobHistoryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListResultExportJobHistoryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListResultExportJobHistoryResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListSparkAppAttemptsRequest : Tea.TeaModel {
    public var appId: String?

    public var DBClusterId: String?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["PageNumber"] as? Int64 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int64 {
            self.pageSize = value
        }
    }
}

public class ListSparkAppAttemptsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var attemptInfoList: [SparkAttemptInfo]?

        public var pageNumber: Int64?

        public var pageSize: Int64?

        public var totalCount: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.attemptInfoList != nil {
                var tmp : [Any] = []
                for k in self.attemptInfoList! {
                    tmp.append(k.toMap())
                }
                map["AttemptInfoList"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AttemptInfoList"] as? [Any?] {
                var tmp : [SparkAttemptInfo] = []
                for v in value {
                    if v != nil {
                        var model = SparkAttemptInfo()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.attemptInfoList = tmp
            }
            if let value = dict["PageNumber"] as? Int64 {
                self.pageNumber = value
            }
            if let value = dict["PageSize"] as? Int64 {
                self.pageSize = value
            }
            if let value = dict["TotalCount"] as? Int64 {
                self.totalCount = value
            }
        }
    }
    public var data: ListSparkAppAttemptsResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [String: Any?] {
            var model = ListSparkAppAttemptsResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ListSparkAppAttemptsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListSparkAppAttemptsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListSparkAppAttemptsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListSparkAppsRequest : Tea.TeaModel {
    public var DBClusterId: String?

    public var filters: String?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var resourceGroupName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.filters != nil {
            map["Filters"] = self.filters!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.resourceGroupName != nil {
            map["ResourceGroupName"] = self.resourceGroupName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["Filters"] as? String {
            self.filters = value
        }
        if let value = dict["PageNumber"] as? Int64 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int64 {
            self.pageSize = value
        }
        if let value = dict["ResourceGroupName"] as? String {
            self.resourceGroupName = value
        }
    }
}

public class ListSparkAppsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var appInfoList: [SparkAppInfo]?

        public var pageNumber: Int64?

        public var pageSize: Int64?

        public var totalCount: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appInfoList != nil {
                var tmp : [Any] = []
                for k in self.appInfoList! {
                    tmp.append(k.toMap())
                }
                map["AppInfoList"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AppInfoList"] as? [Any?] {
                var tmp : [SparkAppInfo] = []
                for v in value {
                    if v != nil {
                        var model = SparkAppInfo()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.appInfoList = tmp
            }
            if let value = dict["PageNumber"] as? Int64 {
                self.pageNumber = value
            }
            if let value = dict["PageSize"] as? Int64 {
                self.pageSize = value
            }
            if let value = dict["TotalCount"] as? Int64 {
                self.totalCount = value
            }
        }
    }
    public var data: ListSparkAppsResponseBody.Data?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var requestId: String?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [String: Any?] {
            var model = ListSparkAppsResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["PageNumber"] as? Int64 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int64 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? Int64 {
            self.totalCount = value
        }
    }
}

public class ListSparkAppsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListSparkAppsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListSparkAppsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListSparkLogAnalyzeTasksRequest : Tea.TeaModel {
    public var DBClusterId: String?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["PageNumber"] as? Int64 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int64 {
            self.pageSize = value
        }
    }
}

public class ListSparkLogAnalyzeTasksResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var pageNumber: Int64?

        public var pageSize: Int64?

        public var taskList: [SparkAnalyzeLogTask]?

        public var totalCount: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.taskList != nil {
                var tmp : [Any] = []
                for k in self.taskList! {
                    tmp.append(k.toMap())
                }
                map["TaskList"] = tmp
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["PageNumber"] as? Int64 {
                self.pageNumber = value
            }
            if let value = dict["PageSize"] as? Int64 {
                self.pageSize = value
            }
            if let value = dict["TaskList"] as? [Any?] {
                var tmp : [SparkAnalyzeLogTask] = []
                for v in value {
                    if v != nil {
                        var model = SparkAnalyzeLogTask()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.taskList = tmp
            }
            if let value = dict["TotalCount"] as? Int64 {
                self.totalCount = value
            }
        }
    }
    public var data: ListSparkLogAnalyzeTasksResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [String: Any?] {
            var model = ListSparkLogAnalyzeTasksResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ListSparkLogAnalyzeTasksResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListSparkLogAnalyzeTasksResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListSparkLogAnalyzeTasksResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListSparkTemplateFileIdsRequest : Tea.TeaModel {
    public var DBClusterId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
    }
}

public class ListSparkTemplateFileIdsResponseBody : Tea.TeaModel {
    public var data: [Int64]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [Int64] {
            self.data = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ListSparkTemplateFileIdsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListSparkTemplateFileIdsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListSparkTemplateFileIdsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListSparkWarehouseBatchSQLRequest : Tea.TeaModel {
    public var DBClusterId: String?

    public var pageNumber: Int64?

    public var pageSize: String?

    public var resourceGroupName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.resourceGroupName != nil {
            map["ResourceGroupName"] = self.resourceGroupName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["PageNumber"] as? Int64 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? String {
            self.pageSize = value
        }
        if let value = dict["ResourceGroupName"] as? String {
            self.resourceGroupName = value
        }
    }
}

public class ListSparkWarehouseBatchSQLResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var pageNumber: Int64?

        public var pageSize: Int64?

        public var queries: [SparkBatchSQL]?

        public var total: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.queries != nil {
                var tmp : [Any] = []
                for k in self.queries! {
                    tmp.append(k.toMap())
                }
                map["Queries"] = tmp
            }
            if self.total != nil {
                map["Total"] = self.total!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["PageNumber"] as? Int64 {
                self.pageNumber = value
            }
            if let value = dict["PageSize"] as? Int64 {
                self.pageSize = value
            }
            if let value = dict["Queries"] as? [Any?] {
                var tmp : [SparkBatchSQL] = []
                for v in value {
                    if v != nil {
                        var model = SparkBatchSQL()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.queries = tmp
            }
            if let value = dict["Total"] as? Int64 {
                self.total = value
            }
        }
    }
    public var data: ListSparkWarehouseBatchSQLResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [String: Any?] {
            var model = ListSparkWarehouseBatchSQLResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ListSparkWarehouseBatchSQLResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListSparkWarehouseBatchSQLResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListSparkWarehouseBatchSQLResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListTagResourcesRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Value"] as? String {
                self.value = value
            }
        }
    }
    public var nextToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceId: [String]?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var resourceType: String?

    public var tag: [ListTagResourcesRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceId"] as? [String] {
            self.resourceId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["ResourceType"] as? String {
            self.resourceType = value
        }
        if let value = dict["Tag"] as? [Any?] {
            var tmp : [ListTagResourcesRequest.Tag] = []
            for v in value {
                if v != nil {
                    var model = ListTagResourcesRequest.Tag()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tag = tmp
        }
    }
}

public class ListTagResourcesResponseBody : Tea.TeaModel {
    public class TagResources : Tea.TeaModel {
        public class TagResource : Tea.TeaModel {
            public var resourceId: String?

            public var resourceType: String?

            public var tagKey: String?

            public var tagValue: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.resourceId != nil {
                    map["ResourceId"] = self.resourceId!
                }
                if self.resourceType != nil {
                    map["ResourceType"] = self.resourceType!
                }
                if self.tagKey != nil {
                    map["TagKey"] = self.tagKey!
                }
                if self.tagValue != nil {
                    map["TagValue"] = self.tagValue!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ResourceId"] as? String {
                    self.resourceId = value
                }
                if let value = dict["ResourceType"] as? String {
                    self.resourceType = value
                }
                if let value = dict["TagKey"] as? String {
                    self.tagKey = value
                }
                if let value = dict["TagValue"] as? String {
                    self.tagValue = value
                }
            }
        }
        public var tagResource: [ListTagResourcesResponseBody.TagResources.TagResource]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tagResource != nil {
                var tmp : [Any] = []
                for k in self.tagResource! {
                    tmp.append(k.toMap())
                }
                map["TagResource"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["TagResource"] as? [Any?] {
                var tmp : [ListTagResourcesResponseBody.TagResources.TagResource] = []
                for v in value {
                    if v != nil {
                        var model = ListTagResourcesResponseBody.TagResources.TagResource()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.tagResource = tmp
            }
        }
    }
    public var nextToken: String?

    public var requestId: String?

    public var tagResources: ListTagResourcesResponseBody.TagResources?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tagResources?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.tagResources != nil {
            map["TagResources"] = self.tagResources?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TagResources"] as? [String: Any?] {
            var model = ListTagResourcesResponseBody.TagResources()
            model.fromMap(value)
            self.tagResources = model
        }
    }
}

public class ListTagResourcesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListTagResourcesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListTagResourcesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class LoadSampleDataSetRequest : Tea.TeaModel {
    public var DBClusterId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
    }
}

public class LoadSampleDataSetResponseBody : Tea.TeaModel {
    public var DBClusterId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class LoadSampleDataSetResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: LoadSampleDataSetResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = LoadSampleDataSetResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyAccountDescriptionRequest : Tea.TeaModel {
    public var accountDescription: String?

    public var accountName: String?

    public var DBClusterId: String?

    public var engine: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accountDescription != nil {
            map["AccountDescription"] = self.accountDescription!
        }
        if self.accountName != nil {
            map["AccountName"] = self.accountName!
        }
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.engine != nil {
            map["Engine"] = self.engine!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AccountDescription"] as? String {
            self.accountDescription = value
        }
        if let value = dict["AccountName"] as? String {
            self.accountName = value
        }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["Engine"] as? String {
            self.engine = value
        }
    }
}

public class ModifyAccountDescriptionResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyAccountDescriptionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyAccountDescriptionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyAccountDescriptionResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyAccountPrivilegesRequest : Tea.TeaModel {
    public class AccountPrivileges : Tea.TeaModel {
        public class PrivilegeObject : Tea.TeaModel {
            public var column: String?

            public var database: String?

            public var table: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.column != nil {
                    map["Column"] = self.column!
                }
                if self.database != nil {
                    map["Database"] = self.database!
                }
                if self.table != nil {
                    map["Table"] = self.table!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Column"] as? String {
                    self.column = value
                }
                if let value = dict["Database"] as? String {
                    self.database = value
                }
                if let value = dict["Table"] as? String {
                    self.table = value
                }
            }
        }
        public var privilegeObject: ModifyAccountPrivilegesRequest.AccountPrivileges.PrivilegeObject?

        public var privilegeType: String?

        public var privileges: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.privilegeObject?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.privilegeObject != nil {
                map["PrivilegeObject"] = self.privilegeObject?.toMap()
            }
            if self.privilegeType != nil {
                map["PrivilegeType"] = self.privilegeType!
            }
            if self.privileges != nil {
                map["Privileges"] = self.privileges!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["PrivilegeObject"] as? [String: Any?] {
                var model = ModifyAccountPrivilegesRequest.AccountPrivileges.PrivilegeObject()
                model.fromMap(value)
                self.privilegeObject = model
            }
            if let value = dict["PrivilegeType"] as? String {
                self.privilegeType = value
            }
            if let value = dict["Privileges"] as? [String] {
                self.privileges = value
            }
        }
    }
    public var accountName: String?

    public var accountPrivileges: [ModifyAccountPrivilegesRequest.AccountPrivileges]?

    public var DBClusterId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accountName != nil {
            map["AccountName"] = self.accountName!
        }
        if self.accountPrivileges != nil {
            var tmp : [Any] = []
            for k in self.accountPrivileges! {
                tmp.append(k.toMap())
            }
            map["AccountPrivileges"] = tmp
        }
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AccountName"] as? String {
            self.accountName = value
        }
        if let value = dict["AccountPrivileges"] as? [Any?] {
            var tmp : [ModifyAccountPrivilegesRequest.AccountPrivileges] = []
            for v in value {
                if v != nil {
                    var model = ModifyAccountPrivilegesRequest.AccountPrivileges()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.accountPrivileges = tmp
        }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class ModifyAccountPrivilegesShrinkRequest : Tea.TeaModel {
    public var accountName: String?

    public var accountPrivilegesShrink: String?

    public var DBClusterId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accountName != nil {
            map["AccountName"] = self.accountName!
        }
        if self.accountPrivilegesShrink != nil {
            map["AccountPrivileges"] = self.accountPrivilegesShrink!
        }
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AccountName"] as? String {
            self.accountName = value
        }
        if let value = dict["AccountPrivileges"] as? String {
            self.accountPrivilegesShrink = value
        }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class ModifyAccountPrivilegesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyAccountPrivilegesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyAccountPrivilegesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyAccountPrivilegesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyApsDatasoureRequest : Tea.TeaModel {
    public class KafkaInfo : Tea.TeaModel {
        public var kafkaClusterId: String?

        public var kafkaTopic: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.kafkaClusterId != nil {
                map["KafkaClusterId"] = self.kafkaClusterId!
            }
            if self.kafkaTopic != nil {
                map["KafkaTopic"] = self.kafkaTopic!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["KafkaClusterId"] as? String {
                self.kafkaClusterId = value
            }
            if let value = dict["KafkaTopic"] as? String {
                self.kafkaTopic = value
            }
        }
    }
    public class LakehouseId : Tea.TeaModel {
        public var securityGroup: String?

        public var vpcId: String?

        public var vswitch: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.securityGroup != nil {
                map["SecurityGroup"] = self.securityGroup!
            }
            if self.vpcId != nil {
                map["VpcId"] = self.vpcId!
            }
            if self.vswitch != nil {
                map["Vswitch"] = self.vswitch!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["SecurityGroup"] as? String {
                self.securityGroup = value
            }
            if let value = dict["VpcId"] as? String {
                self.vpcId = value
            }
            if let value = dict["Vswitch"] as? String {
                self.vswitch = value
            }
        }
    }
    public class PolarDBMysqlInfo : Tea.TeaModel {
        public var connectUrl: String?

        public var password: String?

        public var regionId: String?

        public var userName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.connectUrl != nil {
                map["ConnectUrl"] = self.connectUrl!
            }
            if self.password != nil {
                map["Password"] = self.password!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.userName != nil {
                map["UserName"] = self.userName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ConnectUrl"] as? String {
                self.connectUrl = value
            }
            if let value = dict["Password"] as? String {
                self.password = value
            }
            if let value = dict["RegionId"] as? String {
                self.regionId = value
            }
            if let value = dict["UserName"] as? String {
                self.userName = value
            }
        }
    }
    public class RdsMysqlInfo : Tea.TeaModel {
        public var connectUrl: String?

        public var password: String?

        public var regionId: String?

        public var userName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.connectUrl != nil {
                map["ConnectUrl"] = self.connectUrl!
            }
            if self.password != nil {
                map["Password"] = self.password!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.userName != nil {
                map["UserName"] = self.userName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ConnectUrl"] as? String {
                self.connectUrl = value
            }
            if let value = dict["Password"] as? String {
                self.password = value
            }
            if let value = dict["RegionId"] as? String {
                self.regionId = value
            }
            if let value = dict["UserName"] as? String {
                self.userName = value
            }
        }
    }
    public class SlsInfo : Tea.TeaModel {
        public var across: Bool?

        public var acrossRole: String?

        public var acrossUid: String?

        public var sourceRegionId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.across != nil {
                map["Across"] = self.across!
            }
            if self.acrossRole != nil {
                map["AcrossRole"] = self.acrossRole!
            }
            if self.acrossUid != nil {
                map["AcrossUid"] = self.acrossUid!
            }
            if self.sourceRegionId != nil {
                map["SourceRegionId"] = self.sourceRegionId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Across"] as? Bool {
                self.across = value
            }
            if let value = dict["AcrossRole"] as? String {
                self.acrossRole = value
            }
            if let value = dict["AcrossUid"] as? String {
                self.acrossUid = value
            }
            if let value = dict["SourceRegionId"] as? String {
                self.sourceRegionId = value
            }
        }
    }
    public var DBClusterId: String?

    public var datasourceDescription: String?

    public var datasourceId: Int64?

    public var datasourceName: String?

    public var kafkaInfo: ModifyApsDatasoureRequest.KafkaInfo?

    public var lakehouseId: ModifyApsDatasoureRequest.LakehouseId?

    public var polarDBMysqlInfo: ModifyApsDatasoureRequest.PolarDBMysqlInfo?

    public var rdsMysqlInfo: ModifyApsDatasoureRequest.RdsMysqlInfo?

    public var regionId: String?

    public var slsInfo: ModifyApsDatasoureRequest.SlsInfo?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.kafkaInfo?.validate()
        try self.lakehouseId?.validate()
        try self.polarDBMysqlInfo?.validate()
        try self.rdsMysqlInfo?.validate()
        try self.slsInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.datasourceDescription != nil {
            map["DatasourceDescription"] = self.datasourceDescription!
        }
        if self.datasourceId != nil {
            map["DatasourceId"] = self.datasourceId!
        }
        if self.datasourceName != nil {
            map["DatasourceName"] = self.datasourceName!
        }
        if self.kafkaInfo != nil {
            map["KafkaInfo"] = self.kafkaInfo?.toMap()
        }
        if self.lakehouseId != nil {
            map["LakehouseId"] = self.lakehouseId?.toMap()
        }
        if self.polarDBMysqlInfo != nil {
            map["PolarDBMysqlInfo"] = self.polarDBMysqlInfo?.toMap()
        }
        if self.rdsMysqlInfo != nil {
            map["RdsMysqlInfo"] = self.rdsMysqlInfo?.toMap()
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.slsInfo != nil {
            map["SlsInfo"] = self.slsInfo?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["DatasourceDescription"] as? String {
            self.datasourceDescription = value
        }
        if let value = dict["DatasourceId"] as? Int64 {
            self.datasourceId = value
        }
        if let value = dict["DatasourceName"] as? String {
            self.datasourceName = value
        }
        if let value = dict["KafkaInfo"] as? [String: Any?] {
            var model = ModifyApsDatasoureRequest.KafkaInfo()
            model.fromMap(value)
            self.kafkaInfo = model
        }
        if let value = dict["LakehouseId"] as? [String: Any?] {
            var model = ModifyApsDatasoureRequest.LakehouseId()
            model.fromMap(value)
            self.lakehouseId = model
        }
        if let value = dict["PolarDBMysqlInfo"] as? [String: Any?] {
            var model = ModifyApsDatasoureRequest.PolarDBMysqlInfo()
            model.fromMap(value)
            self.polarDBMysqlInfo = model
        }
        if let value = dict["RdsMysqlInfo"] as? [String: Any?] {
            var model = ModifyApsDatasoureRequest.RdsMysqlInfo()
            model.fromMap(value)
            self.rdsMysqlInfo = model
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["SlsInfo"] as? [String: Any?] {
            var model = ModifyApsDatasoureRequest.SlsInfo()
            model.fromMap(value)
            self.slsInfo = model
        }
    }
}

public class ModifyApsDatasoureShrinkRequest : Tea.TeaModel {
    public var DBClusterId: String?

    public var datasourceDescription: String?

    public var datasourceId: Int64?

    public var datasourceName: String?

    public var kafkaInfoShrink: String?

    public var lakehouseIdShrink: String?

    public var polarDBMysqlInfoShrink: String?

    public var rdsMysqlInfoShrink: String?

    public var regionId: String?

    public var slsInfoShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.datasourceDescription != nil {
            map["DatasourceDescription"] = self.datasourceDescription!
        }
        if self.datasourceId != nil {
            map["DatasourceId"] = self.datasourceId!
        }
        if self.datasourceName != nil {
            map["DatasourceName"] = self.datasourceName!
        }
        if self.kafkaInfoShrink != nil {
            map["KafkaInfo"] = self.kafkaInfoShrink!
        }
        if self.lakehouseIdShrink != nil {
            map["LakehouseId"] = self.lakehouseIdShrink!
        }
        if self.polarDBMysqlInfoShrink != nil {
            map["PolarDBMysqlInfo"] = self.polarDBMysqlInfoShrink!
        }
        if self.rdsMysqlInfoShrink != nil {
            map["RdsMysqlInfo"] = self.rdsMysqlInfoShrink!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.slsInfoShrink != nil {
            map["SlsInfo"] = self.slsInfoShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["DatasourceDescription"] as? String {
            self.datasourceDescription = value
        }
        if let value = dict["DatasourceId"] as? Int64 {
            self.datasourceId = value
        }
        if let value = dict["DatasourceName"] as? String {
            self.datasourceName = value
        }
        if let value = dict["KafkaInfo"] as? String {
            self.kafkaInfoShrink = value
        }
        if let value = dict["LakehouseId"] as? String {
            self.lakehouseIdShrink = value
        }
        if let value = dict["PolarDBMysqlInfo"] as? String {
            self.polarDBMysqlInfoShrink = value
        }
        if let value = dict["RdsMysqlInfo"] as? String {
            self.rdsMysqlInfoShrink = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["SlsInfo"] as? String {
            self.slsInfoShrink = value
        }
    }
}

public class ModifyApsDatasoureResponseBody : Tea.TeaModel {
    public var code: String?

    public var data: String?

    public var httpStatusCode: String?

    public var message: String?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? String {
            self.data = value
        }
        if let value = dict["HttpStatusCode"] as? String {
            self.httpStatusCode = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? String {
            self.success = value
        }
    }
}

public class ModifyApsDatasoureResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyApsDatasoureResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyApsDatasoureResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyApsJobRequest : Tea.TeaModel {
    public var apsJobId: String?

    public var dbList: String?

    public var partitionList: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apsJobId != nil {
            map["ApsJobId"] = self.apsJobId!
        }
        if self.dbList != nil {
            map["DbList"] = self.dbList!
        }
        if self.partitionList != nil {
            map["PartitionList"] = self.partitionList!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ApsJobId"] as? String {
            self.apsJobId = value
        }
        if let value = dict["DbList"] as? String {
            self.dbList = value
        }
        if let value = dict["PartitionList"] as? String {
            self.partitionList = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class ModifyApsJobResponseBody : Tea.TeaModel {
    public var apsJobId: String?

    public var code: String?

    public var errCode: String?

    public var errMessage: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apsJobId != nil {
            map["ApsJobId"] = self.apsJobId!
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.errCode != nil {
            map["ErrCode"] = self.errCode!
        }
        if self.errMessage != nil {
            map["ErrMessage"] = self.errMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ApsJobId"] as? String {
            self.apsJobId = value
        }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["ErrCode"] as? String {
            self.errCode = value
        }
        if let value = dict["ErrMessage"] as? String {
            self.errMessage = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class ModifyApsJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyApsJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyApsJobResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyApsSlsADBJobRequest : Tea.TeaModel {
    public class Columns : Tea.TeaModel {
        public var mapName: String?

        public var mapType: String?

        public var name: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.mapName != nil {
                map["MapName"] = self.mapName!
            }
            if self.mapType != nil {
                map["MapType"] = self.mapType!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["MapName"] as? String {
                self.mapName = value
            }
            if let value = dict["MapType"] as? String {
                self.mapType = value
            }
            if let value = dict["Name"] as? String {
                self.name = value
            }
            if let value = dict["Type"] as? String {
                self.type = value
            }
        }
    }
    public var columns: [ModifyApsSlsADBJobRequest.Columns]?

    public var DBClusterId: String?

    public var dbName: String?

    public var dirtyDataProcessPattern: String?

    public var exactlyOnce: String?

    public var password: String?

    public var regionId: String?

    public var startingOffsets: String?

    public var tableName: String?

    public var unixTimestampConvert: String?

    public var userName: String?

    public var workloadId: String?

    public var workloadName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.columns != nil {
            var tmp : [Any] = []
            for k in self.columns! {
                tmp.append(k.toMap())
            }
            map["Columns"] = tmp
        }
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.dbName != nil {
            map["DbName"] = self.dbName!
        }
        if self.dirtyDataProcessPattern != nil {
            map["DirtyDataProcessPattern"] = self.dirtyDataProcessPattern!
        }
        if self.exactlyOnce != nil {
            map["ExactlyOnce"] = self.exactlyOnce!
        }
        if self.password != nil {
            map["Password"] = self.password!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.startingOffsets != nil {
            map["StartingOffsets"] = self.startingOffsets!
        }
        if self.tableName != nil {
            map["TableName"] = self.tableName!
        }
        if self.unixTimestampConvert != nil {
            map["UnixTimestampConvert"] = self.unixTimestampConvert!
        }
        if self.userName != nil {
            map["UserName"] = self.userName!
        }
        if self.workloadId != nil {
            map["WorkloadId"] = self.workloadId!
        }
        if self.workloadName != nil {
            map["WorkloadName"] = self.workloadName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Columns"] as? [Any?] {
            var tmp : [ModifyApsSlsADBJobRequest.Columns] = []
            for v in value {
                if v != nil {
                    var model = ModifyApsSlsADBJobRequest.Columns()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.columns = tmp
        }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["DbName"] as? String {
            self.dbName = value
        }
        if let value = dict["DirtyDataProcessPattern"] as? String {
            self.dirtyDataProcessPattern = value
        }
        if let value = dict["ExactlyOnce"] as? String {
            self.exactlyOnce = value
        }
        if let value = dict["Password"] as? String {
            self.password = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["StartingOffsets"] as? String {
            self.startingOffsets = value
        }
        if let value = dict["TableName"] as? String {
            self.tableName = value
        }
        if let value = dict["UnixTimestampConvert"] as? String {
            self.unixTimestampConvert = value
        }
        if let value = dict["UserName"] as? String {
            self.userName = value
        }
        if let value = dict["WorkloadId"] as? String {
            self.workloadId = value
        }
        if let value = dict["WorkloadName"] as? String {
            self.workloadName = value
        }
    }
}

public class ModifyApsSlsADBJobShrinkRequest : Tea.TeaModel {
    public var columnsShrink: String?

    public var DBClusterId: String?

    public var dbName: String?

    public var dirtyDataProcessPattern: String?

    public var exactlyOnce: String?

    public var password: String?

    public var regionId: String?

    public var startingOffsets: String?

    public var tableName: String?

    public var unixTimestampConvert: String?

    public var userName: String?

    public var workloadId: String?

    public var workloadName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.columnsShrink != nil {
            map["Columns"] = self.columnsShrink!
        }
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.dbName != nil {
            map["DbName"] = self.dbName!
        }
        if self.dirtyDataProcessPattern != nil {
            map["DirtyDataProcessPattern"] = self.dirtyDataProcessPattern!
        }
        if self.exactlyOnce != nil {
            map["ExactlyOnce"] = self.exactlyOnce!
        }
        if self.password != nil {
            map["Password"] = self.password!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.startingOffsets != nil {
            map["StartingOffsets"] = self.startingOffsets!
        }
        if self.tableName != nil {
            map["TableName"] = self.tableName!
        }
        if self.unixTimestampConvert != nil {
            map["UnixTimestampConvert"] = self.unixTimestampConvert!
        }
        if self.userName != nil {
            map["UserName"] = self.userName!
        }
        if self.workloadId != nil {
            map["WorkloadId"] = self.workloadId!
        }
        if self.workloadName != nil {
            map["WorkloadName"] = self.workloadName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Columns"] as? String {
            self.columnsShrink = value
        }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["DbName"] as? String {
            self.dbName = value
        }
        if let value = dict["DirtyDataProcessPattern"] as? String {
            self.dirtyDataProcessPattern = value
        }
        if let value = dict["ExactlyOnce"] as? String {
            self.exactlyOnce = value
        }
        if let value = dict["Password"] as? String {
            self.password = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["StartingOffsets"] as? String {
            self.startingOffsets = value
        }
        if let value = dict["TableName"] as? String {
            self.tableName = value
        }
        if let value = dict["UnixTimestampConvert"] as? String {
            self.unixTimestampConvert = value
        }
        if let value = dict["UserName"] as? String {
            self.userName = value
        }
        if let value = dict["WorkloadId"] as? String {
            self.workloadId = value
        }
        if let value = dict["WorkloadName"] as? String {
            self.workloadName = value
        }
    }
}

public class ModifyApsSlsADBJobResponseBody : Tea.TeaModel {
    public var code: String?

    public var data: [String: Any]?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any] {
            self.data = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class ModifyApsSlsADBJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyApsSlsADBJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyApsSlsADBJobResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyApsWorkloadNameRequest : Tea.TeaModel {
    public var DBClusterId: String?

    public var regionId: String?

    public var workloadId: String?

    public var workloadName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.workloadId != nil {
            map["WorkloadId"] = self.workloadId!
        }
        if self.workloadName != nil {
            map["WorkloadName"] = self.workloadName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["WorkloadId"] as? String {
            self.workloadId = value
        }
        if let value = dict["WorkloadName"] as? String {
            self.workloadName = value
        }
    }
}

public class ModifyApsWorkloadNameResponseBody : Tea.TeaModel {
    public var code: String?

    public var data: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? String {
            self.data = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class ModifyApsWorkloadNameResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyApsWorkloadNameResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyApsWorkloadNameResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyAuditLogConfigRequest : Tea.TeaModel {
    public var auditLogStatus: String?

    public var DBClusterId: String?

    public var engineType: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.auditLogStatus != nil {
            map["AuditLogStatus"] = self.auditLogStatus!
        }
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.engineType != nil {
            map["EngineType"] = self.engineType!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AuditLogStatus"] as? String {
            self.auditLogStatus = value
        }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["EngineType"] as? String {
            self.engineType = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class ModifyAuditLogConfigResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var updateSucceed: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.updateSucceed != nil {
            map["UpdateSucceed"] = self.updateSucceed!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["UpdateSucceed"] as? Bool {
            self.updateSucceed = value
        }
    }
}

public class ModifyAuditLogConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyAuditLogConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyAuditLogConfigResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyBackupPolicyRequest : Tea.TeaModel {
    public var backupRetentionPeriod: String?

    public var DBClusterId: String?

    public var enableBackupLog: String?

    public var logBackupRetentionPeriod: Int32?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var preferredBackupPeriod: String?

    public var preferredBackupTime: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.backupRetentionPeriod != nil {
            map["BackupRetentionPeriod"] = self.backupRetentionPeriod!
        }
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.enableBackupLog != nil {
            map["EnableBackupLog"] = self.enableBackupLog!
        }
        if self.logBackupRetentionPeriod != nil {
            map["LogBackupRetentionPeriod"] = self.logBackupRetentionPeriod!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.preferredBackupPeriod != nil {
            map["PreferredBackupPeriod"] = self.preferredBackupPeriod!
        }
        if self.preferredBackupTime != nil {
            map["PreferredBackupTime"] = self.preferredBackupTime!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["BackupRetentionPeriod"] as? String {
            self.backupRetentionPeriod = value
        }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["EnableBackupLog"] as? String {
            self.enableBackupLog = value
        }
        if let value = dict["LogBackupRetentionPeriod"] as? Int32 {
            self.logBackupRetentionPeriod = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["PreferredBackupPeriod"] as? String {
            self.preferredBackupPeriod = value
        }
        if let value = dict["PreferredBackupTime"] as? String {
            self.preferredBackupTime = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class ModifyBackupPolicyResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyBackupPolicyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyBackupPolicyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyBackupPolicyResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyClickhouseEngineRequest : Tea.TeaModel {
    public var cacheSize: Int32?

    public var DBClusterId: String?

    public var enabled: Bool?

    public var ownerId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cacheSize != nil {
            map["CacheSize"] = self.cacheSize!
        }
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.enabled != nil {
            map["Enabled"] = self.enabled!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CacheSize"] as? Int32 {
            self.cacheSize = value
        }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["Enabled"] as? Bool {
            self.enabled = value
        }
        if let value = dict["OwnerId"] as? String {
            self.ownerId = value
        }
    }
}

public class ModifyClickhouseEngineResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyClickhouseEngineResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyClickhouseEngineResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyClickhouseEngineResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyClusterAccessWhiteListRequest : Tea.TeaModel {
    public var DBClusterIPArrayAttribute: String?

    public var DBClusterIPArrayName: String?

    public var DBClusterId: String?

    public var modifyMode: String?

    public var securityIps: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBClusterIPArrayAttribute != nil {
            map["DBClusterIPArrayAttribute"] = self.DBClusterIPArrayAttribute!
        }
        if self.DBClusterIPArrayName != nil {
            map["DBClusterIPArrayName"] = self.DBClusterIPArrayName!
        }
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.modifyMode != nil {
            map["ModifyMode"] = self.modifyMode!
        }
        if self.securityIps != nil {
            map["SecurityIps"] = self.securityIps!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBClusterIPArrayAttribute"] as? String {
            self.DBClusterIPArrayAttribute = value
        }
        if let value = dict["DBClusterIPArrayName"] as? String {
            self.DBClusterIPArrayName = value
        }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["ModifyMode"] as? String {
            self.modifyMode = value
        }
        if let value = dict["SecurityIps"] as? String {
            self.securityIps = value
        }
    }
}

public class ModifyClusterAccessWhiteListResponseBody : Tea.TeaModel {
    public var DBClusterId: String?

    public var requestId: String?

    public var taskId: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TaskId"] as? Int32 {
            self.taskId = value
        }
    }
}

public class ModifyClusterAccessWhiteListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyClusterAccessWhiteListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyClusterAccessWhiteListResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyClusterConnectionStringRequest : Tea.TeaModel {
    public var connectionStringPrefix: String?

    public var currentConnectionString: String?

    public var DBClusterId: String?

    public var port: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.connectionStringPrefix != nil {
            map["ConnectionStringPrefix"] = self.connectionStringPrefix!
        }
        if self.currentConnectionString != nil {
            map["CurrentConnectionString"] = self.currentConnectionString!
        }
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.port != nil {
            map["Port"] = self.port!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ConnectionStringPrefix"] as? String {
            self.connectionStringPrefix = value
        }
        if let value = dict["CurrentConnectionString"] as? String {
            self.currentConnectionString = value
        }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["Port"] as? Int32 {
            self.port = value
        }
    }
}

public class ModifyClusterConnectionStringResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyClusterConnectionStringResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyClusterConnectionStringResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyClusterConnectionStringResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyCompactionServiceSwitchRequest : Tea.TeaModel {
    public var DBClusterId: String?

    public var enableCompactionService: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.enableCompactionService != nil {
            map["EnableCompactionService"] = self.enableCompactionService!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["EnableCompactionService"] as? Bool {
            self.enableCompactionService = value
        }
    }
}

public class ModifyCompactionServiceSwitchResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyCompactionServiceSwitchResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyCompactionServiceSwitchResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyCompactionServiceSwitchResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyDBClusterRequest : Tea.TeaModel {
    public var computeResource: String?

    public var DBClusterId: String?

    public var enableDefaultResourcePool: Bool?

    public var productForm: String?

    public var regionId: String?

    public var reservedNodeCount: Int32?

    public var reservedNodeSize: String?

    public var storageResource: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.computeResource != nil {
            map["ComputeResource"] = self.computeResource!
        }
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.enableDefaultResourcePool != nil {
            map["EnableDefaultResourcePool"] = self.enableDefaultResourcePool!
        }
        if self.productForm != nil {
            map["ProductForm"] = self.productForm!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.reservedNodeCount != nil {
            map["ReservedNodeCount"] = self.reservedNodeCount!
        }
        if self.reservedNodeSize != nil {
            map["ReservedNodeSize"] = self.reservedNodeSize!
        }
        if self.storageResource != nil {
            map["StorageResource"] = self.storageResource!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ComputeResource"] as? String {
            self.computeResource = value
        }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["EnableDefaultResourcePool"] as? Bool {
            self.enableDefaultResourcePool = value
        }
        if let value = dict["ProductForm"] as? String {
            self.productForm = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ReservedNodeCount"] as? Int32 {
            self.reservedNodeCount = value
        }
        if let value = dict["ReservedNodeSize"] as? String {
            self.reservedNodeSize = value
        }
        if let value = dict["StorageResource"] as? String {
            self.storageResource = value
        }
    }
}

public class ModifyDBClusterResponseBody : Tea.TeaModel {
    public var DBClusterId: String?

    public var orderId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["OrderId"] as? String {
            self.orderId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyDBClusterResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyDBClusterResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyDBClusterResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyDBClusterDescriptionRequest : Tea.TeaModel {
    public var DBClusterDescription: String?

    public var DBClusterId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBClusterDescription != nil {
            map["DBClusterDescription"] = self.DBClusterDescription!
        }
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBClusterDescription"] as? String {
            self.DBClusterDescription = value
        }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
    }
}

public class ModifyDBClusterDescriptionResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyDBClusterDescriptionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyDBClusterDescriptionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyDBClusterDescriptionResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyDBClusterMaintainTimeRequest : Tea.TeaModel {
    public var DBClusterId: String?

    public var maintainTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.maintainTime != nil {
            map["MaintainTime"] = self.maintainTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["MaintainTime"] as? String {
            self.maintainTime = value
        }
    }
}

public class ModifyDBClusterMaintainTimeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyDBClusterMaintainTimeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyDBClusterMaintainTimeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyDBClusterMaintainTimeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyDBClusterResourceGroupRequest : Tea.TeaModel {
    public var DBClusterId: String?

    public var newResourceGroupId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.newResourceGroupId != nil {
            map["NewResourceGroupId"] = self.newResourceGroupId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["NewResourceGroupId"] as? String {
            self.newResourceGroupId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class ModifyDBClusterResourceGroupResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyDBClusterResourceGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyDBClusterResourceGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyDBClusterResourceGroupResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyDBClusterVipRequest : Tea.TeaModel {
    public var connectString: String?

    public var DBClusterId: String?

    public var VPCId: String?

    public var vSwitchId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.connectString != nil {
            map["ConnectString"] = self.connectString!
        }
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.VPCId != nil {
            map["VPCId"] = self.VPCId!
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ConnectString"] as? String {
            self.connectString = value
        }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["VPCId"] as? String {
            self.VPCId = value
        }
        if let value = dict["VSwitchId"] as? String {
            self.vSwitchId = value
        }
    }
}

public class ModifyDBClusterVipResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyDBClusterVipResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyDBClusterVipResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyDBClusterVipResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyDBResourceGroupRequest : Tea.TeaModel {
    public class RayConfig : Tea.TeaModel {
        public class WorkerGroups : Tea.TeaModel {
            public var allocateUnit: String?

            public var groupName: String?

            public var maxWorkerQuantity: Int32?

            public var minWorkerQuantity: Int32?

            public var workerDiskCapacity: String?

            public var workerSpecName: String?

            public var workerSpecType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.allocateUnit != nil {
                    map["AllocateUnit"] = self.allocateUnit!
                }
                if self.groupName != nil {
                    map["GroupName"] = self.groupName!
                }
                if self.maxWorkerQuantity != nil {
                    map["MaxWorkerQuantity"] = self.maxWorkerQuantity!
                }
                if self.minWorkerQuantity != nil {
                    map["MinWorkerQuantity"] = self.minWorkerQuantity!
                }
                if self.workerDiskCapacity != nil {
                    map["WorkerDiskCapacity"] = self.workerDiskCapacity!
                }
                if self.workerSpecName != nil {
                    map["WorkerSpecName"] = self.workerSpecName!
                }
                if self.workerSpecType != nil {
                    map["WorkerSpecType"] = self.workerSpecType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AllocateUnit"] as? String {
                    self.allocateUnit = value
                }
                if let value = dict["GroupName"] as? String {
                    self.groupName = value
                }
                if let value = dict["MaxWorkerQuantity"] as? Int32 {
                    self.maxWorkerQuantity = value
                }
                if let value = dict["MinWorkerQuantity"] as? Int32 {
                    self.minWorkerQuantity = value
                }
                if let value = dict["WorkerDiskCapacity"] as? String {
                    self.workerDiskCapacity = value
                }
                if let value = dict["WorkerSpecName"] as? String {
                    self.workerSpecName = value
                }
                if let value = dict["WorkerSpecType"] as? String {
                    self.workerSpecType = value
                }
            }
        }
        public var category: String?

        public var headSpec: String?

        public var workerGroups: [ModifyDBResourceGroupRequest.RayConfig.WorkerGroups]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.category != nil {
                map["Category"] = self.category!
            }
            if self.headSpec != nil {
                map["HeadSpec"] = self.headSpec!
            }
            if self.workerGroups != nil {
                var tmp : [Any] = []
                for k in self.workerGroups! {
                    tmp.append(k.toMap())
                }
                map["WorkerGroups"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Category"] as? String {
                self.category = value
            }
            if let value = dict["HeadSpec"] as? String {
                self.headSpec = value
            }
            if let value = dict["WorkerGroups"] as? [Any?] {
                var tmp : [ModifyDBResourceGroupRequest.RayConfig.WorkerGroups] = []
                for v in value {
                    if v != nil {
                        var model = ModifyDBResourceGroupRequest.RayConfig.WorkerGroups()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.workerGroups = tmp
            }
        }
    }
    public class Rules : Tea.TeaModel {
        public var groupName: String?

        public var queryTime: String?

        public var targetGroupName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.groupName != nil {
                map["GroupName"] = self.groupName!
            }
            if self.queryTime != nil {
                map["QueryTime"] = self.queryTime!
            }
            if self.targetGroupName != nil {
                map["TargetGroupName"] = self.targetGroupName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["GroupName"] as? String {
                self.groupName = value
            }
            if let value = dict["QueryTime"] as? String {
                self.queryTime = value
            }
            if let value = dict["TargetGroupName"] as? String {
                self.targetGroupName = value
            }
        }
    }
    public var autoStopInterval: String?

    public var clusterMode: String?

    public var clusterSizeResource: String?

    public var DBClusterId: String?

    public var enableSpot: Bool?

    public var engineParams: [String: Any]?

    public var groupName: String?

    public var groupType: String?

    public var maxClusterCount: Int32?

    public var maxComputeResource: String?

    public var maxGpuQuantity: Int32?

    public var minClusterCount: Int32?

    public var minComputeResource: String?

    public var minGpuQuantity: Int32?

    public var rayConfig: ModifyDBResourceGroupRequest.RayConfig?

    public var regionId: String?

    public var rules: [ModifyDBResourceGroupRequest.Rules]?

    public var specName: String?

    public var status: String?

    public var targetResourceGroupName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.rayConfig?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.autoStopInterval != nil {
            map["AutoStopInterval"] = self.autoStopInterval!
        }
        if self.clusterMode != nil {
            map["ClusterMode"] = self.clusterMode!
        }
        if self.clusterSizeResource != nil {
            map["ClusterSizeResource"] = self.clusterSizeResource!
        }
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.enableSpot != nil {
            map["EnableSpot"] = self.enableSpot!
        }
        if self.engineParams != nil {
            map["EngineParams"] = self.engineParams!
        }
        if self.groupName != nil {
            map["GroupName"] = self.groupName!
        }
        if self.groupType != nil {
            map["GroupType"] = self.groupType!
        }
        if self.maxClusterCount != nil {
            map["MaxClusterCount"] = self.maxClusterCount!
        }
        if self.maxComputeResource != nil {
            map["MaxComputeResource"] = self.maxComputeResource!
        }
        if self.maxGpuQuantity != nil {
            map["MaxGpuQuantity"] = self.maxGpuQuantity!
        }
        if self.minClusterCount != nil {
            map["MinClusterCount"] = self.minClusterCount!
        }
        if self.minComputeResource != nil {
            map["MinComputeResource"] = self.minComputeResource!
        }
        if self.minGpuQuantity != nil {
            map["MinGpuQuantity"] = self.minGpuQuantity!
        }
        if self.rayConfig != nil {
            map["RayConfig"] = self.rayConfig?.toMap()
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.rules != nil {
            var tmp : [Any] = []
            for k in self.rules! {
                tmp.append(k.toMap())
            }
            map["Rules"] = tmp
        }
        if self.specName != nil {
            map["SpecName"] = self.specName!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.targetResourceGroupName != nil {
            map["TargetResourceGroupName"] = self.targetResourceGroupName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AutoStopInterval"] as? String {
            self.autoStopInterval = value
        }
        if let value = dict["ClusterMode"] as? String {
            self.clusterMode = value
        }
        if let value = dict["ClusterSizeResource"] as? String {
            self.clusterSizeResource = value
        }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["EnableSpot"] as? Bool {
            self.enableSpot = value
        }
        if let value = dict["EngineParams"] as? [String: Any] {
            self.engineParams = value
        }
        if let value = dict["GroupName"] as? String {
            self.groupName = value
        }
        if let value = dict["GroupType"] as? String {
            self.groupType = value
        }
        if let value = dict["MaxClusterCount"] as? Int32 {
            self.maxClusterCount = value
        }
        if let value = dict["MaxComputeResource"] as? String {
            self.maxComputeResource = value
        }
        if let value = dict["MaxGpuQuantity"] as? Int32 {
            self.maxGpuQuantity = value
        }
        if let value = dict["MinClusterCount"] as? Int32 {
            self.minClusterCount = value
        }
        if let value = dict["MinComputeResource"] as? String {
            self.minComputeResource = value
        }
        if let value = dict["MinGpuQuantity"] as? Int32 {
            self.minGpuQuantity = value
        }
        if let value = dict["RayConfig"] as? [String: Any?] {
            var model = ModifyDBResourceGroupRequest.RayConfig()
            model.fromMap(value)
            self.rayConfig = model
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["Rules"] as? [Any?] {
            var tmp : [ModifyDBResourceGroupRequest.Rules] = []
            for v in value {
                if v != nil {
                    var model = ModifyDBResourceGroupRequest.Rules()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.rules = tmp
        }
        if let value = dict["SpecName"] as? String {
            self.specName = value
        }
        if let value = dict["Status"] as? String {
            self.status = value
        }
        if let value = dict["TargetResourceGroupName"] as? String {
            self.targetResourceGroupName = value
        }
    }
}

public class ModifyDBResourceGroupShrinkRequest : Tea.TeaModel {
    public var autoStopInterval: String?

    public var clusterMode: String?

    public var clusterSizeResource: String?

    public var DBClusterId: String?

    public var enableSpot: Bool?

    public var engineParamsShrink: String?

    public var groupName: String?

    public var groupType: String?

    public var maxClusterCount: Int32?

    public var maxComputeResource: String?

    public var maxGpuQuantity: Int32?

    public var minClusterCount: Int32?

    public var minComputeResource: String?

    public var minGpuQuantity: Int32?

    public var rayConfigShrink: String?

    public var regionId: String?

    public var rulesShrink: String?

    public var specName: String?

    public var status: String?

    public var targetResourceGroupName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.autoStopInterval != nil {
            map["AutoStopInterval"] = self.autoStopInterval!
        }
        if self.clusterMode != nil {
            map["ClusterMode"] = self.clusterMode!
        }
        if self.clusterSizeResource != nil {
            map["ClusterSizeResource"] = self.clusterSizeResource!
        }
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.enableSpot != nil {
            map["EnableSpot"] = self.enableSpot!
        }
        if self.engineParamsShrink != nil {
            map["EngineParams"] = self.engineParamsShrink!
        }
        if self.groupName != nil {
            map["GroupName"] = self.groupName!
        }
        if self.groupType != nil {
            map["GroupType"] = self.groupType!
        }
        if self.maxClusterCount != nil {
            map["MaxClusterCount"] = self.maxClusterCount!
        }
        if self.maxComputeResource != nil {
            map["MaxComputeResource"] = self.maxComputeResource!
        }
        if self.maxGpuQuantity != nil {
            map["MaxGpuQuantity"] = self.maxGpuQuantity!
        }
        if self.minClusterCount != nil {
            map["MinClusterCount"] = self.minClusterCount!
        }
        if self.minComputeResource != nil {
            map["MinComputeResource"] = self.minComputeResource!
        }
        if self.minGpuQuantity != nil {
            map["MinGpuQuantity"] = self.minGpuQuantity!
        }
        if self.rayConfigShrink != nil {
            map["RayConfig"] = self.rayConfigShrink!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.rulesShrink != nil {
            map["Rules"] = self.rulesShrink!
        }
        if self.specName != nil {
            map["SpecName"] = self.specName!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.targetResourceGroupName != nil {
            map["TargetResourceGroupName"] = self.targetResourceGroupName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AutoStopInterval"] as? String {
            self.autoStopInterval = value
        }
        if let value = dict["ClusterMode"] as? String {
            self.clusterMode = value
        }
        if let value = dict["ClusterSizeResource"] as? String {
            self.clusterSizeResource = value
        }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["EnableSpot"] as? Bool {
            self.enableSpot = value
        }
        if let value = dict["EngineParams"] as? String {
            self.engineParamsShrink = value
        }
        if let value = dict["GroupName"] as? String {
            self.groupName = value
        }
        if let value = dict["GroupType"] as? String {
            self.groupType = value
        }
        if let value = dict["MaxClusterCount"] as? Int32 {
            self.maxClusterCount = value
        }
        if let value = dict["MaxComputeResource"] as? String {
            self.maxComputeResource = value
        }
        if let value = dict["MaxGpuQuantity"] as? Int32 {
            self.maxGpuQuantity = value
        }
        if let value = dict["MinClusterCount"] as? Int32 {
            self.minClusterCount = value
        }
        if let value = dict["MinComputeResource"] as? String {
            self.minComputeResource = value
        }
        if let value = dict["MinGpuQuantity"] as? Int32 {
            self.minGpuQuantity = value
        }
        if let value = dict["RayConfig"] as? String {
            self.rayConfigShrink = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["Rules"] as? String {
            self.rulesShrink = value
        }
        if let value = dict["SpecName"] as? String {
            self.specName = value
        }
        if let value = dict["Status"] as? String {
            self.status = value
        }
        if let value = dict["TargetResourceGroupName"] as? String {
            self.targetResourceGroupName = value
        }
    }
}

public class ModifyDBResourceGroupResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyDBResourceGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyDBResourceGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyDBResourceGroupResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyElasticPlanRequest : Tea.TeaModel {
    public var cronExpression: String?

    public var DBClusterId: String?

    public var elasticPlanName: String?

    public var endTime: String?

    public var startTime: String?

    public var targetSize: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cronExpression != nil {
            map["CronExpression"] = self.cronExpression!
        }
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.elasticPlanName != nil {
            map["ElasticPlanName"] = self.elasticPlanName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.targetSize != nil {
            map["TargetSize"] = self.targetSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CronExpression"] as? String {
            self.cronExpression = value
        }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["ElasticPlanName"] as? String {
            self.elasticPlanName = value
        }
        if let value = dict["EndTime"] as? String {
            self.endTime = value
        }
        if let value = dict["StartTime"] as? String {
            self.startTime = value
        }
        if let value = dict["TargetSize"] as? String {
            self.targetSize = value
        }
    }
}

public class ModifyElasticPlanResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyElasticPlanResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyElasticPlanResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyElasticPlanResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyEssdCacheConfigRequest : Tea.TeaModel {
    public var DBClusterId: String?

    public var enableEssdCache: Bool?

    public var essdCacheSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.enableEssdCache != nil {
            map["EnableEssdCache"] = self.enableEssdCache!
        }
        if self.essdCacheSize != nil {
            map["EssdCacheSize"] = self.essdCacheSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["EnableEssdCache"] as? Bool {
            self.enableEssdCache = value
        }
        if let value = dict["EssdCacheSize"] as? Int32 {
            self.essdCacheSize = value
        }
    }
}

public class ModifyEssdCacheConfigResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyEssdCacheConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyEssdCacheConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyEssdCacheConfigResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyLakeCacheSizeRequest : Tea.TeaModel {
    public var capacity: Int64?

    public var DBClusterId: String?

    public var enableLakeCache: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.capacity != nil {
            map["Capacity"] = self.capacity!
        }
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.enableLakeCache != nil {
            map["EnableLakeCache"] = self.enableLakeCache!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Capacity"] as? Int64 {
            self.capacity = value
        }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["EnableLakeCache"] as? Bool {
            self.enableLakeCache = value
        }
    }
}

public class ModifyLakeCacheSizeResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var capacity: Int64?

        public var dataSize: Int64?

        public var instances: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.capacity != nil {
                map["Capacity"] = self.capacity!
            }
            if self.dataSize != nil {
                map["DataSize"] = self.dataSize!
            }
            if self.instances != nil {
                map["Instances"] = self.instances!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Capacity"] as? Int64 {
                self.capacity = value
            }
            if let value = dict["DataSize"] as? Int64 {
                self.dataSize = value
            }
            if let value = dict["Instances"] as? [String] {
                self.instances = value
            }
        }
    }
    public var code: Int32?

    public var data: ModifyLakeCacheSizeResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? Int32 {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = ModifyLakeCacheSizeResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyLakeCacheSizeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyLakeCacheSizeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyLakeCacheSizeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyPerformanceViewRequest : Tea.TeaModel {
    public class ViewDetail : Tea.TeaModel {
        public class Categories : Tea.TeaModel {
            public class Keys : Tea.TeaModel {
                public var keyName: String?

                public var selected: Bool?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.keyName != nil {
                        map["KeyName"] = self.keyName!
                    }
                    if self.selected != nil {
                        map["Selected"] = self.selected!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["KeyName"] as? String {
                        self.keyName = value
                    }
                    if let value = dict["Selected"] as? Bool {
                        self.selected = value
                    }
                }
            }
            public var category: String?

            public var keys: [ModifyPerformanceViewRequest.ViewDetail.Categories.Keys]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.category != nil {
                    map["Category"] = self.category!
                }
                if self.keys != nil {
                    var tmp : [Any] = []
                    for k in self.keys! {
                        tmp.append(k.toMap())
                    }
                    map["Keys"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Category"] as? String {
                    self.category = value
                }
                if let value = dict["Keys"] as? [Any?] {
                    var tmp : [ModifyPerformanceViewRequest.ViewDetail.Categories.Keys] = []
                    for v in value {
                        if v != nil {
                            var model = ModifyPerformanceViewRequest.ViewDetail.Categories.Keys()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.keys = tmp
                }
            }
        }
        public var categories: [ModifyPerformanceViewRequest.ViewDetail.Categories]?

        public var chartLinked: Bool?

        public var chartsPerLine: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.categories != nil {
                var tmp : [Any] = []
                for k in self.categories! {
                    tmp.append(k.toMap())
                }
                map["Categories"] = tmp
            }
            if self.chartLinked != nil {
                map["ChartLinked"] = self.chartLinked!
            }
            if self.chartsPerLine != nil {
                map["ChartsPerLine"] = self.chartsPerLine!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Categories"] as? [Any?] {
                var tmp : [ModifyPerformanceViewRequest.ViewDetail.Categories] = []
                for v in value {
                    if v != nil {
                        var model = ModifyPerformanceViewRequest.ViewDetail.Categories()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.categories = tmp
            }
            if let value = dict["ChartLinked"] as? Bool {
                self.chartLinked = value
            }
            if let value = dict["ChartsPerLine"] as? Int32 {
                self.chartsPerLine = value
            }
        }
    }
    public var DBClusterId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var viewDetail: ModifyPerformanceViewRequest.ViewDetail?

    public var viewName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.viewDetail?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.viewDetail != nil {
            map["ViewDetail"] = self.viewDetail?.toMap()
        }
        if self.viewName != nil {
            map["ViewName"] = self.viewName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["ViewDetail"] as? [String: Any?] {
            var model = ModifyPerformanceViewRequest.ViewDetail()
            model.fromMap(value)
            self.viewDetail = model
        }
        if let value = dict["ViewName"] as? String {
            self.viewName = value
        }
    }
}

public class ModifyPerformanceViewShrinkRequest : Tea.TeaModel {
    public var DBClusterId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var viewDetailShrink: String?

    public var viewName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.viewDetailShrink != nil {
            map["ViewDetail"] = self.viewDetailShrink!
        }
        if self.viewName != nil {
            map["ViewName"] = self.viewName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["ViewDetail"] as? String {
            self.viewDetailShrink = value
        }
        if let value = dict["ViewName"] as? String {
            self.viewName = value
        }
    }
}

public class ModifyPerformanceViewResponseBody : Tea.TeaModel {
    public var accessDeniedDetail: String?

    public var modifyStatus: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessDeniedDetail != nil {
            map["AccessDeniedDetail"] = self.accessDeniedDetail!
        }
        if self.modifyStatus != nil {
            map["ModifyStatus"] = self.modifyStatus!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AccessDeniedDetail"] as? String {
            self.accessDeniedDetail = value
        }
        if let value = dict["ModifyStatus"] as? String {
            self.modifyStatus = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ModifyPerformanceViewResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyPerformanceViewResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyPerformanceViewResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyUserEniVswitchOptionsRequest : Tea.TeaModel {
    public var dbClusterId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var vSwitchOptions: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dbClusterId != nil {
            map["DbClusterId"] = self.dbClusterId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.vSwitchOptions != nil {
            map["VSwitchOptions"] = self.vSwitchOptions!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DbClusterId"] as? String {
            self.dbClusterId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["VSwitchOptions"] as? String {
            self.vSwitchOptions = value
        }
    }
}

public class ModifyUserEniVswitchOptionsResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class ModifyUserEniVswitchOptionsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyUserEniVswitchOptionsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyUserEniVswitchOptionsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class PreloadSparkAppMetricsRequest : Tea.TeaModel {
    public var appId: String?

    public var DBClusterId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
    }
}

public class PreloadSparkAppMetricsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class ScanMetrics : Tea.TeaModel {
            public var outputRowsCount: Int64?

            public var totalReadFileSizeInByte: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.outputRowsCount != nil {
                    map["OutputRowsCount"] = self.outputRowsCount!
                }
                if self.totalReadFileSizeInByte != nil {
                    map["TotalReadFileSizeInByte"] = self.totalReadFileSizeInByte!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["OutputRowsCount"] as? Int64 {
                    self.outputRowsCount = value
                }
                if let value = dict["TotalReadFileSizeInByte"] as? Int64 {
                    self.totalReadFileSizeInByte = value
                }
            }
        }
        public var appId: String?

        public var attemptId: String?

        public var eventLogPath: String?

        public var finished: Bool?

        public var scanMetrics: PreloadSparkAppMetricsResponseBody.Data.ScanMetrics?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.scanMetrics?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appId != nil {
                map["AppId"] = self.appId!
            }
            if self.attemptId != nil {
                map["AttemptId"] = self.attemptId!
            }
            if self.eventLogPath != nil {
                map["EventLogPath"] = self.eventLogPath!
            }
            if self.finished != nil {
                map["Finished"] = self.finished!
            }
            if self.scanMetrics != nil {
                map["ScanMetrics"] = self.scanMetrics?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AppId"] as? String {
                self.appId = value
            }
            if let value = dict["AttemptId"] as? String {
                self.attemptId = value
            }
            if let value = dict["EventLogPath"] as? String {
                self.eventLogPath = value
            }
            if let value = dict["Finished"] as? Bool {
                self.finished = value
            }
            if let value = dict["ScanMetrics"] as? [String: Any?] {
                var model = PreloadSparkAppMetricsResponseBody.Data.ScanMetrics()
                model.fromMap(value)
                self.scanMetrics = model
            }
        }
    }
    public var data: PreloadSparkAppMetricsResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [String: Any?] {
            var model = PreloadSparkAppMetricsResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class PreloadSparkAppMetricsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: PreloadSparkAppMetricsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = PreloadSparkAppMetricsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ReleaseClusterPublicConnectionRequest : Tea.TeaModel {
    public var DBClusterId: String?

    public var engine: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.engine != nil {
            map["Engine"] = self.engine!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["Engine"] as? String {
            self.engine = value
        }
    }
}

public class ReleaseClusterPublicConnectionResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ReleaseClusterPublicConnectionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ReleaseClusterPublicConnectionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ReleaseClusterPublicConnectionResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ResetAccountPasswordRequest : Tea.TeaModel {
    public var accountDescription: String?

    public var accountName: String?

    public var accountPassword: String?

    public var DBClusterId: String?

    public var engine: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accountDescription != nil {
            map["AccountDescription"] = self.accountDescription!
        }
        if self.accountName != nil {
            map["AccountName"] = self.accountName!
        }
        if self.accountPassword != nil {
            map["AccountPassword"] = self.accountPassword!
        }
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.engine != nil {
            map["Engine"] = self.engine!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AccountDescription"] as? String {
            self.accountDescription = value
        }
        if let value = dict["AccountName"] as? String {
            self.accountName = value
        }
        if let value = dict["AccountPassword"] as? String {
            self.accountPassword = value
        }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["Engine"] as? String {
            self.engine = value
        }
    }
}

public class ResetAccountPasswordResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ResetAccountPasswordResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ResetAccountPasswordResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ResetAccountPasswordResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class RevokeOperatorPermissionRequest : Tea.TeaModel {
    public var DBClusterId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
    }
}

public class RevokeOperatorPermissionResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class RevokeOperatorPermissionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RevokeOperatorPermissionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = RevokeOperatorPermissionResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class SetSparkAppLogRootPathRequest : Tea.TeaModel {
    public var DBClusterId: String?

    public var ossLogPath: String?

    public var useDefaultOss: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.ossLogPath != nil {
            map["OssLogPath"] = self.ossLogPath!
        }
        if self.useDefaultOss != nil {
            map["UseDefaultOss"] = self.useDefaultOss!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["OssLogPath"] as? String {
            self.ossLogPath = value
        }
        if let value = dict["UseDefaultOss"] as? Bool {
            self.useDefaultOss = value
        }
    }
}

public class SetSparkAppLogRootPathResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var defaultLogPath: String?

        public var isLogPathExists: Bool?

        public var modifiedTimestamp: String?

        public var modifiedUid: String?

        public var recordedLogPath: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.defaultLogPath != nil {
                map["DefaultLogPath"] = self.defaultLogPath!
            }
            if self.isLogPathExists != nil {
                map["IsLogPathExists"] = self.isLogPathExists!
            }
            if self.modifiedTimestamp != nil {
                map["ModifiedTimestamp"] = self.modifiedTimestamp!
            }
            if self.modifiedUid != nil {
                map["ModifiedUid"] = self.modifiedUid!
            }
            if self.recordedLogPath != nil {
                map["RecordedLogPath"] = self.recordedLogPath!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DefaultLogPath"] as? String {
                self.defaultLogPath = value
            }
            if let value = dict["IsLogPathExists"] as? Bool {
                self.isLogPathExists = value
            }
            if let value = dict["ModifiedTimestamp"] as? String {
                self.modifiedTimestamp = value
            }
            if let value = dict["ModifiedUid"] as? String {
                self.modifiedUid = value
            }
            if let value = dict["RecordedLogPath"] as? String {
                self.recordedLogPath = value
            }
        }
    }
    public var data: SetSparkAppLogRootPathResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [String: Any?] {
            var model = SetSparkAppLogRootPathResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class SetSparkAppLogRootPathResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SetSparkAppLogRootPathResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = SetSparkAppLogRootPathResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class StartApsJobRequest : Tea.TeaModel {
    public var apsJobId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apsJobId != nil {
            map["ApsJobId"] = self.apsJobId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ApsJobId"] as? String {
            self.apsJobId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class StartApsJobResponseBody : Tea.TeaModel {
    public var apsJobId: String?

    public var code: String?

    public var errCode: String?

    public var errMessage: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apsJobId != nil {
            map["ApsJobId"] = self.apsJobId!
        }
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.errCode != nil {
            map["ErrCode"] = self.errCode!
        }
        if self.errMessage != nil {
            map["ErrMessage"] = self.errMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ApsJobId"] as? String {
            self.apsJobId = value
        }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["ErrCode"] as? String {
            self.errCode = value
        }
        if let value = dict["ErrMessage"] as? String {
            self.errMessage = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class StartApsJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StartApsJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = StartApsJobResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class StartSparkReplSessionRequest : Tea.TeaModel {
    public var config: String?

    public var DBClusterId: String?

    public var resourceGroupName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.config != nil {
            map["Config"] = self.config!
        }
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.resourceGroupName != nil {
            map["ResourceGroupName"] = self.resourceGroupName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Config"] as? String {
            self.config = value
        }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["ResourceGroupName"] as? String {
            self.resourceGroupName = value
        }
    }
}

public class StartSparkReplSessionResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var aliyunUid: String?

        public var attemptId: String?

        public var error: String?

        public var sessionId: Int64?

        public var state: String?

        public var webUiAddress: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.aliyunUid != nil {
                map["AliyunUid"] = self.aliyunUid!
            }
            if self.attemptId != nil {
                map["AttemptId"] = self.attemptId!
            }
            if self.error != nil {
                map["Error"] = self.error!
            }
            if self.sessionId != nil {
                map["SessionId"] = self.sessionId!
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            if self.webUiAddress != nil {
                map["WebUiAddress"] = self.webUiAddress!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AliyunUid"] as? String {
                self.aliyunUid = value
            }
            if let value = dict["AttemptId"] as? String {
                self.attemptId = value
            }
            if let value = dict["Error"] as? String {
                self.error = value
            }
            if let value = dict["SessionId"] as? Int64 {
                self.sessionId = value
            }
            if let value = dict["State"] as? String {
                self.state = value
            }
            if let value = dict["WebUiAddress"] as? String {
                self.webUiAddress = value
            }
        }
    }
    public var data: StartSparkReplSessionResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [String: Any?] {
            var model = StartSparkReplSessionResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class StartSparkReplSessionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StartSparkReplSessionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = StartSparkReplSessionResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class StartSparkSQLEngineRequest : Tea.TeaModel {
    public var config: String?

    public var DBClusterId: String?

    public var jars: String?

    public var maxExecutor: Int64?

    public var minExecutor: Int64?

    public var resourceGroupName: String?

    public var slotNum: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.config != nil {
            map["Config"] = self.config!
        }
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.jars != nil {
            map["Jars"] = self.jars!
        }
        if self.maxExecutor != nil {
            map["MaxExecutor"] = self.maxExecutor!
        }
        if self.minExecutor != nil {
            map["MinExecutor"] = self.minExecutor!
        }
        if self.resourceGroupName != nil {
            map["ResourceGroupName"] = self.resourceGroupName!
        }
        if self.slotNum != nil {
            map["SlotNum"] = self.slotNum!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Config"] as? String {
            self.config = value
        }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["Jars"] as? String {
            self.jars = value
        }
        if let value = dict["MaxExecutor"] as? Int64 {
            self.maxExecutor = value
        }
        if let value = dict["MinExecutor"] as? Int64 {
            self.minExecutor = value
        }
        if let value = dict["ResourceGroupName"] as? String {
            self.resourceGroupName = value
        }
        if let value = dict["SlotNum"] as? Int64 {
            self.slotNum = value
        }
    }
}

public class StartSparkSQLEngineResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var appId: String?

        public var appName: String?

        public var state: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appId != nil {
                map["AppId"] = self.appId!
            }
            if self.appName != nil {
                map["AppName"] = self.appName!
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AppId"] as? String {
                self.appId = value
            }
            if let value = dict["AppName"] as? String {
                self.appName = value
            }
            if let value = dict["State"] as? String {
                self.state = value
            }
        }
    }
    public var data: StartSparkSQLEngineResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [String: Any?] {
            var model = StartSparkSQLEngineResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class StartSparkSQLEngineResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StartSparkSQLEngineResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = StartSparkSQLEngineResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class SubmitResultExportJobRequest : Tea.TeaModel {
    public var DBClusterId: String?

    public var engine: String?

    public var exportType: String?

    public var regionId: String?

    public var resourceGroup: String?

    public var SQL: String?

    public var schema: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.engine != nil {
            map["Engine"] = self.engine!
        }
        if self.exportType != nil {
            map["ExportType"] = self.exportType!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroup != nil {
            map["ResourceGroup"] = self.resourceGroup!
        }
        if self.SQL != nil {
            map["SQL"] = self.SQL!
        }
        if self.schema != nil {
            map["Schema"] = self.schema!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["Engine"] as? String {
            self.engine = value
        }
        if let value = dict["ExportType"] as? String {
            self.exportType = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["ResourceGroup"] as? String {
            self.resourceGroup = value
        }
        if let value = dict["SQL"] as? String {
            self.SQL = value
        }
        if let value = dict["Schema"] as? String {
            self.schema = value
        }
    }
}

public class SubmitResultExportJobResponseBody : Tea.TeaModel {
    public var code: String?

    public var data: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? String {
            self.data = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class SubmitResultExportJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SubmitResultExportJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = SubmitResultExportJobResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class SubmitSparkAppRequest : Tea.TeaModel {
    public var agentSource: String?

    public var agentVersion: String?

    public var appName: String?

    public var appType: String?

    public var DBClusterId: String?

    public var data: String?

    public var resourceGroupName: String?

    public var templateFileId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.agentSource != nil {
            map["AgentSource"] = self.agentSource!
        }
        if self.agentVersion != nil {
            map["AgentVersion"] = self.agentVersion!
        }
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.appType != nil {
            map["AppType"] = self.appType!
        }
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.resourceGroupName != nil {
            map["ResourceGroupName"] = self.resourceGroupName!
        }
        if self.templateFileId != nil {
            map["TemplateFileId"] = self.templateFileId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AgentSource"] as? String {
            self.agentSource = value
        }
        if let value = dict["AgentVersion"] as? String {
            self.agentVersion = value
        }
        if let value = dict["AppName"] as? String {
            self.appName = value
        }
        if let value = dict["AppType"] as? String {
            self.appType = value
        }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["Data"] as? String {
            self.data = value
        }
        if let value = dict["ResourceGroupName"] as? String {
            self.resourceGroupName = value
        }
        if let value = dict["TemplateFileId"] as? Int64 {
            self.templateFileId = value
        }
    }
}

public class SubmitSparkAppResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var appId: String?

        public var appName: String?

        public var message: String?

        public var state: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appId != nil {
                map["AppId"] = self.appId!
            }
            if self.appName != nil {
                map["AppName"] = self.appName!
            }
            if self.message != nil {
                map["Message"] = self.message!
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AppId"] as? String {
                self.appId = value
            }
            if let value = dict["AppName"] as? String {
                self.appName = value
            }
            if let value = dict["Message"] as? String {
                self.message = value
            }
            if let value = dict["State"] as? String {
                self.state = value
            }
        }
    }
    public var data: SubmitSparkAppResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [String: Any?] {
            var model = SubmitSparkAppResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class SubmitSparkAppResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SubmitSparkAppResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = SubmitSparkAppResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class SubmitSparkLogAnalyzeTaskRequest : Tea.TeaModel {
    public var appId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AppId"] as? String {
            self.appId = value
        }
    }
}

public class SubmitSparkLogAnalyzeTaskResponseBody : Tea.TeaModel {
    public var data: SparkAnalyzeLogTask?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [String: Any?] {
            var model = SparkAnalyzeLogTask()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class SubmitSparkLogAnalyzeTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SubmitSparkLogAnalyzeTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = SubmitSparkLogAnalyzeTaskResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class SuspendApsJobRequest : Tea.TeaModel {
    public var apsJobId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apsJobId != nil {
            map["ApsJobId"] = self.apsJobId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ApsJobId"] as? String {
            self.apsJobId = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class SuspendApsJobResponseBody : Tea.TeaModel {
    public var apsJobId: String?

    public var errCode: String?

    public var errMessage: String?

    public var httpStatusCode: Int32?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.apsJobId != nil {
            map["ApsJobId"] = self.apsJobId!
        }
        if self.errCode != nil {
            map["ErrCode"] = self.errCode!
        }
        if self.errMessage != nil {
            map["ErrMessage"] = self.errMessage!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ApsJobId"] as? String {
            self.apsJobId = value
        }
        if let value = dict["ErrCode"] as? String {
            self.errCode = value
        }
        if let value = dict["ErrMessage"] as? String {
            self.errMessage = value
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class SuspendApsJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SuspendApsJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = SuspendApsJobResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UnbindAccountRequest : Tea.TeaModel {
    public var accountName: String?

    public var DBClusterId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accountName != nil {
            map["AccountName"] = self.accountName!
        }
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AccountName"] as? String {
            self.accountName = value
        }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
    }
}

public class UnbindAccountResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class UnbindAccountResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UnbindAccountResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UnbindAccountResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UnbindDBResourceGroupWithUserRequest : Tea.TeaModel {
    public var DBClusterId: String?

    public var groupName: String?

    public var groupUser: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.groupName != nil {
            map["GroupName"] = self.groupName!
        }
        if self.groupUser != nil {
            map["GroupUser"] = self.groupUser!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["GroupName"] as? String {
            self.groupName = value
        }
        if let value = dict["GroupUser"] as? String {
            self.groupUser = value
        }
    }
}

public class UnbindDBResourceGroupWithUserResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class UnbindDBResourceGroupWithUserResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UnbindDBResourceGroupWithUserResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UnbindDBResourceGroupWithUserResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateLakeStorageRequest : Tea.TeaModel {
    public class Permissions : Tea.TeaModel {
        public var account: String?

        public var read: Bool?

        public var type: String?

        public var write: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.account != nil {
                map["Account"] = self.account!
            }
            if self.read != nil {
                map["Read"] = self.read!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.write != nil {
                map["Write"] = self.write!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Account"] as? String {
                self.account = value
            }
            if let value = dict["Read"] as? Bool {
                self.read = value
            }
            if let value = dict["Type"] as? String {
                self.type = value
            }
            if let value = dict["Write"] as? Bool {
                self.write = value
            }
        }
    }
    public var DBClusterId: String?

    public var description_: String?

    public var lakeStorageId: String?

    public var permissions: [UpdateLakeStorageRequest.Permissions]?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.lakeStorageId != nil {
            map["LakeStorageId"] = self.lakeStorageId!
        }
        if self.permissions != nil {
            var tmp : [Any] = []
            for k in self.permissions! {
                tmp.append(k.toMap())
            }
            map["Permissions"] = tmp
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["LakeStorageId"] as? String {
            self.lakeStorageId = value
        }
        if let value = dict["Permissions"] as? [Any?] {
            var tmp : [UpdateLakeStorageRequest.Permissions] = []
            for v in value {
                if v != nil {
                    var model = UpdateLakeStorageRequest.Permissions()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.permissions = tmp
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class UpdateLakeStorageShrinkRequest : Tea.TeaModel {
    public var DBClusterId: String?

    public var description_: String?

    public var lakeStorageId: String?

    public var permissionsShrink: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.lakeStorageId != nil {
            map["LakeStorageId"] = self.lakeStorageId!
        }
        if self.permissionsShrink != nil {
            map["Permissions"] = self.permissionsShrink!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["LakeStorageId"] as? String {
            self.lakeStorageId = value
        }
        if let value = dict["Permissions"] as? String {
            self.permissionsShrink = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
    }
}

public class UpdateLakeStorageResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Permissions : Tea.TeaModel {
            public var account: String?

            public var read: Bool?

            public var type: String?

            public var write: Bool?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.account != nil {
                    map["Account"] = self.account!
                }
                if self.read != nil {
                    map["Read"] = self.read!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.write != nil {
                    map["Write"] = self.write!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Account"] as? String {
                    self.account = value
                }
                if let value = dict["Read"] as? Bool {
                    self.read = value
                }
                if let value = dict["Type"] as? String {
                    self.type = value
                }
                if let value = dict["Write"] as? Bool {
                    self.write = value
                }
            }
        }
        public var createTime: String?

        public var creatorUid: String?

        public var DBClusterId: String?

        public var description_: String?

        public var fileSize: String?

        public var lakeStorageId: String?

        public var operatorUid: String?

        public var ownerUid: String?

        public var partitionCount: String?

        public var permissions: [UpdateLakeStorageResponseBody.Data.Permissions]?

        public var regionId: String?

        public var rowCount: Int64?

        public var tableCount: Int32?

        public var updateTime: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.creatorUid != nil {
                map["CreatorUid"] = self.creatorUid!
            }
            if self.DBClusterId != nil {
                map["DBClusterId"] = self.DBClusterId!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.fileSize != nil {
                map["FileSize"] = self.fileSize!
            }
            if self.lakeStorageId != nil {
                map["LakeStorageId"] = self.lakeStorageId!
            }
            if self.operatorUid != nil {
                map["OperatorUid"] = self.operatorUid!
            }
            if self.ownerUid != nil {
                map["OwnerUid"] = self.ownerUid!
            }
            if self.partitionCount != nil {
                map["PartitionCount"] = self.partitionCount!
            }
            if self.permissions != nil {
                var tmp : [Any] = []
                for k in self.permissions! {
                    tmp.append(k.toMap())
                }
                map["Permissions"] = tmp
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.rowCount != nil {
                map["RowCount"] = self.rowCount!
            }
            if self.tableCount != nil {
                map["TableCount"] = self.tableCount!
            }
            if self.updateTime != nil {
                map["UpdateTime"] = self.updateTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["CreateTime"] as? String {
                self.createTime = value
            }
            if let value = dict["CreatorUid"] as? String {
                self.creatorUid = value
            }
            if let value = dict["DBClusterId"] as? String {
                self.DBClusterId = value
            }
            if let value = dict["Description"] as? String {
                self.description_ = value
            }
            if let value = dict["FileSize"] as? String {
                self.fileSize = value
            }
            if let value = dict["LakeStorageId"] as? String {
                self.lakeStorageId = value
            }
            if let value = dict["OperatorUid"] as? String {
                self.operatorUid = value
            }
            if let value = dict["OwnerUid"] as? String {
                self.ownerUid = value
            }
            if let value = dict["PartitionCount"] as? String {
                self.partitionCount = value
            }
            if let value = dict["Permissions"] as? [Any?] {
                var tmp : [UpdateLakeStorageResponseBody.Data.Permissions] = []
                for v in value {
                    if v != nil {
                        var model = UpdateLakeStorageResponseBody.Data.Permissions()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.permissions = tmp
            }
            if let value = dict["RegionId"] as? String {
                self.regionId = value
            }
            if let value = dict["RowCount"] as? Int64 {
                self.rowCount = value
            }
            if let value = dict["TableCount"] as? Int32 {
                self.tableCount = value
            }
            if let value = dict["UpdateTime"] as? String {
                self.updateTime = value
            }
        }
    }
    public var code: String?

    public var data: UpdateLakeStorageResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Data"] as? [String: Any?] {
            var model = UpdateLakeStorageResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["HttpStatusCode"] as? Int32 {
            self.httpStatusCode = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class UpdateLakeStorageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateLakeStorageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateLakeStorageResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateSparkTemplateFileRequest : Tea.TeaModel {
    public var content: String?

    public var DBClusterId: String?

    public var id: Int64?

    public var resourceGroupName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.content != nil {
            map["Content"] = self.content!
        }
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.resourceGroupName != nil {
            map["ResourceGroupName"] = self.resourceGroupName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Content"] as? String {
            self.content = value
        }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["Id"] as? Int64 {
            self.id = value
        }
        if let value = dict["ResourceGroupName"] as? String {
            self.resourceGroupName = value
        }
    }
}

public class UpdateSparkTemplateFileResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var succeeded: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.succeeded != nil {
                map["Succeeded"] = self.succeeded!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Succeeded"] as? Bool {
                self.succeeded = value
            }
        }
    }
    public var data: UpdateSparkTemplateFileResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Data"] as? [String: Any?] {
            var model = UpdateSparkTemplateFileResponseBody.Data()
            model.fromMap(value)
            self.data = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class UpdateSparkTemplateFileResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateSparkTemplateFileResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateSparkTemplateFileResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpgradeKernelVersionRequest : Tea.TeaModel {
    public var DBClusterId: String?

    public var DBVersion: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var switchMode: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.DBClusterId != nil {
            map["DBClusterId"] = self.DBClusterId!
        }
        if self.DBVersion != nil {
            map["DBVersion"] = self.DBVersion!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.switchMode != nil {
            map["SwitchMode"] = self.switchMode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DBClusterId"] as? String {
            self.DBClusterId = value
        }
        if let value = dict["DBVersion"] as? String {
            self.DBVersion = value
        }
        if let value = dict["OwnerAccount"] as? String {
            self.ownerAccount = value
        }
        if let value = dict["OwnerId"] as? Int64 {
            self.ownerId = value
        }
        if let value = dict["ResourceOwnerAccount"] as? String {
            self.resourceOwnerAccount = value
        }
        if let value = dict["ResourceOwnerId"] as? Int64 {
            self.resourceOwnerId = value
        }
        if let value = dict["SwitchMode"] as? Int32 {
            self.switchMode = value
        }
    }
}

public class UpgradeKernelVersionResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class UpgradeKernelVersionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpgradeKernelVersionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpgradeKernelVersionResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}
