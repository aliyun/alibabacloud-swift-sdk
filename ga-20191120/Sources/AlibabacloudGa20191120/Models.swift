import Foundation
import Tea
import TeaUtils
import AlibabacloudOpenApi
import AlibabaCloudOpenApiUtil
import AlibabacloudEndpointUtil

public class AddEntriesToAclRequest : Tea.TeaModel {
    public class AclEntries : Tea.TeaModel {
        public var entry: String?

        public var entryDescription: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.entry != nil {
                map["Entry"] = self.entry!
            }
            if self.entryDescription != nil {
                map["EntryDescription"] = self.entryDescription!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Entry") && dict["Entry"] != nil {
                self.entry = dict["Entry"] as! String
            }
            if dict.keys.contains("EntryDescription") && dict["EntryDescription"] != nil {
                self.entryDescription = dict["EntryDescription"] as! String
            }
        }
    }
    public var aclEntries: [AddEntriesToAclRequest.AclEntries]?

    public var aclId: String?

    public var clientToken: String?

    public var dryRun: Bool?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aclEntries != nil {
            var tmp : [Any] = []
            for k in self.aclEntries! {
                tmp.append(k.toMap())
            }
            map["AclEntries"] = tmp
        }
        if self.aclId != nil {
            map["AclId"] = self.aclId!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AclEntries") && dict["AclEntries"] != nil {
            var tmp : [AddEntriesToAclRequest.AclEntries] = []
            for v in dict["AclEntries"] as! [Any] {
                var model = AddEntriesToAclRequest.AclEntries()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.aclEntries = tmp
        }
        if dict.keys.contains("AclId") && dict["AclId"] != nil {
            self.aclId = dict["AclId"] as! String
        }
        if dict.keys.contains("ClientToken") && dict["ClientToken"] != nil {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("DryRun") && dict["DryRun"] != nil {
            self.dryRun = dict["DryRun"] as! Bool
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class AddEntriesToAclResponseBody : Tea.TeaModel {
    public var aclId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aclId != nil {
            map["AclId"] = self.aclId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AclId") && dict["AclId"] != nil {
            self.aclId = dict["AclId"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AddEntriesToAclResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddEntriesToAclResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = AddEntriesToAclResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AssociateAclsWithListenerRequest : Tea.TeaModel {
    public var aclIds: [String]?

    public var aclType: String?

    public var clientToken: String?

    public var dryRun: Bool?

    public var listenerId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aclIds != nil {
            map["AclIds"] = self.aclIds!
        }
        if self.aclType != nil {
            map["AclType"] = self.aclType!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.listenerId != nil {
            map["ListenerId"] = self.listenerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AclIds") && dict["AclIds"] != nil {
            self.aclIds = dict["AclIds"] as! [String]
        }
        if dict.keys.contains("AclType") && dict["AclType"] != nil {
            self.aclType = dict["AclType"] as! String
        }
        if dict.keys.contains("ClientToken") && dict["ClientToken"] != nil {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("DryRun") && dict["DryRun"] != nil {
            self.dryRun = dict["DryRun"] as! Bool
        }
        if dict.keys.contains("ListenerId") && dict["ListenerId"] != nil {
            self.listenerId = dict["ListenerId"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class AssociateAclsWithListenerResponseBody : Tea.TeaModel {
    public var aclIds: [String]?

    public var listenerId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aclIds != nil {
            map["AclIds"] = self.aclIds!
        }
        if self.listenerId != nil {
            map["ListenerId"] = self.listenerId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AclIds") && dict["AclIds"] != nil {
            self.aclIds = dict["AclIds"] as! [String]
        }
        if dict.keys.contains("ListenerId") && dict["ListenerId"] != nil {
            self.listenerId = dict["ListenerId"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AssociateAclsWithListenerResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AssociateAclsWithListenerResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = AssociateAclsWithListenerResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AssociateAdditionalCertificatesWithListenerRequest : Tea.TeaModel {
    public class Certificates : Tea.TeaModel {
        public var domain: String?

        public var id: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.domain != nil {
                map["Domain"] = self.domain!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Domain") && dict["Domain"] != nil {
                self.domain = dict["Domain"] as! String
            }
            if dict.keys.contains("Id") && dict["Id"] != nil {
                self.id = dict["Id"] as! String
            }
        }
    }
    public var acceleratorId: String?

    public var certificates: [AssociateAdditionalCertificatesWithListenerRequest.Certificates]?

    public var clientToken: String?

    public var listenerId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceleratorId != nil {
            map["AcceleratorId"] = self.acceleratorId!
        }
        if self.certificates != nil {
            var tmp : [Any] = []
            for k in self.certificates! {
                tmp.append(k.toMap())
            }
            map["Certificates"] = tmp
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.listenerId != nil {
            map["ListenerId"] = self.listenerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceleratorId") && dict["AcceleratorId"] != nil {
            self.acceleratorId = dict["AcceleratorId"] as! String
        }
        if dict.keys.contains("Certificates") && dict["Certificates"] != nil {
            var tmp : [AssociateAdditionalCertificatesWithListenerRequest.Certificates] = []
            for v in dict["Certificates"] as! [Any] {
                var model = AssociateAdditionalCertificatesWithListenerRequest.Certificates()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.certificates = tmp
        }
        if dict.keys.contains("ClientToken") && dict["ClientToken"] != nil {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("ListenerId") && dict["ListenerId"] != nil {
            self.listenerId = dict["ListenerId"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class AssociateAdditionalCertificatesWithListenerResponseBody : Tea.TeaModel {
    public var listenerId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.listenerId != nil {
            map["ListenerId"] = self.listenerId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ListenerId") && dict["ListenerId"] != nil {
            self.listenerId = dict["ListenerId"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AssociateAdditionalCertificatesWithListenerResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AssociateAdditionalCertificatesWithListenerResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = AssociateAdditionalCertificatesWithListenerResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AttachDdosToAcceleratorRequest : Tea.TeaModel {
    public var acceleratorId: String?

    public var ddosId: String?

    public var ddosRegionId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceleratorId != nil {
            map["AcceleratorId"] = self.acceleratorId!
        }
        if self.ddosId != nil {
            map["DdosId"] = self.ddosId!
        }
        if self.ddosRegionId != nil {
            map["DdosRegionId"] = self.ddosRegionId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceleratorId") && dict["AcceleratorId"] != nil {
            self.acceleratorId = dict["AcceleratorId"] as! String
        }
        if dict.keys.contains("DdosId") && dict["DdosId"] != nil {
            self.ddosId = dict["DdosId"] as! String
        }
        if dict.keys.contains("DdosRegionId") && dict["DdosRegionId"] != nil {
            self.ddosRegionId = dict["DdosRegionId"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class AttachDdosToAcceleratorResponseBody : Tea.TeaModel {
    public var ddosId: String?

    public var gaId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ddosId != nil {
            map["DdosId"] = self.ddosId!
        }
        if self.gaId != nil {
            map["GaId"] = self.gaId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DdosId") && dict["DdosId"] != nil {
            self.ddosId = dict["DdosId"] as! String
        }
        if dict.keys.contains("GaId") && dict["GaId"] != nil {
            self.gaId = dict["GaId"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AttachDdosToAcceleratorResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AttachDdosToAcceleratorResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = AttachDdosToAcceleratorResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AttachLogStoreToEndpointGroupRequest : Tea.TeaModel {
    public var acceleratorId: String?

    public var clientToken: String?

    public var endpointGroupIds: [String]?

    public var listenerId: String?

    public var regionId: String?

    public var slsLogStoreName: String?

    public var slsProjectName: String?

    public var slsRegionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceleratorId != nil {
            map["AcceleratorId"] = self.acceleratorId!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.endpointGroupIds != nil {
            map["EndpointGroupIds"] = self.endpointGroupIds!
        }
        if self.listenerId != nil {
            map["ListenerId"] = self.listenerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.slsLogStoreName != nil {
            map["SlsLogStoreName"] = self.slsLogStoreName!
        }
        if self.slsProjectName != nil {
            map["SlsProjectName"] = self.slsProjectName!
        }
        if self.slsRegionId != nil {
            map["SlsRegionId"] = self.slsRegionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceleratorId") && dict["AcceleratorId"] != nil {
            self.acceleratorId = dict["AcceleratorId"] as! String
        }
        if dict.keys.contains("ClientToken") && dict["ClientToken"] != nil {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("EndpointGroupIds") && dict["EndpointGroupIds"] != nil {
            self.endpointGroupIds = dict["EndpointGroupIds"] as! [String]
        }
        if dict.keys.contains("ListenerId") && dict["ListenerId"] != nil {
            self.listenerId = dict["ListenerId"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("SlsLogStoreName") && dict["SlsLogStoreName"] != nil {
            self.slsLogStoreName = dict["SlsLogStoreName"] as! String
        }
        if dict.keys.contains("SlsProjectName") && dict["SlsProjectName"] != nil {
            self.slsProjectName = dict["SlsProjectName"] as! String
        }
        if dict.keys.contains("SlsRegionId") && dict["SlsRegionId"] != nil {
            self.slsRegionId = dict["SlsRegionId"] as! String
        }
    }
}

public class AttachLogStoreToEndpointGroupResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AttachLogStoreToEndpointGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AttachLogStoreToEndpointGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = AttachLogStoreToEndpointGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class BandwidthPackageAddAcceleratorRequest : Tea.TeaModel {
    public var acceleratorId: String?

    public var bandwidthPackageId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceleratorId != nil {
            map["AcceleratorId"] = self.acceleratorId!
        }
        if self.bandwidthPackageId != nil {
            map["BandwidthPackageId"] = self.bandwidthPackageId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceleratorId") && dict["AcceleratorId"] != nil {
            self.acceleratorId = dict["AcceleratorId"] as! String
        }
        if dict.keys.contains("BandwidthPackageId") && dict["BandwidthPackageId"] != nil {
            self.bandwidthPackageId = dict["BandwidthPackageId"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class BandwidthPackageAddAcceleratorResponseBody : Tea.TeaModel {
    public var accelerators: [String]?

    public var bandwidthPackageId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accelerators != nil {
            map["Accelerators"] = self.accelerators!
        }
        if self.bandwidthPackageId != nil {
            map["BandwidthPackageId"] = self.bandwidthPackageId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Accelerators") && dict["Accelerators"] != nil {
            self.accelerators = dict["Accelerators"] as! [String]
        }
        if dict.keys.contains("BandwidthPackageId") && dict["BandwidthPackageId"] != nil {
            self.bandwidthPackageId = dict["BandwidthPackageId"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class BandwidthPackageAddAcceleratorResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: BandwidthPackageAddAcceleratorResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = BandwidthPackageAddAcceleratorResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class BandwidthPackageRemoveAcceleratorRequest : Tea.TeaModel {
    public var acceleratorId: String?

    public var bandwidthPackageId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceleratorId != nil {
            map["AcceleratorId"] = self.acceleratorId!
        }
        if self.bandwidthPackageId != nil {
            map["BandwidthPackageId"] = self.bandwidthPackageId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceleratorId") && dict["AcceleratorId"] != nil {
            self.acceleratorId = dict["AcceleratorId"] as! String
        }
        if dict.keys.contains("BandwidthPackageId") && dict["BandwidthPackageId"] != nil {
            self.bandwidthPackageId = dict["BandwidthPackageId"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class BandwidthPackageRemoveAcceleratorResponseBody : Tea.TeaModel {
    public var accelerators: [String]?

    public var bandwidthPackageId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accelerators != nil {
            map["Accelerators"] = self.accelerators!
        }
        if self.bandwidthPackageId != nil {
            map["BandwidthPackageId"] = self.bandwidthPackageId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Accelerators") && dict["Accelerators"] != nil {
            self.accelerators = dict["Accelerators"] as! [String]
        }
        if dict.keys.contains("BandwidthPackageId") && dict["BandwidthPackageId"] != nil {
            self.bandwidthPackageId = dict["BandwidthPackageId"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class BandwidthPackageRemoveAcceleratorResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: BandwidthPackageRemoveAcceleratorResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = BandwidthPackageRemoveAcceleratorResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ChangeResourceGroupRequest : Tea.TeaModel {
    public var clientToken: String?

    public var newResourceGroupId: String?

    public var regionId: String?

    public var resourceId: String?

    public var resourceType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.newResourceGroupId != nil {
            map["NewResourceGroupId"] = self.newResourceGroupId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") && dict["ClientToken"] != nil {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("NewResourceGroupId") && dict["NewResourceGroupId"] != nil {
            self.newResourceGroupId = dict["NewResourceGroupId"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceId") && dict["ResourceId"] != nil {
            self.resourceId = dict["ResourceId"] as! String
        }
        if dict.keys.contains("ResourceType") && dict["ResourceType"] != nil {
            self.resourceType = dict["ResourceType"] as! String
        }
    }
}

public class ChangeResourceGroupResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ChangeResourceGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ChangeResourceGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ChangeResourceGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ConfigEndpointProbeRequest : Tea.TeaModel {
    public var clientToken: String?

    public var enable: String?

    public var endpoint: String?

    public var endpointGroupId: String?

    public var endpointType: String?

    public var probePort: String?

    public var probeProtocol: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.enable != nil {
            map["Enable"] = self.enable!
        }
        if self.endpoint != nil {
            map["Endpoint"] = self.endpoint!
        }
        if self.endpointGroupId != nil {
            map["EndpointGroupId"] = self.endpointGroupId!
        }
        if self.endpointType != nil {
            map["EndpointType"] = self.endpointType!
        }
        if self.probePort != nil {
            map["ProbePort"] = self.probePort!
        }
        if self.probeProtocol != nil {
            map["ProbeProtocol"] = self.probeProtocol!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") && dict["ClientToken"] != nil {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("Enable") && dict["Enable"] != nil {
            self.enable = dict["Enable"] as! String
        }
        if dict.keys.contains("Endpoint") && dict["Endpoint"] != nil {
            self.endpoint = dict["Endpoint"] as! String
        }
        if dict.keys.contains("EndpointGroupId") && dict["EndpointGroupId"] != nil {
            self.endpointGroupId = dict["EndpointGroupId"] as! String
        }
        if dict.keys.contains("EndpointType") && dict["EndpointType"] != nil {
            self.endpointType = dict["EndpointType"] as! String
        }
        if dict.keys.contains("ProbePort") && dict["ProbePort"] != nil {
            self.probePort = dict["ProbePort"] as! String
        }
        if dict.keys.contains("ProbeProtocol") && dict["ProbeProtocol"] != nil {
            self.probeProtocol = dict["ProbeProtocol"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class ConfigEndpointProbeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ConfigEndpointProbeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ConfigEndpointProbeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ConfigEndpointProbeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateAcceleratorRequest : Tea.TeaModel {
    public class IpSetConfig : Tea.TeaModel {
        public var accessMode: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accessMode != nil {
                map["AccessMode"] = self.accessMode!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AccessMode") && dict["AccessMode"] != nil {
                self.accessMode = dict["AccessMode"] as! String
            }
        }
    }
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") && dict["Key"] != nil {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") && dict["Value"] != nil {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var autoPay: Bool?

    public var autoRenew: Bool?

    public var autoRenewDuration: Int32?

    public var autoUseCoupon: String?

    public var bandwidthBillingType: String?

    public var clientToken: String?

    public var dryRun: Bool?

    public var duration: Int32?

    public var instanceChargeType: String?

    public var ipSetConfig: CreateAcceleratorRequest.IpSetConfig?

    public var name: String?

    public var pricingCycle: String?

    public var promotionOptionNo: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var spec: String?

    public var tag: [CreateAcceleratorRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.ipSetConfig?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.autoPay != nil {
            map["AutoPay"] = self.autoPay!
        }
        if self.autoRenew != nil {
            map["AutoRenew"] = self.autoRenew!
        }
        if self.autoRenewDuration != nil {
            map["AutoRenewDuration"] = self.autoRenewDuration!
        }
        if self.autoUseCoupon != nil {
            map["AutoUseCoupon"] = self.autoUseCoupon!
        }
        if self.bandwidthBillingType != nil {
            map["BandwidthBillingType"] = self.bandwidthBillingType!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.duration != nil {
            map["Duration"] = self.duration!
        }
        if self.instanceChargeType != nil {
            map["InstanceChargeType"] = self.instanceChargeType!
        }
        if self.ipSetConfig != nil {
            map["IpSetConfig"] = self.ipSetConfig?.toMap()
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.pricingCycle != nil {
            map["PricingCycle"] = self.pricingCycle!
        }
        if self.promotionOptionNo != nil {
            map["PromotionOptionNo"] = self.promotionOptionNo!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.spec != nil {
            map["Spec"] = self.spec!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AutoPay") && dict["AutoPay"] != nil {
            self.autoPay = dict["AutoPay"] as! Bool
        }
        if dict.keys.contains("AutoRenew") && dict["AutoRenew"] != nil {
            self.autoRenew = dict["AutoRenew"] as! Bool
        }
        if dict.keys.contains("AutoRenewDuration") && dict["AutoRenewDuration"] != nil {
            self.autoRenewDuration = dict["AutoRenewDuration"] as! Int32
        }
        if dict.keys.contains("AutoUseCoupon") && dict["AutoUseCoupon"] != nil {
            self.autoUseCoupon = dict["AutoUseCoupon"] as! String
        }
        if dict.keys.contains("BandwidthBillingType") && dict["BandwidthBillingType"] != nil {
            self.bandwidthBillingType = dict["BandwidthBillingType"] as! String
        }
        if dict.keys.contains("ClientToken") && dict["ClientToken"] != nil {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("DryRun") && dict["DryRun"] != nil {
            self.dryRun = dict["DryRun"] as! Bool
        }
        if dict.keys.contains("Duration") && dict["Duration"] != nil {
            self.duration = dict["Duration"] as! Int32
        }
        if dict.keys.contains("InstanceChargeType") && dict["InstanceChargeType"] != nil {
            self.instanceChargeType = dict["InstanceChargeType"] as! String
        }
        if dict.keys.contains("IpSetConfig") && dict["IpSetConfig"] != nil {
            var model = CreateAcceleratorRequest.IpSetConfig()
            model.fromMap(dict["IpSetConfig"] as! [String: Any])
            self.ipSetConfig = model
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("PricingCycle") && dict["PricingCycle"] != nil {
            self.pricingCycle = dict["PricingCycle"] as! String
        }
        if dict.keys.contains("PromotionOptionNo") && dict["PromotionOptionNo"] != nil {
            self.promotionOptionNo = dict["PromotionOptionNo"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") && dict["ResourceGroupId"] != nil {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("Spec") && dict["Spec"] != nil {
            self.spec = dict["Spec"] as! String
        }
        if dict.keys.contains("Tag") && dict["Tag"] != nil {
            var tmp : [CreateAcceleratorRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = CreateAcceleratorRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
    }
}

public class CreateAcceleratorResponseBody : Tea.TeaModel {
    public var acceleratorId: String?

    public var orderId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceleratorId != nil {
            map["AcceleratorId"] = self.acceleratorId!
        }
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceleratorId") && dict["AcceleratorId"] != nil {
            self.acceleratorId = dict["AcceleratorId"] as! String
        }
        if dict.keys.contains("OrderId") && dict["OrderId"] != nil {
            self.orderId = dict["OrderId"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateAcceleratorResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateAcceleratorResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateAcceleratorResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateAclRequest : Tea.TeaModel {
    public class AclEntries : Tea.TeaModel {
        public var entry: String?

        public var entryDescription: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.entry != nil {
                map["Entry"] = self.entry!
            }
            if self.entryDescription != nil {
                map["EntryDescription"] = self.entryDescription!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Entry") && dict["Entry"] != nil {
                self.entry = dict["Entry"] as! String
            }
            if dict.keys.contains("EntryDescription") && dict["EntryDescription"] != nil {
                self.entryDescription = dict["EntryDescription"] as! String
            }
        }
    }
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") && dict["Key"] != nil {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") && dict["Value"] != nil {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var aclEntries: [CreateAclRequest.AclEntries]?

    public var aclName: String?

    public var addressIPVersion: String?

    public var clientToken: String?

    public var dryRun: Bool?

    public var regionId: String?

    public var resourceGroupId: String?

    public var tag: [CreateAclRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aclEntries != nil {
            var tmp : [Any] = []
            for k in self.aclEntries! {
                tmp.append(k.toMap())
            }
            map["AclEntries"] = tmp
        }
        if self.aclName != nil {
            map["AclName"] = self.aclName!
        }
        if self.addressIPVersion != nil {
            map["AddressIPVersion"] = self.addressIPVersion!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AclEntries") && dict["AclEntries"] != nil {
            var tmp : [CreateAclRequest.AclEntries] = []
            for v in dict["AclEntries"] as! [Any] {
                var model = CreateAclRequest.AclEntries()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.aclEntries = tmp
        }
        if dict.keys.contains("AclName") && dict["AclName"] != nil {
            self.aclName = dict["AclName"] as! String
        }
        if dict.keys.contains("AddressIPVersion") && dict["AddressIPVersion"] != nil {
            self.addressIPVersion = dict["AddressIPVersion"] as! String
        }
        if dict.keys.contains("ClientToken") && dict["ClientToken"] != nil {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("DryRun") && dict["DryRun"] != nil {
            self.dryRun = dict["DryRun"] as! Bool
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") && dict["ResourceGroupId"] != nil {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("Tag") && dict["Tag"] != nil {
            var tmp : [CreateAclRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = CreateAclRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
    }
}

public class CreateAclResponseBody : Tea.TeaModel {
    public var aclId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aclId != nil {
            map["AclId"] = self.aclId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AclId") && dict["AclId"] != nil {
            self.aclId = dict["AclId"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateAclResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateAclResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateAclResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateApplicationMonitorRequest : Tea.TeaModel {
    public var acceleratorId: String?

    public var address: String?

    public var clientToken: String?

    public var detectEnable: Bool?

    public var detectThreshold: Int32?

    public var detectTimes: Int32?

    public var listenerId: String?

    public var optionsJson: String?

    public var regionId: String?

    public var silenceTime: Int32?

    public var taskName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceleratorId != nil {
            map["AcceleratorId"] = self.acceleratorId!
        }
        if self.address != nil {
            map["Address"] = self.address!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.detectEnable != nil {
            map["DetectEnable"] = self.detectEnable!
        }
        if self.detectThreshold != nil {
            map["DetectThreshold"] = self.detectThreshold!
        }
        if self.detectTimes != nil {
            map["DetectTimes"] = self.detectTimes!
        }
        if self.listenerId != nil {
            map["ListenerId"] = self.listenerId!
        }
        if self.optionsJson != nil {
            map["OptionsJson"] = self.optionsJson!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.silenceTime != nil {
            map["SilenceTime"] = self.silenceTime!
        }
        if self.taskName != nil {
            map["TaskName"] = self.taskName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceleratorId") && dict["AcceleratorId"] != nil {
            self.acceleratorId = dict["AcceleratorId"] as! String
        }
        if dict.keys.contains("Address") && dict["Address"] != nil {
            self.address = dict["Address"] as! String
        }
        if dict.keys.contains("ClientToken") && dict["ClientToken"] != nil {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("DetectEnable") && dict["DetectEnable"] != nil {
            self.detectEnable = dict["DetectEnable"] as! Bool
        }
        if dict.keys.contains("DetectThreshold") && dict["DetectThreshold"] != nil {
            self.detectThreshold = dict["DetectThreshold"] as! Int32
        }
        if dict.keys.contains("DetectTimes") && dict["DetectTimes"] != nil {
            self.detectTimes = dict["DetectTimes"] as! Int32
        }
        if dict.keys.contains("ListenerId") && dict["ListenerId"] != nil {
            self.listenerId = dict["ListenerId"] as! String
        }
        if dict.keys.contains("OptionsJson") && dict["OptionsJson"] != nil {
            self.optionsJson = dict["OptionsJson"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("SilenceTime") && dict["SilenceTime"] != nil {
            self.silenceTime = dict["SilenceTime"] as! Int32
        }
        if dict.keys.contains("TaskName") && dict["TaskName"] != nil {
            self.taskName = dict["TaskName"] as! String
        }
    }
}

public class CreateApplicationMonitorResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var taskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TaskId") && dict["TaskId"] != nil {
            self.taskId = dict["TaskId"] as! String
        }
    }
}

public class CreateApplicationMonitorResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateApplicationMonitorResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateApplicationMonitorResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateBandwidthPackageRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") && dict["Key"] != nil {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") && dict["Value"] != nil {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var autoPay: Bool?

    public var autoRenew: Bool?

    public var autoRenewDuration: Int32?

    public var autoUseCoupon: String?

    public var bandwidth: Int32?

    public var bandwidthType: String?

    public var billingType: String?

    public var cbnGeographicRegionIdA: String?

    public var cbnGeographicRegionIdB: String?

    public var chargeType: String?

    public var clientToken: String?

    public var duration: String?

    public var pricingCycle: String?

    public var promotionOptionNo: String?

    public var ratio: Int32?

    public var regionId: String?

    public var resourceGroupId: String?

    public var tag: [CreateBandwidthPackageRequest.Tag]?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.autoPay != nil {
            map["AutoPay"] = self.autoPay!
        }
        if self.autoRenew != nil {
            map["AutoRenew"] = self.autoRenew!
        }
        if self.autoRenewDuration != nil {
            map["AutoRenewDuration"] = self.autoRenewDuration!
        }
        if self.autoUseCoupon != nil {
            map["AutoUseCoupon"] = self.autoUseCoupon!
        }
        if self.bandwidth != nil {
            map["Bandwidth"] = self.bandwidth!
        }
        if self.bandwidthType != nil {
            map["BandwidthType"] = self.bandwidthType!
        }
        if self.billingType != nil {
            map["BillingType"] = self.billingType!
        }
        if self.cbnGeographicRegionIdA != nil {
            map["CbnGeographicRegionIdA"] = self.cbnGeographicRegionIdA!
        }
        if self.cbnGeographicRegionIdB != nil {
            map["CbnGeographicRegionIdB"] = self.cbnGeographicRegionIdB!
        }
        if self.chargeType != nil {
            map["ChargeType"] = self.chargeType!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.duration != nil {
            map["Duration"] = self.duration!
        }
        if self.pricingCycle != nil {
            map["PricingCycle"] = self.pricingCycle!
        }
        if self.promotionOptionNo != nil {
            map["PromotionOptionNo"] = self.promotionOptionNo!
        }
        if self.ratio != nil {
            map["Ratio"] = self.ratio!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AutoPay") && dict["AutoPay"] != nil {
            self.autoPay = dict["AutoPay"] as! Bool
        }
        if dict.keys.contains("AutoRenew") && dict["AutoRenew"] != nil {
            self.autoRenew = dict["AutoRenew"] as! Bool
        }
        if dict.keys.contains("AutoRenewDuration") && dict["AutoRenewDuration"] != nil {
            self.autoRenewDuration = dict["AutoRenewDuration"] as! Int32
        }
        if dict.keys.contains("AutoUseCoupon") && dict["AutoUseCoupon"] != nil {
            self.autoUseCoupon = dict["AutoUseCoupon"] as! String
        }
        if dict.keys.contains("Bandwidth") && dict["Bandwidth"] != nil {
            self.bandwidth = dict["Bandwidth"] as! Int32
        }
        if dict.keys.contains("BandwidthType") && dict["BandwidthType"] != nil {
            self.bandwidthType = dict["BandwidthType"] as! String
        }
        if dict.keys.contains("BillingType") && dict["BillingType"] != nil {
            self.billingType = dict["BillingType"] as! String
        }
        if dict.keys.contains("CbnGeographicRegionIdA") && dict["CbnGeographicRegionIdA"] != nil {
            self.cbnGeographicRegionIdA = dict["CbnGeographicRegionIdA"] as! String
        }
        if dict.keys.contains("CbnGeographicRegionIdB") && dict["CbnGeographicRegionIdB"] != nil {
            self.cbnGeographicRegionIdB = dict["CbnGeographicRegionIdB"] as! String
        }
        if dict.keys.contains("ChargeType") && dict["ChargeType"] != nil {
            self.chargeType = dict["ChargeType"] as! String
        }
        if dict.keys.contains("ClientToken") && dict["ClientToken"] != nil {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("Duration") && dict["Duration"] != nil {
            self.duration = dict["Duration"] as! String
        }
        if dict.keys.contains("PricingCycle") && dict["PricingCycle"] != nil {
            self.pricingCycle = dict["PricingCycle"] as! String
        }
        if dict.keys.contains("PromotionOptionNo") && dict["PromotionOptionNo"] != nil {
            self.promotionOptionNo = dict["PromotionOptionNo"] as! String
        }
        if dict.keys.contains("Ratio") && dict["Ratio"] != nil {
            self.ratio = dict["Ratio"] as! Int32
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") && dict["ResourceGroupId"] != nil {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("Tag") && dict["Tag"] != nil {
            var tmp : [CreateBandwidthPackageRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = CreateBandwidthPackageRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! String
        }
    }
}

public class CreateBandwidthPackageResponseBody : Tea.TeaModel {
    public var bandwidthPackageId: String?

    public var orderId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bandwidthPackageId != nil {
            map["BandwidthPackageId"] = self.bandwidthPackageId!
        }
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BandwidthPackageId") && dict["BandwidthPackageId"] != nil {
            self.bandwidthPackageId = dict["BandwidthPackageId"] as! String
        }
        if dict.keys.contains("OrderId") && dict["OrderId"] != nil {
            self.orderId = dict["OrderId"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateBandwidthPackageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateBandwidthPackageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateBandwidthPackageResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateBasicAccelerateIpRequest : Tea.TeaModel {
    public var acceleratorId: String?

    public var clientToken: String?

    public var ipSetId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceleratorId != nil {
            map["AcceleratorId"] = self.acceleratorId!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ipSetId != nil {
            map["IpSetId"] = self.ipSetId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceleratorId") && dict["AcceleratorId"] != nil {
            self.acceleratorId = dict["AcceleratorId"] as! String
        }
        if dict.keys.contains("ClientToken") && dict["ClientToken"] != nil {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("IpSetId") && dict["IpSetId"] != nil {
            self.ipSetId = dict["IpSetId"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class CreateBasicAccelerateIpResponseBody : Tea.TeaModel {
    public var accelerateIpAddress: String?

    public var accelerateIpId: String?

    public var acceleratorId: String?

    public var ipSetId: String?

    public var requestId: String?

    public var state: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accelerateIpAddress != nil {
            map["AccelerateIpAddress"] = self.accelerateIpAddress!
        }
        if self.accelerateIpId != nil {
            map["AccelerateIpId"] = self.accelerateIpId!
        }
        if self.acceleratorId != nil {
            map["AcceleratorId"] = self.acceleratorId!
        }
        if self.ipSetId != nil {
            map["IpSetId"] = self.ipSetId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.state != nil {
            map["State"] = self.state!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AccelerateIpAddress") && dict["AccelerateIpAddress"] != nil {
            self.accelerateIpAddress = dict["AccelerateIpAddress"] as! String
        }
        if dict.keys.contains("AccelerateIpId") && dict["AccelerateIpId"] != nil {
            self.accelerateIpId = dict["AccelerateIpId"] as! String
        }
        if dict.keys.contains("AcceleratorId") && dict["AcceleratorId"] != nil {
            self.acceleratorId = dict["AcceleratorId"] as! String
        }
        if dict.keys.contains("IpSetId") && dict["IpSetId"] != nil {
            self.ipSetId = dict["IpSetId"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("State") && dict["State"] != nil {
            self.state = dict["State"] as! String
        }
    }
}

public class CreateBasicAccelerateIpResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateBasicAccelerateIpResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateBasicAccelerateIpResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateBasicAccelerateIpEndpointRelationRequest : Tea.TeaModel {
    public var accelerateIpId: String?

    public var acceleratorId: String?

    public var clientToken: String?

    public var endpointId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accelerateIpId != nil {
            map["AccelerateIpId"] = self.accelerateIpId!
        }
        if self.acceleratorId != nil {
            map["AcceleratorId"] = self.acceleratorId!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.endpointId != nil {
            map["EndpointId"] = self.endpointId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AccelerateIpId") && dict["AccelerateIpId"] != nil {
            self.accelerateIpId = dict["AccelerateIpId"] as! String
        }
        if dict.keys.contains("AcceleratorId") && dict["AcceleratorId"] != nil {
            self.acceleratorId = dict["AcceleratorId"] as! String
        }
        if dict.keys.contains("ClientToken") && dict["ClientToken"] != nil {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("EndpointId") && dict["EndpointId"] != nil {
            self.endpointId = dict["EndpointId"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class CreateBasicAccelerateIpEndpointRelationResponseBody : Tea.TeaModel {
    public var accelerateIpId: String?

    public var acceleratorId: String?

    public var endpointId: String?

    public var requestId: String?

    public var state: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accelerateIpId != nil {
            map["AccelerateIpId"] = self.accelerateIpId!
        }
        if self.acceleratorId != nil {
            map["AcceleratorId"] = self.acceleratorId!
        }
        if self.endpointId != nil {
            map["EndpointId"] = self.endpointId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.state != nil {
            map["State"] = self.state!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AccelerateIpId") && dict["AccelerateIpId"] != nil {
            self.accelerateIpId = dict["AccelerateIpId"] as! String
        }
        if dict.keys.contains("AcceleratorId") && dict["AcceleratorId"] != nil {
            self.acceleratorId = dict["AcceleratorId"] as! String
        }
        if dict.keys.contains("EndpointId") && dict["EndpointId"] != nil {
            self.endpointId = dict["EndpointId"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("State") && dict["State"] != nil {
            self.state = dict["State"] as! String
        }
    }
}

public class CreateBasicAccelerateIpEndpointRelationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateBasicAccelerateIpEndpointRelationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateBasicAccelerateIpEndpointRelationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateBasicAccelerateIpEndpointRelationsRequest : Tea.TeaModel {
    public class AccelerateIpEndpointRelations : Tea.TeaModel {
        public var accelerateIpId: String?

        public var endpointId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accelerateIpId != nil {
                map["AccelerateIpId"] = self.accelerateIpId!
            }
            if self.endpointId != nil {
                map["EndpointId"] = self.endpointId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AccelerateIpId") && dict["AccelerateIpId"] != nil {
                self.accelerateIpId = dict["AccelerateIpId"] as! String
            }
            if dict.keys.contains("EndpointId") && dict["EndpointId"] != nil {
                self.endpointId = dict["EndpointId"] as! String
            }
        }
    }
    public var accelerateIpEndpointRelations: [CreateBasicAccelerateIpEndpointRelationsRequest.AccelerateIpEndpointRelations]?

    public var acceleratorId: String?

    public var clientToken: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accelerateIpEndpointRelations != nil {
            var tmp : [Any] = []
            for k in self.accelerateIpEndpointRelations! {
                tmp.append(k.toMap())
            }
            map["AccelerateIpEndpointRelations"] = tmp
        }
        if self.acceleratorId != nil {
            map["AcceleratorId"] = self.acceleratorId!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AccelerateIpEndpointRelations") && dict["AccelerateIpEndpointRelations"] != nil {
            var tmp : [CreateBasicAccelerateIpEndpointRelationsRequest.AccelerateIpEndpointRelations] = []
            for v in dict["AccelerateIpEndpointRelations"] as! [Any] {
                var model = CreateBasicAccelerateIpEndpointRelationsRequest.AccelerateIpEndpointRelations()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.accelerateIpEndpointRelations = tmp
        }
        if dict.keys.contains("AcceleratorId") && dict["AcceleratorId"] != nil {
            self.acceleratorId = dict["AcceleratorId"] as! String
        }
        if dict.keys.contains("ClientToken") && dict["ClientToken"] != nil {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class CreateBasicAccelerateIpEndpointRelationsResponseBody : Tea.TeaModel {
    public var acceleratorId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceleratorId != nil {
            map["AcceleratorId"] = self.acceleratorId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceleratorId") && dict["AcceleratorId"] != nil {
            self.acceleratorId = dict["AcceleratorId"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateBasicAccelerateIpEndpointRelationsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateBasicAccelerateIpEndpointRelationsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateBasicAccelerateIpEndpointRelationsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateBasicAcceleratorRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") && dict["Key"] != nil {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") && dict["Value"] != nil {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var autoPay: Bool?

    public var autoRenew: Bool?

    public var autoRenewDuration: Int32?

    public var autoUseCoupon: String?

    public var bandwidthBillingType: String?

    public var chargeType: String?

    public var clientToken: String?

    public var dryRun: Bool?

    public var duration: Int32?

    public var pricingCycle: String?

    public var promotionOptionNo: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var tag: [CreateBasicAcceleratorRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.autoPay != nil {
            map["AutoPay"] = self.autoPay!
        }
        if self.autoRenew != nil {
            map["AutoRenew"] = self.autoRenew!
        }
        if self.autoRenewDuration != nil {
            map["AutoRenewDuration"] = self.autoRenewDuration!
        }
        if self.autoUseCoupon != nil {
            map["AutoUseCoupon"] = self.autoUseCoupon!
        }
        if self.bandwidthBillingType != nil {
            map["BandwidthBillingType"] = self.bandwidthBillingType!
        }
        if self.chargeType != nil {
            map["ChargeType"] = self.chargeType!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.duration != nil {
            map["Duration"] = self.duration!
        }
        if self.pricingCycle != nil {
            map["PricingCycle"] = self.pricingCycle!
        }
        if self.promotionOptionNo != nil {
            map["PromotionOptionNo"] = self.promotionOptionNo!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AutoPay") && dict["AutoPay"] != nil {
            self.autoPay = dict["AutoPay"] as! Bool
        }
        if dict.keys.contains("AutoRenew") && dict["AutoRenew"] != nil {
            self.autoRenew = dict["AutoRenew"] as! Bool
        }
        if dict.keys.contains("AutoRenewDuration") && dict["AutoRenewDuration"] != nil {
            self.autoRenewDuration = dict["AutoRenewDuration"] as! Int32
        }
        if dict.keys.contains("AutoUseCoupon") && dict["AutoUseCoupon"] != nil {
            self.autoUseCoupon = dict["AutoUseCoupon"] as! String
        }
        if dict.keys.contains("BandwidthBillingType") && dict["BandwidthBillingType"] != nil {
            self.bandwidthBillingType = dict["BandwidthBillingType"] as! String
        }
        if dict.keys.contains("ChargeType") && dict["ChargeType"] != nil {
            self.chargeType = dict["ChargeType"] as! String
        }
        if dict.keys.contains("ClientToken") && dict["ClientToken"] != nil {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("DryRun") && dict["DryRun"] != nil {
            self.dryRun = dict["DryRun"] as! Bool
        }
        if dict.keys.contains("Duration") && dict["Duration"] != nil {
            self.duration = dict["Duration"] as! Int32
        }
        if dict.keys.contains("PricingCycle") && dict["PricingCycle"] != nil {
            self.pricingCycle = dict["PricingCycle"] as! String
        }
        if dict.keys.contains("PromotionOptionNo") && dict["PromotionOptionNo"] != nil {
            self.promotionOptionNo = dict["PromotionOptionNo"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") && dict["ResourceGroupId"] != nil {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("Tag") && dict["Tag"] != nil {
            var tmp : [CreateBasicAcceleratorRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = CreateBasicAcceleratorRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
    }
}

public class CreateBasicAcceleratorResponseBody : Tea.TeaModel {
    public var acceleratorId: String?

    public var orderId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceleratorId != nil {
            map["AcceleratorId"] = self.acceleratorId!
        }
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceleratorId") && dict["AcceleratorId"] != nil {
            self.acceleratorId = dict["AcceleratorId"] as! String
        }
        if dict.keys.contains("OrderId") && dict["OrderId"] != nil {
            self.orderId = dict["OrderId"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateBasicAcceleratorResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateBasicAcceleratorResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateBasicAcceleratorResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateBasicEndpointRequest : Tea.TeaModel {
    public var acceleratorId: String?

    public var clientToken: String?

    public var endpointAddress: String?

    public var endpointGroupId: String?

    public var endpointSubAddress: String?

    public var endpointSubAddressType: String?

    public var endpointType: String?

    public var endpointZoneId: String?

    public var name: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceleratorId != nil {
            map["AcceleratorId"] = self.acceleratorId!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.endpointAddress != nil {
            map["EndpointAddress"] = self.endpointAddress!
        }
        if self.endpointGroupId != nil {
            map["EndpointGroupId"] = self.endpointGroupId!
        }
        if self.endpointSubAddress != nil {
            map["EndpointSubAddress"] = self.endpointSubAddress!
        }
        if self.endpointSubAddressType != nil {
            map["EndpointSubAddressType"] = self.endpointSubAddressType!
        }
        if self.endpointType != nil {
            map["EndpointType"] = self.endpointType!
        }
        if self.endpointZoneId != nil {
            map["EndpointZoneId"] = self.endpointZoneId!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceleratorId") && dict["AcceleratorId"] != nil {
            self.acceleratorId = dict["AcceleratorId"] as! String
        }
        if dict.keys.contains("ClientToken") && dict["ClientToken"] != nil {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("EndpointAddress") && dict["EndpointAddress"] != nil {
            self.endpointAddress = dict["EndpointAddress"] as! String
        }
        if dict.keys.contains("EndpointGroupId") && dict["EndpointGroupId"] != nil {
            self.endpointGroupId = dict["EndpointGroupId"] as! String
        }
        if dict.keys.contains("EndpointSubAddress") && dict["EndpointSubAddress"] != nil {
            self.endpointSubAddress = dict["EndpointSubAddress"] as! String
        }
        if dict.keys.contains("EndpointSubAddressType") && dict["EndpointSubAddressType"] != nil {
            self.endpointSubAddressType = dict["EndpointSubAddressType"] as! String
        }
        if dict.keys.contains("EndpointType") && dict["EndpointType"] != nil {
            self.endpointType = dict["EndpointType"] as! String
        }
        if dict.keys.contains("EndpointZoneId") && dict["EndpointZoneId"] != nil {
            self.endpointZoneId = dict["EndpointZoneId"] as! String
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class CreateBasicEndpointResponseBody : Tea.TeaModel {
    public var endpointGroupId: String?

    public var endpointId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endpointGroupId != nil {
            map["EndpointGroupId"] = self.endpointGroupId!
        }
        if self.endpointId != nil {
            map["EndpointId"] = self.endpointId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndpointGroupId") && dict["EndpointGroupId"] != nil {
            self.endpointGroupId = dict["EndpointGroupId"] as! String
        }
        if dict.keys.contains("EndpointId") && dict["EndpointId"] != nil {
            self.endpointId = dict["EndpointId"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateBasicEndpointResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateBasicEndpointResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateBasicEndpointResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateBasicEndpointGroupRequest : Tea.TeaModel {
    public var acceleratorId: String?

    public var clientToken: String?

    public var description_: String?

    public var endpointAddress: String?

    public var endpointGroupRegion: String?

    public var endpointSubAddress: String?

    public var endpointType: String?

    public var name: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceleratorId != nil {
            map["AcceleratorId"] = self.acceleratorId!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.endpointAddress != nil {
            map["EndpointAddress"] = self.endpointAddress!
        }
        if self.endpointGroupRegion != nil {
            map["EndpointGroupRegion"] = self.endpointGroupRegion!
        }
        if self.endpointSubAddress != nil {
            map["EndpointSubAddress"] = self.endpointSubAddress!
        }
        if self.endpointType != nil {
            map["EndpointType"] = self.endpointType!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceleratorId") && dict["AcceleratorId"] != nil {
            self.acceleratorId = dict["AcceleratorId"] as! String
        }
        if dict.keys.contains("ClientToken") && dict["ClientToken"] != nil {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("EndpointAddress") && dict["EndpointAddress"] != nil {
            self.endpointAddress = dict["EndpointAddress"] as! String
        }
        if dict.keys.contains("EndpointGroupRegion") && dict["EndpointGroupRegion"] != nil {
            self.endpointGroupRegion = dict["EndpointGroupRegion"] as! String
        }
        if dict.keys.contains("EndpointSubAddress") && dict["EndpointSubAddress"] != nil {
            self.endpointSubAddress = dict["EndpointSubAddress"] as! String
        }
        if dict.keys.contains("EndpointType") && dict["EndpointType"] != nil {
            self.endpointType = dict["EndpointType"] as! String
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class CreateBasicEndpointGroupResponseBody : Tea.TeaModel {
    public var endpointGroupId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endpointGroupId != nil {
            map["EndpointGroupId"] = self.endpointGroupId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndpointGroupId") && dict["EndpointGroupId"] != nil {
            self.endpointGroupId = dict["EndpointGroupId"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateBasicEndpointGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateBasicEndpointGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateBasicEndpointGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateBasicEndpointsRequest : Tea.TeaModel {
    public class Endpoints : Tea.TeaModel {
        public var endpointAddress: String?

        public var endpointSubAddress: String?

        public var endpointSubAddressType: String?

        public var endpointType: String?

        public var endpointZoneId: String?

        public var name: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.endpointAddress != nil {
                map["EndpointAddress"] = self.endpointAddress!
            }
            if self.endpointSubAddress != nil {
                map["EndpointSubAddress"] = self.endpointSubAddress!
            }
            if self.endpointSubAddressType != nil {
                map["EndpointSubAddressType"] = self.endpointSubAddressType!
            }
            if self.endpointType != nil {
                map["EndpointType"] = self.endpointType!
            }
            if self.endpointZoneId != nil {
                map["EndpointZoneId"] = self.endpointZoneId!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EndpointAddress") && dict["EndpointAddress"] != nil {
                self.endpointAddress = dict["EndpointAddress"] as! String
            }
            if dict.keys.contains("EndpointSubAddress") && dict["EndpointSubAddress"] != nil {
                self.endpointSubAddress = dict["EndpointSubAddress"] as! String
            }
            if dict.keys.contains("EndpointSubAddressType") && dict["EndpointSubAddressType"] != nil {
                self.endpointSubAddressType = dict["EndpointSubAddressType"] as! String
            }
            if dict.keys.contains("EndpointType") && dict["EndpointType"] != nil {
                self.endpointType = dict["EndpointType"] as! String
            }
            if dict.keys.contains("EndpointZoneId") && dict["EndpointZoneId"] != nil {
                self.endpointZoneId = dict["EndpointZoneId"] as! String
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
        }
    }
    public var acceleratorId: String?

    public var clientToken: String?

    public var endpointGroupId: String?

    public var endpoints: [CreateBasicEndpointsRequest.Endpoints]?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceleratorId != nil {
            map["AcceleratorId"] = self.acceleratorId!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.endpointGroupId != nil {
            map["EndpointGroupId"] = self.endpointGroupId!
        }
        if self.endpoints != nil {
            var tmp : [Any] = []
            for k in self.endpoints! {
                tmp.append(k.toMap())
            }
            map["Endpoints"] = tmp
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceleratorId") && dict["AcceleratorId"] != nil {
            self.acceleratorId = dict["AcceleratorId"] as! String
        }
        if dict.keys.contains("ClientToken") && dict["ClientToken"] != nil {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("EndpointGroupId") && dict["EndpointGroupId"] != nil {
            self.endpointGroupId = dict["EndpointGroupId"] as! String
        }
        if dict.keys.contains("Endpoints") && dict["Endpoints"] != nil {
            var tmp : [CreateBasicEndpointsRequest.Endpoints] = []
            for v in dict["Endpoints"] as! [Any] {
                var model = CreateBasicEndpointsRequest.Endpoints()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.endpoints = tmp
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class CreateBasicEndpointsResponseBody : Tea.TeaModel {
    public class Endpoints : Tea.TeaModel {
        public var endpointAddress: String?

        public var endpointId: String?

        public var endpointSubAddress: String?

        public var endpointType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.endpointAddress != nil {
                map["EndpointAddress"] = self.endpointAddress!
            }
            if self.endpointId != nil {
                map["EndpointId"] = self.endpointId!
            }
            if self.endpointSubAddress != nil {
                map["EndpointSubAddress"] = self.endpointSubAddress!
            }
            if self.endpointType != nil {
                map["EndpointType"] = self.endpointType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EndpointAddress") && dict["EndpointAddress"] != nil {
                self.endpointAddress = dict["EndpointAddress"] as! String
            }
            if dict.keys.contains("EndpointId") && dict["EndpointId"] != nil {
                self.endpointId = dict["EndpointId"] as! String
            }
            if dict.keys.contains("EndpointSubAddress") && dict["EndpointSubAddress"] != nil {
                self.endpointSubAddress = dict["EndpointSubAddress"] as! String
            }
            if dict.keys.contains("EndpointType") && dict["EndpointType"] != nil {
                self.endpointType = dict["EndpointType"] as! String
            }
        }
    }
    public var endpointGroupId: String?

    public var endpoints: [CreateBasicEndpointsResponseBody.Endpoints]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endpointGroupId != nil {
            map["EndpointGroupId"] = self.endpointGroupId!
        }
        if self.endpoints != nil {
            var tmp : [Any] = []
            for k in self.endpoints! {
                tmp.append(k.toMap())
            }
            map["Endpoints"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndpointGroupId") && dict["EndpointGroupId"] != nil {
            self.endpointGroupId = dict["EndpointGroupId"] as! String
        }
        if dict.keys.contains("Endpoints") && dict["Endpoints"] != nil {
            var tmp : [CreateBasicEndpointsResponseBody.Endpoints] = []
            for v in dict["Endpoints"] as! [Any] {
                var model = CreateBasicEndpointsResponseBody.Endpoints()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.endpoints = tmp
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateBasicEndpointsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateBasicEndpointsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateBasicEndpointsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateBasicIpSetRequest : Tea.TeaModel {
    public var accelerateRegionId: String?

    public var acceleratorId: String?

    public var bandwidth: Int64?

    public var clientToken: String?

    public var ispType: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accelerateRegionId != nil {
            map["AccelerateRegionId"] = self.accelerateRegionId!
        }
        if self.acceleratorId != nil {
            map["AcceleratorId"] = self.acceleratorId!
        }
        if self.bandwidth != nil {
            map["Bandwidth"] = self.bandwidth!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ispType != nil {
            map["IspType"] = self.ispType!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AccelerateRegionId") && dict["AccelerateRegionId"] != nil {
            self.accelerateRegionId = dict["AccelerateRegionId"] as! String
        }
        if dict.keys.contains("AcceleratorId") && dict["AcceleratorId"] != nil {
            self.acceleratorId = dict["AcceleratorId"] as! String
        }
        if dict.keys.contains("Bandwidth") && dict["Bandwidth"] != nil {
            self.bandwidth = dict["Bandwidth"] as! Int64
        }
        if dict.keys.contains("ClientToken") && dict["ClientToken"] != nil {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("IspType") && dict["IspType"] != nil {
            self.ispType = dict["IspType"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class CreateBasicIpSetResponseBody : Tea.TeaModel {
    public var ipSetId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ipSetId != nil {
            map["IpSetId"] = self.ipSetId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("IpSetId") && dict["IpSetId"] != nil {
            self.ipSetId = dict["IpSetId"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateBasicIpSetResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateBasicIpSetResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateBasicIpSetResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateCustomRoutingEndpointGroupDestinationsRequest : Tea.TeaModel {
    public class DestinationConfigurations : Tea.TeaModel {
        public var fromPort: Int32?

        public var protocols: [String]?

        public var toPort: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.fromPort != nil {
                map["FromPort"] = self.fromPort!
            }
            if self.protocols != nil {
                map["Protocols"] = self.protocols!
            }
            if self.toPort != nil {
                map["ToPort"] = self.toPort!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("FromPort") && dict["FromPort"] != nil {
                self.fromPort = dict["FromPort"] as! Int32
            }
            if dict.keys.contains("Protocols") && dict["Protocols"] != nil {
                self.protocols = dict["Protocols"] as! [String]
            }
            if dict.keys.contains("ToPort") && dict["ToPort"] != nil {
                self.toPort = dict["ToPort"] as! Int32
            }
        }
    }
    public var clientToken: String?

    public var destinationConfigurations: [CreateCustomRoutingEndpointGroupDestinationsRequest.DestinationConfigurations]?

    public var dryRun: Bool?

    public var endpointGroupId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.destinationConfigurations != nil {
            var tmp : [Any] = []
            for k in self.destinationConfigurations! {
                tmp.append(k.toMap())
            }
            map["DestinationConfigurations"] = tmp
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.endpointGroupId != nil {
            map["EndpointGroupId"] = self.endpointGroupId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") && dict["ClientToken"] != nil {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("DestinationConfigurations") && dict["DestinationConfigurations"] != nil {
            var tmp : [CreateCustomRoutingEndpointGroupDestinationsRequest.DestinationConfigurations] = []
            for v in dict["DestinationConfigurations"] as! [Any] {
                var model = CreateCustomRoutingEndpointGroupDestinationsRequest.DestinationConfigurations()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.destinationConfigurations = tmp
        }
        if dict.keys.contains("DryRun") && dict["DryRun"] != nil {
            self.dryRun = dict["DryRun"] as! Bool
        }
        if dict.keys.contains("EndpointGroupId") && dict["EndpointGroupId"] != nil {
            self.endpointGroupId = dict["EndpointGroupId"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class CreateCustomRoutingEndpointGroupDestinationsResponseBody : Tea.TeaModel {
    public var destinationIds: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.destinationIds != nil {
            map["DestinationIds"] = self.destinationIds!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DestinationIds") && dict["DestinationIds"] != nil {
            self.destinationIds = dict["DestinationIds"] as! [String]
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateCustomRoutingEndpointGroupDestinationsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateCustomRoutingEndpointGroupDestinationsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateCustomRoutingEndpointGroupDestinationsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateCustomRoutingEndpointGroupsRequest : Tea.TeaModel {
    public class EndpointGroupConfigurations : Tea.TeaModel {
        public class DestinationConfigurations : Tea.TeaModel {
            public var fromPort: Int32?

            public var protocols: [String]?

            public var toPort: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.fromPort != nil {
                    map["FromPort"] = self.fromPort!
                }
                if self.protocols != nil {
                    map["Protocols"] = self.protocols!
                }
                if self.toPort != nil {
                    map["ToPort"] = self.toPort!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("FromPort") && dict["FromPort"] != nil {
                    self.fromPort = dict["FromPort"] as! Int32
                }
                if dict.keys.contains("Protocols") && dict["Protocols"] != nil {
                    self.protocols = dict["Protocols"] as! [String]
                }
                if dict.keys.contains("ToPort") && dict["ToPort"] != nil {
                    self.toPort = dict["ToPort"] as! Int32
                }
            }
        }
        public class EndpointConfigurations : Tea.TeaModel {
            public class PolicyConfigurations : Tea.TeaModel {
                public class PortRanges : Tea.TeaModel {
                    public var fromPort: Int32?

                    public var toPort: Int32?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.fromPort != nil {
                            map["FromPort"] = self.fromPort!
                        }
                        if self.toPort != nil {
                            map["ToPort"] = self.toPort!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("FromPort") && dict["FromPort"] != nil {
                            self.fromPort = dict["FromPort"] as! Int32
                        }
                        if dict.keys.contains("ToPort") && dict["ToPort"] != nil {
                            self.toPort = dict["ToPort"] as! Int32
                        }
                    }
                }
                public var address: String?

                public var portRanges: [CreateCustomRoutingEndpointGroupsRequest.EndpointGroupConfigurations.EndpointConfigurations.PolicyConfigurations.PortRanges]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.address != nil {
                        map["Address"] = self.address!
                    }
                    if self.portRanges != nil {
                        var tmp : [Any] = []
                        for k in self.portRanges! {
                            tmp.append(k.toMap())
                        }
                        map["PortRanges"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Address") && dict["Address"] != nil {
                        self.address = dict["Address"] as! String
                    }
                    if dict.keys.contains("PortRanges") && dict["PortRanges"] != nil {
                        var tmp : [CreateCustomRoutingEndpointGroupsRequest.EndpointGroupConfigurations.EndpointConfigurations.PolicyConfigurations.PortRanges] = []
                        for v in dict["PortRanges"] as! [Any] {
                            var model = CreateCustomRoutingEndpointGroupsRequest.EndpointGroupConfigurations.EndpointConfigurations.PolicyConfigurations.PortRanges()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.portRanges = tmp
                    }
                }
            }
            public var endpoint: String?

            public var policyConfigurations: [CreateCustomRoutingEndpointGroupsRequest.EndpointGroupConfigurations.EndpointConfigurations.PolicyConfigurations]?

            public var trafficToEndpointPolicy: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.endpoint != nil {
                    map["Endpoint"] = self.endpoint!
                }
                if self.policyConfigurations != nil {
                    var tmp : [Any] = []
                    for k in self.policyConfigurations! {
                        tmp.append(k.toMap())
                    }
                    map["PolicyConfigurations"] = tmp
                }
                if self.trafficToEndpointPolicy != nil {
                    map["TrafficToEndpointPolicy"] = self.trafficToEndpointPolicy!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Endpoint") && dict["Endpoint"] != nil {
                    self.endpoint = dict["Endpoint"] as! String
                }
                if dict.keys.contains("PolicyConfigurations") && dict["PolicyConfigurations"] != nil {
                    var tmp : [CreateCustomRoutingEndpointGroupsRequest.EndpointGroupConfigurations.EndpointConfigurations.PolicyConfigurations] = []
                    for v in dict["PolicyConfigurations"] as! [Any] {
                        var model = CreateCustomRoutingEndpointGroupsRequest.EndpointGroupConfigurations.EndpointConfigurations.PolicyConfigurations()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.policyConfigurations = tmp
                }
                if dict.keys.contains("TrafficToEndpointPolicy") && dict["TrafficToEndpointPolicy"] != nil {
                    self.trafficToEndpointPolicy = dict["TrafficToEndpointPolicy"] as! String
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var description_: String?

        public var destinationConfigurations: [CreateCustomRoutingEndpointGroupsRequest.EndpointGroupConfigurations.DestinationConfigurations]?

        public var endpointConfigurations: [CreateCustomRoutingEndpointGroupsRequest.EndpointGroupConfigurations.EndpointConfigurations]?

        public var endpointGroupRegion: String?

        public var name: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.destinationConfigurations != nil {
                var tmp : [Any] = []
                for k in self.destinationConfigurations! {
                    tmp.append(k.toMap())
                }
                map["DestinationConfigurations"] = tmp
            }
            if self.endpointConfigurations != nil {
                var tmp : [Any] = []
                for k in self.endpointConfigurations! {
                    tmp.append(k.toMap())
                }
                map["EndpointConfigurations"] = tmp
            }
            if self.endpointGroupRegion != nil {
                map["EndpointGroupRegion"] = self.endpointGroupRegion!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Description") && dict["Description"] != nil {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("DestinationConfigurations") && dict["DestinationConfigurations"] != nil {
                var tmp : [CreateCustomRoutingEndpointGroupsRequest.EndpointGroupConfigurations.DestinationConfigurations] = []
                for v in dict["DestinationConfigurations"] as! [Any] {
                    var model = CreateCustomRoutingEndpointGroupsRequest.EndpointGroupConfigurations.DestinationConfigurations()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.destinationConfigurations = tmp
            }
            if dict.keys.contains("EndpointConfigurations") && dict["EndpointConfigurations"] != nil {
                var tmp : [CreateCustomRoutingEndpointGroupsRequest.EndpointGroupConfigurations.EndpointConfigurations] = []
                for v in dict["EndpointConfigurations"] as! [Any] {
                    var model = CreateCustomRoutingEndpointGroupsRequest.EndpointGroupConfigurations.EndpointConfigurations()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.endpointConfigurations = tmp
            }
            if dict.keys.contains("EndpointGroupRegion") && dict["EndpointGroupRegion"] != nil {
                self.endpointGroupRegion = dict["EndpointGroupRegion"] as! String
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
        }
    }
    public var acceleratorId: String?

    public var clientToken: String?

    public var dryRun: Bool?

    public var endpointGroupConfigurations: [CreateCustomRoutingEndpointGroupsRequest.EndpointGroupConfigurations]?

    public var listenerId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceleratorId != nil {
            map["AcceleratorId"] = self.acceleratorId!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.endpointGroupConfigurations != nil {
            var tmp : [Any] = []
            for k in self.endpointGroupConfigurations! {
                tmp.append(k.toMap())
            }
            map["EndpointGroupConfigurations"] = tmp
        }
        if self.listenerId != nil {
            map["ListenerId"] = self.listenerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceleratorId") && dict["AcceleratorId"] != nil {
            self.acceleratorId = dict["AcceleratorId"] as! String
        }
        if dict.keys.contains("ClientToken") && dict["ClientToken"] != nil {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("DryRun") && dict["DryRun"] != nil {
            self.dryRun = dict["DryRun"] as! Bool
        }
        if dict.keys.contains("EndpointGroupConfigurations") && dict["EndpointGroupConfigurations"] != nil {
            var tmp : [CreateCustomRoutingEndpointGroupsRequest.EndpointGroupConfigurations] = []
            for v in dict["EndpointGroupConfigurations"] as! [Any] {
                var model = CreateCustomRoutingEndpointGroupsRequest.EndpointGroupConfigurations()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.endpointGroupConfigurations = tmp
        }
        if dict.keys.contains("ListenerId") && dict["ListenerId"] != nil {
            self.listenerId = dict["ListenerId"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class CreateCustomRoutingEndpointGroupsResponseBody : Tea.TeaModel {
    public var endpointGroupIds: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endpointGroupIds != nil {
            map["EndpointGroupIds"] = self.endpointGroupIds!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndpointGroupIds") && dict["EndpointGroupIds"] != nil {
            self.endpointGroupIds = dict["EndpointGroupIds"] as! [String]
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateCustomRoutingEndpointGroupsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateCustomRoutingEndpointGroupsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateCustomRoutingEndpointGroupsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateCustomRoutingEndpointTrafficPoliciesRequest : Tea.TeaModel {
    public class PolicyConfigurations : Tea.TeaModel {
        public class PortRanges : Tea.TeaModel {
            public var fromPort: Int32?

            public var toPort: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.fromPort != nil {
                    map["FromPort"] = self.fromPort!
                }
                if self.toPort != nil {
                    map["ToPort"] = self.toPort!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("FromPort") && dict["FromPort"] != nil {
                    self.fromPort = dict["FromPort"] as! Int32
                }
                if dict.keys.contains("ToPort") && dict["ToPort"] != nil {
                    self.toPort = dict["ToPort"] as! Int32
                }
            }
        }
        public var address: String?

        public var portRanges: [CreateCustomRoutingEndpointTrafficPoliciesRequest.PolicyConfigurations.PortRanges]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.address != nil {
                map["Address"] = self.address!
            }
            if self.portRanges != nil {
                var tmp : [Any] = []
                for k in self.portRanges! {
                    tmp.append(k.toMap())
                }
                map["PortRanges"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Address") && dict["Address"] != nil {
                self.address = dict["Address"] as! String
            }
            if dict.keys.contains("PortRanges") && dict["PortRanges"] != nil {
                var tmp : [CreateCustomRoutingEndpointTrafficPoliciesRequest.PolicyConfigurations.PortRanges] = []
                for v in dict["PortRanges"] as! [Any] {
                    var model = CreateCustomRoutingEndpointTrafficPoliciesRequest.PolicyConfigurations.PortRanges()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.portRanges = tmp
            }
        }
    }
    public var clientToken: String?

    public var endpointId: String?

    public var policyConfigurations: [CreateCustomRoutingEndpointTrafficPoliciesRequest.PolicyConfigurations]?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.endpointId != nil {
            map["EndpointId"] = self.endpointId!
        }
        if self.policyConfigurations != nil {
            var tmp : [Any] = []
            for k in self.policyConfigurations! {
                tmp.append(k.toMap())
            }
            map["PolicyConfigurations"] = tmp
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") && dict["ClientToken"] != nil {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("EndpointId") && dict["EndpointId"] != nil {
            self.endpointId = dict["EndpointId"] as! String
        }
        if dict.keys.contains("PolicyConfigurations") && dict["PolicyConfigurations"] != nil {
            var tmp : [CreateCustomRoutingEndpointTrafficPoliciesRequest.PolicyConfigurations] = []
            for v in dict["PolicyConfigurations"] as! [Any] {
                var model = CreateCustomRoutingEndpointTrafficPoliciesRequest.PolicyConfigurations()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.policyConfigurations = tmp
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class CreateCustomRoutingEndpointTrafficPoliciesResponseBody : Tea.TeaModel {
    public var policyIds: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.policyIds != nil {
            map["PolicyIds"] = self.policyIds!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PolicyIds") && dict["PolicyIds"] != nil {
            self.policyIds = dict["PolicyIds"] as! [String]
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateCustomRoutingEndpointTrafficPoliciesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateCustomRoutingEndpointTrafficPoliciesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateCustomRoutingEndpointTrafficPoliciesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateCustomRoutingEndpointsRequest : Tea.TeaModel {
    public class EndpointConfigurations : Tea.TeaModel {
        public class PolicyConfigurations : Tea.TeaModel {
            public class PortRanges : Tea.TeaModel {
                public var fromPort: Int32?

                public var toPort: Int32?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.fromPort != nil {
                        map["FromPort"] = self.fromPort!
                    }
                    if self.toPort != nil {
                        map["ToPort"] = self.toPort!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("FromPort") && dict["FromPort"] != nil {
                        self.fromPort = dict["FromPort"] as! Int32
                    }
                    if dict.keys.contains("ToPort") && dict["ToPort"] != nil {
                        self.toPort = dict["ToPort"] as! Int32
                    }
                }
            }
            public var address: String?

            public var portRanges: [CreateCustomRoutingEndpointsRequest.EndpointConfigurations.PolicyConfigurations.PortRanges]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.address != nil {
                    map["Address"] = self.address!
                }
                if self.portRanges != nil {
                    var tmp : [Any] = []
                    for k in self.portRanges! {
                        tmp.append(k.toMap())
                    }
                    map["PortRanges"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Address") && dict["Address"] != nil {
                    self.address = dict["Address"] as! String
                }
                if dict.keys.contains("PortRanges") && dict["PortRanges"] != nil {
                    var tmp : [CreateCustomRoutingEndpointsRequest.EndpointConfigurations.PolicyConfigurations.PortRanges] = []
                    for v in dict["PortRanges"] as! [Any] {
                        var model = CreateCustomRoutingEndpointsRequest.EndpointConfigurations.PolicyConfigurations.PortRanges()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.portRanges = tmp
                }
            }
        }
        public var endpoint: String?

        public var policyConfigurations: [CreateCustomRoutingEndpointsRequest.EndpointConfigurations.PolicyConfigurations]?

        public var trafficToEndpointPolicy: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.endpoint != nil {
                map["Endpoint"] = self.endpoint!
            }
            if self.policyConfigurations != nil {
                var tmp : [Any] = []
                for k in self.policyConfigurations! {
                    tmp.append(k.toMap())
                }
                map["PolicyConfigurations"] = tmp
            }
            if self.trafficToEndpointPolicy != nil {
                map["TrafficToEndpointPolicy"] = self.trafficToEndpointPolicy!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Endpoint") && dict["Endpoint"] != nil {
                self.endpoint = dict["Endpoint"] as! String
            }
            if dict.keys.contains("PolicyConfigurations") && dict["PolicyConfigurations"] != nil {
                var tmp : [CreateCustomRoutingEndpointsRequest.EndpointConfigurations.PolicyConfigurations] = []
                for v in dict["PolicyConfigurations"] as! [Any] {
                    var model = CreateCustomRoutingEndpointsRequest.EndpointConfigurations.PolicyConfigurations()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.policyConfigurations = tmp
            }
            if dict.keys.contains("TrafficToEndpointPolicy") && dict["TrafficToEndpointPolicy"] != nil {
                self.trafficToEndpointPolicy = dict["TrafficToEndpointPolicy"] as! String
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var clientToken: String?

    public var endpointConfigurations: [CreateCustomRoutingEndpointsRequest.EndpointConfigurations]?

    public var endpointGroupId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.endpointConfigurations != nil {
            var tmp : [Any] = []
            for k in self.endpointConfigurations! {
                tmp.append(k.toMap())
            }
            map["EndpointConfigurations"] = tmp
        }
        if self.endpointGroupId != nil {
            map["EndpointGroupId"] = self.endpointGroupId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") && dict["ClientToken"] != nil {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("EndpointConfigurations") && dict["EndpointConfigurations"] != nil {
            var tmp : [CreateCustomRoutingEndpointsRequest.EndpointConfigurations] = []
            for v in dict["EndpointConfigurations"] as! [Any] {
                var model = CreateCustomRoutingEndpointsRequest.EndpointConfigurations()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.endpointConfigurations = tmp
        }
        if dict.keys.contains("EndpointGroupId") && dict["EndpointGroupId"] != nil {
            self.endpointGroupId = dict["EndpointGroupId"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class CreateCustomRoutingEndpointsResponseBody : Tea.TeaModel {
    public var endpointIds: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endpointIds != nil {
            map["EndpointIds"] = self.endpointIds!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndpointIds") && dict["EndpointIds"] != nil {
            self.endpointIds = dict["EndpointIds"] as! [String]
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateCustomRoutingEndpointsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateCustomRoutingEndpointsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateCustomRoutingEndpointsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateDomainRequest : Tea.TeaModel {
    public var acceleratorIds: [String]?

    public var domain: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceleratorIds != nil {
            map["AcceleratorIds"] = self.acceleratorIds!
        }
        if self.domain != nil {
            map["Domain"] = self.domain!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceleratorIds") && dict["AcceleratorIds"] != nil {
            self.acceleratorIds = dict["AcceleratorIds"] as! [String]
        }
        if dict.keys.contains("Domain") && dict["Domain"] != nil {
            self.domain = dict["Domain"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class CreateDomainResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateDomainResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateDomainResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateDomainResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateEndpointGroupRequest : Tea.TeaModel {
    public class EndpointConfigurations : Tea.TeaModel {
        public var enableClientIPPreservation: Bool?

        public var enableProxyProtocol: Bool?

        public var endpoint: String?

        public var subAddress: String?

        public var type: String?

        public var weight: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.enableClientIPPreservation != nil {
                map["EnableClientIPPreservation"] = self.enableClientIPPreservation!
            }
            if self.enableProxyProtocol != nil {
                map["EnableProxyProtocol"] = self.enableProxyProtocol!
            }
            if self.endpoint != nil {
                map["Endpoint"] = self.endpoint!
            }
            if self.subAddress != nil {
                map["SubAddress"] = self.subAddress!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.weight != nil {
                map["Weight"] = self.weight!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EnableClientIPPreservation") && dict["EnableClientIPPreservation"] != nil {
                self.enableClientIPPreservation = dict["EnableClientIPPreservation"] as! Bool
            }
            if dict.keys.contains("EnableProxyProtocol") && dict["EnableProxyProtocol"] != nil {
                self.enableProxyProtocol = dict["EnableProxyProtocol"] as! Bool
            }
            if dict.keys.contains("Endpoint") && dict["Endpoint"] != nil {
                self.endpoint = dict["Endpoint"] as! String
            }
            if dict.keys.contains("SubAddress") && dict["SubAddress"] != nil {
                self.subAddress = dict["SubAddress"] as! String
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
            if dict.keys.contains("Weight") && dict["Weight"] != nil {
                self.weight = dict["Weight"] as! Int32
            }
        }
    }
    public class PortOverrides : Tea.TeaModel {
        public var endpointPort: Int32?

        public var listenerPort: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.endpointPort != nil {
                map["EndpointPort"] = self.endpointPort!
            }
            if self.listenerPort != nil {
                map["ListenerPort"] = self.listenerPort!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EndpointPort") && dict["EndpointPort"] != nil {
                self.endpointPort = dict["EndpointPort"] as! Int32
            }
            if dict.keys.contains("ListenerPort") && dict["ListenerPort"] != nil {
                self.listenerPort = dict["ListenerPort"] as! Int32
            }
        }
    }
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") && dict["Key"] != nil {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") && dict["Value"] != nil {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var acceleratorId: String?

    public var clientToken: String?

    public var description_: String?

    public var endpointConfigurations: [CreateEndpointGroupRequest.EndpointConfigurations]?

    public var endpointGroupRegion: String?

    public var endpointGroupType: String?

    public var endpointRequestProtocol: String?

    public var healthCheckEnabled: Bool?

    public var healthCheckIntervalSeconds: Int32?

    public var healthCheckPath: String?

    public var healthCheckPort: Int32?

    public var healthCheckProtocol: String?

    public var listenerId: String?

    public var name: String?

    public var portOverrides: [CreateEndpointGroupRequest.PortOverrides]?

    public var regionId: String?

    public var tag: [CreateEndpointGroupRequest.Tag]?

    public var thresholdCount: Int32?

    public var trafficPercentage: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceleratorId != nil {
            map["AcceleratorId"] = self.acceleratorId!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.endpointConfigurations != nil {
            var tmp : [Any] = []
            for k in self.endpointConfigurations! {
                tmp.append(k.toMap())
            }
            map["EndpointConfigurations"] = tmp
        }
        if self.endpointGroupRegion != nil {
            map["EndpointGroupRegion"] = self.endpointGroupRegion!
        }
        if self.endpointGroupType != nil {
            map["EndpointGroupType"] = self.endpointGroupType!
        }
        if self.endpointRequestProtocol != nil {
            map["EndpointRequestProtocol"] = self.endpointRequestProtocol!
        }
        if self.healthCheckEnabled != nil {
            map["HealthCheckEnabled"] = self.healthCheckEnabled!
        }
        if self.healthCheckIntervalSeconds != nil {
            map["HealthCheckIntervalSeconds"] = self.healthCheckIntervalSeconds!
        }
        if self.healthCheckPath != nil {
            map["HealthCheckPath"] = self.healthCheckPath!
        }
        if self.healthCheckPort != nil {
            map["HealthCheckPort"] = self.healthCheckPort!
        }
        if self.healthCheckProtocol != nil {
            map["HealthCheckProtocol"] = self.healthCheckProtocol!
        }
        if self.listenerId != nil {
            map["ListenerId"] = self.listenerId!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.portOverrides != nil {
            var tmp : [Any] = []
            for k in self.portOverrides! {
                tmp.append(k.toMap())
            }
            map["PortOverrides"] = tmp
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.thresholdCount != nil {
            map["ThresholdCount"] = self.thresholdCount!
        }
        if self.trafficPercentage != nil {
            map["TrafficPercentage"] = self.trafficPercentage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceleratorId") && dict["AcceleratorId"] != nil {
            self.acceleratorId = dict["AcceleratorId"] as! String
        }
        if dict.keys.contains("ClientToken") && dict["ClientToken"] != nil {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("EndpointConfigurations") && dict["EndpointConfigurations"] != nil {
            var tmp : [CreateEndpointGroupRequest.EndpointConfigurations] = []
            for v in dict["EndpointConfigurations"] as! [Any] {
                var model = CreateEndpointGroupRequest.EndpointConfigurations()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.endpointConfigurations = tmp
        }
        if dict.keys.contains("EndpointGroupRegion") && dict["EndpointGroupRegion"] != nil {
            self.endpointGroupRegion = dict["EndpointGroupRegion"] as! String
        }
        if dict.keys.contains("EndpointGroupType") && dict["EndpointGroupType"] != nil {
            self.endpointGroupType = dict["EndpointGroupType"] as! String
        }
        if dict.keys.contains("EndpointRequestProtocol") && dict["EndpointRequestProtocol"] != nil {
            self.endpointRequestProtocol = dict["EndpointRequestProtocol"] as! String
        }
        if dict.keys.contains("HealthCheckEnabled") && dict["HealthCheckEnabled"] != nil {
            self.healthCheckEnabled = dict["HealthCheckEnabled"] as! Bool
        }
        if dict.keys.contains("HealthCheckIntervalSeconds") && dict["HealthCheckIntervalSeconds"] != nil {
            self.healthCheckIntervalSeconds = dict["HealthCheckIntervalSeconds"] as! Int32
        }
        if dict.keys.contains("HealthCheckPath") && dict["HealthCheckPath"] != nil {
            self.healthCheckPath = dict["HealthCheckPath"] as! String
        }
        if dict.keys.contains("HealthCheckPort") && dict["HealthCheckPort"] != nil {
            self.healthCheckPort = dict["HealthCheckPort"] as! Int32
        }
        if dict.keys.contains("HealthCheckProtocol") && dict["HealthCheckProtocol"] != nil {
            self.healthCheckProtocol = dict["HealthCheckProtocol"] as! String
        }
        if dict.keys.contains("ListenerId") && dict["ListenerId"] != nil {
            self.listenerId = dict["ListenerId"] as! String
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("PortOverrides") && dict["PortOverrides"] != nil {
            var tmp : [CreateEndpointGroupRequest.PortOverrides] = []
            for v in dict["PortOverrides"] as! [Any] {
                var model = CreateEndpointGroupRequest.PortOverrides()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.portOverrides = tmp
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("Tag") && dict["Tag"] != nil {
            var tmp : [CreateEndpointGroupRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = CreateEndpointGroupRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
        if dict.keys.contains("ThresholdCount") && dict["ThresholdCount"] != nil {
            self.thresholdCount = dict["ThresholdCount"] as! Int32
        }
        if dict.keys.contains("TrafficPercentage") && dict["TrafficPercentage"] != nil {
            self.trafficPercentage = dict["TrafficPercentage"] as! Int32
        }
    }
}

public class CreateEndpointGroupResponseBody : Tea.TeaModel {
    public var endpointGroupId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endpointGroupId != nil {
            map["EndpointGroupId"] = self.endpointGroupId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndpointGroupId") && dict["EndpointGroupId"] != nil {
            self.endpointGroupId = dict["EndpointGroupId"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateEndpointGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateEndpointGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateEndpointGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateEndpointGroupsRequest : Tea.TeaModel {
    public class EndpointGroupConfigurations : Tea.TeaModel {
        public class EndpointConfigurations : Tea.TeaModel {
            public var endpoint: String?

            public var subAddress: String?

            public var type: String?

            public var weight: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.endpoint != nil {
                    map["Endpoint"] = self.endpoint!
                }
                if self.subAddress != nil {
                    map["SubAddress"] = self.subAddress!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.weight != nil {
                    map["Weight"] = self.weight!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Endpoint") && dict["Endpoint"] != nil {
                    self.endpoint = dict["Endpoint"] as! String
                }
                if dict.keys.contains("SubAddress") && dict["SubAddress"] != nil {
                    self.subAddress = dict["SubAddress"] as! String
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("Weight") && dict["Weight"] != nil {
                    self.weight = dict["Weight"] as! Int64
                }
            }
        }
        public class PortOverrides : Tea.TeaModel {
            public var endpointPort: Int64?

            public var listenerPort: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.endpointPort != nil {
                    map["EndpointPort"] = self.endpointPort!
                }
                if self.listenerPort != nil {
                    map["ListenerPort"] = self.listenerPort!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("EndpointPort") && dict["EndpointPort"] != nil {
                    self.endpointPort = dict["EndpointPort"] as! Int64
                }
                if dict.keys.contains("ListenerPort") && dict["ListenerPort"] != nil {
                    self.listenerPort = dict["ListenerPort"] as! Int64
                }
            }
        }
        public class SystemTag : Tea.TeaModel {
            public var key: String?

            public var scope: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.scope != nil {
                    map["Scope"] = self.scope!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Key") && dict["Key"] != nil {
                    self.key = dict["Key"] as! String
                }
                if dict.keys.contains("Scope") && dict["Scope"] != nil {
                    self.scope = dict["Scope"] as! String
                }
                if dict.keys.contains("Value") && dict["Value"] != nil {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public class Tag : Tea.TeaModel {
            public var key: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Key") && dict["Key"] != nil {
                    self.key = dict["Key"] as! String
                }
                if dict.keys.contains("Value") && dict["Value"] != nil {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public var enableClientIPPreservationProxyProtocol: Bool?

        public var enableClientIPPreservationToa: Bool?

        public var endpointConfigurations: [CreateEndpointGroupsRequest.EndpointGroupConfigurations.EndpointConfigurations]?

        public var endpointGroupDescription: String?

        public var endpointGroupName: String?

        public var endpointGroupRegion: String?

        public var endpointGroupType: String?

        public var endpointRequestProtocol: String?

        public var healthCheckEnabled: Bool?

        public var healthCheckIntervalSeconds: Int64?

        public var healthCheckPath: String?

        public var healthCheckPort: Int64?

        public var healthCheckProtocol: String?

        public var portOverrides: [CreateEndpointGroupsRequest.EndpointGroupConfigurations.PortOverrides]?

        public var systemTag: [CreateEndpointGroupsRequest.EndpointGroupConfigurations.SystemTag]?

        public var tag: [CreateEndpointGroupsRequest.EndpointGroupConfigurations.Tag]?

        public var thresholdCount: Int64?

        public var trafficPercentage: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.enableClientIPPreservationProxyProtocol != nil {
                map["EnableClientIPPreservationProxyProtocol"] = self.enableClientIPPreservationProxyProtocol!
            }
            if self.enableClientIPPreservationToa != nil {
                map["EnableClientIPPreservationToa"] = self.enableClientIPPreservationToa!
            }
            if self.endpointConfigurations != nil {
                var tmp : [Any] = []
                for k in self.endpointConfigurations! {
                    tmp.append(k.toMap())
                }
                map["EndpointConfigurations"] = tmp
            }
            if self.endpointGroupDescription != nil {
                map["EndpointGroupDescription"] = self.endpointGroupDescription!
            }
            if self.endpointGroupName != nil {
                map["EndpointGroupName"] = self.endpointGroupName!
            }
            if self.endpointGroupRegion != nil {
                map["EndpointGroupRegion"] = self.endpointGroupRegion!
            }
            if self.endpointGroupType != nil {
                map["EndpointGroupType"] = self.endpointGroupType!
            }
            if self.endpointRequestProtocol != nil {
                map["EndpointRequestProtocol"] = self.endpointRequestProtocol!
            }
            if self.healthCheckEnabled != nil {
                map["HealthCheckEnabled"] = self.healthCheckEnabled!
            }
            if self.healthCheckIntervalSeconds != nil {
                map["HealthCheckIntervalSeconds"] = self.healthCheckIntervalSeconds!
            }
            if self.healthCheckPath != nil {
                map["HealthCheckPath"] = self.healthCheckPath!
            }
            if self.healthCheckPort != nil {
                map["HealthCheckPort"] = self.healthCheckPort!
            }
            if self.healthCheckProtocol != nil {
                map["HealthCheckProtocol"] = self.healthCheckProtocol!
            }
            if self.portOverrides != nil {
                var tmp : [Any] = []
                for k in self.portOverrides! {
                    tmp.append(k.toMap())
                }
                map["PortOverrides"] = tmp
            }
            if self.systemTag != nil {
                var tmp : [Any] = []
                for k in self.systemTag! {
                    tmp.append(k.toMap())
                }
                map["SystemTag"] = tmp
            }
            if self.tag != nil {
                var tmp : [Any] = []
                for k in self.tag! {
                    tmp.append(k.toMap())
                }
                map["Tag"] = tmp
            }
            if self.thresholdCount != nil {
                map["ThresholdCount"] = self.thresholdCount!
            }
            if self.trafficPercentage != nil {
                map["TrafficPercentage"] = self.trafficPercentage!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EnableClientIPPreservationProxyProtocol") && dict["EnableClientIPPreservationProxyProtocol"] != nil {
                self.enableClientIPPreservationProxyProtocol = dict["EnableClientIPPreservationProxyProtocol"] as! Bool
            }
            if dict.keys.contains("EnableClientIPPreservationToa") && dict["EnableClientIPPreservationToa"] != nil {
                self.enableClientIPPreservationToa = dict["EnableClientIPPreservationToa"] as! Bool
            }
            if dict.keys.contains("EndpointConfigurations") && dict["EndpointConfigurations"] != nil {
                var tmp : [CreateEndpointGroupsRequest.EndpointGroupConfigurations.EndpointConfigurations] = []
                for v in dict["EndpointConfigurations"] as! [Any] {
                    var model = CreateEndpointGroupsRequest.EndpointGroupConfigurations.EndpointConfigurations()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.endpointConfigurations = tmp
            }
            if dict.keys.contains("EndpointGroupDescription") && dict["EndpointGroupDescription"] != nil {
                self.endpointGroupDescription = dict["EndpointGroupDescription"] as! String
            }
            if dict.keys.contains("EndpointGroupName") && dict["EndpointGroupName"] != nil {
                self.endpointGroupName = dict["EndpointGroupName"] as! String
            }
            if dict.keys.contains("EndpointGroupRegion") && dict["EndpointGroupRegion"] != nil {
                self.endpointGroupRegion = dict["EndpointGroupRegion"] as! String
            }
            if dict.keys.contains("EndpointGroupType") && dict["EndpointGroupType"] != nil {
                self.endpointGroupType = dict["EndpointGroupType"] as! String
            }
            if dict.keys.contains("EndpointRequestProtocol") && dict["EndpointRequestProtocol"] != nil {
                self.endpointRequestProtocol = dict["EndpointRequestProtocol"] as! String
            }
            if dict.keys.contains("HealthCheckEnabled") && dict["HealthCheckEnabled"] != nil {
                self.healthCheckEnabled = dict["HealthCheckEnabled"] as! Bool
            }
            if dict.keys.contains("HealthCheckIntervalSeconds") && dict["HealthCheckIntervalSeconds"] != nil {
                self.healthCheckIntervalSeconds = dict["HealthCheckIntervalSeconds"] as! Int64
            }
            if dict.keys.contains("HealthCheckPath") && dict["HealthCheckPath"] != nil {
                self.healthCheckPath = dict["HealthCheckPath"] as! String
            }
            if dict.keys.contains("HealthCheckPort") && dict["HealthCheckPort"] != nil {
                self.healthCheckPort = dict["HealthCheckPort"] as! Int64
            }
            if dict.keys.contains("HealthCheckProtocol") && dict["HealthCheckProtocol"] != nil {
                self.healthCheckProtocol = dict["HealthCheckProtocol"] as! String
            }
            if dict.keys.contains("PortOverrides") && dict["PortOverrides"] != nil {
                var tmp : [CreateEndpointGroupsRequest.EndpointGroupConfigurations.PortOverrides] = []
                for v in dict["PortOverrides"] as! [Any] {
                    var model = CreateEndpointGroupsRequest.EndpointGroupConfigurations.PortOverrides()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.portOverrides = tmp
            }
            if dict.keys.contains("SystemTag") && dict["SystemTag"] != nil {
                var tmp : [CreateEndpointGroupsRequest.EndpointGroupConfigurations.SystemTag] = []
                for v in dict["SystemTag"] as! [Any] {
                    var model = CreateEndpointGroupsRequest.EndpointGroupConfigurations.SystemTag()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.systemTag = tmp
            }
            if dict.keys.contains("Tag") && dict["Tag"] != nil {
                var tmp : [CreateEndpointGroupsRequest.EndpointGroupConfigurations.Tag] = []
                for v in dict["Tag"] as! [Any] {
                    var model = CreateEndpointGroupsRequest.EndpointGroupConfigurations.Tag()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.tag = tmp
            }
            if dict.keys.contains("ThresholdCount") && dict["ThresholdCount"] != nil {
                self.thresholdCount = dict["ThresholdCount"] as! Int64
            }
            if dict.keys.contains("TrafficPercentage") && dict["TrafficPercentage"] != nil {
                self.trafficPercentage = dict["TrafficPercentage"] as! Int64
            }
        }
    }
    public var acceleratorId: String?

    public var clientToken: String?

    public var dryRun: Bool?

    public var endpointGroupConfigurations: [CreateEndpointGroupsRequest.EndpointGroupConfigurations]?

    public var listenerId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceleratorId != nil {
            map["AcceleratorId"] = self.acceleratorId!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.endpointGroupConfigurations != nil {
            var tmp : [Any] = []
            for k in self.endpointGroupConfigurations! {
                tmp.append(k.toMap())
            }
            map["EndpointGroupConfigurations"] = tmp
        }
        if self.listenerId != nil {
            map["ListenerId"] = self.listenerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceleratorId") && dict["AcceleratorId"] != nil {
            self.acceleratorId = dict["AcceleratorId"] as! String
        }
        if dict.keys.contains("ClientToken") && dict["ClientToken"] != nil {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("DryRun") && dict["DryRun"] != nil {
            self.dryRun = dict["DryRun"] as! Bool
        }
        if dict.keys.contains("EndpointGroupConfigurations") && dict["EndpointGroupConfigurations"] != nil {
            var tmp : [CreateEndpointGroupsRequest.EndpointGroupConfigurations] = []
            for v in dict["EndpointGroupConfigurations"] as! [Any] {
                var model = CreateEndpointGroupsRequest.EndpointGroupConfigurations()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.endpointGroupConfigurations = tmp
        }
        if dict.keys.contains("ListenerId") && dict["ListenerId"] != nil {
            self.listenerId = dict["ListenerId"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class CreateEndpointGroupsResponseBody : Tea.TeaModel {
    public var endpointGroupIds: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endpointGroupIds != nil {
            map["EndpointGroupIds"] = self.endpointGroupIds!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndpointGroupIds") && dict["EndpointGroupIds"] != nil {
            self.endpointGroupIds = dict["EndpointGroupIds"] as! [String]
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateEndpointGroupsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateEndpointGroupsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateEndpointGroupsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateForwardingRulesRequest : Tea.TeaModel {
    public class ForwardingRules : Tea.TeaModel {
        public class RuleActions : Tea.TeaModel {
            public class ForwardGroupConfig : Tea.TeaModel {
                public class ServerGroupTuples : Tea.TeaModel {
                    public var endpointGroupId: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.endpointGroupId != nil {
                            map["EndpointGroupId"] = self.endpointGroupId!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("EndpointGroupId") && dict["EndpointGroupId"] != nil {
                            self.endpointGroupId = dict["EndpointGroupId"] as! String
                        }
                    }
                }
                public var serverGroupTuples: [CreateForwardingRulesRequest.ForwardingRules.RuleActions.ForwardGroupConfig.ServerGroupTuples]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.serverGroupTuples != nil {
                        var tmp : [Any] = []
                        for k in self.serverGroupTuples! {
                            tmp.append(k.toMap())
                        }
                        map["ServerGroupTuples"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ServerGroupTuples") && dict["ServerGroupTuples"] != nil {
                        var tmp : [CreateForwardingRulesRequest.ForwardingRules.RuleActions.ForwardGroupConfig.ServerGroupTuples] = []
                        for v in dict["ServerGroupTuples"] as! [Any] {
                            var model = CreateForwardingRulesRequest.ForwardingRules.RuleActions.ForwardGroupConfig.ServerGroupTuples()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.serverGroupTuples = tmp
                    }
                }
            }
            public var forwardGroupConfig: CreateForwardingRulesRequest.ForwardingRules.RuleActions.ForwardGroupConfig?

            public var order: Int32?

            public var ruleActionType: String?

            public var ruleActionValue: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.forwardGroupConfig?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.forwardGroupConfig != nil {
                    map["ForwardGroupConfig"] = self.forwardGroupConfig?.toMap()
                }
                if self.order != nil {
                    map["Order"] = self.order!
                }
                if self.ruleActionType != nil {
                    map["RuleActionType"] = self.ruleActionType!
                }
                if self.ruleActionValue != nil {
                    map["RuleActionValue"] = self.ruleActionValue!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ForwardGroupConfig") && dict["ForwardGroupConfig"] != nil {
                    var model = CreateForwardingRulesRequest.ForwardingRules.RuleActions.ForwardGroupConfig()
                    model.fromMap(dict["ForwardGroupConfig"] as! [String: Any])
                    self.forwardGroupConfig = model
                }
                if dict.keys.contains("Order") && dict["Order"] != nil {
                    self.order = dict["Order"] as! Int32
                }
                if dict.keys.contains("RuleActionType") && dict["RuleActionType"] != nil {
                    self.ruleActionType = dict["RuleActionType"] as! String
                }
                if dict.keys.contains("RuleActionValue") && dict["RuleActionValue"] != nil {
                    self.ruleActionValue = dict["RuleActionValue"] as! String
                }
            }
        }
        public class RuleConditions : Tea.TeaModel {
            public class HostConfig : Tea.TeaModel {
                public var values: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.values != nil {
                        map["Values"] = self.values!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Values") && dict["Values"] != nil {
                        self.values = dict["Values"] as! [String]
                    }
                }
            }
            public class PathConfig : Tea.TeaModel {
                public var values: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.values != nil {
                        map["Values"] = self.values!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Values") && dict["Values"] != nil {
                        self.values = dict["Values"] as! [String]
                    }
                }
            }
            public var hostConfig: CreateForwardingRulesRequest.ForwardingRules.RuleConditions.HostConfig?

            public var pathConfig: CreateForwardingRulesRequest.ForwardingRules.RuleConditions.PathConfig?

            public var ruleConditionType: String?

            public var ruleConditionValue: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.hostConfig?.validate()
                try self.pathConfig?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.hostConfig != nil {
                    map["HostConfig"] = self.hostConfig?.toMap()
                }
                if self.pathConfig != nil {
                    map["PathConfig"] = self.pathConfig?.toMap()
                }
                if self.ruleConditionType != nil {
                    map["RuleConditionType"] = self.ruleConditionType!
                }
                if self.ruleConditionValue != nil {
                    map["RuleConditionValue"] = self.ruleConditionValue!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("HostConfig") && dict["HostConfig"] != nil {
                    var model = CreateForwardingRulesRequest.ForwardingRules.RuleConditions.HostConfig()
                    model.fromMap(dict["HostConfig"] as! [String: Any])
                    self.hostConfig = model
                }
                if dict.keys.contains("PathConfig") && dict["PathConfig"] != nil {
                    var model = CreateForwardingRulesRequest.ForwardingRules.RuleConditions.PathConfig()
                    model.fromMap(dict["PathConfig"] as! [String: Any])
                    self.pathConfig = model
                }
                if dict.keys.contains("RuleConditionType") && dict["RuleConditionType"] != nil {
                    self.ruleConditionType = dict["RuleConditionType"] as! String
                }
                if dict.keys.contains("RuleConditionValue") && dict["RuleConditionValue"] != nil {
                    self.ruleConditionValue = dict["RuleConditionValue"] as! String
                }
            }
        }
        public var forwardingRuleName: String?

        public var priority: Int32?

        public var ruleActions: [CreateForwardingRulesRequest.ForwardingRules.RuleActions]?

        public var ruleConditions: [CreateForwardingRulesRequest.ForwardingRules.RuleConditions]?

        public var ruleDirection: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.forwardingRuleName != nil {
                map["ForwardingRuleName"] = self.forwardingRuleName!
            }
            if self.priority != nil {
                map["Priority"] = self.priority!
            }
            if self.ruleActions != nil {
                var tmp : [Any] = []
                for k in self.ruleActions! {
                    tmp.append(k.toMap())
                }
                map["RuleActions"] = tmp
            }
            if self.ruleConditions != nil {
                var tmp : [Any] = []
                for k in self.ruleConditions! {
                    tmp.append(k.toMap())
                }
                map["RuleConditions"] = tmp
            }
            if self.ruleDirection != nil {
                map["RuleDirection"] = self.ruleDirection!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ForwardingRuleName") && dict["ForwardingRuleName"] != nil {
                self.forwardingRuleName = dict["ForwardingRuleName"] as! String
            }
            if dict.keys.contains("Priority") && dict["Priority"] != nil {
                self.priority = dict["Priority"] as! Int32
            }
            if dict.keys.contains("RuleActions") && dict["RuleActions"] != nil {
                var tmp : [CreateForwardingRulesRequest.ForwardingRules.RuleActions] = []
                for v in dict["RuleActions"] as! [Any] {
                    var model = CreateForwardingRulesRequest.ForwardingRules.RuleActions()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.ruleActions = tmp
            }
            if dict.keys.contains("RuleConditions") && dict["RuleConditions"] != nil {
                var tmp : [CreateForwardingRulesRequest.ForwardingRules.RuleConditions] = []
                for v in dict["RuleConditions"] as! [Any] {
                    var model = CreateForwardingRulesRequest.ForwardingRules.RuleConditions()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.ruleConditions = tmp
            }
            if dict.keys.contains("RuleDirection") && dict["RuleDirection"] != nil {
                self.ruleDirection = dict["RuleDirection"] as! String
            }
        }
    }
    public var acceleratorId: String?

    public var clientToken: String?

    public var forwardingRules: [CreateForwardingRulesRequest.ForwardingRules]?

    public var listenerId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceleratorId != nil {
            map["AcceleratorId"] = self.acceleratorId!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.forwardingRules != nil {
            var tmp : [Any] = []
            for k in self.forwardingRules! {
                tmp.append(k.toMap())
            }
            map["ForwardingRules"] = tmp
        }
        if self.listenerId != nil {
            map["ListenerId"] = self.listenerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceleratorId") && dict["AcceleratorId"] != nil {
            self.acceleratorId = dict["AcceleratorId"] as! String
        }
        if dict.keys.contains("ClientToken") && dict["ClientToken"] != nil {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("ForwardingRules") && dict["ForwardingRules"] != nil {
            var tmp : [CreateForwardingRulesRequest.ForwardingRules] = []
            for v in dict["ForwardingRules"] as! [Any] {
                var model = CreateForwardingRulesRequest.ForwardingRules()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.forwardingRules = tmp
        }
        if dict.keys.contains("ListenerId") && dict["ListenerId"] != nil {
            self.listenerId = dict["ListenerId"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class CreateForwardingRulesResponseBody : Tea.TeaModel {
    public class ForwardingRules : Tea.TeaModel {
        public var forwardingRuleId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.forwardingRuleId != nil {
                map["ForwardingRuleId"] = self.forwardingRuleId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ForwardingRuleId") && dict["ForwardingRuleId"] != nil {
                self.forwardingRuleId = dict["ForwardingRuleId"] as! String
            }
        }
    }
    public var forwardingRules: [CreateForwardingRulesResponseBody.ForwardingRules]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.forwardingRules != nil {
            var tmp : [Any] = []
            for k in self.forwardingRules! {
                tmp.append(k.toMap())
            }
            map["ForwardingRules"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ForwardingRules") && dict["ForwardingRules"] != nil {
            var tmp : [CreateForwardingRulesResponseBody.ForwardingRules] = []
            for v in dict["ForwardingRules"] as! [Any] {
                var model = CreateForwardingRulesResponseBody.ForwardingRules()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.forwardingRules = tmp
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateForwardingRulesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateForwardingRulesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateForwardingRulesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateIpSetsRequest : Tea.TeaModel {
    public class AccelerateRegion : Tea.TeaModel {
        public var accelerateRegionId: String?

        public var bandwidth: Int32?

        public var ipVersion: String?

        public var ispType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accelerateRegionId != nil {
                map["AccelerateRegionId"] = self.accelerateRegionId!
            }
            if self.bandwidth != nil {
                map["Bandwidth"] = self.bandwidth!
            }
            if self.ipVersion != nil {
                map["IpVersion"] = self.ipVersion!
            }
            if self.ispType != nil {
                map["IspType"] = self.ispType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AccelerateRegionId") && dict["AccelerateRegionId"] != nil {
                self.accelerateRegionId = dict["AccelerateRegionId"] as! String
            }
            if dict.keys.contains("Bandwidth") && dict["Bandwidth"] != nil {
                self.bandwidth = dict["Bandwidth"] as! Int32
            }
            if dict.keys.contains("IpVersion") && dict["IpVersion"] != nil {
                self.ipVersion = dict["IpVersion"] as! String
            }
            if dict.keys.contains("IspType") && dict["IspType"] != nil {
                self.ispType = dict["IspType"] as! String
            }
        }
    }
    public var accelerateRegion: [CreateIpSetsRequest.AccelerateRegion]?

    public var acceleratorId: String?

    public var clientToken: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accelerateRegion != nil {
            var tmp : [Any] = []
            for k in self.accelerateRegion! {
                tmp.append(k.toMap())
            }
            map["AccelerateRegion"] = tmp
        }
        if self.acceleratorId != nil {
            map["AcceleratorId"] = self.acceleratorId!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AccelerateRegion") && dict["AccelerateRegion"] != nil {
            var tmp : [CreateIpSetsRequest.AccelerateRegion] = []
            for v in dict["AccelerateRegion"] as! [Any] {
                var model = CreateIpSetsRequest.AccelerateRegion()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.accelerateRegion = tmp
        }
        if dict.keys.contains("AcceleratorId") && dict["AcceleratorId"] != nil {
            self.acceleratorId = dict["AcceleratorId"] as! String
        }
        if dict.keys.contains("ClientToken") && dict["ClientToken"] != nil {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class CreateIpSetsResponseBody : Tea.TeaModel {
    public class IpSets : Tea.TeaModel {
        public var accelerateRegionId: String?

        public var bandwidth: Int32?

        public var ipSetId: String?

        public var ispType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accelerateRegionId != nil {
                map["AccelerateRegionId"] = self.accelerateRegionId!
            }
            if self.bandwidth != nil {
                map["Bandwidth"] = self.bandwidth!
            }
            if self.ipSetId != nil {
                map["IpSetId"] = self.ipSetId!
            }
            if self.ispType != nil {
                map["IspType"] = self.ispType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AccelerateRegionId") && dict["AccelerateRegionId"] != nil {
                self.accelerateRegionId = dict["AccelerateRegionId"] as! String
            }
            if dict.keys.contains("Bandwidth") && dict["Bandwidth"] != nil {
                self.bandwidth = dict["Bandwidth"] as! Int32
            }
            if dict.keys.contains("IpSetId") && dict["IpSetId"] != nil {
                self.ipSetId = dict["IpSetId"] as! String
            }
            if dict.keys.contains("IspType") && dict["IspType"] != nil {
                self.ispType = dict["IspType"] as! String
            }
        }
    }
    public var acceleratorId: String?

    public var ipSets: [CreateIpSetsResponseBody.IpSets]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceleratorId != nil {
            map["AcceleratorId"] = self.acceleratorId!
        }
        if self.ipSets != nil {
            var tmp : [Any] = []
            for k in self.ipSets! {
                tmp.append(k.toMap())
            }
            map["IpSets"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceleratorId") && dict["AcceleratorId"] != nil {
            self.acceleratorId = dict["AcceleratorId"] as! String
        }
        if dict.keys.contains("IpSets") && dict["IpSets"] != nil {
            var tmp : [CreateIpSetsResponseBody.IpSets] = []
            for v in dict["IpSets"] as! [Any] {
                var model = CreateIpSetsResponseBody.IpSets()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.ipSets = tmp
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateIpSetsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateIpSetsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateIpSetsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateListenerRequest : Tea.TeaModel {
    public class Certificates : Tea.TeaModel {
        public var id: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.id != nil {
                map["Id"] = self.id!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Id") && dict["Id"] != nil {
                self.id = dict["Id"] as! String
            }
        }
    }
    public class CustomRoutingEndpointGroupConfigurations : Tea.TeaModel {
        public class DestinationConfigurations : Tea.TeaModel {
            public var fromPort: Int32?

            public var protocols: [String]?

            public var toPort: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.fromPort != nil {
                    map["FromPort"] = self.fromPort!
                }
                if self.protocols != nil {
                    map["Protocols"] = self.protocols!
                }
                if self.toPort != nil {
                    map["ToPort"] = self.toPort!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("FromPort") && dict["FromPort"] != nil {
                    self.fromPort = dict["FromPort"] as! Int32
                }
                if dict.keys.contains("Protocols") && dict["Protocols"] != nil {
                    self.protocols = dict["Protocols"] as! [String]
                }
                if dict.keys.contains("ToPort") && dict["ToPort"] != nil {
                    self.toPort = dict["ToPort"] as! Int32
                }
            }
        }
        public class EndpointConfigurations : Tea.TeaModel {
            public class PolicyConfigurations : Tea.TeaModel {
                public class PortRanges : Tea.TeaModel {
                    public var fromPort: Int32?

                    public var toPort: Int32?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.fromPort != nil {
                            map["FromPort"] = self.fromPort!
                        }
                        if self.toPort != nil {
                            map["ToPort"] = self.toPort!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("FromPort") && dict["FromPort"] != nil {
                            self.fromPort = dict["FromPort"] as! Int32
                        }
                        if dict.keys.contains("ToPort") && dict["ToPort"] != nil {
                            self.toPort = dict["ToPort"] as! Int32
                        }
                    }
                }
                public var address: String?

                public var portRanges: [CreateListenerRequest.CustomRoutingEndpointGroupConfigurations.EndpointConfigurations.PolicyConfigurations.PortRanges]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.address != nil {
                        map["Address"] = self.address!
                    }
                    if self.portRanges != nil {
                        var tmp : [Any] = []
                        for k in self.portRanges! {
                            tmp.append(k.toMap())
                        }
                        map["PortRanges"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Address") && dict["Address"] != nil {
                        self.address = dict["Address"] as! String
                    }
                    if dict.keys.contains("PortRanges") && dict["PortRanges"] != nil {
                        var tmp : [CreateListenerRequest.CustomRoutingEndpointGroupConfigurations.EndpointConfigurations.PolicyConfigurations.PortRanges] = []
                        for v in dict["PortRanges"] as! [Any] {
                            var model = CreateListenerRequest.CustomRoutingEndpointGroupConfigurations.EndpointConfigurations.PolicyConfigurations.PortRanges()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.portRanges = tmp
                    }
                }
            }
            public var endpoint: String?

            public var policyConfigurations: [CreateListenerRequest.CustomRoutingEndpointGroupConfigurations.EndpointConfigurations.PolicyConfigurations]?

            public var trafficToEndpointPolicy: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.endpoint != nil {
                    map["Endpoint"] = self.endpoint!
                }
                if self.policyConfigurations != nil {
                    var tmp : [Any] = []
                    for k in self.policyConfigurations! {
                        tmp.append(k.toMap())
                    }
                    map["PolicyConfigurations"] = tmp
                }
                if self.trafficToEndpointPolicy != nil {
                    map["TrafficToEndpointPolicy"] = self.trafficToEndpointPolicy!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Endpoint") && dict["Endpoint"] != nil {
                    self.endpoint = dict["Endpoint"] as! String
                }
                if dict.keys.contains("PolicyConfigurations") && dict["PolicyConfigurations"] != nil {
                    var tmp : [CreateListenerRequest.CustomRoutingEndpointGroupConfigurations.EndpointConfigurations.PolicyConfigurations] = []
                    for v in dict["PolicyConfigurations"] as! [Any] {
                        var model = CreateListenerRequest.CustomRoutingEndpointGroupConfigurations.EndpointConfigurations.PolicyConfigurations()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.policyConfigurations = tmp
                }
                if dict.keys.contains("TrafficToEndpointPolicy") && dict["TrafficToEndpointPolicy"] != nil {
                    self.trafficToEndpointPolicy = dict["TrafficToEndpointPolicy"] as! String
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var description_: String?

        public var destinationConfigurations: [CreateListenerRequest.CustomRoutingEndpointGroupConfigurations.DestinationConfigurations]?

        public var endpointConfigurations: [CreateListenerRequest.CustomRoutingEndpointGroupConfigurations.EndpointConfigurations]?

        public var endpointGroupRegion: String?

        public var name: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.destinationConfigurations != nil {
                var tmp : [Any] = []
                for k in self.destinationConfigurations! {
                    tmp.append(k.toMap())
                }
                map["DestinationConfigurations"] = tmp
            }
            if self.endpointConfigurations != nil {
                var tmp : [Any] = []
                for k in self.endpointConfigurations! {
                    tmp.append(k.toMap())
                }
                map["EndpointConfigurations"] = tmp
            }
            if self.endpointGroupRegion != nil {
                map["EndpointGroupRegion"] = self.endpointGroupRegion!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Description") && dict["Description"] != nil {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("DestinationConfigurations") && dict["DestinationConfigurations"] != nil {
                var tmp : [CreateListenerRequest.CustomRoutingEndpointGroupConfigurations.DestinationConfigurations] = []
                for v in dict["DestinationConfigurations"] as! [Any] {
                    var model = CreateListenerRequest.CustomRoutingEndpointGroupConfigurations.DestinationConfigurations()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.destinationConfigurations = tmp
            }
            if dict.keys.contains("EndpointConfigurations") && dict["EndpointConfigurations"] != nil {
                var tmp : [CreateListenerRequest.CustomRoutingEndpointGroupConfigurations.EndpointConfigurations] = []
                for v in dict["EndpointConfigurations"] as! [Any] {
                    var model = CreateListenerRequest.CustomRoutingEndpointGroupConfigurations.EndpointConfigurations()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.endpointConfigurations = tmp
            }
            if dict.keys.contains("EndpointGroupRegion") && dict["EndpointGroupRegion"] != nil {
                self.endpointGroupRegion = dict["EndpointGroupRegion"] as! String
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
        }
    }
    public class EndpointGroupConfigurations : Tea.TeaModel {
        public class EndpointConfigurations : Tea.TeaModel {
            public var endpoint: String?

            public var subAddress: String?

            public var type: String?

            public var weight: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.endpoint != nil {
                    map["Endpoint"] = self.endpoint!
                }
                if self.subAddress != nil {
                    map["SubAddress"] = self.subAddress!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.weight != nil {
                    map["Weight"] = self.weight!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Endpoint") && dict["Endpoint"] != nil {
                    self.endpoint = dict["Endpoint"] as! String
                }
                if dict.keys.contains("SubAddress") && dict["SubAddress"] != nil {
                    self.subAddress = dict["SubAddress"] as! String
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("Weight") && dict["Weight"] != nil {
                    self.weight = dict["Weight"] as! Int64
                }
            }
        }
        public class PortOverrides : Tea.TeaModel {
            public var endpointPort: Int64?

            public var listenerPort: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.endpointPort != nil {
                    map["EndpointPort"] = self.endpointPort!
                }
                if self.listenerPort != nil {
                    map["ListenerPort"] = self.listenerPort!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("EndpointPort") && dict["EndpointPort"] != nil {
                    self.endpointPort = dict["EndpointPort"] as! Int64
                }
                if dict.keys.contains("ListenerPort") && dict["ListenerPort"] != nil {
                    self.listenerPort = dict["ListenerPort"] as! Int64
                }
            }
        }
        public var enableClientIPPreservationProxyProtocol: Bool?

        public var enableClientIPPreservationToa: Bool?

        public var endpointConfigurations: [CreateListenerRequest.EndpointGroupConfigurations.EndpointConfigurations]?

        public var endpointGroupDescription: String?

        public var endpointGroupName: String?

        public var endpointGroupRegion: String?

        public var endpointGroupType: String?

        public var endpointRequestProtocol: String?

        public var healthCheckEnabled: Bool?

        public var healthCheckIntervalSeconds: Int64?

        public var healthCheckPath: String?

        public var healthCheckPort: Int64?

        public var healthCheckProtocol: String?

        public var portOverrides: [CreateListenerRequest.EndpointGroupConfigurations.PortOverrides]?

        public var thresholdCount: Int64?

        public var trafficPercentage: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.enableClientIPPreservationProxyProtocol != nil {
                map["EnableClientIPPreservationProxyProtocol"] = self.enableClientIPPreservationProxyProtocol!
            }
            if self.enableClientIPPreservationToa != nil {
                map["EnableClientIPPreservationToa"] = self.enableClientIPPreservationToa!
            }
            if self.endpointConfigurations != nil {
                var tmp : [Any] = []
                for k in self.endpointConfigurations! {
                    tmp.append(k.toMap())
                }
                map["EndpointConfigurations"] = tmp
            }
            if self.endpointGroupDescription != nil {
                map["EndpointGroupDescription"] = self.endpointGroupDescription!
            }
            if self.endpointGroupName != nil {
                map["EndpointGroupName"] = self.endpointGroupName!
            }
            if self.endpointGroupRegion != nil {
                map["EndpointGroupRegion"] = self.endpointGroupRegion!
            }
            if self.endpointGroupType != nil {
                map["EndpointGroupType"] = self.endpointGroupType!
            }
            if self.endpointRequestProtocol != nil {
                map["EndpointRequestProtocol"] = self.endpointRequestProtocol!
            }
            if self.healthCheckEnabled != nil {
                map["HealthCheckEnabled"] = self.healthCheckEnabled!
            }
            if self.healthCheckIntervalSeconds != nil {
                map["HealthCheckIntervalSeconds"] = self.healthCheckIntervalSeconds!
            }
            if self.healthCheckPath != nil {
                map["HealthCheckPath"] = self.healthCheckPath!
            }
            if self.healthCheckPort != nil {
                map["HealthCheckPort"] = self.healthCheckPort!
            }
            if self.healthCheckProtocol != nil {
                map["HealthCheckProtocol"] = self.healthCheckProtocol!
            }
            if self.portOverrides != nil {
                var tmp : [Any] = []
                for k in self.portOverrides! {
                    tmp.append(k.toMap())
                }
                map["PortOverrides"] = tmp
            }
            if self.thresholdCount != nil {
                map["ThresholdCount"] = self.thresholdCount!
            }
            if self.trafficPercentage != nil {
                map["TrafficPercentage"] = self.trafficPercentage!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EnableClientIPPreservationProxyProtocol") && dict["EnableClientIPPreservationProxyProtocol"] != nil {
                self.enableClientIPPreservationProxyProtocol = dict["EnableClientIPPreservationProxyProtocol"] as! Bool
            }
            if dict.keys.contains("EnableClientIPPreservationToa") && dict["EnableClientIPPreservationToa"] != nil {
                self.enableClientIPPreservationToa = dict["EnableClientIPPreservationToa"] as! Bool
            }
            if dict.keys.contains("EndpointConfigurations") && dict["EndpointConfigurations"] != nil {
                var tmp : [CreateListenerRequest.EndpointGroupConfigurations.EndpointConfigurations] = []
                for v in dict["EndpointConfigurations"] as! [Any] {
                    var model = CreateListenerRequest.EndpointGroupConfigurations.EndpointConfigurations()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.endpointConfigurations = tmp
            }
            if dict.keys.contains("EndpointGroupDescription") && dict["EndpointGroupDescription"] != nil {
                self.endpointGroupDescription = dict["EndpointGroupDescription"] as! String
            }
            if dict.keys.contains("EndpointGroupName") && dict["EndpointGroupName"] != nil {
                self.endpointGroupName = dict["EndpointGroupName"] as! String
            }
            if dict.keys.contains("EndpointGroupRegion") && dict["EndpointGroupRegion"] != nil {
                self.endpointGroupRegion = dict["EndpointGroupRegion"] as! String
            }
            if dict.keys.contains("EndpointGroupType") && dict["EndpointGroupType"] != nil {
                self.endpointGroupType = dict["EndpointGroupType"] as! String
            }
            if dict.keys.contains("EndpointRequestProtocol") && dict["EndpointRequestProtocol"] != nil {
                self.endpointRequestProtocol = dict["EndpointRequestProtocol"] as! String
            }
            if dict.keys.contains("HealthCheckEnabled") && dict["HealthCheckEnabled"] != nil {
                self.healthCheckEnabled = dict["HealthCheckEnabled"] as! Bool
            }
            if dict.keys.contains("HealthCheckIntervalSeconds") && dict["HealthCheckIntervalSeconds"] != nil {
                self.healthCheckIntervalSeconds = dict["HealthCheckIntervalSeconds"] as! Int64
            }
            if dict.keys.contains("HealthCheckPath") && dict["HealthCheckPath"] != nil {
                self.healthCheckPath = dict["HealthCheckPath"] as! String
            }
            if dict.keys.contains("HealthCheckPort") && dict["HealthCheckPort"] != nil {
                self.healthCheckPort = dict["HealthCheckPort"] as! Int64
            }
            if dict.keys.contains("HealthCheckProtocol") && dict["HealthCheckProtocol"] != nil {
                self.healthCheckProtocol = dict["HealthCheckProtocol"] as! String
            }
            if dict.keys.contains("PortOverrides") && dict["PortOverrides"] != nil {
                var tmp : [CreateListenerRequest.EndpointGroupConfigurations.PortOverrides] = []
                for v in dict["PortOverrides"] as! [Any] {
                    var model = CreateListenerRequest.EndpointGroupConfigurations.PortOverrides()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.portOverrides = tmp
            }
            if dict.keys.contains("ThresholdCount") && dict["ThresholdCount"] != nil {
                self.thresholdCount = dict["ThresholdCount"] as! Int64
            }
            if dict.keys.contains("TrafficPercentage") && dict["TrafficPercentage"] != nil {
                self.trafficPercentage = dict["TrafficPercentage"] as! Int64
            }
        }
    }
    public class PortRanges : Tea.TeaModel {
        public var fromPort: Int32?

        public var toPort: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.fromPort != nil {
                map["FromPort"] = self.fromPort!
            }
            if self.toPort != nil {
                map["ToPort"] = self.toPort!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("FromPort") && dict["FromPort"] != nil {
                self.fromPort = dict["FromPort"] as! Int32
            }
            if dict.keys.contains("ToPort") && dict["ToPort"] != nil {
                self.toPort = dict["ToPort"] as! Int32
            }
        }
    }
    public class XForwardedForConfig : Tea.TeaModel {
        public var XForwardedForGaApEnabled: Bool?

        public var XForwardedForGaIdEnabled: Bool?

        public var XForwardedForPortEnabled: Bool?

        public var XForwardedForProtoEnabled: Bool?

        public var XRealIpEnabled: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.XForwardedForGaApEnabled != nil {
                map["XForwardedForGaApEnabled"] = self.XForwardedForGaApEnabled!
            }
            if self.XForwardedForGaIdEnabled != nil {
                map["XForwardedForGaIdEnabled"] = self.XForwardedForGaIdEnabled!
            }
            if self.XForwardedForPortEnabled != nil {
                map["XForwardedForPortEnabled"] = self.XForwardedForPortEnabled!
            }
            if self.XForwardedForProtoEnabled != nil {
                map["XForwardedForProtoEnabled"] = self.XForwardedForProtoEnabled!
            }
            if self.XRealIpEnabled != nil {
                map["XRealIpEnabled"] = self.XRealIpEnabled!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("XForwardedForGaApEnabled") && dict["XForwardedForGaApEnabled"] != nil {
                self.XForwardedForGaApEnabled = dict["XForwardedForGaApEnabled"] as! Bool
            }
            if dict.keys.contains("XForwardedForGaIdEnabled") && dict["XForwardedForGaIdEnabled"] != nil {
                self.XForwardedForGaIdEnabled = dict["XForwardedForGaIdEnabled"] as! Bool
            }
            if dict.keys.contains("XForwardedForPortEnabled") && dict["XForwardedForPortEnabled"] != nil {
                self.XForwardedForPortEnabled = dict["XForwardedForPortEnabled"] as! Bool
            }
            if dict.keys.contains("XForwardedForProtoEnabled") && dict["XForwardedForProtoEnabled"] != nil {
                self.XForwardedForProtoEnabled = dict["XForwardedForProtoEnabled"] as! Bool
            }
            if dict.keys.contains("XRealIpEnabled") && dict["XRealIpEnabled"] != nil {
                self.XRealIpEnabled = dict["XRealIpEnabled"] as! Bool
            }
        }
    }
    public var acceleratorId: String?

    public var certificates: [CreateListenerRequest.Certificates]?

    public var clientAffinity: String?

    public var clientToken: String?

    public var customRoutingEndpointGroupConfigurations: [CreateListenerRequest.CustomRoutingEndpointGroupConfigurations]?

    public var description_: String?

    public var endpointGroupConfigurations: [CreateListenerRequest.EndpointGroupConfigurations]?

    public var idleTimeout: Int32?

    public var name: String?

    public var portRanges: [CreateListenerRequest.PortRanges]?

    public var protocol_: String?

    public var proxyProtocol: Bool?

    public var regionId: String?

    public var requestTimeout: Int32?

    public var securityPolicyId: String?

    public var type: String?

    public var XForwardedForConfig: CreateListenerRequest.XForwardedForConfig?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.XForwardedForConfig?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceleratorId != nil {
            map["AcceleratorId"] = self.acceleratorId!
        }
        if self.certificates != nil {
            var tmp : [Any] = []
            for k in self.certificates! {
                tmp.append(k.toMap())
            }
            map["Certificates"] = tmp
        }
        if self.clientAffinity != nil {
            map["ClientAffinity"] = self.clientAffinity!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.customRoutingEndpointGroupConfigurations != nil {
            var tmp : [Any] = []
            for k in self.customRoutingEndpointGroupConfigurations! {
                tmp.append(k.toMap())
            }
            map["CustomRoutingEndpointGroupConfigurations"] = tmp
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.endpointGroupConfigurations != nil {
            var tmp : [Any] = []
            for k in self.endpointGroupConfigurations! {
                tmp.append(k.toMap())
            }
            map["EndpointGroupConfigurations"] = tmp
        }
        if self.idleTimeout != nil {
            map["IdleTimeout"] = self.idleTimeout!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.portRanges != nil {
            var tmp : [Any] = []
            for k in self.portRanges! {
                tmp.append(k.toMap())
            }
            map["PortRanges"] = tmp
        }
        if self.protocol_ != nil {
            map["Protocol"] = self.protocol_!
        }
        if self.proxyProtocol != nil {
            map["ProxyProtocol"] = self.proxyProtocol!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.requestTimeout != nil {
            map["RequestTimeout"] = self.requestTimeout!
        }
        if self.securityPolicyId != nil {
            map["SecurityPolicyId"] = self.securityPolicyId!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        if self.XForwardedForConfig != nil {
            map["XForwardedForConfig"] = self.XForwardedForConfig?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceleratorId") && dict["AcceleratorId"] != nil {
            self.acceleratorId = dict["AcceleratorId"] as! String
        }
        if dict.keys.contains("Certificates") && dict["Certificates"] != nil {
            var tmp : [CreateListenerRequest.Certificates] = []
            for v in dict["Certificates"] as! [Any] {
                var model = CreateListenerRequest.Certificates()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.certificates = tmp
        }
        if dict.keys.contains("ClientAffinity") && dict["ClientAffinity"] != nil {
            self.clientAffinity = dict["ClientAffinity"] as! String
        }
        if dict.keys.contains("ClientToken") && dict["ClientToken"] != nil {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("CustomRoutingEndpointGroupConfigurations") && dict["CustomRoutingEndpointGroupConfigurations"] != nil {
            var tmp : [CreateListenerRequest.CustomRoutingEndpointGroupConfigurations] = []
            for v in dict["CustomRoutingEndpointGroupConfigurations"] as! [Any] {
                var model = CreateListenerRequest.CustomRoutingEndpointGroupConfigurations()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.customRoutingEndpointGroupConfigurations = tmp
        }
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("EndpointGroupConfigurations") && dict["EndpointGroupConfigurations"] != nil {
            var tmp : [CreateListenerRequest.EndpointGroupConfigurations] = []
            for v in dict["EndpointGroupConfigurations"] as! [Any] {
                var model = CreateListenerRequest.EndpointGroupConfigurations()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.endpointGroupConfigurations = tmp
        }
        if dict.keys.contains("IdleTimeout") && dict["IdleTimeout"] != nil {
            self.idleTimeout = dict["IdleTimeout"] as! Int32
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("PortRanges") && dict["PortRanges"] != nil {
            var tmp : [CreateListenerRequest.PortRanges] = []
            for v in dict["PortRanges"] as! [Any] {
                var model = CreateListenerRequest.PortRanges()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.portRanges = tmp
        }
        if dict.keys.contains("Protocol") && dict["Protocol"] != nil {
            self.protocol_ = dict["Protocol"] as! String
        }
        if dict.keys.contains("ProxyProtocol") && dict["ProxyProtocol"] != nil {
            self.proxyProtocol = dict["ProxyProtocol"] as! Bool
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("RequestTimeout") && dict["RequestTimeout"] != nil {
            self.requestTimeout = dict["RequestTimeout"] as! Int32
        }
        if dict.keys.contains("SecurityPolicyId") && dict["SecurityPolicyId"] != nil {
            self.securityPolicyId = dict["SecurityPolicyId"] as! String
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! String
        }
        if dict.keys.contains("XForwardedForConfig") && dict["XForwardedForConfig"] != nil {
            var model = CreateListenerRequest.XForwardedForConfig()
            model.fromMap(dict["XForwardedForConfig"] as! [String: Any])
            self.XForwardedForConfig = model
        }
    }
}

public class CreateListenerResponseBody : Tea.TeaModel {
    public var listenerId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.listenerId != nil {
            map["ListenerId"] = self.listenerId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ListenerId") && dict["ListenerId"] != nil {
            self.listenerId = dict["ListenerId"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateListenerResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateListenerResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateListenerResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateSpareIpsRequest : Tea.TeaModel {
    public var acceleratorId: String?

    public var clientToken: String?

    public var dryRun: Bool?

    public var regionId: String?

    public var spareIps: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceleratorId != nil {
            map["AcceleratorId"] = self.acceleratorId!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.spareIps != nil {
            map["SpareIps"] = self.spareIps!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceleratorId") && dict["AcceleratorId"] != nil {
            self.acceleratorId = dict["AcceleratorId"] as! String
        }
        if dict.keys.contains("ClientToken") && dict["ClientToken"] != nil {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("DryRun") && dict["DryRun"] != nil {
            self.dryRun = dict["DryRun"] as! Bool
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("SpareIps") && dict["SpareIps"] != nil {
            self.spareIps = dict["SpareIps"] as! [String]
        }
    }
}

public class CreateSpareIpsResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateSpareIpsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateSpareIpsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateSpareIpsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteAcceleratorRequest : Tea.TeaModel {
    public var acceleratorId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceleratorId != nil {
            map["AcceleratorId"] = self.acceleratorId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceleratorId") && dict["AcceleratorId"] != nil {
            self.acceleratorId = dict["AcceleratorId"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DeleteAcceleratorResponseBody : Tea.TeaModel {
    public var acceleratorId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceleratorId != nil {
            map["AcceleratorId"] = self.acceleratorId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceleratorId") && dict["AcceleratorId"] != nil {
            self.acceleratorId = dict["AcceleratorId"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteAcceleratorResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteAcceleratorResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteAcceleratorResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteAclRequest : Tea.TeaModel {
    public var aclId: String?

    public var clientToken: String?

    public var dryRun: Bool?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aclId != nil {
            map["AclId"] = self.aclId!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AclId") && dict["AclId"] != nil {
            self.aclId = dict["AclId"] as! String
        }
        if dict.keys.contains("ClientToken") && dict["ClientToken"] != nil {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("DryRun") && dict["DryRun"] != nil {
            self.dryRun = dict["DryRun"] as! Bool
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DeleteAclResponseBody : Tea.TeaModel {
    public var aclId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aclId != nil {
            map["AclId"] = self.aclId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AclId") && dict["AclId"] != nil {
            self.aclId = dict["AclId"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteAclResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteAclResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteAclResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteApplicationMonitorRequest : Tea.TeaModel {
    public var clientToken: String?

    public var regionId: String?

    public var taskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") && dict["ClientToken"] != nil {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("TaskId") && dict["TaskId"] != nil {
            self.taskId = dict["TaskId"] as! String
        }
    }
}

public class DeleteApplicationMonitorResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteApplicationMonitorResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteApplicationMonitorResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteApplicationMonitorResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteBandwidthPackageRequest : Tea.TeaModel {
    public var bandwidthPackageId: String?

    public var clientToken: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bandwidthPackageId != nil {
            map["BandwidthPackageId"] = self.bandwidthPackageId!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BandwidthPackageId") && dict["BandwidthPackageId"] != nil {
            self.bandwidthPackageId = dict["BandwidthPackageId"] as! String
        }
        if dict.keys.contains("ClientToken") && dict["ClientToken"] != nil {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DeleteBandwidthPackageResponseBody : Tea.TeaModel {
    public var bandwidthPackageId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bandwidthPackageId != nil {
            map["BandwidthPackageId"] = self.bandwidthPackageId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BandwidthPackageId") && dict["BandwidthPackageId"] != nil {
            self.bandwidthPackageId = dict["BandwidthPackageId"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteBandwidthPackageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteBandwidthPackageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteBandwidthPackageResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteBasicAccelerateIpRequest : Tea.TeaModel {
    public var accelerateIpId: String?

    public var clientToken: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accelerateIpId != nil {
            map["AccelerateIpId"] = self.accelerateIpId!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AccelerateIpId") && dict["AccelerateIpId"] != nil {
            self.accelerateIpId = dict["AccelerateIpId"] as! String
        }
        if dict.keys.contains("ClientToken") && dict["ClientToken"] != nil {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DeleteBasicAccelerateIpResponseBody : Tea.TeaModel {
    public var accelerateIpId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accelerateIpId != nil {
            map["AccelerateIpId"] = self.accelerateIpId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AccelerateIpId") && dict["AccelerateIpId"] != nil {
            self.accelerateIpId = dict["AccelerateIpId"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteBasicAccelerateIpResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteBasicAccelerateIpResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteBasicAccelerateIpResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteBasicAccelerateIpEndpointRelationRequest : Tea.TeaModel {
    public var accelerateIpId: String?

    public var acceleratorId: String?

    public var clientToken: String?

    public var endpointId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accelerateIpId != nil {
            map["AccelerateIpId"] = self.accelerateIpId!
        }
        if self.acceleratorId != nil {
            map["AcceleratorId"] = self.acceleratorId!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.endpointId != nil {
            map["EndpointId"] = self.endpointId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AccelerateIpId") && dict["AccelerateIpId"] != nil {
            self.accelerateIpId = dict["AccelerateIpId"] as! String
        }
        if dict.keys.contains("AcceleratorId") && dict["AcceleratorId"] != nil {
            self.acceleratorId = dict["AcceleratorId"] as! String
        }
        if dict.keys.contains("ClientToken") && dict["ClientToken"] != nil {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("EndpointId") && dict["EndpointId"] != nil {
            self.endpointId = dict["EndpointId"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DeleteBasicAccelerateIpEndpointRelationResponseBody : Tea.TeaModel {
    public var accelerateIpId: String?

    public var acceleratorId: String?

    public var endpointId: String?

    public var requestId: String?

    public var state: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accelerateIpId != nil {
            map["AccelerateIpId"] = self.accelerateIpId!
        }
        if self.acceleratorId != nil {
            map["AcceleratorId"] = self.acceleratorId!
        }
        if self.endpointId != nil {
            map["EndpointId"] = self.endpointId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.state != nil {
            map["State"] = self.state!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AccelerateIpId") && dict["AccelerateIpId"] != nil {
            self.accelerateIpId = dict["AccelerateIpId"] as! String
        }
        if dict.keys.contains("AcceleratorId") && dict["AcceleratorId"] != nil {
            self.acceleratorId = dict["AcceleratorId"] as! String
        }
        if dict.keys.contains("EndpointId") && dict["EndpointId"] != nil {
            self.endpointId = dict["EndpointId"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("State") && dict["State"] != nil {
            self.state = dict["State"] as! String
        }
    }
}

public class DeleteBasicAccelerateIpEndpointRelationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteBasicAccelerateIpEndpointRelationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteBasicAccelerateIpEndpointRelationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteBasicAcceleratorRequest : Tea.TeaModel {
    public var acceleratorId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceleratorId != nil {
            map["AcceleratorId"] = self.acceleratorId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceleratorId") && dict["AcceleratorId"] != nil {
            self.acceleratorId = dict["AcceleratorId"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DeleteBasicAcceleratorResponseBody : Tea.TeaModel {
    public var acceleratorId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceleratorId != nil {
            map["AcceleratorId"] = self.acceleratorId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceleratorId") && dict["AcceleratorId"] != nil {
            self.acceleratorId = dict["AcceleratorId"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteBasicAcceleratorResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteBasicAcceleratorResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteBasicAcceleratorResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteBasicEndpointRequest : Tea.TeaModel {
    public var clientToken: String?

    public var endpointGroupId: String?

    public var endpointId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.endpointGroupId != nil {
            map["EndpointGroupId"] = self.endpointGroupId!
        }
        if self.endpointId != nil {
            map["EndpointId"] = self.endpointId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") && dict["ClientToken"] != nil {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("EndpointGroupId") && dict["EndpointGroupId"] != nil {
            self.endpointGroupId = dict["EndpointGroupId"] as! String
        }
        if dict.keys.contains("EndpointId") && dict["EndpointId"] != nil {
            self.endpointId = dict["EndpointId"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DeleteBasicEndpointResponseBody : Tea.TeaModel {
    public var endpointId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endpointId != nil {
            map["EndpointId"] = self.endpointId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndpointId") && dict["EndpointId"] != nil {
            self.endpointId = dict["EndpointId"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteBasicEndpointResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteBasicEndpointResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteBasicEndpointResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteBasicEndpointGroupRequest : Tea.TeaModel {
    public var clientToken: String?

    public var endpointGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.endpointGroupId != nil {
            map["EndpointGroupId"] = self.endpointGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") && dict["ClientToken"] != nil {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("EndpointGroupId") && dict["EndpointGroupId"] != nil {
            self.endpointGroupId = dict["EndpointGroupId"] as! String
        }
    }
}

public class DeleteBasicEndpointGroupResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteBasicEndpointGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteBasicEndpointGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteBasicEndpointGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteBasicIpSetRequest : Tea.TeaModel {
    public var clientToken: String?

    public var ipSetId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ipSetId != nil {
            map["IpSetId"] = self.ipSetId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") && dict["ClientToken"] != nil {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("IpSetId") && dict["IpSetId"] != nil {
            self.ipSetId = dict["IpSetId"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DeleteBasicIpSetResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteBasicIpSetResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteBasicIpSetResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteBasicIpSetResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteCustomRoutingEndpointGroupDestinationsRequest : Tea.TeaModel {
    public var clientToken: String?

    public var destinationIds: [String]?

    public var dryRun: Bool?

    public var endpointGroupId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.destinationIds != nil {
            map["DestinationIds"] = self.destinationIds!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.endpointGroupId != nil {
            map["EndpointGroupId"] = self.endpointGroupId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") && dict["ClientToken"] != nil {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("DestinationIds") && dict["DestinationIds"] != nil {
            self.destinationIds = dict["DestinationIds"] as! [String]
        }
        if dict.keys.contains("DryRun") && dict["DryRun"] != nil {
            self.dryRun = dict["DryRun"] as! Bool
        }
        if dict.keys.contains("EndpointGroupId") && dict["EndpointGroupId"] != nil {
            self.endpointGroupId = dict["EndpointGroupId"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DeleteCustomRoutingEndpointGroupDestinationsResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteCustomRoutingEndpointGroupDestinationsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteCustomRoutingEndpointGroupDestinationsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteCustomRoutingEndpointGroupDestinationsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteCustomRoutingEndpointGroupsRequest : Tea.TeaModel {
    public var acceleratorId: String?

    public var clientToken: String?

    public var dryRun: Bool?

    public var endpointGroupIds: [String]?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceleratorId != nil {
            map["AcceleratorId"] = self.acceleratorId!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.endpointGroupIds != nil {
            map["EndpointGroupIds"] = self.endpointGroupIds!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceleratorId") && dict["AcceleratorId"] != nil {
            self.acceleratorId = dict["AcceleratorId"] as! String
        }
        if dict.keys.contains("ClientToken") && dict["ClientToken"] != nil {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("DryRun") && dict["DryRun"] != nil {
            self.dryRun = dict["DryRun"] as! Bool
        }
        if dict.keys.contains("EndpointGroupIds") && dict["EndpointGroupIds"] != nil {
            self.endpointGroupIds = dict["EndpointGroupIds"] as! [String]
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DeleteCustomRoutingEndpointGroupsResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteCustomRoutingEndpointGroupsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteCustomRoutingEndpointGroupsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteCustomRoutingEndpointGroupsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteCustomRoutingEndpointTrafficPoliciesRequest : Tea.TeaModel {
    public var clientToken: String?

    public var endpointId: String?

    public var policyIds: [String]?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.endpointId != nil {
            map["EndpointId"] = self.endpointId!
        }
        if self.policyIds != nil {
            map["PolicyIds"] = self.policyIds!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") && dict["ClientToken"] != nil {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("EndpointId") && dict["EndpointId"] != nil {
            self.endpointId = dict["EndpointId"] as! String
        }
        if dict.keys.contains("PolicyIds") && dict["PolicyIds"] != nil {
            self.policyIds = dict["PolicyIds"] as! [String]
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DeleteCustomRoutingEndpointTrafficPoliciesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteCustomRoutingEndpointTrafficPoliciesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteCustomRoutingEndpointTrafficPoliciesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteCustomRoutingEndpointTrafficPoliciesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteCustomRoutingEndpointsRequest : Tea.TeaModel {
    public var clientToken: String?

    public var endpointGroupId: String?

    public var endpointIds: [String]?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.endpointGroupId != nil {
            map["EndpointGroupId"] = self.endpointGroupId!
        }
        if self.endpointIds != nil {
            map["EndpointIds"] = self.endpointIds!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") && dict["ClientToken"] != nil {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("EndpointGroupId") && dict["EndpointGroupId"] != nil {
            self.endpointGroupId = dict["EndpointGroupId"] as! String
        }
        if dict.keys.contains("EndpointIds") && dict["EndpointIds"] != nil {
            self.endpointIds = dict["EndpointIds"] as! [String]
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DeleteCustomRoutingEndpointsResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteCustomRoutingEndpointsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteCustomRoutingEndpointsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteCustomRoutingEndpointsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteDomainAcceleratorRelationRequest : Tea.TeaModel {
    public var acceleratorIds: [String]?

    public var domain: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceleratorIds != nil {
            map["AcceleratorIds"] = self.acceleratorIds!
        }
        if self.domain != nil {
            map["Domain"] = self.domain!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceleratorIds") && dict["AcceleratorIds"] != nil {
            self.acceleratorIds = dict["AcceleratorIds"] as! [String]
        }
        if dict.keys.contains("Domain") && dict["Domain"] != nil {
            self.domain = dict["Domain"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DeleteDomainAcceleratorRelationResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteDomainAcceleratorRelationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteDomainAcceleratorRelationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteDomainAcceleratorRelationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteEndpointGroupRequest : Tea.TeaModel {
    public var acceleratorId: String?

    public var clientToken: String?

    public var endpointGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceleratorId != nil {
            map["AcceleratorId"] = self.acceleratorId!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.endpointGroupId != nil {
            map["EndpointGroupId"] = self.endpointGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceleratorId") && dict["AcceleratorId"] != nil {
            self.acceleratorId = dict["AcceleratorId"] as! String
        }
        if dict.keys.contains("ClientToken") && dict["ClientToken"] != nil {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("EndpointGroupId") && dict["EndpointGroupId"] != nil {
            self.endpointGroupId = dict["EndpointGroupId"] as! String
        }
    }
}

public class DeleteEndpointGroupResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteEndpointGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteEndpointGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteEndpointGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteEndpointGroupsRequest : Tea.TeaModel {
    public var clientToken: String?

    public var dryRun: Bool?

    public var endpointGroupIds: [String]?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.endpointGroupIds != nil {
            map["EndpointGroupIds"] = self.endpointGroupIds!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") && dict["ClientToken"] != nil {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("DryRun") && dict["DryRun"] != nil {
            self.dryRun = dict["DryRun"] as! Bool
        }
        if dict.keys.contains("EndpointGroupIds") && dict["EndpointGroupIds"] != nil {
            self.endpointGroupIds = dict["EndpointGroupIds"] as! [String]
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DeleteEndpointGroupsResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteEndpointGroupsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteEndpointGroupsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteEndpointGroupsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteForwardingRulesRequest : Tea.TeaModel {
    public var acceleratorId: String?

    public var clientToken: String?

    public var forwardingRuleIds: [String]?

    public var listenerId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceleratorId != nil {
            map["AcceleratorId"] = self.acceleratorId!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.forwardingRuleIds != nil {
            map["ForwardingRuleIds"] = self.forwardingRuleIds!
        }
        if self.listenerId != nil {
            map["ListenerId"] = self.listenerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceleratorId") && dict["AcceleratorId"] != nil {
            self.acceleratorId = dict["AcceleratorId"] as! String
        }
        if dict.keys.contains("ClientToken") && dict["ClientToken"] != nil {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("ForwardingRuleIds") && dict["ForwardingRuleIds"] != nil {
            self.forwardingRuleIds = dict["ForwardingRuleIds"] as! [String]
        }
        if dict.keys.contains("ListenerId") && dict["ListenerId"] != nil {
            self.listenerId = dict["ListenerId"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DeleteForwardingRulesResponseBody : Tea.TeaModel {
    public class ForwardingRules : Tea.TeaModel {
        public var forwardingRuleId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.forwardingRuleId != nil {
                map["ForwardingRuleId"] = self.forwardingRuleId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ForwardingRuleId") && dict["ForwardingRuleId"] != nil {
                self.forwardingRuleId = dict["ForwardingRuleId"] as! String
            }
        }
    }
    public var forwardingRules: [DeleteForwardingRulesResponseBody.ForwardingRules]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.forwardingRules != nil {
            var tmp : [Any] = []
            for k in self.forwardingRules! {
                tmp.append(k.toMap())
            }
            map["ForwardingRules"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ForwardingRules") && dict["ForwardingRules"] != nil {
            var tmp : [DeleteForwardingRulesResponseBody.ForwardingRules] = []
            for v in dict["ForwardingRules"] as! [Any] {
                var model = DeleteForwardingRulesResponseBody.ForwardingRules()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.forwardingRules = tmp
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteForwardingRulesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteForwardingRulesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteForwardingRulesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteIpSetRequest : Tea.TeaModel {
    public var acceleratorId: String?

    public var clientToken: String?

    public var ipSetId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceleratorId != nil {
            map["AcceleratorId"] = self.acceleratorId!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ipSetId != nil {
            map["IpSetId"] = self.ipSetId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceleratorId") && dict["AcceleratorId"] != nil {
            self.acceleratorId = dict["AcceleratorId"] as! String
        }
        if dict.keys.contains("ClientToken") && dict["ClientToken"] != nil {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("IpSetId") && dict["IpSetId"] != nil {
            self.ipSetId = dict["IpSetId"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DeleteIpSetResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteIpSetResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteIpSetResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteIpSetResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteIpSetsRequest : Tea.TeaModel {
    public var ipSetIds: [String]?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ipSetIds != nil {
            map["IpSetIds"] = self.ipSetIds!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("IpSetIds") && dict["IpSetIds"] != nil {
            self.ipSetIds = dict["IpSetIds"] as! [String]
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DeleteIpSetsResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteIpSetsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteIpSetsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteIpSetsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteListenerRequest : Tea.TeaModel {
    public var acceleratorId: String?

    public var clientToken: String?

    public var listenerId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceleratorId != nil {
            map["AcceleratorId"] = self.acceleratorId!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.listenerId != nil {
            map["ListenerId"] = self.listenerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceleratorId") && dict["AcceleratorId"] != nil {
            self.acceleratorId = dict["AcceleratorId"] as! String
        }
        if dict.keys.contains("ClientToken") && dict["ClientToken"] != nil {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("ListenerId") && dict["ListenerId"] != nil {
            self.listenerId = dict["ListenerId"] as! String
        }
    }
}

public class DeleteListenerResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteListenerResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteListenerResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteListenerResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteSpareIpsRequest : Tea.TeaModel {
    public var acceleratorId: String?

    public var clientToken: String?

    public var dryRun: Bool?

    public var regionId: String?

    public var spareIps: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceleratorId != nil {
            map["AcceleratorId"] = self.acceleratorId!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.spareIps != nil {
            map["SpareIps"] = self.spareIps!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceleratorId") && dict["AcceleratorId"] != nil {
            self.acceleratorId = dict["AcceleratorId"] as! String
        }
        if dict.keys.contains("ClientToken") && dict["ClientToken"] != nil {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("DryRun") && dict["DryRun"] != nil {
            self.dryRun = dict["DryRun"] as! Bool
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("SpareIps") && dict["SpareIps"] != nil {
            self.spareIps = dict["SpareIps"] as! [String]
        }
    }
}

public class DeleteSpareIpsResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteSpareIpsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteSpareIpsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteSpareIpsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeAcceleratorRequest : Tea.TeaModel {
    public var acceleratorId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceleratorId != nil {
            map["AcceleratorId"] = self.acceleratorId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceleratorId") && dict["AcceleratorId"] != nil {
            self.acceleratorId = dict["AcceleratorId"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DescribeAcceleratorResponseBody : Tea.TeaModel {
    public class BasicBandwidthPackage : Tea.TeaModel {
        public var bandwidth: Int32?

        public var bandwidthType: String?

        public var instanceId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.bandwidth != nil {
                map["Bandwidth"] = self.bandwidth!
            }
            if self.bandwidthType != nil {
                map["BandwidthType"] = self.bandwidthType!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Bandwidth") && dict["Bandwidth"] != nil {
                self.bandwidth = dict["Bandwidth"] as! Int32
            }
            if dict.keys.contains("BandwidthType") && dict["BandwidthType"] != nil {
                self.bandwidthType = dict["BandwidthType"] as! String
            }
            if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                self.instanceId = dict["InstanceId"] as! String
            }
        }
    }
    public class CrossDomainBandwidthPackage : Tea.TeaModel {
        public var bandwidth: Int32?

        public var instanceId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.bandwidth != nil {
                map["Bandwidth"] = self.bandwidth!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Bandwidth") && dict["Bandwidth"] != nil {
                self.bandwidth = dict["Bandwidth"] as! Int32
            }
            if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                self.instanceId = dict["InstanceId"] as! String
            }
        }
    }
    public class IpSetConfig : Tea.TeaModel {
        public var accessMode: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accessMode != nil {
                map["AccessMode"] = self.accessMode!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AccessMode") && dict["AccessMode"] != nil {
                self.accessMode = dict["AccessMode"] as! String
            }
        }
    }
    public class ServiceManagedInfos : Tea.TeaModel {
        public var action: String?

        public var childType: String?

        public var isManaged: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.action != nil {
                map["Action"] = self.action!
            }
            if self.childType != nil {
                map["ChildType"] = self.childType!
            }
            if self.isManaged != nil {
                map["IsManaged"] = self.isManaged!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Action") && dict["Action"] != nil {
                self.action = dict["Action"] as! String
            }
            if dict.keys.contains("ChildType") && dict["ChildType"] != nil {
                self.childType = dict["ChildType"] as! String
            }
            if dict.keys.contains("IsManaged") && dict["IsManaged"] != nil {
                self.isManaged = dict["IsManaged"] as! Bool
            }
        }
    }
    public class Tags : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") && dict["Key"] != nil {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") && dict["Value"] != nil {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var acceleratorId: String?

    public var bandwidthBillingType: String?

    public var basicBandwidthPackage: DescribeAcceleratorResponseBody.BasicBandwidthPackage?

    public var cenId: String?

    public var createTime: Int64?

    public var crossBorderMode: String?

    public var crossBorderStatus: Bool?

    public var crossDomainBandwidthPackage: DescribeAcceleratorResponseBody.CrossDomainBandwidthPackage?

    public var crossPrivateState: String?

    public var ddosId: String?

    public var description_: String?

    public var dnsName: String?

    public var expiredTime: Int64?

    public var instanceChargeType: String?

    public var ipSetConfig: DescribeAcceleratorResponseBody.IpSetConfig?

    public var name: String?

    public var regionId: String?

    public var requestId: String?

    public var resourceGroupId: String?

    public var secondDnsName: String?

    public var serviceId: String?

    public var serviceManaged: Bool?

    public var serviceManagedInfos: [DescribeAcceleratorResponseBody.ServiceManagedInfos]?

    public var spec: String?

    public var state: String?

    public var tags: [DescribeAcceleratorResponseBody.Tags]?

    public var upgradableStatus: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.basicBandwidthPackage?.validate()
        try self.crossDomainBandwidthPackage?.validate()
        try self.ipSetConfig?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceleratorId != nil {
            map["AcceleratorId"] = self.acceleratorId!
        }
        if self.bandwidthBillingType != nil {
            map["BandwidthBillingType"] = self.bandwidthBillingType!
        }
        if self.basicBandwidthPackage != nil {
            map["BasicBandwidthPackage"] = self.basicBandwidthPackage?.toMap()
        }
        if self.cenId != nil {
            map["CenId"] = self.cenId!
        }
        if self.createTime != nil {
            map["CreateTime"] = self.createTime!
        }
        if self.crossBorderMode != nil {
            map["CrossBorderMode"] = self.crossBorderMode!
        }
        if self.crossBorderStatus != nil {
            map["CrossBorderStatus"] = self.crossBorderStatus!
        }
        if self.crossDomainBandwidthPackage != nil {
            map["CrossDomainBandwidthPackage"] = self.crossDomainBandwidthPackage?.toMap()
        }
        if self.crossPrivateState != nil {
            map["CrossPrivateState"] = self.crossPrivateState!
        }
        if self.ddosId != nil {
            map["DdosId"] = self.ddosId!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.dnsName != nil {
            map["DnsName"] = self.dnsName!
        }
        if self.expiredTime != nil {
            map["ExpiredTime"] = self.expiredTime!
        }
        if self.instanceChargeType != nil {
            map["InstanceChargeType"] = self.instanceChargeType!
        }
        if self.ipSetConfig != nil {
            map["IpSetConfig"] = self.ipSetConfig?.toMap()
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.secondDnsName != nil {
            map["SecondDnsName"] = self.secondDnsName!
        }
        if self.serviceId != nil {
            map["ServiceId"] = self.serviceId!
        }
        if self.serviceManaged != nil {
            map["ServiceManaged"] = self.serviceManaged!
        }
        if self.serviceManagedInfos != nil {
            var tmp : [Any] = []
            for k in self.serviceManagedInfos! {
                tmp.append(k.toMap())
            }
            map["ServiceManagedInfos"] = tmp
        }
        if self.spec != nil {
            map["Spec"] = self.spec!
        }
        if self.state != nil {
            map["State"] = self.state!
        }
        if self.tags != nil {
            var tmp : [Any] = []
            for k in self.tags! {
                tmp.append(k.toMap())
            }
            map["Tags"] = tmp
        }
        if self.upgradableStatus != nil {
            map["UpgradableStatus"] = self.upgradableStatus!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceleratorId") && dict["AcceleratorId"] != nil {
            self.acceleratorId = dict["AcceleratorId"] as! String
        }
        if dict.keys.contains("BandwidthBillingType") && dict["BandwidthBillingType"] != nil {
            self.bandwidthBillingType = dict["BandwidthBillingType"] as! String
        }
        if dict.keys.contains("BasicBandwidthPackage") && dict["BasicBandwidthPackage"] != nil {
            var model = DescribeAcceleratorResponseBody.BasicBandwidthPackage()
            model.fromMap(dict["BasicBandwidthPackage"] as! [String: Any])
            self.basicBandwidthPackage = model
        }
        if dict.keys.contains("CenId") && dict["CenId"] != nil {
            self.cenId = dict["CenId"] as! String
        }
        if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
            self.createTime = dict["CreateTime"] as! Int64
        }
        if dict.keys.contains("CrossBorderMode") && dict["CrossBorderMode"] != nil {
            self.crossBorderMode = dict["CrossBorderMode"] as! String
        }
        if dict.keys.contains("CrossBorderStatus") && dict["CrossBorderStatus"] != nil {
            self.crossBorderStatus = dict["CrossBorderStatus"] as! Bool
        }
        if dict.keys.contains("CrossDomainBandwidthPackage") && dict["CrossDomainBandwidthPackage"] != nil {
            var model = DescribeAcceleratorResponseBody.CrossDomainBandwidthPackage()
            model.fromMap(dict["CrossDomainBandwidthPackage"] as! [String: Any])
            self.crossDomainBandwidthPackage = model
        }
        if dict.keys.contains("CrossPrivateState") && dict["CrossPrivateState"] != nil {
            self.crossPrivateState = dict["CrossPrivateState"] as! String
        }
        if dict.keys.contains("DdosId") && dict["DdosId"] != nil {
            self.ddosId = dict["DdosId"] as! String
        }
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("DnsName") && dict["DnsName"] != nil {
            self.dnsName = dict["DnsName"] as! String
        }
        if dict.keys.contains("ExpiredTime") && dict["ExpiredTime"] != nil {
            self.expiredTime = dict["ExpiredTime"] as! Int64
        }
        if dict.keys.contains("InstanceChargeType") && dict["InstanceChargeType"] != nil {
            self.instanceChargeType = dict["InstanceChargeType"] as! String
        }
        if dict.keys.contains("IpSetConfig") && dict["IpSetConfig"] != nil {
            var model = DescribeAcceleratorResponseBody.IpSetConfig()
            model.fromMap(dict["IpSetConfig"] as! [String: Any])
            self.ipSetConfig = model
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") && dict["ResourceGroupId"] != nil {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("SecondDnsName") && dict["SecondDnsName"] != nil {
            self.secondDnsName = dict["SecondDnsName"] as! String
        }
        if dict.keys.contains("ServiceId") && dict["ServiceId"] != nil {
            self.serviceId = dict["ServiceId"] as! String
        }
        if dict.keys.contains("ServiceManaged") && dict["ServiceManaged"] != nil {
            self.serviceManaged = dict["ServiceManaged"] as! Bool
        }
        if dict.keys.contains("ServiceManagedInfos") && dict["ServiceManagedInfos"] != nil {
            var tmp : [DescribeAcceleratorResponseBody.ServiceManagedInfos] = []
            for v in dict["ServiceManagedInfos"] as! [Any] {
                var model = DescribeAcceleratorResponseBody.ServiceManagedInfos()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.serviceManagedInfos = tmp
        }
        if dict.keys.contains("Spec") && dict["Spec"] != nil {
            self.spec = dict["Spec"] as! String
        }
        if dict.keys.contains("State") && dict["State"] != nil {
            self.state = dict["State"] as! String
        }
        if dict.keys.contains("Tags") && dict["Tags"] != nil {
            var tmp : [DescribeAcceleratorResponseBody.Tags] = []
            for v in dict["Tags"] as! [Any] {
                var model = DescribeAcceleratorResponseBody.Tags()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tags = tmp
        }
        if dict.keys.contains("UpgradableStatus") && dict["UpgradableStatus"] != nil {
            self.upgradableStatus = dict["UpgradableStatus"] as! String
        }
    }
}

public class DescribeAcceleratorResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAcceleratorResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeAcceleratorResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeAcceleratorAutoRenewAttributeRequest : Tea.TeaModel {
    public var acceleratorId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceleratorId != nil {
            map["AcceleratorId"] = self.acceleratorId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceleratorId") && dict["AcceleratorId"] != nil {
            self.acceleratorId = dict["AcceleratorId"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DescribeAcceleratorAutoRenewAttributeResponseBody : Tea.TeaModel {
    public var acceleratorId: String?

    public var autoRenew: Bool?

    public var autoRenewDuration: Int32?

    public var renewalStatus: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceleratorId != nil {
            map["AcceleratorId"] = self.acceleratorId!
        }
        if self.autoRenew != nil {
            map["AutoRenew"] = self.autoRenew!
        }
        if self.autoRenewDuration != nil {
            map["AutoRenewDuration"] = self.autoRenewDuration!
        }
        if self.renewalStatus != nil {
            map["RenewalStatus"] = self.renewalStatus!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceleratorId") && dict["AcceleratorId"] != nil {
            self.acceleratorId = dict["AcceleratorId"] as! String
        }
        if dict.keys.contains("AutoRenew") && dict["AutoRenew"] != nil {
            self.autoRenew = dict["AutoRenew"] as! Bool
        }
        if dict.keys.contains("AutoRenewDuration") && dict["AutoRenewDuration"] != nil {
            self.autoRenewDuration = dict["AutoRenewDuration"] as! Int32
        }
        if dict.keys.contains("RenewalStatus") && dict["RenewalStatus"] != nil {
            self.renewalStatus = dict["RenewalStatus"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeAcceleratorAutoRenewAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAcceleratorAutoRenewAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeAcceleratorAutoRenewAttributeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeAcceleratorServiceStatusRequest : Tea.TeaModel {
    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DescribeAcceleratorServiceStatusResponseBody : Tea.TeaModel {
    public var code: String?

    public var message: String?

    public var requestId: String?

    public var status: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Status") && dict["Status"] != nil {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! String
        }
    }
}

public class DescribeAcceleratorServiceStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAcceleratorServiceStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeAcceleratorServiceStatusResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeApplicationMonitorRequest : Tea.TeaModel {
    public var clientToken: String?

    public var regionId: String?

    public var taskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") && dict["ClientToken"] != nil {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("TaskId") && dict["TaskId"] != nil {
            self.taskId = dict["TaskId"] as! String
        }
    }
}

public class DescribeApplicationMonitorResponseBody : Tea.TeaModel {
    public class IspCityList : Tea.TeaModel {
        public var city: String?

        public var cityName: String?

        public var isp: String?

        public var ispName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.city != nil {
                map["City"] = self.city!
            }
            if self.cityName != nil {
                map["CityName"] = self.cityName!
            }
            if self.isp != nil {
                map["Isp"] = self.isp!
            }
            if self.ispName != nil {
                map["IspName"] = self.ispName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("City") && dict["City"] != nil {
                self.city = dict["City"] as! String
            }
            if dict.keys.contains("CityName") && dict["CityName"] != nil {
                self.cityName = dict["CityName"] as! String
            }
            if dict.keys.contains("Isp") && dict["Isp"] != nil {
                self.isp = dict["Isp"] as! String
            }
            if dict.keys.contains("IspName") && dict["IspName"] != nil {
                self.ispName = dict["IspName"] as! String
            }
        }
    }
    public var acceleratorId: String?

    public var address: String?

    public var detectEnable: Bool?

    public var detectThreshold: Int32?

    public var detectTimes: Int32?

    public var ispCityList: [DescribeApplicationMonitorResponseBody.IspCityList]?

    public var listenerId: String?

    public var optionsJson: String?

    public var regionId: String?

    public var requestId: String?

    public var silenceTime: Int32?

    public var state: String?

    public var taskId: String?

    public var taskName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceleratorId != nil {
            map["AcceleratorId"] = self.acceleratorId!
        }
        if self.address != nil {
            map["Address"] = self.address!
        }
        if self.detectEnable != nil {
            map["DetectEnable"] = self.detectEnable!
        }
        if self.detectThreshold != nil {
            map["DetectThreshold"] = self.detectThreshold!
        }
        if self.detectTimes != nil {
            map["DetectTimes"] = self.detectTimes!
        }
        if self.ispCityList != nil {
            var tmp : [Any] = []
            for k in self.ispCityList! {
                tmp.append(k.toMap())
            }
            map["IspCityList"] = tmp
        }
        if self.listenerId != nil {
            map["ListenerId"] = self.listenerId!
        }
        if self.optionsJson != nil {
            map["OptionsJson"] = self.optionsJson!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.silenceTime != nil {
            map["SilenceTime"] = self.silenceTime!
        }
        if self.state != nil {
            map["State"] = self.state!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        if self.taskName != nil {
            map["TaskName"] = self.taskName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceleratorId") && dict["AcceleratorId"] != nil {
            self.acceleratorId = dict["AcceleratorId"] as! String
        }
        if dict.keys.contains("Address") && dict["Address"] != nil {
            self.address = dict["Address"] as! String
        }
        if dict.keys.contains("DetectEnable") && dict["DetectEnable"] != nil {
            self.detectEnable = dict["DetectEnable"] as! Bool
        }
        if dict.keys.contains("DetectThreshold") && dict["DetectThreshold"] != nil {
            self.detectThreshold = dict["DetectThreshold"] as! Int32
        }
        if dict.keys.contains("DetectTimes") && dict["DetectTimes"] != nil {
            self.detectTimes = dict["DetectTimes"] as! Int32
        }
        if dict.keys.contains("IspCityList") && dict["IspCityList"] != nil {
            var tmp : [DescribeApplicationMonitorResponseBody.IspCityList] = []
            for v in dict["IspCityList"] as! [Any] {
                var model = DescribeApplicationMonitorResponseBody.IspCityList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.ispCityList = tmp
        }
        if dict.keys.contains("ListenerId") && dict["ListenerId"] != nil {
            self.listenerId = dict["ListenerId"] as! String
        }
        if dict.keys.contains("OptionsJson") && dict["OptionsJson"] != nil {
            self.optionsJson = dict["OptionsJson"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SilenceTime") && dict["SilenceTime"] != nil {
            self.silenceTime = dict["SilenceTime"] as! Int32
        }
        if dict.keys.contains("State") && dict["State"] != nil {
            self.state = dict["State"] as! String
        }
        if dict.keys.contains("TaskId") && dict["TaskId"] != nil {
            self.taskId = dict["TaskId"] as! String
        }
        if dict.keys.contains("TaskName") && dict["TaskName"] != nil {
            self.taskName = dict["TaskName"] as! String
        }
    }
}

public class DescribeApplicationMonitorResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeApplicationMonitorResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeApplicationMonitorResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeBandwidthPackageRequest : Tea.TeaModel {
    public var bandwidthPackageId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bandwidthPackageId != nil {
            map["BandwidthPackageId"] = self.bandwidthPackageId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BandwidthPackageId") && dict["BandwidthPackageId"] != nil {
            self.bandwidthPackageId = dict["BandwidthPackageId"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DescribeBandwidthPackageResponseBody : Tea.TeaModel {
    public class Tags : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") && dict["Key"] != nil {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") && dict["Value"] != nil {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var accelerators: [String]?

    public var bandwidth: Int32?

    public var bandwidthPackageId: String?

    public var bandwidthType: String?

    public var billingType: String?

    public var cbnGeographicRegionIdA: String?

    public var cbnGeographicRegionIdB: String?

    public var chargeType: String?

    public var createTime: String?

    public var description_: String?

    public var expiredTime: String?

    public var name: String?

    public var ratio: Int32?

    public var regionId: String?

    public var requestId: String?

    public var resourceGroupId: String?

    public var state: String?

    public var tags: [DescribeBandwidthPackageResponseBody.Tags]?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accelerators != nil {
            map["Accelerators"] = self.accelerators!
        }
        if self.bandwidth != nil {
            map["Bandwidth"] = self.bandwidth!
        }
        if self.bandwidthPackageId != nil {
            map["BandwidthPackageId"] = self.bandwidthPackageId!
        }
        if self.bandwidthType != nil {
            map["BandwidthType"] = self.bandwidthType!
        }
        if self.billingType != nil {
            map["BillingType"] = self.billingType!
        }
        if self.cbnGeographicRegionIdA != nil {
            map["CbnGeographicRegionIdA"] = self.cbnGeographicRegionIdA!
        }
        if self.cbnGeographicRegionIdB != nil {
            map["CbnGeographicRegionIdB"] = self.cbnGeographicRegionIdB!
        }
        if self.chargeType != nil {
            map["ChargeType"] = self.chargeType!
        }
        if self.createTime != nil {
            map["CreateTime"] = self.createTime!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.expiredTime != nil {
            map["ExpiredTime"] = self.expiredTime!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.ratio != nil {
            map["Ratio"] = self.ratio!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.state != nil {
            map["State"] = self.state!
        }
        if self.tags != nil {
            var tmp : [Any] = []
            for k in self.tags! {
                tmp.append(k.toMap())
            }
            map["Tags"] = tmp
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Accelerators") && dict["Accelerators"] != nil {
            self.accelerators = dict["Accelerators"] as! [String]
        }
        if dict.keys.contains("Bandwidth") && dict["Bandwidth"] != nil {
            self.bandwidth = dict["Bandwidth"] as! Int32
        }
        if dict.keys.contains("BandwidthPackageId") && dict["BandwidthPackageId"] != nil {
            self.bandwidthPackageId = dict["BandwidthPackageId"] as! String
        }
        if dict.keys.contains("BandwidthType") && dict["BandwidthType"] != nil {
            self.bandwidthType = dict["BandwidthType"] as! String
        }
        if dict.keys.contains("BillingType") && dict["BillingType"] != nil {
            self.billingType = dict["BillingType"] as! String
        }
        if dict.keys.contains("CbnGeographicRegionIdA") && dict["CbnGeographicRegionIdA"] != nil {
            self.cbnGeographicRegionIdA = dict["CbnGeographicRegionIdA"] as! String
        }
        if dict.keys.contains("CbnGeographicRegionIdB") && dict["CbnGeographicRegionIdB"] != nil {
            self.cbnGeographicRegionIdB = dict["CbnGeographicRegionIdB"] as! String
        }
        if dict.keys.contains("ChargeType") && dict["ChargeType"] != nil {
            self.chargeType = dict["ChargeType"] as! String
        }
        if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
            self.createTime = dict["CreateTime"] as! String
        }
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("ExpiredTime") && dict["ExpiredTime"] != nil {
            self.expiredTime = dict["ExpiredTime"] as! String
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Ratio") && dict["Ratio"] != nil {
            self.ratio = dict["Ratio"] as! Int32
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") && dict["ResourceGroupId"] != nil {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("State") && dict["State"] != nil {
            self.state = dict["State"] as! String
        }
        if dict.keys.contains("Tags") && dict["Tags"] != nil {
            var tmp : [DescribeBandwidthPackageResponseBody.Tags] = []
            for v in dict["Tags"] as! [Any] {
                var model = DescribeBandwidthPackageResponseBody.Tags()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tags = tmp
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! String
        }
    }
}

public class DescribeBandwidthPackageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeBandwidthPackageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeBandwidthPackageResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeBandwidthPackageAutoRenewAttributeRequest : Tea.TeaModel {
    public var instanceId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DescribeBandwidthPackageAutoRenewAttributeResponseBody : Tea.TeaModel {
    public var autoRenew: Bool?

    public var autoRenewDuration: Int32?

    public var instanceId: String?

    public var renewalStatus: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.autoRenew != nil {
            map["AutoRenew"] = self.autoRenew!
        }
        if self.autoRenewDuration != nil {
            map["AutoRenewDuration"] = self.autoRenewDuration!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.renewalStatus != nil {
            map["RenewalStatus"] = self.renewalStatus!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AutoRenew") && dict["AutoRenew"] != nil {
            self.autoRenew = dict["AutoRenew"] as! Bool
        }
        if dict.keys.contains("AutoRenewDuration") && dict["AutoRenewDuration"] != nil {
            self.autoRenewDuration = dict["AutoRenewDuration"] as! Int32
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("RenewalStatus") && dict["RenewalStatus"] != nil {
            self.renewalStatus = dict["RenewalStatus"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeBandwidthPackageAutoRenewAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeBandwidthPackageAutoRenewAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeBandwidthPackageAutoRenewAttributeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeCommodityRequest : Tea.TeaModel {
    public var commodityCode: String?

    public var orderType: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commodityCode != nil {
            map["CommodityCode"] = self.commodityCode!
        }
        if self.orderType != nil {
            map["OrderType"] = self.orderType!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CommodityCode") && dict["CommodityCode"] != nil {
            self.commodityCode = dict["CommodityCode"] as! String
        }
        if dict.keys.contains("OrderType") && dict["OrderType"] != nil {
            self.orderType = dict["OrderType"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DescribeCommodityResponseBody : Tea.TeaModel {
    public class Components : Tea.TeaModel {
        public class Properties : Tea.TeaModel {
            public class PropertyValueList : Tea.TeaModel {
                public var orderIndex: Int64?

                public var text: String?

                public var tips: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.orderIndex != nil {
                        map["OrderIndex"] = self.orderIndex!
                    }
                    if self.text != nil {
                        map["Text"] = self.text!
                    }
                    if self.tips != nil {
                        map["Tips"] = self.tips!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("OrderIndex") && dict["OrderIndex"] != nil {
                        self.orderIndex = dict["OrderIndex"] as! Int64
                    }
                    if dict.keys.contains("Text") && dict["Text"] != nil {
                        self.text = dict["Text"] as! String
                    }
                    if dict.keys.contains("Tips") && dict["Tips"] != nil {
                        self.tips = dict["Tips"] as! String
                    }
                    if dict.keys.contains("Value") && dict["Value"] != nil {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public var code: String?

            public var name: String?

            public var propertyValueList: [DescribeCommodityResponseBody.Components.Properties.PropertyValueList]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.code != nil {
                    map["Code"] = self.code!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.propertyValueList != nil {
                    var tmp : [Any] = []
                    for k in self.propertyValueList! {
                        tmp.append(k.toMap())
                    }
                    map["PropertyValueList"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Code") && dict["Code"] != nil {
                    self.code = dict["Code"] as! String
                }
                if dict.keys.contains("Name") && dict["Name"] != nil {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("PropertyValueList") && dict["PropertyValueList"] != nil {
                    var tmp : [DescribeCommodityResponseBody.Components.Properties.PropertyValueList] = []
                    for v in dict["PropertyValueList"] as! [Any] {
                        var model = DescribeCommodityResponseBody.Components.Properties.PropertyValueList()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.propertyValueList = tmp
                }
            }
        }
        public var componentCode: String?

        public var componentName: String?

        public var properties: [DescribeCommodityResponseBody.Components.Properties]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.componentCode != nil {
                map["ComponentCode"] = self.componentCode!
            }
            if self.componentName != nil {
                map["ComponentName"] = self.componentName!
            }
            if self.properties != nil {
                var tmp : [Any] = []
                for k in self.properties! {
                    tmp.append(k.toMap())
                }
                map["Properties"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ComponentCode") && dict["ComponentCode"] != nil {
                self.componentCode = dict["ComponentCode"] as! String
            }
            if dict.keys.contains("ComponentName") && dict["ComponentName"] != nil {
                self.componentName = dict["ComponentName"] as! String
            }
            if dict.keys.contains("Properties") && dict["Properties"] != nil {
                var tmp : [DescribeCommodityResponseBody.Components.Properties] = []
                for v in dict["Properties"] as! [Any] {
                    var model = DescribeCommodityResponseBody.Components.Properties()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.properties = tmp
            }
        }
    }
    public var commodityCode: String?

    public var commodityName: String?

    public var components: [DescribeCommodityResponseBody.Components]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commodityCode != nil {
            map["CommodityCode"] = self.commodityCode!
        }
        if self.commodityName != nil {
            map["CommodityName"] = self.commodityName!
        }
        if self.components != nil {
            var tmp : [Any] = []
            for k in self.components! {
                tmp.append(k.toMap())
            }
            map["Components"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CommodityCode") && dict["CommodityCode"] != nil {
            self.commodityCode = dict["CommodityCode"] as! String
        }
        if dict.keys.contains("CommodityName") && dict["CommodityName"] != nil {
            self.commodityName = dict["CommodityName"] as! String
        }
        if dict.keys.contains("Components") && dict["Components"] != nil {
            var tmp : [DescribeCommodityResponseBody.Components] = []
            for v in dict["Components"] as! [Any] {
                var model = DescribeCommodityResponseBody.Components()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.components = tmp
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeCommodityResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeCommodityResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeCommodityResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeCommodityPriceRequest : Tea.TeaModel {
    public class Orders : Tea.TeaModel {
        public class Components : Tea.TeaModel {
            public class Properties : Tea.TeaModel {
                public var code: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.code != nil {
                        map["Code"] = self.code!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Code") && dict["Code"] != nil {
                        self.code = dict["Code"] as! String
                    }
                    if dict.keys.contains("Value") && dict["Value"] != nil {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public var componentCode: String?

            public var properties: [DescribeCommodityPriceRequest.Orders.Components.Properties]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.componentCode != nil {
                    map["ComponentCode"] = self.componentCode!
                }
                if self.properties != nil {
                    var tmp : [Any] = []
                    for k in self.properties! {
                        tmp.append(k.toMap())
                    }
                    map["Properties"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ComponentCode") && dict["ComponentCode"] != nil {
                    self.componentCode = dict["ComponentCode"] as! String
                }
                if dict.keys.contains("Properties") && dict["Properties"] != nil {
                    var tmp : [DescribeCommodityPriceRequest.Orders.Components.Properties] = []
                    for v in dict["Properties"] as! [Any] {
                        var model = DescribeCommodityPriceRequest.Orders.Components.Properties()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.properties = tmp
                }
            }
        }
        public var chargeType: String?

        public var commodityCode: String?

        public var components: [DescribeCommodityPriceRequest.Orders.Components]?

        public var duration: Int64?

        public var orderType: String?

        public var pricingCycle: String?

        public var quantity: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.chargeType != nil {
                map["ChargeType"] = self.chargeType!
            }
            if self.commodityCode != nil {
                map["CommodityCode"] = self.commodityCode!
            }
            if self.components != nil {
                var tmp : [Any] = []
                for k in self.components! {
                    tmp.append(k.toMap())
                }
                map["Components"] = tmp
            }
            if self.duration != nil {
                map["Duration"] = self.duration!
            }
            if self.orderType != nil {
                map["OrderType"] = self.orderType!
            }
            if self.pricingCycle != nil {
                map["PricingCycle"] = self.pricingCycle!
            }
            if self.quantity != nil {
                map["Quantity"] = self.quantity!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ChargeType") && dict["ChargeType"] != nil {
                self.chargeType = dict["ChargeType"] as! String
            }
            if dict.keys.contains("CommodityCode") && dict["CommodityCode"] != nil {
                self.commodityCode = dict["CommodityCode"] as! String
            }
            if dict.keys.contains("Components") && dict["Components"] != nil {
                var tmp : [DescribeCommodityPriceRequest.Orders.Components] = []
                for v in dict["Components"] as! [Any] {
                    var model = DescribeCommodityPriceRequest.Orders.Components()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.components = tmp
            }
            if dict.keys.contains("Duration") && dict["Duration"] != nil {
                self.duration = dict["Duration"] as! Int64
            }
            if dict.keys.contains("OrderType") && dict["OrderType"] != nil {
                self.orderType = dict["OrderType"] as! String
            }
            if dict.keys.contains("PricingCycle") && dict["PricingCycle"] != nil {
                self.pricingCycle = dict["PricingCycle"] as! String
            }
            if dict.keys.contains("Quantity") && dict["Quantity"] != nil {
                self.quantity = dict["Quantity"] as! Int64
            }
        }
    }
    public var orders: [DescribeCommodityPriceRequest.Orders]?

    public var promotionOptionNo: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.orders != nil {
            var tmp : [Any] = []
            for k in self.orders! {
                tmp.append(k.toMap())
            }
            map["Orders"] = tmp
        }
        if self.promotionOptionNo != nil {
            map["PromotionOptionNo"] = self.promotionOptionNo!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Orders") && dict["Orders"] != nil {
            var tmp : [DescribeCommodityPriceRequest.Orders] = []
            for v in dict["Orders"] as! [Any] {
                var model = DescribeCommodityPriceRequest.Orders()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.orders = tmp
        }
        if dict.keys.contains("PromotionOptionNo") && dict["PromotionOptionNo"] != nil {
            self.promotionOptionNo = dict["PromotionOptionNo"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DescribeCommodityPriceResponseBody : Tea.TeaModel {
    public class OrderDetails : Tea.TeaModel {
        public class ModuleDetails : Tea.TeaModel {
            public var discountPrice: Double?

            public var moduleCode: String?

            public var moduleName: String?

            public var originalPrice: Double?

            public var tradePrice: Double?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.discountPrice != nil {
                    map["DiscountPrice"] = self.discountPrice!
                }
                if self.moduleCode != nil {
                    map["ModuleCode"] = self.moduleCode!
                }
                if self.moduleName != nil {
                    map["ModuleName"] = self.moduleName!
                }
                if self.originalPrice != nil {
                    map["OriginalPrice"] = self.originalPrice!
                }
                if self.tradePrice != nil {
                    map["TradePrice"] = self.tradePrice!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DiscountPrice") && dict["DiscountPrice"] != nil {
                    self.discountPrice = dict["DiscountPrice"] as! Double
                }
                if dict.keys.contains("ModuleCode") && dict["ModuleCode"] != nil {
                    self.moduleCode = dict["ModuleCode"] as! String
                }
                if dict.keys.contains("ModuleName") && dict["ModuleName"] != nil {
                    self.moduleName = dict["ModuleName"] as! String
                }
                if dict.keys.contains("OriginalPrice") && dict["OriginalPrice"] != nil {
                    self.originalPrice = dict["OriginalPrice"] as! Double
                }
                if dict.keys.contains("TradePrice") && dict["TradePrice"] != nil {
                    self.tradePrice = dict["TradePrice"] as! Double
                }
            }
        }
        public class PromDetails : Tea.TeaModel {
            public var finalPromFee: Double?

            public var optionCode: String?

            public var promType: String?

            public var promotionId: String?

            public var promotionName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.finalPromFee != nil {
                    map["FinalPromFee"] = self.finalPromFee!
                }
                if self.optionCode != nil {
                    map["OptionCode"] = self.optionCode!
                }
                if self.promType != nil {
                    map["PromType"] = self.promType!
                }
                if self.promotionId != nil {
                    map["PromotionId"] = self.promotionId!
                }
                if self.promotionName != nil {
                    map["PromotionName"] = self.promotionName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("FinalPromFee") && dict["FinalPromFee"] != nil {
                    self.finalPromFee = dict["FinalPromFee"] as! Double
                }
                if dict.keys.contains("OptionCode") && dict["OptionCode"] != nil {
                    self.optionCode = dict["OptionCode"] as! String
                }
                if dict.keys.contains("PromType") && dict["PromType"] != nil {
                    self.promType = dict["PromType"] as! String
                }
                if dict.keys.contains("PromotionId") && dict["PromotionId"] != nil {
                    self.promotionId = dict["PromotionId"] as! String
                }
                if dict.keys.contains("PromotionName") && dict["PromotionName"] != nil {
                    self.promotionName = dict["PromotionName"] as! String
                }
            }
        }
        public var commodityCode: String?

        public var commodityName: String?

        public var discountPrice: Double?

        public var moduleDetails: [DescribeCommodityPriceResponseBody.OrderDetails.ModuleDetails]?

        public var originalPrice: Double?

        public var promDetails: [DescribeCommodityPriceResponseBody.OrderDetails.PromDetails]?

        public var quantity: Int64?

        public var ruleIds: [Int64]?

        public var tradePrice: Double?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.commodityCode != nil {
                map["CommodityCode"] = self.commodityCode!
            }
            if self.commodityName != nil {
                map["CommodityName"] = self.commodityName!
            }
            if self.discountPrice != nil {
                map["DiscountPrice"] = self.discountPrice!
            }
            if self.moduleDetails != nil {
                var tmp : [Any] = []
                for k in self.moduleDetails! {
                    tmp.append(k.toMap())
                }
                map["ModuleDetails"] = tmp
            }
            if self.originalPrice != nil {
                map["OriginalPrice"] = self.originalPrice!
            }
            if self.promDetails != nil {
                var tmp : [Any] = []
                for k in self.promDetails! {
                    tmp.append(k.toMap())
                }
                map["PromDetails"] = tmp
            }
            if self.quantity != nil {
                map["Quantity"] = self.quantity!
            }
            if self.ruleIds != nil {
                map["RuleIds"] = self.ruleIds!
            }
            if self.tradePrice != nil {
                map["TradePrice"] = self.tradePrice!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CommodityCode") && dict["CommodityCode"] != nil {
                self.commodityCode = dict["CommodityCode"] as! String
            }
            if dict.keys.contains("CommodityName") && dict["CommodityName"] != nil {
                self.commodityName = dict["CommodityName"] as! String
            }
            if dict.keys.contains("DiscountPrice") && dict["DiscountPrice"] != nil {
                self.discountPrice = dict["DiscountPrice"] as! Double
            }
            if dict.keys.contains("ModuleDetails") && dict["ModuleDetails"] != nil {
                var tmp : [DescribeCommodityPriceResponseBody.OrderDetails.ModuleDetails] = []
                for v in dict["ModuleDetails"] as! [Any] {
                    var model = DescribeCommodityPriceResponseBody.OrderDetails.ModuleDetails()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.moduleDetails = tmp
            }
            if dict.keys.contains("OriginalPrice") && dict["OriginalPrice"] != nil {
                self.originalPrice = dict["OriginalPrice"] as! Double
            }
            if dict.keys.contains("PromDetails") && dict["PromDetails"] != nil {
                var tmp : [DescribeCommodityPriceResponseBody.OrderDetails.PromDetails] = []
                for v in dict["PromDetails"] as! [Any] {
                    var model = DescribeCommodityPriceResponseBody.OrderDetails.PromDetails()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.promDetails = tmp
            }
            if dict.keys.contains("Quantity") && dict["Quantity"] != nil {
                self.quantity = dict["Quantity"] as! Int64
            }
            if dict.keys.contains("RuleIds") && dict["RuleIds"] != nil {
                self.ruleIds = dict["RuleIds"] as! [Int64]
            }
            if dict.keys.contains("TradePrice") && dict["TradePrice"] != nil {
                self.tradePrice = dict["TradePrice"] as! Double
            }
        }
    }
    public class Promotions : Tea.TeaModel {
        public var canPromFee: Double?

        public var optionCode: String?

        public var promotionName: String?

        public var promotionOptionNo: String?

        public var selected: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.canPromFee != nil {
                map["CanPromFee"] = self.canPromFee!
            }
            if self.optionCode != nil {
                map["OptionCode"] = self.optionCode!
            }
            if self.promotionName != nil {
                map["PromotionName"] = self.promotionName!
            }
            if self.promotionOptionNo != nil {
                map["PromotionOptionNo"] = self.promotionOptionNo!
            }
            if self.selected != nil {
                map["Selected"] = self.selected!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CanPromFee") && dict["CanPromFee"] != nil {
                self.canPromFee = dict["CanPromFee"] as! Double
            }
            if dict.keys.contains("OptionCode") && dict["OptionCode"] != nil {
                self.optionCode = dict["OptionCode"] as! String
            }
            if dict.keys.contains("PromotionName") && dict["PromotionName"] != nil {
                self.promotionName = dict["PromotionName"] as! String
            }
            if dict.keys.contains("PromotionOptionNo") && dict["PromotionOptionNo"] != nil {
                self.promotionOptionNo = dict["PromotionOptionNo"] as! String
            }
            if dict.keys.contains("Selected") && dict["Selected"] != nil {
                self.selected = dict["Selected"] as! Bool
            }
        }
    }
    public class RuleDetails : Tea.TeaModel {
        public var ruleId: String?

        public var ruleName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ruleId != nil {
                map["RuleId"] = self.ruleId!
            }
            if self.ruleName != nil {
                map["RuleName"] = self.ruleName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("RuleId") && dict["RuleId"] != nil {
                self.ruleId = dict["RuleId"] as! String
            }
            if dict.keys.contains("RuleName") && dict["RuleName"] != nil {
                self.ruleName = dict["RuleName"] as! String
            }
        }
    }
    public var currency: String?

    public var discountPrice: Double?

    public var orderDetails: [DescribeCommodityPriceResponseBody.OrderDetails]?

    public var originalPrice: Double?

    public var promotions: [DescribeCommodityPriceResponseBody.Promotions]?

    public var requestId: String?

    public var ruleDetails: [DescribeCommodityPriceResponseBody.RuleDetails]?

    public var tradePrice: Double?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.currency != nil {
            map["Currency"] = self.currency!
        }
        if self.discountPrice != nil {
            map["DiscountPrice"] = self.discountPrice!
        }
        if self.orderDetails != nil {
            var tmp : [Any] = []
            for k in self.orderDetails! {
                tmp.append(k.toMap())
            }
            map["OrderDetails"] = tmp
        }
        if self.originalPrice != nil {
            map["OriginalPrice"] = self.originalPrice!
        }
        if self.promotions != nil {
            var tmp : [Any] = []
            for k in self.promotions! {
                tmp.append(k.toMap())
            }
            map["Promotions"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.ruleDetails != nil {
            var tmp : [Any] = []
            for k in self.ruleDetails! {
                tmp.append(k.toMap())
            }
            map["RuleDetails"] = tmp
        }
        if self.tradePrice != nil {
            map["TradePrice"] = self.tradePrice!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Currency") && dict["Currency"] != nil {
            self.currency = dict["Currency"] as! String
        }
        if dict.keys.contains("DiscountPrice") && dict["DiscountPrice"] != nil {
            self.discountPrice = dict["DiscountPrice"] as! Double
        }
        if dict.keys.contains("OrderDetails") && dict["OrderDetails"] != nil {
            var tmp : [DescribeCommodityPriceResponseBody.OrderDetails] = []
            for v in dict["OrderDetails"] as! [Any] {
                var model = DescribeCommodityPriceResponseBody.OrderDetails()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.orderDetails = tmp
        }
        if dict.keys.contains("OriginalPrice") && dict["OriginalPrice"] != nil {
            self.originalPrice = dict["OriginalPrice"] as! Double
        }
        if dict.keys.contains("Promotions") && dict["Promotions"] != nil {
            var tmp : [DescribeCommodityPriceResponseBody.Promotions] = []
            for v in dict["Promotions"] as! [Any] {
                var model = DescribeCommodityPriceResponseBody.Promotions()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.promotions = tmp
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("RuleDetails") && dict["RuleDetails"] != nil {
            var tmp : [DescribeCommodityPriceResponseBody.RuleDetails] = []
            for v in dict["RuleDetails"] as! [Any] {
                var model = DescribeCommodityPriceResponseBody.RuleDetails()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.ruleDetails = tmp
        }
        if dict.keys.contains("TradePrice") && dict["TradePrice"] != nil {
            self.tradePrice = dict["TradePrice"] as! Double
        }
    }
}

public class DescribeCommodityPriceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeCommodityPriceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeCommodityPriceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeCustomRoutingEndPointTrafficPolicyRequest : Tea.TeaModel {
    public var endpointId: String?

    public var policyId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endpointId != nil {
            map["EndpointId"] = self.endpointId!
        }
        if self.policyId != nil {
            map["PolicyId"] = self.policyId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndpointId") && dict["EndpointId"] != nil {
            self.endpointId = dict["EndpointId"] as! String
        }
        if dict.keys.contains("PolicyId") && dict["PolicyId"] != nil {
            self.policyId = dict["PolicyId"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DescribeCustomRoutingEndPointTrafficPolicyResponseBody : Tea.TeaModel {
    public class PortRanges : Tea.TeaModel {
        public var fromPort: Int32?

        public var toPort: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.fromPort != nil {
                map["FromPort"] = self.fromPort!
            }
            if self.toPort != nil {
                map["ToPort"] = self.toPort!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("FromPort") && dict["FromPort"] != nil {
                self.fromPort = dict["FromPort"] as! Int32
            }
            if dict.keys.contains("ToPort") && dict["ToPort"] != nil {
                self.toPort = dict["ToPort"] as! Int32
            }
        }
    }
    public class ServiceManagedInfos : Tea.TeaModel {
        public var action: String?

        public var childType: String?

        public var isManaged: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.action != nil {
                map["Action"] = self.action!
            }
            if self.childType != nil {
                map["ChildType"] = self.childType!
            }
            if self.isManaged != nil {
                map["IsManaged"] = self.isManaged!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Action") && dict["Action"] != nil {
                self.action = dict["Action"] as! String
            }
            if dict.keys.contains("ChildType") && dict["ChildType"] != nil {
                self.childType = dict["ChildType"] as! String
            }
            if dict.keys.contains("IsManaged") && dict["IsManaged"] != nil {
                self.isManaged = dict["IsManaged"] as! Bool
            }
        }
    }
    public var acceleratorId: String?

    public var address: String?

    public var endpoint: String?

    public var endpointGroupId: String?

    public var endpointId: String?

    public var listenerId: String?

    public var policyId: String?

    public var portRanges: [DescribeCustomRoutingEndPointTrafficPolicyResponseBody.PortRanges]?

    public var requestId: String?

    public var serviceId: String?

    public var serviceManaged: Bool?

    public var serviceManagedInfos: [DescribeCustomRoutingEndPointTrafficPolicyResponseBody.ServiceManagedInfos]?

    public var state: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceleratorId != nil {
            map["AcceleratorId"] = self.acceleratorId!
        }
        if self.address != nil {
            map["Address"] = self.address!
        }
        if self.endpoint != nil {
            map["Endpoint"] = self.endpoint!
        }
        if self.endpointGroupId != nil {
            map["EndpointGroupId"] = self.endpointGroupId!
        }
        if self.endpointId != nil {
            map["EndpointId"] = self.endpointId!
        }
        if self.listenerId != nil {
            map["ListenerId"] = self.listenerId!
        }
        if self.policyId != nil {
            map["PolicyId"] = self.policyId!
        }
        if self.portRanges != nil {
            var tmp : [Any] = []
            for k in self.portRanges! {
                tmp.append(k.toMap())
            }
            map["PortRanges"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.serviceId != nil {
            map["ServiceId"] = self.serviceId!
        }
        if self.serviceManaged != nil {
            map["ServiceManaged"] = self.serviceManaged!
        }
        if self.serviceManagedInfos != nil {
            var tmp : [Any] = []
            for k in self.serviceManagedInfos! {
                tmp.append(k.toMap())
            }
            map["ServiceManagedInfos"] = tmp
        }
        if self.state != nil {
            map["State"] = self.state!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceleratorId") && dict["AcceleratorId"] != nil {
            self.acceleratorId = dict["AcceleratorId"] as! String
        }
        if dict.keys.contains("Address") && dict["Address"] != nil {
            self.address = dict["Address"] as! String
        }
        if dict.keys.contains("Endpoint") && dict["Endpoint"] != nil {
            self.endpoint = dict["Endpoint"] as! String
        }
        if dict.keys.contains("EndpointGroupId") && dict["EndpointGroupId"] != nil {
            self.endpointGroupId = dict["EndpointGroupId"] as! String
        }
        if dict.keys.contains("EndpointId") && dict["EndpointId"] != nil {
            self.endpointId = dict["EndpointId"] as! String
        }
        if dict.keys.contains("ListenerId") && dict["ListenerId"] != nil {
            self.listenerId = dict["ListenerId"] as! String
        }
        if dict.keys.contains("PolicyId") && dict["PolicyId"] != nil {
            self.policyId = dict["PolicyId"] as! String
        }
        if dict.keys.contains("PortRanges") && dict["PortRanges"] != nil {
            var tmp : [DescribeCustomRoutingEndPointTrafficPolicyResponseBody.PortRanges] = []
            for v in dict["PortRanges"] as! [Any] {
                var model = DescribeCustomRoutingEndPointTrafficPolicyResponseBody.PortRanges()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.portRanges = tmp
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ServiceId") && dict["ServiceId"] != nil {
            self.serviceId = dict["ServiceId"] as! String
        }
        if dict.keys.contains("ServiceManaged") && dict["ServiceManaged"] != nil {
            self.serviceManaged = dict["ServiceManaged"] as! Bool
        }
        if dict.keys.contains("ServiceManagedInfos") && dict["ServiceManagedInfos"] != nil {
            var tmp : [DescribeCustomRoutingEndPointTrafficPolicyResponseBody.ServiceManagedInfos] = []
            for v in dict["ServiceManagedInfos"] as! [Any] {
                var model = DescribeCustomRoutingEndPointTrafficPolicyResponseBody.ServiceManagedInfos()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.serviceManagedInfos = tmp
        }
        if dict.keys.contains("State") && dict["State"] != nil {
            self.state = dict["State"] as! String
        }
    }
}

public class DescribeCustomRoutingEndPointTrafficPolicyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeCustomRoutingEndPointTrafficPolicyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeCustomRoutingEndPointTrafficPolicyResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeCustomRoutingEndpointRequest : Tea.TeaModel {
    public var endpointGroup: String?

    public var endpointId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endpointGroup != nil {
            map["EndpointGroup"] = self.endpointGroup!
        }
        if self.endpointId != nil {
            map["EndpointId"] = self.endpointId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndpointGroup") && dict["EndpointGroup"] != nil {
            self.endpointGroup = dict["EndpointGroup"] as! String
        }
        if dict.keys.contains("EndpointId") && dict["EndpointId"] != nil {
            self.endpointId = dict["EndpointId"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DescribeCustomRoutingEndpointResponseBody : Tea.TeaModel {
    public class ServiceManagedInfos : Tea.TeaModel {
        public var action: String?

        public var childType: String?

        public var isManaged: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.action != nil {
                map["Action"] = self.action!
            }
            if self.childType != nil {
                map["ChildType"] = self.childType!
            }
            if self.isManaged != nil {
                map["IsManaged"] = self.isManaged!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Action") && dict["Action"] != nil {
                self.action = dict["Action"] as! String
            }
            if dict.keys.contains("ChildType") && dict["ChildType"] != nil {
                self.childType = dict["ChildType"] as! String
            }
            if dict.keys.contains("IsManaged") && dict["IsManaged"] != nil {
                self.isManaged = dict["IsManaged"] as! Bool
            }
        }
    }
    public var acceleratorId: String?

    public var endpoint: String?

    public var endpointGroupId: String?

    public var endpointId: String?

    public var listenerId: String?

    public var requestId: String?

    public var serviceId: String?

    public var serviceManaged: Bool?

    public var serviceManagedInfos: [DescribeCustomRoutingEndpointResponseBody.ServiceManagedInfos]?

    public var state: String?

    public var trafficToEndpointPolicy: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceleratorId != nil {
            map["AcceleratorId"] = self.acceleratorId!
        }
        if self.endpoint != nil {
            map["Endpoint"] = self.endpoint!
        }
        if self.endpointGroupId != nil {
            map["EndpointGroupId"] = self.endpointGroupId!
        }
        if self.endpointId != nil {
            map["EndpointId"] = self.endpointId!
        }
        if self.listenerId != nil {
            map["ListenerId"] = self.listenerId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.serviceId != nil {
            map["ServiceId"] = self.serviceId!
        }
        if self.serviceManaged != nil {
            map["ServiceManaged"] = self.serviceManaged!
        }
        if self.serviceManagedInfos != nil {
            var tmp : [Any] = []
            for k in self.serviceManagedInfos! {
                tmp.append(k.toMap())
            }
            map["ServiceManagedInfos"] = tmp
        }
        if self.state != nil {
            map["State"] = self.state!
        }
        if self.trafficToEndpointPolicy != nil {
            map["TrafficToEndpointPolicy"] = self.trafficToEndpointPolicy!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceleratorId") && dict["AcceleratorId"] != nil {
            self.acceleratorId = dict["AcceleratorId"] as! String
        }
        if dict.keys.contains("Endpoint") && dict["Endpoint"] != nil {
            self.endpoint = dict["Endpoint"] as! String
        }
        if dict.keys.contains("EndpointGroupId") && dict["EndpointGroupId"] != nil {
            self.endpointGroupId = dict["EndpointGroupId"] as! String
        }
        if dict.keys.contains("EndpointId") && dict["EndpointId"] != nil {
            self.endpointId = dict["EndpointId"] as! String
        }
        if dict.keys.contains("ListenerId") && dict["ListenerId"] != nil {
            self.listenerId = dict["ListenerId"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ServiceId") && dict["ServiceId"] != nil {
            self.serviceId = dict["ServiceId"] as! String
        }
        if dict.keys.contains("ServiceManaged") && dict["ServiceManaged"] != nil {
            self.serviceManaged = dict["ServiceManaged"] as! Bool
        }
        if dict.keys.contains("ServiceManagedInfos") && dict["ServiceManagedInfos"] != nil {
            var tmp : [DescribeCustomRoutingEndpointResponseBody.ServiceManagedInfos] = []
            for v in dict["ServiceManagedInfos"] as! [Any] {
                var model = DescribeCustomRoutingEndpointResponseBody.ServiceManagedInfos()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.serviceManagedInfos = tmp
        }
        if dict.keys.contains("State") && dict["State"] != nil {
            self.state = dict["State"] as! String
        }
        if dict.keys.contains("TrafficToEndpointPolicy") && dict["TrafficToEndpointPolicy"] != nil {
            self.trafficToEndpointPolicy = dict["TrafficToEndpointPolicy"] as! String
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! String
        }
    }
}

public class DescribeCustomRoutingEndpointResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeCustomRoutingEndpointResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeCustomRoutingEndpointResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeCustomRoutingEndpointGroupRequest : Tea.TeaModel {
    public var endpointGroupId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endpointGroupId != nil {
            map["EndpointGroupId"] = self.endpointGroupId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndpointGroupId") && dict["EndpointGroupId"] != nil {
            self.endpointGroupId = dict["EndpointGroupId"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DescribeCustomRoutingEndpointGroupResponseBody : Tea.TeaModel {
    public class ServiceManagedInfos : Tea.TeaModel {
        public var action: String?

        public var childType: String?

        public var isManaged: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.action != nil {
                map["Action"] = self.action!
            }
            if self.childType != nil {
                map["ChildType"] = self.childType!
            }
            if self.isManaged != nil {
                map["IsManaged"] = self.isManaged!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Action") && dict["Action"] != nil {
                self.action = dict["Action"] as! String
            }
            if dict.keys.contains("ChildType") && dict["ChildType"] != nil {
                self.childType = dict["ChildType"] as! String
            }
            if dict.keys.contains("IsManaged") && dict["IsManaged"] != nil {
                self.isManaged = dict["IsManaged"] as! Bool
            }
        }
    }
    public var acceleratorId: String?

    public var accessLogSwitch: String?

    public var description_: String?

    public var enableAccessLog: Bool?

    public var endpointGroupId: String?

    public var endpointGroupIpList: [String]?

    public var endpointGroupRegion: String?

    public var endpointGroupUnconfirmedIpList: [String]?

    public var listenerId: String?

    public var name: String?

    public var requestId: String?

    public var serviceId: String?

    public var serviceManaged: Bool?

    public var serviceManagedInfos: [DescribeCustomRoutingEndpointGroupResponseBody.ServiceManagedInfos]?

    public var slsLogStoreName: String?

    public var slsProjectName: String?

    public var slsRegion: String?

    public var state: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceleratorId != nil {
            map["AcceleratorId"] = self.acceleratorId!
        }
        if self.accessLogSwitch != nil {
            map["AccessLogSwitch"] = self.accessLogSwitch!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.enableAccessLog != nil {
            map["EnableAccessLog"] = self.enableAccessLog!
        }
        if self.endpointGroupId != nil {
            map["EndpointGroupId"] = self.endpointGroupId!
        }
        if self.endpointGroupIpList != nil {
            map["EndpointGroupIpList"] = self.endpointGroupIpList!
        }
        if self.endpointGroupRegion != nil {
            map["EndpointGroupRegion"] = self.endpointGroupRegion!
        }
        if self.endpointGroupUnconfirmedIpList != nil {
            map["EndpointGroupUnconfirmedIpList"] = self.endpointGroupUnconfirmedIpList!
        }
        if self.listenerId != nil {
            map["ListenerId"] = self.listenerId!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.serviceId != nil {
            map["ServiceId"] = self.serviceId!
        }
        if self.serviceManaged != nil {
            map["ServiceManaged"] = self.serviceManaged!
        }
        if self.serviceManagedInfos != nil {
            var tmp : [Any] = []
            for k in self.serviceManagedInfos! {
                tmp.append(k.toMap())
            }
            map["ServiceManagedInfos"] = tmp
        }
        if self.slsLogStoreName != nil {
            map["SlsLogStoreName"] = self.slsLogStoreName!
        }
        if self.slsProjectName != nil {
            map["SlsProjectName"] = self.slsProjectName!
        }
        if self.slsRegion != nil {
            map["SlsRegion"] = self.slsRegion!
        }
        if self.state != nil {
            map["State"] = self.state!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceleratorId") && dict["AcceleratorId"] != nil {
            self.acceleratorId = dict["AcceleratorId"] as! String
        }
        if dict.keys.contains("AccessLogSwitch") && dict["AccessLogSwitch"] != nil {
            self.accessLogSwitch = dict["AccessLogSwitch"] as! String
        }
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("EnableAccessLog") && dict["EnableAccessLog"] != nil {
            self.enableAccessLog = dict["EnableAccessLog"] as! Bool
        }
        if dict.keys.contains("EndpointGroupId") && dict["EndpointGroupId"] != nil {
            self.endpointGroupId = dict["EndpointGroupId"] as! String
        }
        if dict.keys.contains("EndpointGroupIpList") && dict["EndpointGroupIpList"] != nil {
            self.endpointGroupIpList = dict["EndpointGroupIpList"] as! [String]
        }
        if dict.keys.contains("EndpointGroupRegion") && dict["EndpointGroupRegion"] != nil {
            self.endpointGroupRegion = dict["EndpointGroupRegion"] as! String
        }
        if dict.keys.contains("EndpointGroupUnconfirmedIpList") && dict["EndpointGroupUnconfirmedIpList"] != nil {
            self.endpointGroupUnconfirmedIpList = dict["EndpointGroupUnconfirmedIpList"] as! [String]
        }
        if dict.keys.contains("ListenerId") && dict["ListenerId"] != nil {
            self.listenerId = dict["ListenerId"] as! String
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ServiceId") && dict["ServiceId"] != nil {
            self.serviceId = dict["ServiceId"] as! String
        }
        if dict.keys.contains("ServiceManaged") && dict["ServiceManaged"] != nil {
            self.serviceManaged = dict["ServiceManaged"] as! Bool
        }
        if dict.keys.contains("ServiceManagedInfos") && dict["ServiceManagedInfos"] != nil {
            var tmp : [DescribeCustomRoutingEndpointGroupResponseBody.ServiceManagedInfos] = []
            for v in dict["ServiceManagedInfos"] as! [Any] {
                var model = DescribeCustomRoutingEndpointGroupResponseBody.ServiceManagedInfos()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.serviceManagedInfos = tmp
        }
        if dict.keys.contains("SlsLogStoreName") && dict["SlsLogStoreName"] != nil {
            self.slsLogStoreName = dict["SlsLogStoreName"] as! String
        }
        if dict.keys.contains("SlsProjectName") && dict["SlsProjectName"] != nil {
            self.slsProjectName = dict["SlsProjectName"] as! String
        }
        if dict.keys.contains("SlsRegion") && dict["SlsRegion"] != nil {
            self.slsRegion = dict["SlsRegion"] as! String
        }
        if dict.keys.contains("State") && dict["State"] != nil {
            self.state = dict["State"] as! String
        }
    }
}

public class DescribeCustomRoutingEndpointGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeCustomRoutingEndpointGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeCustomRoutingEndpointGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeCustomRoutingEndpointGroupDestinationsRequest : Tea.TeaModel {
    public var destinationId: String?

    public var endpointGroupId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.destinationId != nil {
            map["DestinationId"] = self.destinationId!
        }
        if self.endpointGroupId != nil {
            map["EndpointGroupId"] = self.endpointGroupId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DestinationId") && dict["DestinationId"] != nil {
            self.destinationId = dict["DestinationId"] as! String
        }
        if dict.keys.contains("EndpointGroupId") && dict["EndpointGroupId"] != nil {
            self.endpointGroupId = dict["EndpointGroupId"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DescribeCustomRoutingEndpointGroupDestinationsResponseBody : Tea.TeaModel {
    public class ServiceManagedInfos : Tea.TeaModel {
        public var action: String?

        public var childType: String?

        public var isManaged: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.action != nil {
                map["Action"] = self.action!
            }
            if self.childType != nil {
                map["ChildType"] = self.childType!
            }
            if self.isManaged != nil {
                map["IsManaged"] = self.isManaged!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Action") && dict["Action"] != nil {
                self.action = dict["Action"] as! String
            }
            if dict.keys.contains("ChildType") && dict["ChildType"] != nil {
                self.childType = dict["ChildType"] as! String
            }
            if dict.keys.contains("IsManaged") && dict["IsManaged"] != nil {
                self.isManaged = dict["IsManaged"] as! Bool
            }
        }
    }
    public var acceleratorId: String?

    public var destinationId: String?

    public var endpointGroupId: String?

    public var fromPort: Int32?

    public var listenerId: String?

    public var protocols: [String]?

    public var requestId: String?

    public var serviceId: String?

    public var serviceManaged: Bool?

    public var serviceManagedInfos: [DescribeCustomRoutingEndpointGroupDestinationsResponseBody.ServiceManagedInfos]?

    public var state: String?

    public var toPort: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceleratorId != nil {
            map["AcceleratorId"] = self.acceleratorId!
        }
        if self.destinationId != nil {
            map["DestinationId"] = self.destinationId!
        }
        if self.endpointGroupId != nil {
            map["EndpointGroupId"] = self.endpointGroupId!
        }
        if self.fromPort != nil {
            map["FromPort"] = self.fromPort!
        }
        if self.listenerId != nil {
            map["ListenerId"] = self.listenerId!
        }
        if self.protocols != nil {
            map["Protocols"] = self.protocols!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.serviceId != nil {
            map["ServiceId"] = self.serviceId!
        }
        if self.serviceManaged != nil {
            map["ServiceManaged"] = self.serviceManaged!
        }
        if self.serviceManagedInfos != nil {
            var tmp : [Any] = []
            for k in self.serviceManagedInfos! {
                tmp.append(k.toMap())
            }
            map["ServiceManagedInfos"] = tmp
        }
        if self.state != nil {
            map["State"] = self.state!
        }
        if self.toPort != nil {
            map["ToPort"] = self.toPort!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceleratorId") && dict["AcceleratorId"] != nil {
            self.acceleratorId = dict["AcceleratorId"] as! String
        }
        if dict.keys.contains("DestinationId") && dict["DestinationId"] != nil {
            self.destinationId = dict["DestinationId"] as! String
        }
        if dict.keys.contains("EndpointGroupId") && dict["EndpointGroupId"] != nil {
            self.endpointGroupId = dict["EndpointGroupId"] as! String
        }
        if dict.keys.contains("FromPort") && dict["FromPort"] != nil {
            self.fromPort = dict["FromPort"] as! Int32
        }
        if dict.keys.contains("ListenerId") && dict["ListenerId"] != nil {
            self.listenerId = dict["ListenerId"] as! String
        }
        if dict.keys.contains("Protocols") && dict["Protocols"] != nil {
            self.protocols = dict["Protocols"] as! [String]
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ServiceId") && dict["ServiceId"] != nil {
            self.serviceId = dict["ServiceId"] as! String
        }
        if dict.keys.contains("ServiceManaged") && dict["ServiceManaged"] != nil {
            self.serviceManaged = dict["ServiceManaged"] as! Bool
        }
        if dict.keys.contains("ServiceManagedInfos") && dict["ServiceManagedInfos"] != nil {
            var tmp : [DescribeCustomRoutingEndpointGroupDestinationsResponseBody.ServiceManagedInfos] = []
            for v in dict["ServiceManagedInfos"] as! [Any] {
                var model = DescribeCustomRoutingEndpointGroupDestinationsResponseBody.ServiceManagedInfos()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.serviceManagedInfos = tmp
        }
        if dict.keys.contains("State") && dict["State"] != nil {
            self.state = dict["State"] as! String
        }
        if dict.keys.contains("ToPort") && dict["ToPort"] != nil {
            self.toPort = dict["ToPort"] as! Int32
        }
    }
}

public class DescribeCustomRoutingEndpointGroupDestinationsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeCustomRoutingEndpointGroupDestinationsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeCustomRoutingEndpointGroupDestinationsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeEndpointGroupRequest : Tea.TeaModel {
    public var endpointGroupId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endpointGroupId != nil {
            map["EndpointGroupId"] = self.endpointGroupId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndpointGroupId") && dict["EndpointGroupId"] != nil {
            self.endpointGroupId = dict["EndpointGroupId"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DescribeEndpointGroupResponseBody : Tea.TeaModel {
    public class EndpointConfigurations : Tea.TeaModel {
        public var enableClientIPPreservation: Bool?

        public var enableProxyProtocol: Bool?

        public var endpoint: String?

        public var probePort: Int32?

        public var probeProtocol: String?

        public var subAddress: String?

        public var type: String?

        public var weight: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.enableClientIPPreservation != nil {
                map["EnableClientIPPreservation"] = self.enableClientIPPreservation!
            }
            if self.enableProxyProtocol != nil {
                map["EnableProxyProtocol"] = self.enableProxyProtocol!
            }
            if self.endpoint != nil {
                map["Endpoint"] = self.endpoint!
            }
            if self.probePort != nil {
                map["ProbePort"] = self.probePort!
            }
            if self.probeProtocol != nil {
                map["ProbeProtocol"] = self.probeProtocol!
            }
            if self.subAddress != nil {
                map["SubAddress"] = self.subAddress!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.weight != nil {
                map["Weight"] = self.weight!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EnableClientIPPreservation") && dict["EnableClientIPPreservation"] != nil {
                self.enableClientIPPreservation = dict["EnableClientIPPreservation"] as! Bool
            }
            if dict.keys.contains("EnableProxyProtocol") && dict["EnableProxyProtocol"] != nil {
                self.enableProxyProtocol = dict["EnableProxyProtocol"] as! Bool
            }
            if dict.keys.contains("Endpoint") && dict["Endpoint"] != nil {
                self.endpoint = dict["Endpoint"] as! String
            }
            if dict.keys.contains("ProbePort") && dict["ProbePort"] != nil {
                self.probePort = dict["ProbePort"] as! Int32
            }
            if dict.keys.contains("ProbeProtocol") && dict["ProbeProtocol"] != nil {
                self.probeProtocol = dict["ProbeProtocol"] as! String
            }
            if dict.keys.contains("SubAddress") && dict["SubAddress"] != nil {
                self.subAddress = dict["SubAddress"] as! String
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
            if dict.keys.contains("Weight") && dict["Weight"] != nil {
                self.weight = dict["Weight"] as! Int32
            }
        }
    }
    public class PortOverrides : Tea.TeaModel {
        public var endpointPort: Int32?

        public var listenerPort: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.endpointPort != nil {
                map["EndpointPort"] = self.endpointPort!
            }
            if self.listenerPort != nil {
                map["ListenerPort"] = self.listenerPort!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EndpointPort") && dict["EndpointPort"] != nil {
                self.endpointPort = dict["EndpointPort"] as! Int32
            }
            if dict.keys.contains("ListenerPort") && dict["ListenerPort"] != nil {
                self.listenerPort = dict["ListenerPort"] as! Int32
            }
        }
    }
    public class ServiceManagedInfos : Tea.TeaModel {
        public var action: String?

        public var childType: String?

        public var isManaged: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.action != nil {
                map["Action"] = self.action!
            }
            if self.childType != nil {
                map["ChildType"] = self.childType!
            }
            if self.isManaged != nil {
                map["IsManaged"] = self.isManaged!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Action") && dict["Action"] != nil {
                self.action = dict["Action"] as! String
            }
            if dict.keys.contains("ChildType") && dict["ChildType"] != nil {
                self.childType = dict["ChildType"] as! String
            }
            if dict.keys.contains("IsManaged") && dict["IsManaged"] != nil {
                self.isManaged = dict["IsManaged"] as! Bool
            }
        }
    }
    public class Tags : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") && dict["Key"] != nil {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") && dict["Value"] != nil {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var acceleratorId: String?

    public var accessLogSwitch: String?

    public var description_: String?

    public var enableAccessLog: Bool?

    public var endpointConfigurations: [DescribeEndpointGroupResponseBody.EndpointConfigurations]?

    public var endpointGroupId: String?

    public var endpointGroupIpList: [String]?

    public var endpointGroupRegion: String?

    public var endpointGroupType: String?

    public var endpointGroupUnconfirmedIpList: [String]?

    public var endpointRequestProtocol: String?

    public var forwardingRuleIds: [String]?

    public var healthCheckEnabled: Bool?

    public var healthCheckIntervalSeconds: Int32?

    public var healthCheckPath: String?

    public var healthCheckPort: Int32?

    public var healthCheckProtocol: String?

    public var listenerId: String?

    public var name: String?

    public var portOverrides: [DescribeEndpointGroupResponseBody.PortOverrides]?

    public var requestId: String?

    public var serviceId: String?

    public var serviceManaged: Bool?

    public var serviceManagedInfos: [DescribeEndpointGroupResponseBody.ServiceManagedInfos]?

    public var slsLogStoreName: String?

    public var slsProjectName: String?

    public var slsRegion: String?

    public var state: String?

    public var tags: [DescribeEndpointGroupResponseBody.Tags]?

    public var thresholdCount: Int32?

    public var trafficPercentage: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceleratorId != nil {
            map["AcceleratorId"] = self.acceleratorId!
        }
        if self.accessLogSwitch != nil {
            map["AccessLogSwitch"] = self.accessLogSwitch!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.enableAccessLog != nil {
            map["EnableAccessLog"] = self.enableAccessLog!
        }
        if self.endpointConfigurations != nil {
            var tmp : [Any] = []
            for k in self.endpointConfigurations! {
                tmp.append(k.toMap())
            }
            map["EndpointConfigurations"] = tmp
        }
        if self.endpointGroupId != nil {
            map["EndpointGroupId"] = self.endpointGroupId!
        }
        if self.endpointGroupIpList != nil {
            map["EndpointGroupIpList"] = self.endpointGroupIpList!
        }
        if self.endpointGroupRegion != nil {
            map["EndpointGroupRegion"] = self.endpointGroupRegion!
        }
        if self.endpointGroupType != nil {
            map["EndpointGroupType"] = self.endpointGroupType!
        }
        if self.endpointGroupUnconfirmedIpList != nil {
            map["EndpointGroupUnconfirmedIpList"] = self.endpointGroupUnconfirmedIpList!
        }
        if self.endpointRequestProtocol != nil {
            map["EndpointRequestProtocol"] = self.endpointRequestProtocol!
        }
        if self.forwardingRuleIds != nil {
            map["ForwardingRuleIds"] = self.forwardingRuleIds!
        }
        if self.healthCheckEnabled != nil {
            map["HealthCheckEnabled"] = self.healthCheckEnabled!
        }
        if self.healthCheckIntervalSeconds != nil {
            map["HealthCheckIntervalSeconds"] = self.healthCheckIntervalSeconds!
        }
        if self.healthCheckPath != nil {
            map["HealthCheckPath"] = self.healthCheckPath!
        }
        if self.healthCheckPort != nil {
            map["HealthCheckPort"] = self.healthCheckPort!
        }
        if self.healthCheckProtocol != nil {
            map["HealthCheckProtocol"] = self.healthCheckProtocol!
        }
        if self.listenerId != nil {
            map["ListenerId"] = self.listenerId!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.portOverrides != nil {
            var tmp : [Any] = []
            for k in self.portOverrides! {
                tmp.append(k.toMap())
            }
            map["PortOverrides"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.serviceId != nil {
            map["ServiceId"] = self.serviceId!
        }
        if self.serviceManaged != nil {
            map["ServiceManaged"] = self.serviceManaged!
        }
        if self.serviceManagedInfos != nil {
            var tmp : [Any] = []
            for k in self.serviceManagedInfos! {
                tmp.append(k.toMap())
            }
            map["ServiceManagedInfos"] = tmp
        }
        if self.slsLogStoreName != nil {
            map["SlsLogStoreName"] = self.slsLogStoreName!
        }
        if self.slsProjectName != nil {
            map["SlsProjectName"] = self.slsProjectName!
        }
        if self.slsRegion != nil {
            map["SlsRegion"] = self.slsRegion!
        }
        if self.state != nil {
            map["State"] = self.state!
        }
        if self.tags != nil {
            var tmp : [Any] = []
            for k in self.tags! {
                tmp.append(k.toMap())
            }
            map["Tags"] = tmp
        }
        if self.thresholdCount != nil {
            map["ThresholdCount"] = self.thresholdCount!
        }
        if self.trafficPercentage != nil {
            map["TrafficPercentage"] = self.trafficPercentage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceleratorId") && dict["AcceleratorId"] != nil {
            self.acceleratorId = dict["AcceleratorId"] as! String
        }
        if dict.keys.contains("AccessLogSwitch") && dict["AccessLogSwitch"] != nil {
            self.accessLogSwitch = dict["AccessLogSwitch"] as! String
        }
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("EnableAccessLog") && dict["EnableAccessLog"] != nil {
            self.enableAccessLog = dict["EnableAccessLog"] as! Bool
        }
        if dict.keys.contains("EndpointConfigurations") && dict["EndpointConfigurations"] != nil {
            var tmp : [DescribeEndpointGroupResponseBody.EndpointConfigurations] = []
            for v in dict["EndpointConfigurations"] as! [Any] {
                var model = DescribeEndpointGroupResponseBody.EndpointConfigurations()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.endpointConfigurations = tmp
        }
        if dict.keys.contains("EndpointGroupId") && dict["EndpointGroupId"] != nil {
            self.endpointGroupId = dict["EndpointGroupId"] as! String
        }
        if dict.keys.contains("EndpointGroupIpList") && dict["EndpointGroupIpList"] != nil {
            self.endpointGroupIpList = dict["EndpointGroupIpList"] as! [String]
        }
        if dict.keys.contains("EndpointGroupRegion") && dict["EndpointGroupRegion"] != nil {
            self.endpointGroupRegion = dict["EndpointGroupRegion"] as! String
        }
        if dict.keys.contains("EndpointGroupType") && dict["EndpointGroupType"] != nil {
            self.endpointGroupType = dict["EndpointGroupType"] as! String
        }
        if dict.keys.contains("EndpointGroupUnconfirmedIpList") && dict["EndpointGroupUnconfirmedIpList"] != nil {
            self.endpointGroupUnconfirmedIpList = dict["EndpointGroupUnconfirmedIpList"] as! [String]
        }
        if dict.keys.contains("EndpointRequestProtocol") && dict["EndpointRequestProtocol"] != nil {
            self.endpointRequestProtocol = dict["EndpointRequestProtocol"] as! String
        }
        if dict.keys.contains("ForwardingRuleIds") && dict["ForwardingRuleIds"] != nil {
            self.forwardingRuleIds = dict["ForwardingRuleIds"] as! [String]
        }
        if dict.keys.contains("HealthCheckEnabled") && dict["HealthCheckEnabled"] != nil {
            self.healthCheckEnabled = dict["HealthCheckEnabled"] as! Bool
        }
        if dict.keys.contains("HealthCheckIntervalSeconds") && dict["HealthCheckIntervalSeconds"] != nil {
            self.healthCheckIntervalSeconds = dict["HealthCheckIntervalSeconds"] as! Int32
        }
        if dict.keys.contains("HealthCheckPath") && dict["HealthCheckPath"] != nil {
            self.healthCheckPath = dict["HealthCheckPath"] as! String
        }
        if dict.keys.contains("HealthCheckPort") && dict["HealthCheckPort"] != nil {
            self.healthCheckPort = dict["HealthCheckPort"] as! Int32
        }
        if dict.keys.contains("HealthCheckProtocol") && dict["HealthCheckProtocol"] != nil {
            self.healthCheckProtocol = dict["HealthCheckProtocol"] as! String
        }
        if dict.keys.contains("ListenerId") && dict["ListenerId"] != nil {
            self.listenerId = dict["ListenerId"] as! String
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("PortOverrides") && dict["PortOverrides"] != nil {
            var tmp : [DescribeEndpointGroupResponseBody.PortOverrides] = []
            for v in dict["PortOverrides"] as! [Any] {
                var model = DescribeEndpointGroupResponseBody.PortOverrides()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.portOverrides = tmp
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ServiceId") && dict["ServiceId"] != nil {
            self.serviceId = dict["ServiceId"] as! String
        }
        if dict.keys.contains("ServiceManaged") && dict["ServiceManaged"] != nil {
            self.serviceManaged = dict["ServiceManaged"] as! Bool
        }
        if dict.keys.contains("ServiceManagedInfos") && dict["ServiceManagedInfos"] != nil {
            var tmp : [DescribeEndpointGroupResponseBody.ServiceManagedInfos] = []
            for v in dict["ServiceManagedInfos"] as! [Any] {
                var model = DescribeEndpointGroupResponseBody.ServiceManagedInfos()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.serviceManagedInfos = tmp
        }
        if dict.keys.contains("SlsLogStoreName") && dict["SlsLogStoreName"] != nil {
            self.slsLogStoreName = dict["SlsLogStoreName"] as! String
        }
        if dict.keys.contains("SlsProjectName") && dict["SlsProjectName"] != nil {
            self.slsProjectName = dict["SlsProjectName"] as! String
        }
        if dict.keys.contains("SlsRegion") && dict["SlsRegion"] != nil {
            self.slsRegion = dict["SlsRegion"] as! String
        }
        if dict.keys.contains("State") && dict["State"] != nil {
            self.state = dict["State"] as! String
        }
        if dict.keys.contains("Tags") && dict["Tags"] != nil {
            var tmp : [DescribeEndpointGroupResponseBody.Tags] = []
            for v in dict["Tags"] as! [Any] {
                var model = DescribeEndpointGroupResponseBody.Tags()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tags = tmp
        }
        if dict.keys.contains("ThresholdCount") && dict["ThresholdCount"] != nil {
            self.thresholdCount = dict["ThresholdCount"] as! Int32
        }
        if dict.keys.contains("TrafficPercentage") && dict["TrafficPercentage"] != nil {
            self.trafficPercentage = dict["TrafficPercentage"] as! Int32
        }
    }
}

public class DescribeEndpointGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeEndpointGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeEndpointGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeIpSetRequest : Tea.TeaModel {
    public var ipSetId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ipSetId != nil {
            map["IpSetId"] = self.ipSetId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("IpSetId") && dict["IpSetId"] != nil {
            self.ipSetId = dict["IpSetId"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DescribeIpSetResponseBody : Tea.TeaModel {
    public class ServiceManagedInfos : Tea.TeaModel {
        public var action: String?

        public var childType: String?

        public var isManaged: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.action != nil {
                map["Action"] = self.action!
            }
            if self.childType != nil {
                map["ChildType"] = self.childType!
            }
            if self.isManaged != nil {
                map["IsManaged"] = self.isManaged!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Action") && dict["Action"] != nil {
                self.action = dict["Action"] as! String
            }
            if dict.keys.contains("ChildType") && dict["ChildType"] != nil {
                self.childType = dict["ChildType"] as! String
            }
            if dict.keys.contains("IsManaged") && dict["IsManaged"] != nil {
                self.isManaged = dict["IsManaged"] as! Bool
            }
        }
    }
    public var accelerateRegionId: String?

    public var acceleratorId: String?

    public var bandwidth: Int32?

    public var ipAddressList: [String]?

    public var ipSetId: String?

    public var ipVersion: String?

    public var ispType: String?

    public var requestId: String?

    public var serviceId: String?

    public var serviceManaged: Bool?

    public var serviceManagedInfos: [DescribeIpSetResponseBody.ServiceManagedInfos]?

    public var state: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accelerateRegionId != nil {
            map["AccelerateRegionId"] = self.accelerateRegionId!
        }
        if self.acceleratorId != nil {
            map["AcceleratorId"] = self.acceleratorId!
        }
        if self.bandwidth != nil {
            map["Bandwidth"] = self.bandwidth!
        }
        if self.ipAddressList != nil {
            map["IpAddressList"] = self.ipAddressList!
        }
        if self.ipSetId != nil {
            map["IpSetId"] = self.ipSetId!
        }
        if self.ipVersion != nil {
            map["IpVersion"] = self.ipVersion!
        }
        if self.ispType != nil {
            map["IspType"] = self.ispType!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.serviceId != nil {
            map["ServiceId"] = self.serviceId!
        }
        if self.serviceManaged != nil {
            map["ServiceManaged"] = self.serviceManaged!
        }
        if self.serviceManagedInfos != nil {
            var tmp : [Any] = []
            for k in self.serviceManagedInfos! {
                tmp.append(k.toMap())
            }
            map["ServiceManagedInfos"] = tmp
        }
        if self.state != nil {
            map["State"] = self.state!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AccelerateRegionId") && dict["AccelerateRegionId"] != nil {
            self.accelerateRegionId = dict["AccelerateRegionId"] as! String
        }
        if dict.keys.contains("AcceleratorId") && dict["AcceleratorId"] != nil {
            self.acceleratorId = dict["AcceleratorId"] as! String
        }
        if dict.keys.contains("Bandwidth") && dict["Bandwidth"] != nil {
            self.bandwidth = dict["Bandwidth"] as! Int32
        }
        if dict.keys.contains("IpAddressList") && dict["IpAddressList"] != nil {
            self.ipAddressList = dict["IpAddressList"] as! [String]
        }
        if dict.keys.contains("IpSetId") && dict["IpSetId"] != nil {
            self.ipSetId = dict["IpSetId"] as! String
        }
        if dict.keys.contains("IpVersion") && dict["IpVersion"] != nil {
            self.ipVersion = dict["IpVersion"] as! String
        }
        if dict.keys.contains("IspType") && dict["IspType"] != nil {
            self.ispType = dict["IspType"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ServiceId") && dict["ServiceId"] != nil {
            self.serviceId = dict["ServiceId"] as! String
        }
        if dict.keys.contains("ServiceManaged") && dict["ServiceManaged"] != nil {
            self.serviceManaged = dict["ServiceManaged"] as! Bool
        }
        if dict.keys.contains("ServiceManagedInfos") && dict["ServiceManagedInfos"] != nil {
            var tmp : [DescribeIpSetResponseBody.ServiceManagedInfos] = []
            for v in dict["ServiceManagedInfos"] as! [Any] {
                var model = DescribeIpSetResponseBody.ServiceManagedInfos()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.serviceManagedInfos = tmp
        }
        if dict.keys.contains("State") && dict["State"] != nil {
            self.state = dict["State"] as! String
        }
    }
}

public class DescribeIpSetResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeIpSetResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeIpSetResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeListenerRequest : Tea.TeaModel {
    public var listenerId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.listenerId != nil {
            map["ListenerId"] = self.listenerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ListenerId") && dict["ListenerId"] != nil {
            self.listenerId = dict["ListenerId"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DescribeListenerResponseBody : Tea.TeaModel {
    public class BackendPorts : Tea.TeaModel {
        public var fromPort: String?

        public var toPort: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.fromPort != nil {
                map["FromPort"] = self.fromPort!
            }
            if self.toPort != nil {
                map["ToPort"] = self.toPort!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("FromPort") && dict["FromPort"] != nil {
                self.fromPort = dict["FromPort"] as! String
            }
            if dict.keys.contains("ToPort") && dict["ToPort"] != nil {
                self.toPort = dict["ToPort"] as! String
            }
        }
    }
    public class Certificates : Tea.TeaModel {
        public var id: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Id") && dict["Id"] != nil {
                self.id = dict["Id"] as! String
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
        }
    }
    public class PortRanges : Tea.TeaModel {
        public var fromPort: Int32?

        public var toPort: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.fromPort != nil {
                map["FromPort"] = self.fromPort!
            }
            if self.toPort != nil {
                map["ToPort"] = self.toPort!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("FromPort") && dict["FromPort"] != nil {
                self.fromPort = dict["FromPort"] as! Int32
            }
            if dict.keys.contains("ToPort") && dict["ToPort"] != nil {
                self.toPort = dict["ToPort"] as! Int32
            }
        }
    }
    public class RelatedAcls : Tea.TeaModel {
        public var aclId: String?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.aclId != nil {
                map["AclId"] = self.aclId!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AclId") && dict["AclId"] != nil {
                self.aclId = dict["AclId"] as! String
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! String
            }
        }
    }
    public class ServiceManagedInfos : Tea.TeaModel {
        public var action: String?

        public var childType: String?

        public var isManaged: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.action != nil {
                map["Action"] = self.action!
            }
            if self.childType != nil {
                map["ChildType"] = self.childType!
            }
            if self.isManaged != nil {
                map["IsManaged"] = self.isManaged!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Action") && dict["Action"] != nil {
                self.action = dict["Action"] as! String
            }
            if dict.keys.contains("ChildType") && dict["ChildType"] != nil {
                self.childType = dict["ChildType"] as! String
            }
            if dict.keys.contains("IsManaged") && dict["IsManaged"] != nil {
                self.isManaged = dict["IsManaged"] as! Bool
            }
        }
    }
    public class XForwardedForConfig : Tea.TeaModel {
        public var XForwardedForGaApEnabled: Bool?

        public var XForwardedForGaIdEnabled: Bool?

        public var XForwardedForPortEnabled: Bool?

        public var XForwardedForProtoEnabled: Bool?

        public var XRealIpEnabled: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.XForwardedForGaApEnabled != nil {
                map["XForwardedForGaApEnabled"] = self.XForwardedForGaApEnabled!
            }
            if self.XForwardedForGaIdEnabled != nil {
                map["XForwardedForGaIdEnabled"] = self.XForwardedForGaIdEnabled!
            }
            if self.XForwardedForPortEnabled != nil {
                map["XForwardedForPortEnabled"] = self.XForwardedForPortEnabled!
            }
            if self.XForwardedForProtoEnabled != nil {
                map["XForwardedForProtoEnabled"] = self.XForwardedForProtoEnabled!
            }
            if self.XRealIpEnabled != nil {
                map["XRealIpEnabled"] = self.XRealIpEnabled!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("XForwardedForGaApEnabled") && dict["XForwardedForGaApEnabled"] != nil {
                self.XForwardedForGaApEnabled = dict["XForwardedForGaApEnabled"] as! Bool
            }
            if dict.keys.contains("XForwardedForGaIdEnabled") && dict["XForwardedForGaIdEnabled"] != nil {
                self.XForwardedForGaIdEnabled = dict["XForwardedForGaIdEnabled"] as! Bool
            }
            if dict.keys.contains("XForwardedForPortEnabled") && dict["XForwardedForPortEnabled"] != nil {
                self.XForwardedForPortEnabled = dict["XForwardedForPortEnabled"] as! Bool
            }
            if dict.keys.contains("XForwardedForProtoEnabled") && dict["XForwardedForProtoEnabled"] != nil {
                self.XForwardedForProtoEnabled = dict["XForwardedForProtoEnabled"] as! Bool
            }
            if dict.keys.contains("XRealIpEnabled") && dict["XRealIpEnabled"] != nil {
                self.XRealIpEnabled = dict["XRealIpEnabled"] as! Bool
            }
        }
    }
    public var acceleratorId: String?

    public var aclType: String?

    public var backendPorts: [DescribeListenerResponseBody.BackendPorts]?

    public var certificates: [DescribeListenerResponseBody.Certificates]?

    public var clientAffinity: String?

    public var createTime: String?

    public var description_: String?

    public var idleTimeout: Int32?

    public var listenerId: String?

    public var name: String?

    public var portRanges: [DescribeListenerResponseBody.PortRanges]?

    public var protocol_: String?

    public var proxyProtocol: Bool?

    public var relatedAcls: [DescribeListenerResponseBody.RelatedAcls]?

    public var requestId: String?

    public var requestTimeout: Int32?

    public var securityPolicyId: String?

    public var serviceId: String?

    public var serviceManaged: Bool?

    public var serviceManagedInfos: [DescribeListenerResponseBody.ServiceManagedInfos]?

    public var state: String?

    public var type: String?

    public var XForwardedForConfig: DescribeListenerResponseBody.XForwardedForConfig?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.XForwardedForConfig?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceleratorId != nil {
            map["AcceleratorId"] = self.acceleratorId!
        }
        if self.aclType != nil {
            map["AclType"] = self.aclType!
        }
        if self.backendPorts != nil {
            var tmp : [Any] = []
            for k in self.backendPorts! {
                tmp.append(k.toMap())
            }
            map["BackendPorts"] = tmp
        }
        if self.certificates != nil {
            var tmp : [Any] = []
            for k in self.certificates! {
                tmp.append(k.toMap())
            }
            map["Certificates"] = tmp
        }
        if self.clientAffinity != nil {
            map["ClientAffinity"] = self.clientAffinity!
        }
        if self.createTime != nil {
            map["CreateTime"] = self.createTime!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.idleTimeout != nil {
            map["IdleTimeout"] = self.idleTimeout!
        }
        if self.listenerId != nil {
            map["ListenerId"] = self.listenerId!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.portRanges != nil {
            var tmp : [Any] = []
            for k in self.portRanges! {
                tmp.append(k.toMap())
            }
            map["PortRanges"] = tmp
        }
        if self.protocol_ != nil {
            map["Protocol"] = self.protocol_!
        }
        if self.proxyProtocol != nil {
            map["ProxyProtocol"] = self.proxyProtocol!
        }
        if self.relatedAcls != nil {
            var tmp : [Any] = []
            for k in self.relatedAcls! {
                tmp.append(k.toMap())
            }
            map["RelatedAcls"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.requestTimeout != nil {
            map["RequestTimeout"] = self.requestTimeout!
        }
        if self.securityPolicyId != nil {
            map["SecurityPolicyId"] = self.securityPolicyId!
        }
        if self.serviceId != nil {
            map["ServiceId"] = self.serviceId!
        }
        if self.serviceManaged != nil {
            map["ServiceManaged"] = self.serviceManaged!
        }
        if self.serviceManagedInfos != nil {
            var tmp : [Any] = []
            for k in self.serviceManagedInfos! {
                tmp.append(k.toMap())
            }
            map["ServiceManagedInfos"] = tmp
        }
        if self.state != nil {
            map["State"] = self.state!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        if self.XForwardedForConfig != nil {
            map["XForwardedForConfig"] = self.XForwardedForConfig?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceleratorId") && dict["AcceleratorId"] != nil {
            self.acceleratorId = dict["AcceleratorId"] as! String
        }
        if dict.keys.contains("AclType") && dict["AclType"] != nil {
            self.aclType = dict["AclType"] as! String
        }
        if dict.keys.contains("BackendPorts") && dict["BackendPorts"] != nil {
            var tmp : [DescribeListenerResponseBody.BackendPorts] = []
            for v in dict["BackendPorts"] as! [Any] {
                var model = DescribeListenerResponseBody.BackendPorts()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.backendPorts = tmp
        }
        if dict.keys.contains("Certificates") && dict["Certificates"] != nil {
            var tmp : [DescribeListenerResponseBody.Certificates] = []
            for v in dict["Certificates"] as! [Any] {
                var model = DescribeListenerResponseBody.Certificates()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.certificates = tmp
        }
        if dict.keys.contains("ClientAffinity") && dict["ClientAffinity"] != nil {
            self.clientAffinity = dict["ClientAffinity"] as! String
        }
        if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
            self.createTime = dict["CreateTime"] as! String
        }
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("IdleTimeout") && dict["IdleTimeout"] != nil {
            self.idleTimeout = dict["IdleTimeout"] as! Int32
        }
        if dict.keys.contains("ListenerId") && dict["ListenerId"] != nil {
            self.listenerId = dict["ListenerId"] as! String
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("PortRanges") && dict["PortRanges"] != nil {
            var tmp : [DescribeListenerResponseBody.PortRanges] = []
            for v in dict["PortRanges"] as! [Any] {
                var model = DescribeListenerResponseBody.PortRanges()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.portRanges = tmp
        }
        if dict.keys.contains("Protocol") && dict["Protocol"] != nil {
            self.protocol_ = dict["Protocol"] as! String
        }
        if dict.keys.contains("ProxyProtocol") && dict["ProxyProtocol"] != nil {
            self.proxyProtocol = dict["ProxyProtocol"] as! Bool
        }
        if dict.keys.contains("RelatedAcls") && dict["RelatedAcls"] != nil {
            var tmp : [DescribeListenerResponseBody.RelatedAcls] = []
            for v in dict["RelatedAcls"] as! [Any] {
                var model = DescribeListenerResponseBody.RelatedAcls()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.relatedAcls = tmp
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("RequestTimeout") && dict["RequestTimeout"] != nil {
            self.requestTimeout = dict["RequestTimeout"] as! Int32
        }
        if dict.keys.contains("SecurityPolicyId") && dict["SecurityPolicyId"] != nil {
            self.securityPolicyId = dict["SecurityPolicyId"] as! String
        }
        if dict.keys.contains("ServiceId") && dict["ServiceId"] != nil {
            self.serviceId = dict["ServiceId"] as! String
        }
        if dict.keys.contains("ServiceManaged") && dict["ServiceManaged"] != nil {
            self.serviceManaged = dict["ServiceManaged"] as! Bool
        }
        if dict.keys.contains("ServiceManagedInfos") && dict["ServiceManagedInfos"] != nil {
            var tmp : [DescribeListenerResponseBody.ServiceManagedInfos] = []
            for v in dict["ServiceManagedInfos"] as! [Any] {
                var model = DescribeListenerResponseBody.ServiceManagedInfos()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.serviceManagedInfos = tmp
        }
        if dict.keys.contains("State") && dict["State"] != nil {
            self.state = dict["State"] as! String
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! String
        }
        if dict.keys.contains("XForwardedForConfig") && dict["XForwardedForConfig"] != nil {
            var model = DescribeListenerResponseBody.XForwardedForConfig()
            model.fromMap(dict["XForwardedForConfig"] as! [String: Any])
            self.XForwardedForConfig = model
        }
    }
}

public class DescribeListenerResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeListenerResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeListenerResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeLogStoreOfEndpointGroupRequest : Tea.TeaModel {
    public var acceleratorId: String?

    public var endpointGroupId: String?

    public var listenerId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceleratorId != nil {
            map["AcceleratorId"] = self.acceleratorId!
        }
        if self.endpointGroupId != nil {
            map["EndpointGroupId"] = self.endpointGroupId!
        }
        if self.listenerId != nil {
            map["ListenerId"] = self.listenerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceleratorId") && dict["AcceleratorId"] != nil {
            self.acceleratorId = dict["AcceleratorId"] as! String
        }
        if dict.keys.contains("EndpointGroupId") && dict["EndpointGroupId"] != nil {
            self.endpointGroupId = dict["EndpointGroupId"] as! String
        }
        if dict.keys.contains("ListenerId") && dict["ListenerId"] != nil {
            self.listenerId = dict["ListenerId"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DescribeLogStoreOfEndpointGroupResponseBody : Tea.TeaModel {
    public var acceleratorId: String?

    public var endpointGroupId: String?

    public var listenerId: String?

    public var requestId: String?

    public var slsLogStoreName: String?

    public var slsProjectName: String?

    public var slsRegionId: String?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceleratorId != nil {
            map["AcceleratorId"] = self.acceleratorId!
        }
        if self.endpointGroupId != nil {
            map["EndpointGroupId"] = self.endpointGroupId!
        }
        if self.listenerId != nil {
            map["ListenerId"] = self.listenerId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.slsLogStoreName != nil {
            map["SlsLogStoreName"] = self.slsLogStoreName!
        }
        if self.slsProjectName != nil {
            map["SlsProjectName"] = self.slsProjectName!
        }
        if self.slsRegionId != nil {
            map["SlsRegionId"] = self.slsRegionId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceleratorId") && dict["AcceleratorId"] != nil {
            self.acceleratorId = dict["AcceleratorId"] as! String
        }
        if dict.keys.contains("EndpointGroupId") && dict["EndpointGroupId"] != nil {
            self.endpointGroupId = dict["EndpointGroupId"] as! String
        }
        if dict.keys.contains("ListenerId") && dict["ListenerId"] != nil {
            self.listenerId = dict["ListenerId"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SlsLogStoreName") && dict["SlsLogStoreName"] != nil {
            self.slsLogStoreName = dict["SlsLogStoreName"] as! String
        }
        if dict.keys.contains("SlsProjectName") && dict["SlsProjectName"] != nil {
            self.slsProjectName = dict["SlsProjectName"] as! String
        }
        if dict.keys.contains("SlsRegionId") && dict["SlsRegionId"] != nil {
            self.slsRegionId = dict["SlsRegionId"] as! String
        }
        if dict.keys.contains("Status") && dict["Status"] != nil {
            self.status = dict["Status"] as! String
        }
    }
}

public class DescribeLogStoreOfEndpointGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLogStoreOfEndpointGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeLogStoreOfEndpointGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeRegionsRequest : Tea.TeaModel {
    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DescribeRegionsResponseBody : Tea.TeaModel {
    public class Regions : Tea.TeaModel {
        public var localName: String?

        public var regionId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.localName != nil {
                map["LocalName"] = self.localName!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("LocalName") && dict["LocalName"] != nil {
                self.localName = dict["LocalName"] as! String
            }
            if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
                self.regionId = dict["RegionId"] as! String
            }
        }
    }
    public var regions: [DescribeRegionsResponseBody.Regions]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.regions != nil {
            var tmp : [Any] = []
            for k in self.regions! {
                tmp.append(k.toMap())
            }
            map["Regions"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Regions") && dict["Regions"] != nil {
            var tmp : [DescribeRegionsResponseBody.Regions] = []
            for v in dict["Regions"] as! [Any] {
                var model = DescribeRegionsResponseBody.Regions()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.regions = tmp
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeRegionsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeRegionsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeRegionsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DetachDdosFromAcceleratorRequest : Tea.TeaModel {
    public var acceleratorId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceleratorId != nil {
            map["AcceleratorId"] = self.acceleratorId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceleratorId") && dict["AcceleratorId"] != nil {
            self.acceleratorId = dict["AcceleratorId"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DetachDdosFromAcceleratorResponseBody : Tea.TeaModel {
    public var ddosId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ddosId != nil {
            map["DdosId"] = self.ddosId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DdosId") && dict["DdosId"] != nil {
            self.ddosId = dict["DdosId"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DetachDdosFromAcceleratorResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DetachDdosFromAcceleratorResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DetachDdosFromAcceleratorResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DetachLogStoreFromEndpointGroupRequest : Tea.TeaModel {
    public var acceleratorId: String?

    public var clientToken: String?

    public var endpointGroupIds: [String]?

    public var listenerId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceleratorId != nil {
            map["AcceleratorId"] = self.acceleratorId!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.endpointGroupIds != nil {
            map["EndpointGroupIds"] = self.endpointGroupIds!
        }
        if self.listenerId != nil {
            map["ListenerId"] = self.listenerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceleratorId") && dict["AcceleratorId"] != nil {
            self.acceleratorId = dict["AcceleratorId"] as! String
        }
        if dict.keys.contains("ClientToken") && dict["ClientToken"] != nil {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("EndpointGroupIds") && dict["EndpointGroupIds"] != nil {
            self.endpointGroupIds = dict["EndpointGroupIds"] as! [String]
        }
        if dict.keys.contains("ListenerId") && dict["ListenerId"] != nil {
            self.listenerId = dict["ListenerId"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DetachLogStoreFromEndpointGroupResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DetachLogStoreFromEndpointGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DetachLogStoreFromEndpointGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DetachLogStoreFromEndpointGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DetectApplicationMonitorRequest : Tea.TeaModel {
    public var clientToken: String?

    public var regionId: String?

    public var taskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") && dict["ClientToken"] != nil {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("TaskId") && dict["TaskId"] != nil {
            self.taskId = dict["TaskId"] as! String
        }
    }
}

public class DetectApplicationMonitorResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DetectApplicationMonitorResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DetectApplicationMonitorResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DetectApplicationMonitorResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DisableApplicationMonitorRequest : Tea.TeaModel {
    public var clientToken: String?

    public var regionId: String?

    public var taskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") && dict["ClientToken"] != nil {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("TaskId") && dict["TaskId"] != nil {
            self.taskId = dict["TaskId"] as! String
        }
    }
}

public class DisableApplicationMonitorResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DisableApplicationMonitorResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DisableApplicationMonitorResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DisableApplicationMonitorResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DissociateAclsFromListenerRequest : Tea.TeaModel {
    public var aclIds: [String]?

    public var clientToken: String?

    public var dryRun: Bool?

    public var listenerId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aclIds != nil {
            map["AclIds"] = self.aclIds!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.listenerId != nil {
            map["ListenerId"] = self.listenerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AclIds") && dict["AclIds"] != nil {
            self.aclIds = dict["AclIds"] as! [String]
        }
        if dict.keys.contains("ClientToken") && dict["ClientToken"] != nil {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("DryRun") && dict["DryRun"] != nil {
            self.dryRun = dict["DryRun"] as! Bool
        }
        if dict.keys.contains("ListenerId") && dict["ListenerId"] != nil {
            self.listenerId = dict["ListenerId"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DissociateAclsFromListenerResponseBody : Tea.TeaModel {
    public var aclIds: [String]?

    public var listenerId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aclIds != nil {
            map["AclIds"] = self.aclIds!
        }
        if self.listenerId != nil {
            map["ListenerId"] = self.listenerId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AclIds") && dict["AclIds"] != nil {
            self.aclIds = dict["AclIds"] as! [String]
        }
        if dict.keys.contains("ListenerId") && dict["ListenerId"] != nil {
            self.listenerId = dict["ListenerId"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DissociateAclsFromListenerResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DissociateAclsFromListenerResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DissociateAclsFromListenerResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DissociateAdditionalCertificatesFromListenerRequest : Tea.TeaModel {
    public var acceleratorId: String?

    public var clientToken: String?

    public var domains: [String]?

    public var listenerId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceleratorId != nil {
            map["AcceleratorId"] = self.acceleratorId!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.domains != nil {
            map["Domains"] = self.domains!
        }
        if self.listenerId != nil {
            map["ListenerId"] = self.listenerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceleratorId") && dict["AcceleratorId"] != nil {
            self.acceleratorId = dict["AcceleratorId"] as! String
        }
        if dict.keys.contains("ClientToken") && dict["ClientToken"] != nil {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("Domains") && dict["Domains"] != nil {
            self.domains = dict["Domains"] as! [String]
        }
        if dict.keys.contains("ListenerId") && dict["ListenerId"] != nil {
            self.listenerId = dict["ListenerId"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DissociateAdditionalCertificatesFromListenerResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DissociateAdditionalCertificatesFromListenerResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DissociateAdditionalCertificatesFromListenerResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DissociateAdditionalCertificatesFromListenerResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class EnableApplicationMonitorRequest : Tea.TeaModel {
    public var clientToken: String?

    public var regionId: String?

    public var taskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") && dict["ClientToken"] != nil {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("TaskId") && dict["TaskId"] != nil {
            self.taskId = dict["TaskId"] as! String
        }
    }
}

public class EnableApplicationMonitorResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class EnableApplicationMonitorResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: EnableApplicationMonitorResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = EnableApplicationMonitorResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetAclRequest : Tea.TeaModel {
    public var aclId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aclId != nil {
            map["AclId"] = self.aclId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AclId") && dict["AclId"] != nil {
            self.aclId = dict["AclId"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class GetAclResponseBody : Tea.TeaModel {
    public class AclEntries : Tea.TeaModel {
        public var entry: String?

        public var entryDescription: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.entry != nil {
                map["Entry"] = self.entry!
            }
            if self.entryDescription != nil {
                map["EntryDescription"] = self.entryDescription!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Entry") && dict["Entry"] != nil {
                self.entry = dict["Entry"] as! String
            }
            if dict.keys.contains("EntryDescription") && dict["EntryDescription"] != nil {
                self.entryDescription = dict["EntryDescription"] as! String
            }
        }
    }
    public class RelatedListeners : Tea.TeaModel {
        public var acceleratorId: String?

        public var aclType: String?

        public var listenerId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.acceleratorId != nil {
                map["AcceleratorId"] = self.acceleratorId!
            }
            if self.aclType != nil {
                map["AclType"] = self.aclType!
            }
            if self.listenerId != nil {
                map["ListenerId"] = self.listenerId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AcceleratorId") && dict["AcceleratorId"] != nil {
                self.acceleratorId = dict["AcceleratorId"] as! String
            }
            if dict.keys.contains("AclType") && dict["AclType"] != nil {
                self.aclType = dict["AclType"] as! String
            }
            if dict.keys.contains("ListenerId") && dict["ListenerId"] != nil {
                self.listenerId = dict["ListenerId"] as! String
            }
        }
    }
    public class Tags : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") && dict["Key"] != nil {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") && dict["Value"] != nil {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var aclEntries: [GetAclResponseBody.AclEntries]?

    public var aclId: String?

    public var aclName: String?

    public var aclStatus: String?

    public var addressIPVersion: String?

    public var relatedListeners: [GetAclResponseBody.RelatedListeners]?

    public var requestId: String?

    public var resourceGroupId: String?

    public var tags: [GetAclResponseBody.Tags]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aclEntries != nil {
            var tmp : [Any] = []
            for k in self.aclEntries! {
                tmp.append(k.toMap())
            }
            map["AclEntries"] = tmp
        }
        if self.aclId != nil {
            map["AclId"] = self.aclId!
        }
        if self.aclName != nil {
            map["AclName"] = self.aclName!
        }
        if self.aclStatus != nil {
            map["AclStatus"] = self.aclStatus!
        }
        if self.addressIPVersion != nil {
            map["AddressIPVersion"] = self.addressIPVersion!
        }
        if self.relatedListeners != nil {
            var tmp : [Any] = []
            for k in self.relatedListeners! {
                tmp.append(k.toMap())
            }
            map["RelatedListeners"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.tags != nil {
            var tmp : [Any] = []
            for k in self.tags! {
                tmp.append(k.toMap())
            }
            map["Tags"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AclEntries") && dict["AclEntries"] != nil {
            var tmp : [GetAclResponseBody.AclEntries] = []
            for v in dict["AclEntries"] as! [Any] {
                var model = GetAclResponseBody.AclEntries()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.aclEntries = tmp
        }
        if dict.keys.contains("AclId") && dict["AclId"] != nil {
            self.aclId = dict["AclId"] as! String
        }
        if dict.keys.contains("AclName") && dict["AclName"] != nil {
            self.aclName = dict["AclName"] as! String
        }
        if dict.keys.contains("AclStatus") && dict["AclStatus"] != nil {
            self.aclStatus = dict["AclStatus"] as! String
        }
        if dict.keys.contains("AddressIPVersion") && dict["AddressIPVersion"] != nil {
            self.addressIPVersion = dict["AddressIPVersion"] as! String
        }
        if dict.keys.contains("RelatedListeners") && dict["RelatedListeners"] != nil {
            var tmp : [GetAclResponseBody.RelatedListeners] = []
            for v in dict["RelatedListeners"] as! [Any] {
                var model = GetAclResponseBody.RelatedListeners()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.relatedListeners = tmp
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") && dict["ResourceGroupId"] != nil {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("Tags") && dict["Tags"] != nil {
            var tmp : [GetAclResponseBody.Tags] = []
            for v in dict["Tags"] as! [Any] {
                var model = GetAclResponseBody.Tags()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tags = tmp
        }
    }
}

public class GetAclResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetAclResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetAclResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetBasicAccelerateIpRequest : Tea.TeaModel {
    public var accelerateIpId: String?

    public var clientToken: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accelerateIpId != nil {
            map["AccelerateIpId"] = self.accelerateIpId!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AccelerateIpId") && dict["AccelerateIpId"] != nil {
            self.accelerateIpId = dict["AccelerateIpId"] as! String
        }
        if dict.keys.contains("ClientToken") && dict["ClientToken"] != nil {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class GetBasicAccelerateIpResponseBody : Tea.TeaModel {
    public var accelerateIpAddress: String?

    public var accelerateIpId: String?

    public var acceleratorId: String?

    public var ipSetId: String?

    public var requestId: String?

    public var state: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accelerateIpAddress != nil {
            map["AccelerateIpAddress"] = self.accelerateIpAddress!
        }
        if self.accelerateIpId != nil {
            map["AccelerateIpId"] = self.accelerateIpId!
        }
        if self.acceleratorId != nil {
            map["AcceleratorId"] = self.acceleratorId!
        }
        if self.ipSetId != nil {
            map["IpSetId"] = self.ipSetId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.state != nil {
            map["State"] = self.state!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AccelerateIpAddress") && dict["AccelerateIpAddress"] != nil {
            self.accelerateIpAddress = dict["AccelerateIpAddress"] as! String
        }
        if dict.keys.contains("AccelerateIpId") && dict["AccelerateIpId"] != nil {
            self.accelerateIpId = dict["AccelerateIpId"] as! String
        }
        if dict.keys.contains("AcceleratorId") && dict["AcceleratorId"] != nil {
            self.acceleratorId = dict["AcceleratorId"] as! String
        }
        if dict.keys.contains("IpSetId") && dict["IpSetId"] != nil {
            self.ipSetId = dict["IpSetId"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("State") && dict["State"] != nil {
            self.state = dict["State"] as! String
        }
    }
}

public class GetBasicAccelerateIpResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetBasicAccelerateIpResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetBasicAccelerateIpResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetBasicAccelerateIpEndpointRelationRequest : Tea.TeaModel {
    public var accelerateIpId: String?

    public var acceleratorId: String?

    public var clientToken: String?

    public var endpointId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accelerateIpId != nil {
            map["AccelerateIpId"] = self.accelerateIpId!
        }
        if self.acceleratorId != nil {
            map["AcceleratorId"] = self.acceleratorId!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.endpointId != nil {
            map["EndpointId"] = self.endpointId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AccelerateIpId") && dict["AccelerateIpId"] != nil {
            self.accelerateIpId = dict["AccelerateIpId"] as! String
        }
        if dict.keys.contains("AcceleratorId") && dict["AcceleratorId"] != nil {
            self.acceleratorId = dict["AcceleratorId"] as! String
        }
        if dict.keys.contains("ClientToken") && dict["ClientToken"] != nil {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("EndpointId") && dict["EndpointId"] != nil {
            self.endpointId = dict["EndpointId"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class GetBasicAccelerateIpEndpointRelationResponseBody : Tea.TeaModel {
    public var accelerateIpId: String?

    public var acceleratorId: String?

    public var endpointAddress: String?

    public var endpointId: String?

    public var endpointName: String?

    public var endpointSubAddress: String?

    public var endpointSubAddressType: String?

    public var endpointType: String?

    public var endpointZoneId: String?

    public var ipAddress: String?

    public var requestId: String?

    public var state: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accelerateIpId != nil {
            map["AccelerateIpId"] = self.accelerateIpId!
        }
        if self.acceleratorId != nil {
            map["AcceleratorId"] = self.acceleratorId!
        }
        if self.endpointAddress != nil {
            map["EndpointAddress"] = self.endpointAddress!
        }
        if self.endpointId != nil {
            map["EndpointId"] = self.endpointId!
        }
        if self.endpointName != nil {
            map["EndpointName"] = self.endpointName!
        }
        if self.endpointSubAddress != nil {
            map["EndpointSubAddress"] = self.endpointSubAddress!
        }
        if self.endpointSubAddressType != nil {
            map["EndpointSubAddressType"] = self.endpointSubAddressType!
        }
        if self.endpointType != nil {
            map["EndpointType"] = self.endpointType!
        }
        if self.endpointZoneId != nil {
            map["EndpointZoneId"] = self.endpointZoneId!
        }
        if self.ipAddress != nil {
            map["IpAddress"] = self.ipAddress!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.state != nil {
            map["State"] = self.state!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AccelerateIpId") && dict["AccelerateIpId"] != nil {
            self.accelerateIpId = dict["AccelerateIpId"] as! String
        }
        if dict.keys.contains("AcceleratorId") && dict["AcceleratorId"] != nil {
            self.acceleratorId = dict["AcceleratorId"] as! String
        }
        if dict.keys.contains("EndpointAddress") && dict["EndpointAddress"] != nil {
            self.endpointAddress = dict["EndpointAddress"] as! String
        }
        if dict.keys.contains("EndpointId") && dict["EndpointId"] != nil {
            self.endpointId = dict["EndpointId"] as! String
        }
        if dict.keys.contains("EndpointName") && dict["EndpointName"] != nil {
            self.endpointName = dict["EndpointName"] as! String
        }
        if dict.keys.contains("EndpointSubAddress") && dict["EndpointSubAddress"] != nil {
            self.endpointSubAddress = dict["EndpointSubAddress"] as! String
        }
        if dict.keys.contains("EndpointSubAddressType") && dict["EndpointSubAddressType"] != nil {
            self.endpointSubAddressType = dict["EndpointSubAddressType"] as! String
        }
        if dict.keys.contains("EndpointType") && dict["EndpointType"] != nil {
            self.endpointType = dict["EndpointType"] as! String
        }
        if dict.keys.contains("EndpointZoneId") && dict["EndpointZoneId"] != nil {
            self.endpointZoneId = dict["EndpointZoneId"] as! String
        }
        if dict.keys.contains("IpAddress") && dict["IpAddress"] != nil {
            self.ipAddress = dict["IpAddress"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("State") && dict["State"] != nil {
            self.state = dict["State"] as! String
        }
    }
}

public class GetBasicAccelerateIpEndpointRelationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetBasicAccelerateIpEndpointRelationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetBasicAccelerateIpEndpointRelationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetBasicAccelerateIpIdleCountRequest : Tea.TeaModel {
    public var clientToken: String?

    public var ipSetId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ipSetId != nil {
            map["IpSetId"] = self.ipSetId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") && dict["ClientToken"] != nil {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("IpSetId") && dict["IpSetId"] != nil {
            self.ipSetId = dict["IpSetId"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class GetBasicAccelerateIpIdleCountResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class GetBasicAccelerateIpIdleCountResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetBasicAccelerateIpIdleCountResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetBasicAccelerateIpIdleCountResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetBasicAcceleratorRequest : Tea.TeaModel {
    public var acceleratorId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceleratorId != nil {
            map["AcceleratorId"] = self.acceleratorId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceleratorId") && dict["AcceleratorId"] != nil {
            self.acceleratorId = dict["AcceleratorId"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class GetBasicAcceleratorResponseBody : Tea.TeaModel {
    public class BasicBandwidthPackage : Tea.TeaModel {
        public var bandwidth: Int32?

        public var bandwidthType: String?

        public var instanceId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.bandwidth != nil {
                map["Bandwidth"] = self.bandwidth!
            }
            if self.bandwidthType != nil {
                map["BandwidthType"] = self.bandwidthType!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Bandwidth") && dict["Bandwidth"] != nil {
                self.bandwidth = dict["Bandwidth"] as! Int32
            }
            if dict.keys.contains("BandwidthType") && dict["BandwidthType"] != nil {
                self.bandwidthType = dict["BandwidthType"] as! String
            }
            if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                self.instanceId = dict["InstanceId"] as! String
            }
        }
    }
    public class CrossDomainBandwidthPackage : Tea.TeaModel {
        public var bandwidth: Int32?

        public var instanceId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.bandwidth != nil {
                map["Bandwidth"] = self.bandwidth!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Bandwidth") && dict["Bandwidth"] != nil {
                self.bandwidth = dict["Bandwidth"] as! Int32
            }
            if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                self.instanceId = dict["InstanceId"] as! String
            }
        }
    }
    public class Tags : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") && dict["Key"] != nil {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") && dict["Value"] != nil {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var acceleratorId: String?

    public var bandwidthBillingType: String?

    public var basicBandwidthPackage: GetBasicAcceleratorResponseBody.BasicBandwidthPackage?

    public var basicEndpointGroupId: String?

    public var basicIpSetId: String?

    public var cenId: String?

    public var createTime: Int64?

    public var crossBorderStatus: Bool?

    public var crossDomainBandwidthPackage: GetBasicAcceleratorResponseBody.CrossDomainBandwidthPackage?

    public var crossPrivateState: String?

    public var description_: String?

    public var expiredTime: Int64?

    public var instanceChargeType: String?

    public var name: String?

    public var regionId: String?

    public var requestId: String?

    public var resourceGroupId: String?

    public var state: String?

    public var tags: [GetBasicAcceleratorResponseBody.Tags]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.basicBandwidthPackage?.validate()
        try self.crossDomainBandwidthPackage?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceleratorId != nil {
            map["AcceleratorId"] = self.acceleratorId!
        }
        if self.bandwidthBillingType != nil {
            map["BandwidthBillingType"] = self.bandwidthBillingType!
        }
        if self.basicBandwidthPackage != nil {
            map["BasicBandwidthPackage"] = self.basicBandwidthPackage?.toMap()
        }
        if self.basicEndpointGroupId != nil {
            map["BasicEndpointGroupId"] = self.basicEndpointGroupId!
        }
        if self.basicIpSetId != nil {
            map["BasicIpSetId"] = self.basicIpSetId!
        }
        if self.cenId != nil {
            map["CenId"] = self.cenId!
        }
        if self.createTime != nil {
            map["CreateTime"] = self.createTime!
        }
        if self.crossBorderStatus != nil {
            map["CrossBorderStatus"] = self.crossBorderStatus!
        }
        if self.crossDomainBandwidthPackage != nil {
            map["CrossDomainBandwidthPackage"] = self.crossDomainBandwidthPackage?.toMap()
        }
        if self.crossPrivateState != nil {
            map["CrossPrivateState"] = self.crossPrivateState!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.expiredTime != nil {
            map["ExpiredTime"] = self.expiredTime!
        }
        if self.instanceChargeType != nil {
            map["InstanceChargeType"] = self.instanceChargeType!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.state != nil {
            map["State"] = self.state!
        }
        if self.tags != nil {
            var tmp : [Any] = []
            for k in self.tags! {
                tmp.append(k.toMap())
            }
            map["Tags"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceleratorId") && dict["AcceleratorId"] != nil {
            self.acceleratorId = dict["AcceleratorId"] as! String
        }
        if dict.keys.contains("BandwidthBillingType") && dict["BandwidthBillingType"] != nil {
            self.bandwidthBillingType = dict["BandwidthBillingType"] as! String
        }
        if dict.keys.contains("BasicBandwidthPackage") && dict["BasicBandwidthPackage"] != nil {
            var model = GetBasicAcceleratorResponseBody.BasicBandwidthPackage()
            model.fromMap(dict["BasicBandwidthPackage"] as! [String: Any])
            self.basicBandwidthPackage = model
        }
        if dict.keys.contains("BasicEndpointGroupId") && dict["BasicEndpointGroupId"] != nil {
            self.basicEndpointGroupId = dict["BasicEndpointGroupId"] as! String
        }
        if dict.keys.contains("BasicIpSetId") && dict["BasicIpSetId"] != nil {
            self.basicIpSetId = dict["BasicIpSetId"] as! String
        }
        if dict.keys.contains("CenId") && dict["CenId"] != nil {
            self.cenId = dict["CenId"] as! String
        }
        if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
            self.createTime = dict["CreateTime"] as! Int64
        }
        if dict.keys.contains("CrossBorderStatus") && dict["CrossBorderStatus"] != nil {
            self.crossBorderStatus = dict["CrossBorderStatus"] as! Bool
        }
        if dict.keys.contains("CrossDomainBandwidthPackage") && dict["CrossDomainBandwidthPackage"] != nil {
            var model = GetBasicAcceleratorResponseBody.CrossDomainBandwidthPackage()
            model.fromMap(dict["CrossDomainBandwidthPackage"] as! [String: Any])
            self.crossDomainBandwidthPackage = model
        }
        if dict.keys.contains("CrossPrivateState") && dict["CrossPrivateState"] != nil {
            self.crossPrivateState = dict["CrossPrivateState"] as! String
        }
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("ExpiredTime") && dict["ExpiredTime"] != nil {
            self.expiredTime = dict["ExpiredTime"] as! Int64
        }
        if dict.keys.contains("InstanceChargeType") && dict["InstanceChargeType"] != nil {
            self.instanceChargeType = dict["InstanceChargeType"] as! String
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") && dict["ResourceGroupId"] != nil {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("State") && dict["State"] != nil {
            self.state = dict["State"] as! String
        }
        if dict.keys.contains("Tags") && dict["Tags"] != nil {
            var tmp : [GetBasicAcceleratorResponseBody.Tags] = []
            for v in dict["Tags"] as! [Any] {
                var model = GetBasicAcceleratorResponseBody.Tags()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tags = tmp
        }
    }
}

public class GetBasicAcceleratorResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetBasicAcceleratorResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetBasicAcceleratorResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetBasicEndpointRequest : Tea.TeaModel {
    public var clientToken: String?

    public var endpointId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.endpointId != nil {
            map["EndpointId"] = self.endpointId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") && dict["ClientToken"] != nil {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("EndpointId") && dict["EndpointId"] != nil {
            self.endpointId = dict["EndpointId"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class GetBasicEndpointResponseBody : Tea.TeaModel {
    public var acceleratorId: String?

    public var endPointId: String?

    public var endpointAddress: String?

    public var endpointGroupId: String?

    public var endpointSubAddress: String?

    public var endpointSubAddressType: String?

    public var endpointType: String?

    public var endpointZoneId: String?

    public var name: String?

    public var requestId: String?

    public var state: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceleratorId != nil {
            map["AcceleratorId"] = self.acceleratorId!
        }
        if self.endPointId != nil {
            map["EndPointId"] = self.endPointId!
        }
        if self.endpointAddress != nil {
            map["EndpointAddress"] = self.endpointAddress!
        }
        if self.endpointGroupId != nil {
            map["EndpointGroupId"] = self.endpointGroupId!
        }
        if self.endpointSubAddress != nil {
            map["EndpointSubAddress"] = self.endpointSubAddress!
        }
        if self.endpointSubAddressType != nil {
            map["EndpointSubAddressType"] = self.endpointSubAddressType!
        }
        if self.endpointType != nil {
            map["EndpointType"] = self.endpointType!
        }
        if self.endpointZoneId != nil {
            map["EndpointZoneId"] = self.endpointZoneId!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.state != nil {
            map["State"] = self.state!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceleratorId") && dict["AcceleratorId"] != nil {
            self.acceleratorId = dict["AcceleratorId"] as! String
        }
        if dict.keys.contains("EndPointId") && dict["EndPointId"] != nil {
            self.endPointId = dict["EndPointId"] as! String
        }
        if dict.keys.contains("EndpointAddress") && dict["EndpointAddress"] != nil {
            self.endpointAddress = dict["EndpointAddress"] as! String
        }
        if dict.keys.contains("EndpointGroupId") && dict["EndpointGroupId"] != nil {
            self.endpointGroupId = dict["EndpointGroupId"] as! String
        }
        if dict.keys.contains("EndpointSubAddress") && dict["EndpointSubAddress"] != nil {
            self.endpointSubAddress = dict["EndpointSubAddress"] as! String
        }
        if dict.keys.contains("EndpointSubAddressType") && dict["EndpointSubAddressType"] != nil {
            self.endpointSubAddressType = dict["EndpointSubAddressType"] as! String
        }
        if dict.keys.contains("EndpointType") && dict["EndpointType"] != nil {
            self.endpointType = dict["EndpointType"] as! String
        }
        if dict.keys.contains("EndpointZoneId") && dict["EndpointZoneId"] != nil {
            self.endpointZoneId = dict["EndpointZoneId"] as! String
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("State") && dict["State"] != nil {
            self.state = dict["State"] as! String
        }
    }
}

public class GetBasicEndpointResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetBasicEndpointResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetBasicEndpointResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetBasicEndpointGroupRequest : Tea.TeaModel {
    public var clientToken: String?

    public var endpointGroupId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.endpointGroupId != nil {
            map["EndpointGroupId"] = self.endpointGroupId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") && dict["ClientToken"] != nil {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("EndpointGroupId") && dict["EndpointGroupId"] != nil {
            self.endpointGroupId = dict["EndpointGroupId"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class GetBasicEndpointGroupResponseBody : Tea.TeaModel {
    public var acceleratorId: String?

    public var description_: String?

    public var endpointAddress: String?

    public var endpointGroupId: String?

    public var endpointGroupRegion: String?

    public var endpointSubAddress: String?

    public var endpointType: String?

    public var name: String?

    public var requestId: String?

    public var state: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceleratorId != nil {
            map["AcceleratorId"] = self.acceleratorId!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.endpointAddress != nil {
            map["EndpointAddress"] = self.endpointAddress!
        }
        if self.endpointGroupId != nil {
            map["EndpointGroupId"] = self.endpointGroupId!
        }
        if self.endpointGroupRegion != nil {
            map["EndpointGroupRegion"] = self.endpointGroupRegion!
        }
        if self.endpointSubAddress != nil {
            map["EndpointSubAddress"] = self.endpointSubAddress!
        }
        if self.endpointType != nil {
            map["EndpointType"] = self.endpointType!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.state != nil {
            map["State"] = self.state!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceleratorId") && dict["AcceleratorId"] != nil {
            self.acceleratorId = dict["AcceleratorId"] as! String
        }
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("EndpointAddress") && dict["EndpointAddress"] != nil {
            self.endpointAddress = dict["EndpointAddress"] as! String
        }
        if dict.keys.contains("EndpointGroupId") && dict["EndpointGroupId"] != nil {
            self.endpointGroupId = dict["EndpointGroupId"] as! String
        }
        if dict.keys.contains("EndpointGroupRegion") && dict["EndpointGroupRegion"] != nil {
            self.endpointGroupRegion = dict["EndpointGroupRegion"] as! String
        }
        if dict.keys.contains("EndpointSubAddress") && dict["EndpointSubAddress"] != nil {
            self.endpointSubAddress = dict["EndpointSubAddress"] as! String
        }
        if dict.keys.contains("EndpointType") && dict["EndpointType"] != nil {
            self.endpointType = dict["EndpointType"] as! String
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("State") && dict["State"] != nil {
            self.state = dict["State"] as! String
        }
    }
}

public class GetBasicEndpointGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetBasicEndpointGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetBasicEndpointGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetBasicIpSetRequest : Tea.TeaModel {
    public var clientToken: String?

    public var ipSetId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ipSetId != nil {
            map["IpSetId"] = self.ipSetId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") && dict["ClientToken"] != nil {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("IpSetId") && dict["IpSetId"] != nil {
            self.ipSetId = dict["IpSetId"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class GetBasicIpSetResponseBody : Tea.TeaModel {
    public var accelerateRegionId: String?

    public var acceleratorId: String?

    public var bandwidth: Int64?

    public var ipAddress: String?

    public var ipSetId: String?

    public var ipVersion: String?

    public var ispType: String?

    public var requestId: String?

    public var state: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accelerateRegionId != nil {
            map["AccelerateRegionId"] = self.accelerateRegionId!
        }
        if self.acceleratorId != nil {
            map["AcceleratorId"] = self.acceleratorId!
        }
        if self.bandwidth != nil {
            map["Bandwidth"] = self.bandwidth!
        }
        if self.ipAddress != nil {
            map["IpAddress"] = self.ipAddress!
        }
        if self.ipSetId != nil {
            map["IpSetId"] = self.ipSetId!
        }
        if self.ipVersion != nil {
            map["IpVersion"] = self.ipVersion!
        }
        if self.ispType != nil {
            map["IspType"] = self.ispType!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.state != nil {
            map["State"] = self.state!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AccelerateRegionId") && dict["AccelerateRegionId"] != nil {
            self.accelerateRegionId = dict["AccelerateRegionId"] as! String
        }
        if dict.keys.contains("AcceleratorId") && dict["AcceleratorId"] != nil {
            self.acceleratorId = dict["AcceleratorId"] as! String
        }
        if dict.keys.contains("Bandwidth") && dict["Bandwidth"] != nil {
            self.bandwidth = dict["Bandwidth"] as! Int64
        }
        if dict.keys.contains("IpAddress") && dict["IpAddress"] != nil {
            self.ipAddress = dict["IpAddress"] as! String
        }
        if dict.keys.contains("IpSetId") && dict["IpSetId"] != nil {
            self.ipSetId = dict["IpSetId"] as! String
        }
        if dict.keys.contains("IpVersion") && dict["IpVersion"] != nil {
            self.ipVersion = dict["IpVersion"] as! String
        }
        if dict.keys.contains("IspType") && dict["IspType"] != nil {
            self.ispType = dict["IspType"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("State") && dict["State"] != nil {
            self.state = dict["State"] as! String
        }
    }
}

public class GetBasicIpSetResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetBasicIpSetResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetBasicIpSetResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetHealthStatusRequest : Tea.TeaModel {
    public var acceleratorId: String?

    public var clientToken: String?

    public var dryRun: Bool?

    public var listenerId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceleratorId != nil {
            map["AcceleratorId"] = self.acceleratorId!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.listenerId != nil {
            map["ListenerId"] = self.listenerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceleratorId") && dict["AcceleratorId"] != nil {
            self.acceleratorId = dict["AcceleratorId"] as! String
        }
        if dict.keys.contains("ClientToken") && dict["ClientToken"] != nil {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("DryRun") && dict["DryRun"] != nil {
            self.dryRun = dict["DryRun"] as! Bool
        }
        if dict.keys.contains("ListenerId") && dict["ListenerId"] != nil {
            self.listenerId = dict["ListenerId"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class GetHealthStatusResponseBody : Tea.TeaModel {
    public class EndpointGroups : Tea.TeaModel {
        public class Endpoints : Tea.TeaModel {
            public var address: String?

            public var endpointId: String?

            public var healthDetail: String?

            public var healthStatus: String?

            public var port: Int64?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.address != nil {
                    map["Address"] = self.address!
                }
                if self.endpointId != nil {
                    map["EndpointId"] = self.endpointId!
                }
                if self.healthDetail != nil {
                    map["HealthDetail"] = self.healthDetail!
                }
                if self.healthStatus != nil {
                    map["HealthStatus"] = self.healthStatus!
                }
                if self.port != nil {
                    map["Port"] = self.port!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Address") && dict["Address"] != nil {
                    self.address = dict["Address"] as! String
                }
                if dict.keys.contains("EndpointId") && dict["EndpointId"] != nil {
                    self.endpointId = dict["EndpointId"] as! String
                }
                if dict.keys.contains("HealthDetail") && dict["HealthDetail"] != nil {
                    self.healthDetail = dict["HealthDetail"] as! String
                }
                if dict.keys.contains("HealthStatus") && dict["HealthStatus"] != nil {
                    self.healthStatus = dict["HealthStatus"] as! String
                }
                if dict.keys.contains("Port") && dict["Port"] != nil {
                    self.port = dict["Port"] as! Int64
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var endpointGroupId: String?

        public var endpointGroupType: String?

        public var endpoints: [GetHealthStatusResponseBody.EndpointGroups.Endpoints]?

        public var forwardingRuleIds: [String]?

        public var healthStatus: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.endpointGroupId != nil {
                map["EndpointGroupId"] = self.endpointGroupId!
            }
            if self.endpointGroupType != nil {
                map["EndpointGroupType"] = self.endpointGroupType!
            }
            if self.endpoints != nil {
                var tmp : [Any] = []
                for k in self.endpoints! {
                    tmp.append(k.toMap())
                }
                map["Endpoints"] = tmp
            }
            if self.forwardingRuleIds != nil {
                map["ForwardingRuleIds"] = self.forwardingRuleIds!
            }
            if self.healthStatus != nil {
                map["HealthStatus"] = self.healthStatus!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EndpointGroupId") && dict["EndpointGroupId"] != nil {
                self.endpointGroupId = dict["EndpointGroupId"] as! String
            }
            if dict.keys.contains("EndpointGroupType") && dict["EndpointGroupType"] != nil {
                self.endpointGroupType = dict["EndpointGroupType"] as! String
            }
            if dict.keys.contains("Endpoints") && dict["Endpoints"] != nil {
                var tmp : [GetHealthStatusResponseBody.EndpointGroups.Endpoints] = []
                for v in dict["Endpoints"] as! [Any] {
                    var model = GetHealthStatusResponseBody.EndpointGroups.Endpoints()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.endpoints = tmp
            }
            if dict.keys.contains("ForwardingRuleIds") && dict["ForwardingRuleIds"] != nil {
                self.forwardingRuleIds = dict["ForwardingRuleIds"] as! [String]
            }
            if dict.keys.contains("HealthStatus") && dict["HealthStatus"] != nil {
                self.healthStatus = dict["HealthStatus"] as! String
            }
        }
    }
    public var endpointGroups: [GetHealthStatusResponseBody.EndpointGroups]?

    public var healthStatus: String?

    public var listenerId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endpointGroups != nil {
            var tmp : [Any] = []
            for k in self.endpointGroups! {
                tmp.append(k.toMap())
            }
            map["EndpointGroups"] = tmp
        }
        if self.healthStatus != nil {
            map["HealthStatus"] = self.healthStatus!
        }
        if self.listenerId != nil {
            map["ListenerId"] = self.listenerId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndpointGroups") && dict["EndpointGroups"] != nil {
            var tmp : [GetHealthStatusResponseBody.EndpointGroups] = []
            for v in dict["EndpointGroups"] as! [Any] {
                var model = GetHealthStatusResponseBody.EndpointGroups()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.endpointGroups = tmp
        }
        if dict.keys.contains("HealthStatus") && dict["HealthStatus"] != nil {
            self.healthStatus = dict["HealthStatus"] as! String
        }
        if dict.keys.contains("ListenerId") && dict["ListenerId"] != nil {
            self.listenerId = dict["ListenerId"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetHealthStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetHealthStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetHealthStatusResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetInvalidDomainCountRequest : Tea.TeaModel {
    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class GetInvalidDomainCountResponseBody : Tea.TeaModel {
    public var invalidDomainCount: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.invalidDomainCount != nil {
            map["InvalidDomainCount"] = self.invalidDomainCount!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InvalidDomainCount") && dict["InvalidDomainCount"] != nil {
            self.invalidDomainCount = dict["InvalidDomainCount"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetInvalidDomainCountResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetInvalidDomainCountResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetInvalidDomainCountResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetIpsetsBandwidthLimitRequest : Tea.TeaModel {
    public var acceleratorId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceleratorId != nil {
            map["AcceleratorId"] = self.acceleratorId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceleratorId") && dict["AcceleratorId"] != nil {
            self.acceleratorId = dict["AcceleratorId"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class GetIpsetsBandwidthLimitResponseBody : Tea.TeaModel {
    public var bandwidthAllocationType: String?

    public var bandwidthLimit: Int64?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bandwidthAllocationType != nil {
            map["BandwidthAllocationType"] = self.bandwidthAllocationType!
        }
        if self.bandwidthLimit != nil {
            map["BandwidthLimit"] = self.bandwidthLimit!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BandwidthAllocationType") && dict["BandwidthAllocationType"] != nil {
            self.bandwidthAllocationType = dict["BandwidthAllocationType"] as! String
        }
        if dict.keys.contains("BandwidthLimit") && dict["BandwidthLimit"] != nil {
            self.bandwidthLimit = dict["BandwidthLimit"] as! Int64
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetIpsetsBandwidthLimitResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetIpsetsBandwidthLimitResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetIpsetsBandwidthLimitResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetSpareIpRequest : Tea.TeaModel {
    public var acceleratorId: String?

    public var clientToken: String?

    public var dryRun: Bool?

    public var regionId: String?

    public var spareIp: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceleratorId != nil {
            map["AcceleratorId"] = self.acceleratorId!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.spareIp != nil {
            map["SpareIp"] = self.spareIp!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceleratorId") && dict["AcceleratorId"] != nil {
            self.acceleratorId = dict["AcceleratorId"] as! String
        }
        if dict.keys.contains("ClientToken") && dict["ClientToken"] != nil {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("DryRun") && dict["DryRun"] != nil {
            self.dryRun = dict["DryRun"] as! Bool
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("SpareIp") && dict["SpareIp"] != nil {
            self.spareIp = dict["SpareIp"] as! String
        }
    }
}

public class GetSpareIpResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var state: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.state != nil {
            map["State"] = self.state!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("State") && dict["State"] != nil {
            self.state = dict["State"] as! String
        }
    }
}

public class GetSpareIpResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetSpareIpResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetSpareIpResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListAccelerateAreasRequest : Tea.TeaModel {
    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class ListAccelerateAreasResponseBody : Tea.TeaModel {
    public class Areas : Tea.TeaModel {
        public class RegionList : Tea.TeaModel {
            public var localName: String?

            public var regionId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.localName != nil {
                    map["LocalName"] = self.localName!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("LocalName") && dict["LocalName"] != nil {
                    self.localName = dict["LocalName"] as! String
                }
                if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
                    self.regionId = dict["RegionId"] as! String
                }
            }
        }
        public var areaId: String?

        public var localName: String?

        public var regionList: [ListAccelerateAreasResponseBody.Areas.RegionList]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.areaId != nil {
                map["AreaId"] = self.areaId!
            }
            if self.localName != nil {
                map["LocalName"] = self.localName!
            }
            if self.regionList != nil {
                var tmp : [Any] = []
                for k in self.regionList! {
                    tmp.append(k.toMap())
                }
                map["RegionList"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AreaId") && dict["AreaId"] != nil {
                self.areaId = dict["AreaId"] as! String
            }
            if dict.keys.contains("LocalName") && dict["LocalName"] != nil {
                self.localName = dict["LocalName"] as! String
            }
            if dict.keys.contains("RegionList") && dict["RegionList"] != nil {
                var tmp : [ListAccelerateAreasResponseBody.Areas.RegionList] = []
                for v in dict["RegionList"] as! [Any] {
                    var model = ListAccelerateAreasResponseBody.Areas.RegionList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.regionList = tmp
            }
        }
    }
    public var areas: [ListAccelerateAreasResponseBody.Areas]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.areas != nil {
            var tmp : [Any] = []
            for k in self.areas! {
                tmp.append(k.toMap())
            }
            map["Areas"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Areas") && dict["Areas"] != nil {
            var tmp : [ListAccelerateAreasResponseBody.Areas] = []
            for v in dict["Areas"] as! [Any] {
                var model = ListAccelerateAreasResponseBody.Areas()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.areas = tmp
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListAccelerateAreasResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListAccelerateAreasResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListAccelerateAreasResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListAcceleratorsRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") && dict["Key"] != nil {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") && dict["Value"] != nil {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var acceleratorId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceGroupId: String?

    public var state: String?

    public var tag: [ListAcceleratorsRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceleratorId != nil {
            map["AcceleratorId"] = self.acceleratorId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.state != nil {
            map["State"] = self.state!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceleratorId") && dict["AcceleratorId"] != nil {
            self.acceleratorId = dict["AcceleratorId"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") && dict["ResourceGroupId"] != nil {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("State") && dict["State"] != nil {
            self.state = dict["State"] as! String
        }
        if dict.keys.contains("Tag") && dict["Tag"] != nil {
            var tmp : [ListAcceleratorsRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = ListAcceleratorsRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
    }
}

public class ListAcceleratorsResponseBody : Tea.TeaModel {
    public class Accelerators : Tea.TeaModel {
        public class BasicBandwidthPackage : Tea.TeaModel {
            public var bandwidth: Int32?

            public var bandwidthType: String?

            public var instanceId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bandwidth != nil {
                    map["Bandwidth"] = self.bandwidth!
                }
                if self.bandwidthType != nil {
                    map["BandwidthType"] = self.bandwidthType!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Bandwidth") && dict["Bandwidth"] != nil {
                    self.bandwidth = dict["Bandwidth"] as! Int32
                }
                if dict.keys.contains("BandwidthType") && dict["BandwidthType"] != nil {
                    self.bandwidthType = dict["BandwidthType"] as! String
                }
                if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                    self.instanceId = dict["InstanceId"] as! String
                }
            }
        }
        public class CrossDomainBandwidthPackage : Tea.TeaModel {
            public var bandwidth: Int32?

            public var instanceId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bandwidth != nil {
                    map["Bandwidth"] = self.bandwidth!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Bandwidth") && dict["Bandwidth"] != nil {
                    self.bandwidth = dict["Bandwidth"] as! Int32
                }
                if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                    self.instanceId = dict["InstanceId"] as! String
                }
            }
        }
        public class IpSetConfig : Tea.TeaModel {
            public var accessMode: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.accessMode != nil {
                    map["AccessMode"] = self.accessMode!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AccessMode") && dict["AccessMode"] != nil {
                    self.accessMode = dict["AccessMode"] as! String
                }
            }
        }
        public class ServiceManagedInfos : Tea.TeaModel {
            public var action: String?

            public var childType: String?

            public var isManaged: Bool?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.action != nil {
                    map["Action"] = self.action!
                }
                if self.childType != nil {
                    map["ChildType"] = self.childType!
                }
                if self.isManaged != nil {
                    map["IsManaged"] = self.isManaged!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Action") && dict["Action"] != nil {
                    self.action = dict["Action"] as! String
                }
                if dict.keys.contains("ChildType") && dict["ChildType"] != nil {
                    self.childType = dict["ChildType"] as! String
                }
                if dict.keys.contains("IsManaged") && dict["IsManaged"] != nil {
                    self.isManaged = dict["IsManaged"] as! Bool
                }
            }
        }
        public class Tags : Tea.TeaModel {
            public var key: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Key") && dict["Key"] != nil {
                    self.key = dict["Key"] as! String
                }
                if dict.keys.contains("Value") && dict["Value"] != nil {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public var acceleratorId: String?

        public var bandwidth: Int32?

        public var bandwidthBillingType: String?

        public var basicBandwidthPackage: ListAcceleratorsResponseBody.Accelerators.BasicBandwidthPackage?

        public var cenId: String?

        public var createTime: Int64?

        public var crossBorderMode: String?

        public var crossBorderStatus: Bool?

        public var crossDomainBandwidthPackage: ListAcceleratorsResponseBody.Accelerators.CrossDomainBandwidthPackage?

        public var ddosId: String?

        public var description_: String?

        public var dnsName: String?

        public var expiredTime: Int64?

        public var instanceChargeType: String?

        public var ipSetConfig: ListAcceleratorsResponseBody.Accelerators.IpSetConfig?

        public var name: String?

        public var regionId: String?

        public var resourceGroupId: String?

        public var secondDnsName: String?

        public var serviceId: String?

        public var serviceManaged: Bool?

        public var serviceManagedInfos: [ListAcceleratorsResponseBody.Accelerators.ServiceManagedInfos]?

        public var spec: String?

        public var state: String?

        public var tags: [ListAcceleratorsResponseBody.Accelerators.Tags]?

        public var type: String?

        public var upgradableStatus: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.basicBandwidthPackage?.validate()
            try self.crossDomainBandwidthPackage?.validate()
            try self.ipSetConfig?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.acceleratorId != nil {
                map["AcceleratorId"] = self.acceleratorId!
            }
            if self.bandwidth != nil {
                map["Bandwidth"] = self.bandwidth!
            }
            if self.bandwidthBillingType != nil {
                map["BandwidthBillingType"] = self.bandwidthBillingType!
            }
            if self.basicBandwidthPackage != nil {
                map["BasicBandwidthPackage"] = self.basicBandwidthPackage?.toMap()
            }
            if self.cenId != nil {
                map["CenId"] = self.cenId!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.crossBorderMode != nil {
                map["CrossBorderMode"] = self.crossBorderMode!
            }
            if self.crossBorderStatus != nil {
                map["CrossBorderStatus"] = self.crossBorderStatus!
            }
            if self.crossDomainBandwidthPackage != nil {
                map["CrossDomainBandwidthPackage"] = self.crossDomainBandwidthPackage?.toMap()
            }
            if self.ddosId != nil {
                map["DdosId"] = self.ddosId!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.dnsName != nil {
                map["DnsName"] = self.dnsName!
            }
            if self.expiredTime != nil {
                map["ExpiredTime"] = self.expiredTime!
            }
            if self.instanceChargeType != nil {
                map["InstanceChargeType"] = self.instanceChargeType!
            }
            if self.ipSetConfig != nil {
                map["IpSetConfig"] = self.ipSetConfig?.toMap()
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.resourceGroupId != nil {
                map["ResourceGroupId"] = self.resourceGroupId!
            }
            if self.secondDnsName != nil {
                map["SecondDnsName"] = self.secondDnsName!
            }
            if self.serviceId != nil {
                map["ServiceId"] = self.serviceId!
            }
            if self.serviceManaged != nil {
                map["ServiceManaged"] = self.serviceManaged!
            }
            if self.serviceManagedInfos != nil {
                var tmp : [Any] = []
                for k in self.serviceManagedInfos! {
                    tmp.append(k.toMap())
                }
                map["ServiceManagedInfos"] = tmp
            }
            if self.spec != nil {
                map["Spec"] = self.spec!
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            if self.tags != nil {
                var tmp : [Any] = []
                for k in self.tags! {
                    tmp.append(k.toMap())
                }
                map["Tags"] = tmp
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.upgradableStatus != nil {
                map["UpgradableStatus"] = self.upgradableStatus!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AcceleratorId") && dict["AcceleratorId"] != nil {
                self.acceleratorId = dict["AcceleratorId"] as! String
            }
            if dict.keys.contains("Bandwidth") && dict["Bandwidth"] != nil {
                self.bandwidth = dict["Bandwidth"] as! Int32
            }
            if dict.keys.contains("BandwidthBillingType") && dict["BandwidthBillingType"] != nil {
                self.bandwidthBillingType = dict["BandwidthBillingType"] as! String
            }
            if dict.keys.contains("BasicBandwidthPackage") && dict["BasicBandwidthPackage"] != nil {
                var model = ListAcceleratorsResponseBody.Accelerators.BasicBandwidthPackage()
                model.fromMap(dict["BasicBandwidthPackage"] as! [String: Any])
                self.basicBandwidthPackage = model
            }
            if dict.keys.contains("CenId") && dict["CenId"] != nil {
                self.cenId = dict["CenId"] as! String
            }
            if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                self.createTime = dict["CreateTime"] as! Int64
            }
            if dict.keys.contains("CrossBorderMode") && dict["CrossBorderMode"] != nil {
                self.crossBorderMode = dict["CrossBorderMode"] as! String
            }
            if dict.keys.contains("CrossBorderStatus") && dict["CrossBorderStatus"] != nil {
                self.crossBorderStatus = dict["CrossBorderStatus"] as! Bool
            }
            if dict.keys.contains("CrossDomainBandwidthPackage") && dict["CrossDomainBandwidthPackage"] != nil {
                var model = ListAcceleratorsResponseBody.Accelerators.CrossDomainBandwidthPackage()
                model.fromMap(dict["CrossDomainBandwidthPackage"] as! [String: Any])
                self.crossDomainBandwidthPackage = model
            }
            if dict.keys.contains("DdosId") && dict["DdosId"] != nil {
                self.ddosId = dict["DdosId"] as! String
            }
            if dict.keys.contains("Description") && dict["Description"] != nil {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("DnsName") && dict["DnsName"] != nil {
                self.dnsName = dict["DnsName"] as! String
            }
            if dict.keys.contains("ExpiredTime") && dict["ExpiredTime"] != nil {
                self.expiredTime = dict["ExpiredTime"] as! Int64
            }
            if dict.keys.contains("InstanceChargeType") && dict["InstanceChargeType"] != nil {
                self.instanceChargeType = dict["InstanceChargeType"] as! String
            }
            if dict.keys.contains("IpSetConfig") && dict["IpSetConfig"] != nil {
                var model = ListAcceleratorsResponseBody.Accelerators.IpSetConfig()
                model.fromMap(dict["IpSetConfig"] as! [String: Any])
                self.ipSetConfig = model
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("ResourceGroupId") && dict["ResourceGroupId"] != nil {
                self.resourceGroupId = dict["ResourceGroupId"] as! String
            }
            if dict.keys.contains("SecondDnsName") && dict["SecondDnsName"] != nil {
                self.secondDnsName = dict["SecondDnsName"] as! String
            }
            if dict.keys.contains("ServiceId") && dict["ServiceId"] != nil {
                self.serviceId = dict["ServiceId"] as! String
            }
            if dict.keys.contains("ServiceManaged") && dict["ServiceManaged"] != nil {
                self.serviceManaged = dict["ServiceManaged"] as! Bool
            }
            if dict.keys.contains("ServiceManagedInfos") && dict["ServiceManagedInfos"] != nil {
                var tmp : [ListAcceleratorsResponseBody.Accelerators.ServiceManagedInfos] = []
                for v in dict["ServiceManagedInfos"] as! [Any] {
                    var model = ListAcceleratorsResponseBody.Accelerators.ServiceManagedInfos()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.serviceManagedInfos = tmp
            }
            if dict.keys.contains("Spec") && dict["Spec"] != nil {
                self.spec = dict["Spec"] as! String
            }
            if dict.keys.contains("State") && dict["State"] != nil {
                self.state = dict["State"] as! String
            }
            if dict.keys.contains("Tags") && dict["Tags"] != nil {
                var tmp : [ListAcceleratorsResponseBody.Accelerators.Tags] = []
                for v in dict["Tags"] as! [Any] {
                    var model = ListAcceleratorsResponseBody.Accelerators.Tags()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.tags = tmp
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
            if dict.keys.contains("UpgradableStatus") && dict["UpgradableStatus"] != nil {
                self.upgradableStatus = dict["UpgradableStatus"] as! String
            }
        }
    }
    public var accelerators: [ListAcceleratorsResponseBody.Accelerators]?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accelerators != nil {
            var tmp : [Any] = []
            for k in self.accelerators! {
                tmp.append(k.toMap())
            }
            map["Accelerators"] = tmp
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Accelerators") && dict["Accelerators"] != nil {
            var tmp : [ListAcceleratorsResponseBody.Accelerators] = []
            for v in dict["Accelerators"] as! [Any] {
                var model = ListAcceleratorsResponseBody.Accelerators()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.accelerators = tmp
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class ListAcceleratorsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListAcceleratorsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListAcceleratorsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListAclsRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") && dict["Key"] != nil {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") && dict["Value"] != nil {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var aclIds: [String]?

    public var aclName: String?

    public var clientToken: String?

    public var maxResults: Int32?

    public var nextToken: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var tag: [ListAclsRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aclIds != nil {
            map["AclIds"] = self.aclIds!
        }
        if self.aclName != nil {
            map["AclName"] = self.aclName!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AclIds") && dict["AclIds"] != nil {
            self.aclIds = dict["AclIds"] as! [String]
        }
        if dict.keys.contains("AclName") && dict["AclName"] != nil {
            self.aclName = dict["AclName"] as! String
        }
        if dict.keys.contains("ClientToken") && dict["ClientToken"] != nil {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("MaxResults") && dict["MaxResults"] != nil {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") && dict["NextToken"] != nil {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") && dict["ResourceGroupId"] != nil {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("Tag") && dict["Tag"] != nil {
            var tmp : [ListAclsRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = ListAclsRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
    }
}

public class ListAclsResponseBody : Tea.TeaModel {
    public class Acls : Tea.TeaModel {
        public class Tags : Tea.TeaModel {
            public var key: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Key") && dict["Key"] != nil {
                    self.key = dict["Key"] as! String
                }
                if dict.keys.contains("Value") && dict["Value"] != nil {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public var aclId: String?

        public var aclName: String?

        public var aclStatus: String?

        public var addressIPVersion: String?

        public var resourceGroupId: String?

        public var tags: [ListAclsResponseBody.Acls.Tags]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.aclId != nil {
                map["AclId"] = self.aclId!
            }
            if self.aclName != nil {
                map["AclName"] = self.aclName!
            }
            if self.aclStatus != nil {
                map["AclStatus"] = self.aclStatus!
            }
            if self.addressIPVersion != nil {
                map["AddressIPVersion"] = self.addressIPVersion!
            }
            if self.resourceGroupId != nil {
                map["ResourceGroupId"] = self.resourceGroupId!
            }
            if self.tags != nil {
                var tmp : [Any] = []
                for k in self.tags! {
                    tmp.append(k.toMap())
                }
                map["Tags"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AclId") && dict["AclId"] != nil {
                self.aclId = dict["AclId"] as! String
            }
            if dict.keys.contains("AclName") && dict["AclName"] != nil {
                self.aclName = dict["AclName"] as! String
            }
            if dict.keys.contains("AclStatus") && dict["AclStatus"] != nil {
                self.aclStatus = dict["AclStatus"] as! String
            }
            if dict.keys.contains("AddressIPVersion") && dict["AddressIPVersion"] != nil {
                self.addressIPVersion = dict["AddressIPVersion"] as! String
            }
            if dict.keys.contains("ResourceGroupId") && dict["ResourceGroupId"] != nil {
                self.resourceGroupId = dict["ResourceGroupId"] as! String
            }
            if dict.keys.contains("Tags") && dict["Tags"] != nil {
                var tmp : [ListAclsResponseBody.Acls.Tags] = []
                for v in dict["Tags"] as! [Any] {
                    var model = ListAclsResponseBody.Acls.Tags()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.tags = tmp
            }
        }
    }
    public var acls: [ListAclsResponseBody.Acls]?

    public var maxResults: Int32?

    public var nextToken: String?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acls != nil {
            var tmp : [Any] = []
            for k in self.acls! {
                tmp.append(k.toMap())
            }
            map["Acls"] = tmp
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Acls") && dict["Acls"] != nil {
            var tmp : [ListAclsResponseBody.Acls] = []
            for v in dict["Acls"] as! [Any] {
                var model = ListAclsResponseBody.Acls()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.acls = tmp
        }
        if dict.keys.contains("MaxResults") && dict["MaxResults"] != nil {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") && dict["NextToken"] != nil {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class ListAclsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListAclsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListAclsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListApplicationMonitorRequest : Tea.TeaModel {
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var searchValue: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.searchValue != nil {
            map["SearchValue"] = self.searchValue!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("SearchValue") && dict["SearchValue"] != nil {
            self.searchValue = dict["SearchValue"] as! String
        }
    }
}

public class ListApplicationMonitorResponseBody : Tea.TeaModel {
    public class ApplicationMonitors : Tea.TeaModel {
        public var acceleratorId: String?

        public var address: String?

        public var detectEnable: Bool?

        public var detectThreshold: Int32?

        public var detectTimes: Int32?

        public var listenerId: String?

        public var optionsJson: String?

        public var silenceTime: Int32?

        public var state: String?

        public var taskId: String?

        public var taskName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.acceleratorId != nil {
                map["AcceleratorId"] = self.acceleratorId!
            }
            if self.address != nil {
                map["Address"] = self.address!
            }
            if self.detectEnable != nil {
                map["DetectEnable"] = self.detectEnable!
            }
            if self.detectThreshold != nil {
                map["DetectThreshold"] = self.detectThreshold!
            }
            if self.detectTimes != nil {
                map["DetectTimes"] = self.detectTimes!
            }
            if self.listenerId != nil {
                map["ListenerId"] = self.listenerId!
            }
            if self.optionsJson != nil {
                map["OptionsJson"] = self.optionsJson!
            }
            if self.silenceTime != nil {
                map["SilenceTime"] = self.silenceTime!
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            if self.taskId != nil {
                map["TaskId"] = self.taskId!
            }
            if self.taskName != nil {
                map["TaskName"] = self.taskName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AcceleratorId") && dict["AcceleratorId"] != nil {
                self.acceleratorId = dict["AcceleratorId"] as! String
            }
            if dict.keys.contains("Address") && dict["Address"] != nil {
                self.address = dict["Address"] as! String
            }
            if dict.keys.contains("DetectEnable") && dict["DetectEnable"] != nil {
                self.detectEnable = dict["DetectEnable"] as! Bool
            }
            if dict.keys.contains("DetectThreshold") && dict["DetectThreshold"] != nil {
                self.detectThreshold = dict["DetectThreshold"] as! Int32
            }
            if dict.keys.contains("DetectTimes") && dict["DetectTimes"] != nil {
                self.detectTimes = dict["DetectTimes"] as! Int32
            }
            if dict.keys.contains("ListenerId") && dict["ListenerId"] != nil {
                self.listenerId = dict["ListenerId"] as! String
            }
            if dict.keys.contains("OptionsJson") && dict["OptionsJson"] != nil {
                self.optionsJson = dict["OptionsJson"] as! String
            }
            if dict.keys.contains("SilenceTime") && dict["SilenceTime"] != nil {
                self.silenceTime = dict["SilenceTime"] as! Int32
            }
            if dict.keys.contains("State") && dict["State"] != nil {
                self.state = dict["State"] as! String
            }
            if dict.keys.contains("TaskId") && dict["TaskId"] != nil {
                self.taskId = dict["TaskId"] as! String
            }
            if dict.keys.contains("TaskName") && dict["TaskName"] != nil {
                self.taskName = dict["TaskName"] as! String
            }
        }
    }
    public var applicationMonitors: [ListApplicationMonitorResponseBody.ApplicationMonitors]?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.applicationMonitors != nil {
            var tmp : [Any] = []
            for k in self.applicationMonitors! {
                tmp.append(k.toMap())
            }
            map["ApplicationMonitors"] = tmp
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApplicationMonitors") && dict["ApplicationMonitors"] != nil {
            var tmp : [ListApplicationMonitorResponseBody.ApplicationMonitors] = []
            for v in dict["ApplicationMonitors"] as! [Any] {
                var model = ListApplicationMonitorResponseBody.ApplicationMonitors()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.applicationMonitors = tmp
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class ListApplicationMonitorResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListApplicationMonitorResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListApplicationMonitorResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListApplicationMonitorDetectResultRequest : Tea.TeaModel {
    public var beginTime: Int64?

    public var endTime: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var taskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.beginTime != nil {
            map["BeginTime"] = self.beginTime!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BeginTime") && dict["BeginTime"] != nil {
            self.beginTime = dict["BeginTime"] as! Int64
        }
        if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("TaskId") && dict["TaskId"] != nil {
            self.taskId = dict["TaskId"] as! String
        }
    }
}

public class ListApplicationMonitorDetectResultResponseBody : Tea.TeaModel {
    public class ApplicationMonitorDetectResultList : Tea.TeaModel {
        public var acceleratorId: String?

        public var content: String?

        public var detail: String?

        public var detectTime: String?

        public var diagStatus: String?

        public var listenerId: String?

        public var port: String?

        public var protocol_: String?

        public var statusCode: String?

        public var taskId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.acceleratorId != nil {
                map["AcceleratorId"] = self.acceleratorId!
            }
            if self.content != nil {
                map["Content"] = self.content!
            }
            if self.detail != nil {
                map["Detail"] = self.detail!
            }
            if self.detectTime != nil {
                map["DetectTime"] = self.detectTime!
            }
            if self.diagStatus != nil {
                map["DiagStatus"] = self.diagStatus!
            }
            if self.listenerId != nil {
                map["ListenerId"] = self.listenerId!
            }
            if self.port != nil {
                map["Port"] = self.port!
            }
            if self.protocol_ != nil {
                map["Protocol"] = self.protocol_!
            }
            if self.statusCode != nil {
                map["StatusCode"] = self.statusCode!
            }
            if self.taskId != nil {
                map["TaskId"] = self.taskId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AcceleratorId") && dict["AcceleratorId"] != nil {
                self.acceleratorId = dict["AcceleratorId"] as! String
            }
            if dict.keys.contains("Content") && dict["Content"] != nil {
                self.content = dict["Content"] as! String
            }
            if dict.keys.contains("Detail") && dict["Detail"] != nil {
                self.detail = dict["Detail"] as! String
            }
            if dict.keys.contains("DetectTime") && dict["DetectTime"] != nil {
                self.detectTime = dict["DetectTime"] as! String
            }
            if dict.keys.contains("DiagStatus") && dict["DiagStatus"] != nil {
                self.diagStatus = dict["DiagStatus"] as! String
            }
            if dict.keys.contains("ListenerId") && dict["ListenerId"] != nil {
                self.listenerId = dict["ListenerId"] as! String
            }
            if dict.keys.contains("Port") && dict["Port"] != nil {
                self.port = dict["Port"] as! String
            }
            if dict.keys.contains("Protocol") && dict["Protocol"] != nil {
                self.protocol_ = dict["Protocol"] as! String
            }
            if dict.keys.contains("StatusCode") && dict["StatusCode"] != nil {
                self.statusCode = dict["StatusCode"] as! String
            }
            if dict.keys.contains("TaskId") && dict["TaskId"] != nil {
                self.taskId = dict["TaskId"] as! String
            }
        }
    }
    public var applicationMonitorDetectResultList: [ListApplicationMonitorDetectResultResponseBody.ApplicationMonitorDetectResultList]?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.applicationMonitorDetectResultList != nil {
            var tmp : [Any] = []
            for k in self.applicationMonitorDetectResultList! {
                tmp.append(k.toMap())
            }
            map["ApplicationMonitorDetectResultList"] = tmp
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApplicationMonitorDetectResultList") && dict["ApplicationMonitorDetectResultList"] != nil {
            var tmp : [ListApplicationMonitorDetectResultResponseBody.ApplicationMonitorDetectResultList] = []
            for v in dict["ApplicationMonitorDetectResultList"] as! [Any] {
                var model = ListApplicationMonitorDetectResultResponseBody.ApplicationMonitorDetectResultList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.applicationMonitorDetectResultList = tmp
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class ListApplicationMonitorDetectResultResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListApplicationMonitorDetectResultResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListApplicationMonitorDetectResultResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListAvailableAccelerateAreasRequest : Tea.TeaModel {
    public var acceleratorId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceleratorId != nil {
            map["AcceleratorId"] = self.acceleratorId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceleratorId") && dict["AcceleratorId"] != nil {
            self.acceleratorId = dict["AcceleratorId"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class ListAvailableAccelerateAreasResponseBody : Tea.TeaModel {
    public class Areas : Tea.TeaModel {
        public class RegionList : Tea.TeaModel {
            public var chinaMainland: Bool?

            public var ispTypeList: [String]?

            public var localName: String?

            public var regionId: String?

            public var supportIpv6: Bool?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.chinaMainland != nil {
                    map["ChinaMainland"] = self.chinaMainland!
                }
                if self.ispTypeList != nil {
                    map["IspTypeList"] = self.ispTypeList!
                }
                if self.localName != nil {
                    map["LocalName"] = self.localName!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.supportIpv6 != nil {
                    map["SupportIpv6"] = self.supportIpv6!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ChinaMainland") && dict["ChinaMainland"] != nil {
                    self.chinaMainland = dict["ChinaMainland"] as! Bool
                }
                if dict.keys.contains("IspTypeList") && dict["IspTypeList"] != nil {
                    self.ispTypeList = dict["IspTypeList"] as! [String]
                }
                if dict.keys.contains("LocalName") && dict["LocalName"] != nil {
                    self.localName = dict["LocalName"] as! String
                }
                if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("SupportIpv6") && dict["SupportIpv6"] != nil {
                    self.supportIpv6 = dict["SupportIpv6"] as! Bool
                }
            }
        }
        public var areaId: String?

        public var localName: String?

        public var regionList: [ListAvailableAccelerateAreasResponseBody.Areas.RegionList]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.areaId != nil {
                map["AreaId"] = self.areaId!
            }
            if self.localName != nil {
                map["LocalName"] = self.localName!
            }
            if self.regionList != nil {
                var tmp : [Any] = []
                for k in self.regionList! {
                    tmp.append(k.toMap())
                }
                map["RegionList"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AreaId") && dict["AreaId"] != nil {
                self.areaId = dict["AreaId"] as! String
            }
            if dict.keys.contains("LocalName") && dict["LocalName"] != nil {
                self.localName = dict["LocalName"] as! String
            }
            if dict.keys.contains("RegionList") && dict["RegionList"] != nil {
                var tmp : [ListAvailableAccelerateAreasResponseBody.Areas.RegionList] = []
                for v in dict["RegionList"] as! [Any] {
                    var model = ListAvailableAccelerateAreasResponseBody.Areas.RegionList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.regionList = tmp
            }
        }
    }
    public var areas: [ListAvailableAccelerateAreasResponseBody.Areas]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.areas != nil {
            var tmp : [Any] = []
            for k in self.areas! {
                tmp.append(k.toMap())
            }
            map["Areas"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Areas") && dict["Areas"] != nil {
            var tmp : [ListAvailableAccelerateAreasResponseBody.Areas] = []
            for v in dict["Areas"] as! [Any] {
                var model = ListAvailableAccelerateAreasResponseBody.Areas()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.areas = tmp
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListAvailableAccelerateAreasResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListAvailableAccelerateAreasResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListAvailableAccelerateAreasResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListAvailableBusiRegionsRequest : Tea.TeaModel {
    public var acceleratorId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceleratorId != nil {
            map["AcceleratorId"] = self.acceleratorId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceleratorId") && dict["AcceleratorId"] != nil {
            self.acceleratorId = dict["AcceleratorId"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class ListAvailableBusiRegionsResponseBody : Tea.TeaModel {
    public class Regions : Tea.TeaModel {
        public var chinaMainland: Bool?

        public var localName: String?

        public var pop: Bool?

        public var regionId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.chinaMainland != nil {
                map["ChinaMainland"] = self.chinaMainland!
            }
            if self.localName != nil {
                map["LocalName"] = self.localName!
            }
            if self.pop != nil {
                map["Pop"] = self.pop!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ChinaMainland") && dict["ChinaMainland"] != nil {
                self.chinaMainland = dict["ChinaMainland"] as! Bool
            }
            if dict.keys.contains("LocalName") && dict["LocalName"] != nil {
                self.localName = dict["LocalName"] as! String
            }
            if dict.keys.contains("Pop") && dict["Pop"] != nil {
                self.pop = dict["Pop"] as! Bool
            }
            if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
                self.regionId = dict["RegionId"] as! String
            }
        }
    }
    public var regions: [ListAvailableBusiRegionsResponseBody.Regions]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.regions != nil {
            var tmp : [Any] = []
            for k in self.regions! {
                tmp.append(k.toMap())
            }
            map["Regions"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Regions") && dict["Regions"] != nil {
            var tmp : [ListAvailableBusiRegionsResponseBody.Regions] = []
            for v in dict["Regions"] as! [Any] {
                var model = ListAvailableBusiRegionsResponseBody.Regions()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.regions = tmp
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListAvailableBusiRegionsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListAvailableBusiRegionsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListAvailableBusiRegionsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListBandwidthPackagesRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") && dict["Key"] != nil {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") && dict["Value"] != nil {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var bandwidthPackageId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceGroupId: String?

    public var state: String?

    public var tag: [ListBandwidthPackagesRequest.Tag]?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bandwidthPackageId != nil {
            map["BandwidthPackageId"] = self.bandwidthPackageId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.state != nil {
            map["State"] = self.state!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BandwidthPackageId") && dict["BandwidthPackageId"] != nil {
            self.bandwidthPackageId = dict["BandwidthPackageId"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") && dict["ResourceGroupId"] != nil {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("State") && dict["State"] != nil {
            self.state = dict["State"] as! String
        }
        if dict.keys.contains("Tag") && dict["Tag"] != nil {
            var tmp : [ListBandwidthPackagesRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = ListBandwidthPackagesRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! String
        }
    }
}

public class ListBandwidthPackagesResponseBody : Tea.TeaModel {
    public class BandwidthPackages : Tea.TeaModel {
        public class Tags : Tea.TeaModel {
            public var key: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Key") && dict["Key"] != nil {
                    self.key = dict["Key"] as! String
                }
                if dict.keys.contains("Value") && dict["Value"] != nil {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public var accelerators: [String]?

        public var bandwidth: Int32?

        public var bandwidthPackageId: String?

        public var bandwidthType: String?

        public var billingType: String?

        public var cbnGeographicRegionIdA: String?

        public var cbnGeographicRegionIdB: String?

        public var chargeType: String?

        public var createTime: String?

        public var description_: String?

        public var expiredTime: String?

        public var name: String?

        public var ratio: Int32?

        public var regionId: String?

        public var resourceGroupId: String?

        public var state: String?

        public var tags: [ListBandwidthPackagesResponseBody.BandwidthPackages.Tags]?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accelerators != nil {
                map["Accelerators"] = self.accelerators!
            }
            if self.bandwidth != nil {
                map["Bandwidth"] = self.bandwidth!
            }
            if self.bandwidthPackageId != nil {
                map["BandwidthPackageId"] = self.bandwidthPackageId!
            }
            if self.bandwidthType != nil {
                map["BandwidthType"] = self.bandwidthType!
            }
            if self.billingType != nil {
                map["BillingType"] = self.billingType!
            }
            if self.cbnGeographicRegionIdA != nil {
                map["CbnGeographicRegionIdA"] = self.cbnGeographicRegionIdA!
            }
            if self.cbnGeographicRegionIdB != nil {
                map["CbnGeographicRegionIdB"] = self.cbnGeographicRegionIdB!
            }
            if self.chargeType != nil {
                map["ChargeType"] = self.chargeType!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.expiredTime != nil {
                map["ExpiredTime"] = self.expiredTime!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.ratio != nil {
                map["Ratio"] = self.ratio!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.resourceGroupId != nil {
                map["ResourceGroupId"] = self.resourceGroupId!
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            if self.tags != nil {
                var tmp : [Any] = []
                for k in self.tags! {
                    tmp.append(k.toMap())
                }
                map["Tags"] = tmp
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Accelerators") && dict["Accelerators"] != nil {
                self.accelerators = dict["Accelerators"] as! [String]
            }
            if dict.keys.contains("Bandwidth") && dict["Bandwidth"] != nil {
                self.bandwidth = dict["Bandwidth"] as! Int32
            }
            if dict.keys.contains("BandwidthPackageId") && dict["BandwidthPackageId"] != nil {
                self.bandwidthPackageId = dict["BandwidthPackageId"] as! String
            }
            if dict.keys.contains("BandwidthType") && dict["BandwidthType"] != nil {
                self.bandwidthType = dict["BandwidthType"] as! String
            }
            if dict.keys.contains("BillingType") && dict["BillingType"] != nil {
                self.billingType = dict["BillingType"] as! String
            }
            if dict.keys.contains("CbnGeographicRegionIdA") && dict["CbnGeographicRegionIdA"] != nil {
                self.cbnGeographicRegionIdA = dict["CbnGeographicRegionIdA"] as! String
            }
            if dict.keys.contains("CbnGeographicRegionIdB") && dict["CbnGeographicRegionIdB"] != nil {
                self.cbnGeographicRegionIdB = dict["CbnGeographicRegionIdB"] as! String
            }
            if dict.keys.contains("ChargeType") && dict["ChargeType"] != nil {
                self.chargeType = dict["ChargeType"] as! String
            }
            if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("Description") && dict["Description"] != nil {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("ExpiredTime") && dict["ExpiredTime"] != nil {
                self.expiredTime = dict["ExpiredTime"] as! String
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Ratio") && dict["Ratio"] != nil {
                self.ratio = dict["Ratio"] as! Int32
            }
            if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("ResourceGroupId") && dict["ResourceGroupId"] != nil {
                self.resourceGroupId = dict["ResourceGroupId"] as! String
            }
            if dict.keys.contains("State") && dict["State"] != nil {
                self.state = dict["State"] as! String
            }
            if dict.keys.contains("Tags") && dict["Tags"] != nil {
                var tmp : [ListBandwidthPackagesResponseBody.BandwidthPackages.Tags] = []
                for v in dict["Tags"] as! [Any] {
                    var model = ListBandwidthPackagesResponseBody.BandwidthPackages.Tags()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.tags = tmp
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var bandwidthPackages: [ListBandwidthPackagesResponseBody.BandwidthPackages]?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bandwidthPackages != nil {
            var tmp : [Any] = []
            for k in self.bandwidthPackages! {
                tmp.append(k.toMap())
            }
            map["BandwidthPackages"] = tmp
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BandwidthPackages") && dict["BandwidthPackages"] != nil {
            var tmp : [ListBandwidthPackagesResponseBody.BandwidthPackages] = []
            for v in dict["BandwidthPackages"] as! [Any] {
                var model = ListBandwidthPackagesResponseBody.BandwidthPackages()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.bandwidthPackages = tmp
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class ListBandwidthPackagesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListBandwidthPackagesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListBandwidthPackagesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListBandwidthackagesRequest : Tea.TeaModel {
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class ListBandwidthackagesResponseBody : Tea.TeaModel {
    public class BandwidthPackages : Tea.TeaModel {
        public class Tags : Tea.TeaModel {
            public var key: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Key") && dict["Key"] != nil {
                    self.key = dict["Key"] as! String
                }
                if dict.keys.contains("Value") && dict["Value"] != nil {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public var accelerators: [String]?

        public var bandwidth: Int32?

        public var bandwidthPackageId: String?

        public var chargeType: String?

        public var createTime: String?

        public var description_: String?

        public var expiredTime: String?

        public var name: String?

        public var regionId: String?

        public var resourceGroupId: String?

        public var state: String?

        public var tags: [ListBandwidthackagesResponseBody.BandwidthPackages.Tags]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accelerators != nil {
                map["Accelerators"] = self.accelerators!
            }
            if self.bandwidth != nil {
                map["Bandwidth"] = self.bandwidth!
            }
            if self.bandwidthPackageId != nil {
                map["BandwidthPackageId"] = self.bandwidthPackageId!
            }
            if self.chargeType != nil {
                map["ChargeType"] = self.chargeType!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.expiredTime != nil {
                map["ExpiredTime"] = self.expiredTime!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.resourceGroupId != nil {
                map["ResourceGroupId"] = self.resourceGroupId!
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            if self.tags != nil {
                var tmp : [Any] = []
                for k in self.tags! {
                    tmp.append(k.toMap())
                }
                map["Tags"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Accelerators") && dict["Accelerators"] != nil {
                self.accelerators = dict["Accelerators"] as! [String]
            }
            if dict.keys.contains("Bandwidth") && dict["Bandwidth"] != nil {
                self.bandwidth = dict["Bandwidth"] as! Int32
            }
            if dict.keys.contains("BandwidthPackageId") && dict["BandwidthPackageId"] != nil {
                self.bandwidthPackageId = dict["BandwidthPackageId"] as! String
            }
            if dict.keys.contains("ChargeType") && dict["ChargeType"] != nil {
                self.chargeType = dict["ChargeType"] as! String
            }
            if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("Description") && dict["Description"] != nil {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("ExpiredTime") && dict["ExpiredTime"] != nil {
                self.expiredTime = dict["ExpiredTime"] as! String
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("ResourceGroupId") && dict["ResourceGroupId"] != nil {
                self.resourceGroupId = dict["ResourceGroupId"] as! String
            }
            if dict.keys.contains("State") && dict["State"] != nil {
                self.state = dict["State"] as! String
            }
            if dict.keys.contains("Tags") && dict["Tags"] != nil {
                var tmp : [ListBandwidthackagesResponseBody.BandwidthPackages.Tags] = []
                for v in dict["Tags"] as! [Any] {
                    var model = ListBandwidthackagesResponseBody.BandwidthPackages.Tags()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.tags = tmp
            }
        }
    }
    public var bandwidthPackages: [ListBandwidthackagesResponseBody.BandwidthPackages]?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bandwidthPackages != nil {
            var tmp : [Any] = []
            for k in self.bandwidthPackages! {
                tmp.append(k.toMap())
            }
            map["BandwidthPackages"] = tmp
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BandwidthPackages") && dict["BandwidthPackages"] != nil {
            var tmp : [ListBandwidthackagesResponseBody.BandwidthPackages] = []
            for v in dict["BandwidthPackages"] as! [Any] {
                var model = ListBandwidthackagesResponseBody.BandwidthPackages()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.bandwidthPackages = tmp
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class ListBandwidthackagesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListBandwidthackagesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListBandwidthackagesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListBasicAccelerateIpEndpointRelationsRequest : Tea.TeaModel {
    public var accelerateIpId: String?

    public var acceleratorId: String?

    public var clientToken: String?

    public var endpointId: String?

    public var maxResults: Int32?

    public var nextToken: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accelerateIpId != nil {
            map["AccelerateIpId"] = self.accelerateIpId!
        }
        if self.acceleratorId != nil {
            map["AcceleratorId"] = self.acceleratorId!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.endpointId != nil {
            map["EndpointId"] = self.endpointId!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AccelerateIpId") && dict["AccelerateIpId"] != nil {
            self.accelerateIpId = dict["AccelerateIpId"] as! String
        }
        if dict.keys.contains("AcceleratorId") && dict["AcceleratorId"] != nil {
            self.acceleratorId = dict["AcceleratorId"] as! String
        }
        if dict.keys.contains("ClientToken") && dict["ClientToken"] != nil {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("EndpointId") && dict["EndpointId"] != nil {
            self.endpointId = dict["EndpointId"] as! String
        }
        if dict.keys.contains("MaxResults") && dict["MaxResults"] != nil {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") && dict["NextToken"] != nil {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class ListBasicAccelerateIpEndpointRelationsResponseBody : Tea.TeaModel {
    public class AccelerateIpEndpointRelations : Tea.TeaModel {
        public var accelerateIpId: String?

        public var acceleratorId: String?

        public var endpointAddress: String?

        public var endpointId: String?

        public var endpointName: String?

        public var endpointSubAddress: String?

        public var endpointSubAddressType: String?

        public var endpointType: String?

        public var endpointZoneId: String?

        public var ipAddress: String?

        public var state: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accelerateIpId != nil {
                map["AccelerateIpId"] = self.accelerateIpId!
            }
            if self.acceleratorId != nil {
                map["AcceleratorId"] = self.acceleratorId!
            }
            if self.endpointAddress != nil {
                map["EndpointAddress"] = self.endpointAddress!
            }
            if self.endpointId != nil {
                map["EndpointId"] = self.endpointId!
            }
            if self.endpointName != nil {
                map["EndpointName"] = self.endpointName!
            }
            if self.endpointSubAddress != nil {
                map["EndpointSubAddress"] = self.endpointSubAddress!
            }
            if self.endpointSubAddressType != nil {
                map["EndpointSubAddressType"] = self.endpointSubAddressType!
            }
            if self.endpointType != nil {
                map["EndpointType"] = self.endpointType!
            }
            if self.endpointZoneId != nil {
                map["EndpointZoneId"] = self.endpointZoneId!
            }
            if self.ipAddress != nil {
                map["IpAddress"] = self.ipAddress!
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AccelerateIpId") && dict["AccelerateIpId"] != nil {
                self.accelerateIpId = dict["AccelerateIpId"] as! String
            }
            if dict.keys.contains("AcceleratorId") && dict["AcceleratorId"] != nil {
                self.acceleratorId = dict["AcceleratorId"] as! String
            }
            if dict.keys.contains("EndpointAddress") && dict["EndpointAddress"] != nil {
                self.endpointAddress = dict["EndpointAddress"] as! String
            }
            if dict.keys.contains("EndpointId") && dict["EndpointId"] != nil {
                self.endpointId = dict["EndpointId"] as! String
            }
            if dict.keys.contains("EndpointName") && dict["EndpointName"] != nil {
                self.endpointName = dict["EndpointName"] as! String
            }
            if dict.keys.contains("EndpointSubAddress") && dict["EndpointSubAddress"] != nil {
                self.endpointSubAddress = dict["EndpointSubAddress"] as! String
            }
            if dict.keys.contains("EndpointSubAddressType") && dict["EndpointSubAddressType"] != nil {
                self.endpointSubAddressType = dict["EndpointSubAddressType"] as! String
            }
            if dict.keys.contains("EndpointType") && dict["EndpointType"] != nil {
                self.endpointType = dict["EndpointType"] as! String
            }
            if dict.keys.contains("EndpointZoneId") && dict["EndpointZoneId"] != nil {
                self.endpointZoneId = dict["EndpointZoneId"] as! String
            }
            if dict.keys.contains("IpAddress") && dict["IpAddress"] != nil {
                self.ipAddress = dict["IpAddress"] as! String
            }
            if dict.keys.contains("State") && dict["State"] != nil {
                self.state = dict["State"] as! String
            }
        }
    }
    public var accelerateIpEndpointRelations: [ListBasicAccelerateIpEndpointRelationsResponseBody.AccelerateIpEndpointRelations]?

    public var maxResults: String?

    public var nextToken: String?

    public var requestId: String?

    public var totalCount: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accelerateIpEndpointRelations != nil {
            var tmp : [Any] = []
            for k in self.accelerateIpEndpointRelations! {
                tmp.append(k.toMap())
            }
            map["AccelerateIpEndpointRelations"] = tmp
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AccelerateIpEndpointRelations") && dict["AccelerateIpEndpointRelations"] != nil {
            var tmp : [ListBasicAccelerateIpEndpointRelationsResponseBody.AccelerateIpEndpointRelations] = []
            for v in dict["AccelerateIpEndpointRelations"] as! [Any] {
                var model = ListBasicAccelerateIpEndpointRelationsResponseBody.AccelerateIpEndpointRelations()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.accelerateIpEndpointRelations = tmp
        }
        if dict.keys.contains("MaxResults") && dict["MaxResults"] != nil {
            self.maxResults = dict["MaxResults"] as! String
        }
        if dict.keys.contains("NextToken") && dict["NextToken"] != nil {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! String
        }
    }
}

public class ListBasicAccelerateIpEndpointRelationsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListBasicAccelerateIpEndpointRelationsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListBasicAccelerateIpEndpointRelationsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListBasicAccelerateIpsRequest : Tea.TeaModel {
    public var accelerateIpAddress: String?

    public var accelerateIpId: String?

    public var clientToken: String?

    public var ipSetId: String?

    public var maxResults: Int32?

    public var nextToken: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accelerateIpAddress != nil {
            map["AccelerateIpAddress"] = self.accelerateIpAddress!
        }
        if self.accelerateIpId != nil {
            map["AccelerateIpId"] = self.accelerateIpId!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ipSetId != nil {
            map["IpSetId"] = self.ipSetId!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AccelerateIpAddress") && dict["AccelerateIpAddress"] != nil {
            self.accelerateIpAddress = dict["AccelerateIpAddress"] as! String
        }
        if dict.keys.contains("AccelerateIpId") && dict["AccelerateIpId"] != nil {
            self.accelerateIpId = dict["AccelerateIpId"] as! String
        }
        if dict.keys.contains("ClientToken") && dict["ClientToken"] != nil {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("IpSetId") && dict["IpSetId"] != nil {
            self.ipSetId = dict["IpSetId"] as! String
        }
        if dict.keys.contains("MaxResults") && dict["MaxResults"] != nil {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") && dict["NextToken"] != nil {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class ListBasicAccelerateIpsResponseBody : Tea.TeaModel {
    public class AccelerateIps : Tea.TeaModel {
        public var accelerateIpAddress: String?

        public var accelerateIpId: String?

        public var acceleratorId: String?

        public var ipSetId: String?

        public var state: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accelerateIpAddress != nil {
                map["AccelerateIpAddress"] = self.accelerateIpAddress!
            }
            if self.accelerateIpId != nil {
                map["AccelerateIpId"] = self.accelerateIpId!
            }
            if self.acceleratorId != nil {
                map["AcceleratorId"] = self.acceleratorId!
            }
            if self.ipSetId != nil {
                map["IpSetId"] = self.ipSetId!
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AccelerateIpAddress") && dict["AccelerateIpAddress"] != nil {
                self.accelerateIpAddress = dict["AccelerateIpAddress"] as! String
            }
            if dict.keys.contains("AccelerateIpId") && dict["AccelerateIpId"] != nil {
                self.accelerateIpId = dict["AccelerateIpId"] as! String
            }
            if dict.keys.contains("AcceleratorId") && dict["AcceleratorId"] != nil {
                self.acceleratorId = dict["AcceleratorId"] as! String
            }
            if dict.keys.contains("IpSetId") && dict["IpSetId"] != nil {
                self.ipSetId = dict["IpSetId"] as! String
            }
            if dict.keys.contains("State") && dict["State"] != nil {
                self.state = dict["State"] as! String
            }
        }
    }
    public var accelerateIps: [ListBasicAccelerateIpsResponseBody.AccelerateIps]?

    public var maxResults: Int32?

    public var nextToken: String?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accelerateIps != nil {
            var tmp : [Any] = []
            for k in self.accelerateIps! {
                tmp.append(k.toMap())
            }
            map["AccelerateIps"] = tmp
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AccelerateIps") && dict["AccelerateIps"] != nil {
            var tmp : [ListBasicAccelerateIpsResponseBody.AccelerateIps] = []
            for v in dict["AccelerateIps"] as! [Any] {
                var model = ListBasicAccelerateIpsResponseBody.AccelerateIps()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.accelerateIps = tmp
        }
        if dict.keys.contains("MaxResults") && dict["MaxResults"] != nil {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") && dict["NextToken"] != nil {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class ListBasicAccelerateIpsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListBasicAccelerateIpsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListBasicAccelerateIpsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListBasicAcceleratorsRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") && dict["Key"] != nil {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") && dict["Value"] != nil {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var acceleratorId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceGroupId: String?

    public var state: String?

    public var tag: [ListBasicAcceleratorsRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceleratorId != nil {
            map["AcceleratorId"] = self.acceleratorId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.state != nil {
            map["State"] = self.state!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceleratorId") && dict["AcceleratorId"] != nil {
            self.acceleratorId = dict["AcceleratorId"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") && dict["ResourceGroupId"] != nil {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("State") && dict["State"] != nil {
            self.state = dict["State"] as! String
        }
        if dict.keys.contains("Tag") && dict["Tag"] != nil {
            var tmp : [ListBasicAcceleratorsRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = ListBasicAcceleratorsRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
    }
}

public class ListBasicAcceleratorsResponseBody : Tea.TeaModel {
    public class Accelerators : Tea.TeaModel {
        public class BasicBandwidthPackage : Tea.TeaModel {
            public var bandwidth: Int32?

            public var bandwidthType: String?

            public var instanceId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bandwidth != nil {
                    map["Bandwidth"] = self.bandwidth!
                }
                if self.bandwidthType != nil {
                    map["BandwidthType"] = self.bandwidthType!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Bandwidth") && dict["Bandwidth"] != nil {
                    self.bandwidth = dict["Bandwidth"] as! Int32
                }
                if dict.keys.contains("BandwidthType") && dict["BandwidthType"] != nil {
                    self.bandwidthType = dict["BandwidthType"] as! String
                }
                if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                    self.instanceId = dict["InstanceId"] as! String
                }
            }
        }
        public class CrossDomainBandwidthPackage : Tea.TeaModel {
            public var bandwidth: Int32?

            public var instanceId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bandwidth != nil {
                    map["Bandwidth"] = self.bandwidth!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Bandwidth") && dict["Bandwidth"] != nil {
                    self.bandwidth = dict["Bandwidth"] as! Int32
                }
                if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                    self.instanceId = dict["InstanceId"] as! String
                }
            }
        }
        public class Tags : Tea.TeaModel {
            public var key: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Key") && dict["Key"] != nil {
                    self.key = dict["Key"] as! String
                }
                if dict.keys.contains("Value") && dict["Value"] != nil {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public var acceleratorId: String?

        public var bandwidthBillingType: String?

        public var basicBandwidthPackage: ListBasicAcceleratorsResponseBody.Accelerators.BasicBandwidthPackage?

        public var basicEndpointGroupId: String?

        public var basicIpSetId: String?

        public var createTime: Int64?

        public var crossBorderStatus: Bool?

        public var crossDomainBandwidthPackage: ListBasicAcceleratorsResponseBody.Accelerators.CrossDomainBandwidthPackage?

        public var description_: String?

        public var expiredTime: Int64?

        public var instanceChargeType: String?

        public var name: String?

        public var regionId: String?

        public var resourceGroupId: String?

        public var state: String?

        public var tags: [ListBasicAcceleratorsResponseBody.Accelerators.Tags]?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.basicBandwidthPackage?.validate()
            try self.crossDomainBandwidthPackage?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.acceleratorId != nil {
                map["AcceleratorId"] = self.acceleratorId!
            }
            if self.bandwidthBillingType != nil {
                map["BandwidthBillingType"] = self.bandwidthBillingType!
            }
            if self.basicBandwidthPackage != nil {
                map["BasicBandwidthPackage"] = self.basicBandwidthPackage?.toMap()
            }
            if self.basicEndpointGroupId != nil {
                map["BasicEndpointGroupId"] = self.basicEndpointGroupId!
            }
            if self.basicIpSetId != nil {
                map["BasicIpSetId"] = self.basicIpSetId!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.crossBorderStatus != nil {
                map["CrossBorderStatus"] = self.crossBorderStatus!
            }
            if self.crossDomainBandwidthPackage != nil {
                map["CrossDomainBandwidthPackage"] = self.crossDomainBandwidthPackage?.toMap()
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.expiredTime != nil {
                map["ExpiredTime"] = self.expiredTime!
            }
            if self.instanceChargeType != nil {
                map["InstanceChargeType"] = self.instanceChargeType!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.resourceGroupId != nil {
                map["ResourceGroupId"] = self.resourceGroupId!
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            if self.tags != nil {
                var tmp : [Any] = []
                for k in self.tags! {
                    tmp.append(k.toMap())
                }
                map["Tags"] = tmp
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AcceleratorId") && dict["AcceleratorId"] != nil {
                self.acceleratorId = dict["AcceleratorId"] as! String
            }
            if dict.keys.contains("BandwidthBillingType") && dict["BandwidthBillingType"] != nil {
                self.bandwidthBillingType = dict["BandwidthBillingType"] as! String
            }
            if dict.keys.contains("BasicBandwidthPackage") && dict["BasicBandwidthPackage"] != nil {
                var model = ListBasicAcceleratorsResponseBody.Accelerators.BasicBandwidthPackage()
                model.fromMap(dict["BasicBandwidthPackage"] as! [String: Any])
                self.basicBandwidthPackage = model
            }
            if dict.keys.contains("BasicEndpointGroupId") && dict["BasicEndpointGroupId"] != nil {
                self.basicEndpointGroupId = dict["BasicEndpointGroupId"] as! String
            }
            if dict.keys.contains("BasicIpSetId") && dict["BasicIpSetId"] != nil {
                self.basicIpSetId = dict["BasicIpSetId"] as! String
            }
            if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                self.createTime = dict["CreateTime"] as! Int64
            }
            if dict.keys.contains("CrossBorderStatus") && dict["CrossBorderStatus"] != nil {
                self.crossBorderStatus = dict["CrossBorderStatus"] as! Bool
            }
            if dict.keys.contains("CrossDomainBandwidthPackage") && dict["CrossDomainBandwidthPackage"] != nil {
                var model = ListBasicAcceleratorsResponseBody.Accelerators.CrossDomainBandwidthPackage()
                model.fromMap(dict["CrossDomainBandwidthPackage"] as! [String: Any])
                self.crossDomainBandwidthPackage = model
            }
            if dict.keys.contains("Description") && dict["Description"] != nil {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("ExpiredTime") && dict["ExpiredTime"] != nil {
                self.expiredTime = dict["ExpiredTime"] as! Int64
            }
            if dict.keys.contains("InstanceChargeType") && dict["InstanceChargeType"] != nil {
                self.instanceChargeType = dict["InstanceChargeType"] as! String
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("ResourceGroupId") && dict["ResourceGroupId"] != nil {
                self.resourceGroupId = dict["ResourceGroupId"] as! String
            }
            if dict.keys.contains("State") && dict["State"] != nil {
                self.state = dict["State"] as! String
            }
            if dict.keys.contains("Tags") && dict["Tags"] != nil {
                var tmp : [ListBasicAcceleratorsResponseBody.Accelerators.Tags] = []
                for v in dict["Tags"] as! [Any] {
                    var model = ListBasicAcceleratorsResponseBody.Accelerators.Tags()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.tags = tmp
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var accelerators: [ListBasicAcceleratorsResponseBody.Accelerators]?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accelerators != nil {
            var tmp : [Any] = []
            for k in self.accelerators! {
                tmp.append(k.toMap())
            }
            map["Accelerators"] = tmp
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Accelerators") && dict["Accelerators"] != nil {
            var tmp : [ListBasicAcceleratorsResponseBody.Accelerators] = []
            for v in dict["Accelerators"] as! [Any] {
                var model = ListBasicAcceleratorsResponseBody.Accelerators()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.accelerators = tmp
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class ListBasicAcceleratorsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListBasicAcceleratorsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListBasicAcceleratorsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListBasicEndpointsRequest : Tea.TeaModel {
    public var clientToken: String?

    public var endpointGroupId: String?

    public var endpointId: String?

    public var endpointType: String?

    public var maxResults: Int32?

    public var name: String?

    public var nextToken: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.endpointGroupId != nil {
            map["EndpointGroupId"] = self.endpointGroupId!
        }
        if self.endpointId != nil {
            map["EndpointId"] = self.endpointId!
        }
        if self.endpointType != nil {
            map["EndpointType"] = self.endpointType!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") && dict["ClientToken"] != nil {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("EndpointGroupId") && dict["EndpointGroupId"] != nil {
            self.endpointGroupId = dict["EndpointGroupId"] as! String
        }
        if dict.keys.contains("EndpointId") && dict["EndpointId"] != nil {
            self.endpointId = dict["EndpointId"] as! String
        }
        if dict.keys.contains("EndpointType") && dict["EndpointType"] != nil {
            self.endpointType = dict["EndpointType"] as! String
        }
        if dict.keys.contains("MaxResults") && dict["MaxResults"] != nil {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("NextToken") && dict["NextToken"] != nil {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class ListBasicEndpointsResponseBody : Tea.TeaModel {
    public class Endpoints : Tea.TeaModel {
        public var acceleratorId: String?

        public var endpointAddress: String?

        public var endpointGroupId: String?

        public var endpointId: String?

        public var endpointSubAddress: String?

        public var endpointSubAddressType: String?

        public var endpointType: String?

        public var endpointZoneId: String?

        public var name: String?

        public var state: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.acceleratorId != nil {
                map["AcceleratorId"] = self.acceleratorId!
            }
            if self.endpointAddress != nil {
                map["EndpointAddress"] = self.endpointAddress!
            }
            if self.endpointGroupId != nil {
                map["EndpointGroupId"] = self.endpointGroupId!
            }
            if self.endpointId != nil {
                map["EndpointId"] = self.endpointId!
            }
            if self.endpointSubAddress != nil {
                map["EndpointSubAddress"] = self.endpointSubAddress!
            }
            if self.endpointSubAddressType != nil {
                map["EndpointSubAddressType"] = self.endpointSubAddressType!
            }
            if self.endpointType != nil {
                map["EndpointType"] = self.endpointType!
            }
            if self.endpointZoneId != nil {
                map["EndpointZoneId"] = self.endpointZoneId!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AcceleratorId") && dict["AcceleratorId"] != nil {
                self.acceleratorId = dict["AcceleratorId"] as! String
            }
            if dict.keys.contains("EndpointAddress") && dict["EndpointAddress"] != nil {
                self.endpointAddress = dict["EndpointAddress"] as! String
            }
            if dict.keys.contains("EndpointGroupId") && dict["EndpointGroupId"] != nil {
                self.endpointGroupId = dict["EndpointGroupId"] as! String
            }
            if dict.keys.contains("EndpointId") && dict["EndpointId"] != nil {
                self.endpointId = dict["EndpointId"] as! String
            }
            if dict.keys.contains("EndpointSubAddress") && dict["EndpointSubAddress"] != nil {
                self.endpointSubAddress = dict["EndpointSubAddress"] as! String
            }
            if dict.keys.contains("EndpointSubAddressType") && dict["EndpointSubAddressType"] != nil {
                self.endpointSubAddressType = dict["EndpointSubAddressType"] as! String
            }
            if dict.keys.contains("EndpointType") && dict["EndpointType"] != nil {
                self.endpointType = dict["EndpointType"] as! String
            }
            if dict.keys.contains("EndpointZoneId") && dict["EndpointZoneId"] != nil {
                self.endpointZoneId = dict["EndpointZoneId"] as! String
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("State") && dict["State"] != nil {
                self.state = dict["State"] as! String
            }
        }
    }
    public var endpoints: [ListBasicEndpointsResponseBody.Endpoints]?

    public var maxResults: String?

    public var nextToken: String?

    public var requestId: String?

    public var totalCount: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endpoints != nil {
            var tmp : [Any] = []
            for k in self.endpoints! {
                tmp.append(k.toMap())
            }
            map["Endpoints"] = tmp
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Endpoints") && dict["Endpoints"] != nil {
            var tmp : [ListBasicEndpointsResponseBody.Endpoints] = []
            for v in dict["Endpoints"] as! [Any] {
                var model = ListBasicEndpointsResponseBody.Endpoints()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.endpoints = tmp
        }
        if dict.keys.contains("MaxResults") && dict["MaxResults"] != nil {
            self.maxResults = dict["MaxResults"] as! String
        }
        if dict.keys.contains("NextToken") && dict["NextToken"] != nil {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! String
        }
    }
}

public class ListBasicEndpointsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListBasicEndpointsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListBasicEndpointsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListBusiRegionsRequest : Tea.TeaModel {
    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class ListBusiRegionsResponseBody : Tea.TeaModel {
    public class Regions : Tea.TeaModel {
        public var localName: String?

        public var regionId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.localName != nil {
                map["LocalName"] = self.localName!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("LocalName") && dict["LocalName"] != nil {
                self.localName = dict["LocalName"] as! String
            }
            if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
                self.regionId = dict["RegionId"] as! String
            }
        }
    }
    public var regions: [ListBusiRegionsResponseBody.Regions]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.regions != nil {
            var tmp : [Any] = []
            for k in self.regions! {
                tmp.append(k.toMap())
            }
            map["Regions"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Regions") && dict["Regions"] != nil {
            var tmp : [ListBusiRegionsResponseBody.Regions] = []
            for v in dict["Regions"] as! [Any] {
                var model = ListBusiRegionsResponseBody.Regions()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.regions = tmp
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListBusiRegionsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListBusiRegionsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListBusiRegionsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListCommonAreasRequest : Tea.TeaModel {
    public var ipVersion: String?

    public var isEpg: Bool?

    public var isIpSet: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ipVersion != nil {
            map["IpVersion"] = self.ipVersion!
        }
        if self.isEpg != nil {
            map["IsEpg"] = self.isEpg!
        }
        if self.isIpSet != nil {
            map["IsIpSet"] = self.isIpSet!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("IpVersion") && dict["IpVersion"] != nil {
            self.ipVersion = dict["IpVersion"] as! String
        }
        if dict.keys.contains("IsEpg") && dict["IsEpg"] != nil {
            self.isEpg = dict["IsEpg"] as! Bool
        }
        if dict.keys.contains("IsIpSet") && dict["IsIpSet"] != nil {
            self.isIpSet = dict["IsIpSet"] as! Bool
        }
    }
}

public class ListCommonAreasResponseBody : Tea.TeaModel {
    public class Areas : Tea.TeaModel {
        public class RegionList : Tea.TeaModel {
            public var localName: String?

            public var regionId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.localName != nil {
                    map["LocalName"] = self.localName!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("LocalName") && dict["LocalName"] != nil {
                    self.localName = dict["LocalName"] as! String
                }
                if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
                    self.regionId = dict["RegionId"] as! String
                }
            }
        }
        public var areaId: String?

        public var localName: String?

        public var regionList: [ListCommonAreasResponseBody.Areas.RegionList]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.areaId != nil {
                map["AreaId"] = self.areaId!
            }
            if self.localName != nil {
                map["LocalName"] = self.localName!
            }
            if self.regionList != nil {
                var tmp : [Any] = []
                for k in self.regionList! {
                    tmp.append(k.toMap())
                }
                map["RegionList"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AreaId") && dict["AreaId"] != nil {
                self.areaId = dict["AreaId"] as! String
            }
            if dict.keys.contains("LocalName") && dict["LocalName"] != nil {
                self.localName = dict["LocalName"] as! String
            }
            if dict.keys.contains("RegionList") && dict["RegionList"] != nil {
                var tmp : [ListCommonAreasResponseBody.Areas.RegionList] = []
                for v in dict["RegionList"] as! [Any] {
                    var model = ListCommonAreasResponseBody.Areas.RegionList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.regionList = tmp
            }
        }
    }
    public var areas: [ListCommonAreasResponseBody.Areas]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.areas != nil {
            var tmp : [Any] = []
            for k in self.areas! {
                tmp.append(k.toMap())
            }
            map["Areas"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Areas") && dict["Areas"] != nil {
            var tmp : [ListCommonAreasResponseBody.Areas] = []
            for v in dict["Areas"] as! [Any] {
                var model = ListCommonAreasResponseBody.Areas()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.areas = tmp
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListCommonAreasResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListCommonAreasResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListCommonAreasResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListCustomRoutingEndpointGroupDestinationsRequest : Tea.TeaModel {
    public var acceleratorId: String?

    public var endpointGroupId: String?

    public var fromPort: Int32?

    public var listenerId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var protocols: [String]?

    public var regionId: String?

    public var toPort: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceleratorId != nil {
            map["AcceleratorId"] = self.acceleratorId!
        }
        if self.endpointGroupId != nil {
            map["EndpointGroupId"] = self.endpointGroupId!
        }
        if self.fromPort != nil {
            map["FromPort"] = self.fromPort!
        }
        if self.listenerId != nil {
            map["ListenerId"] = self.listenerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.protocols != nil {
            map["Protocols"] = self.protocols!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.toPort != nil {
            map["ToPort"] = self.toPort!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceleratorId") && dict["AcceleratorId"] != nil {
            self.acceleratorId = dict["AcceleratorId"] as! String
        }
        if dict.keys.contains("EndpointGroupId") && dict["EndpointGroupId"] != nil {
            self.endpointGroupId = dict["EndpointGroupId"] as! String
        }
        if dict.keys.contains("FromPort") && dict["FromPort"] != nil {
            self.fromPort = dict["FromPort"] as! Int32
        }
        if dict.keys.contains("ListenerId") && dict["ListenerId"] != nil {
            self.listenerId = dict["ListenerId"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("Protocols") && dict["Protocols"] != nil {
            self.protocols = dict["Protocols"] as! [String]
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ToPort") && dict["ToPort"] != nil {
            self.toPort = dict["ToPort"] as! Int32
        }
    }
}

public class ListCustomRoutingEndpointGroupDestinationsResponseBody : Tea.TeaModel {
    public class Destinations : Tea.TeaModel {
        public class ServiceManagedInfos : Tea.TeaModel {
            public var action: String?

            public var childType: String?

            public var isManaged: Bool?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.action != nil {
                    map["Action"] = self.action!
                }
                if self.childType != nil {
                    map["ChildType"] = self.childType!
                }
                if self.isManaged != nil {
                    map["IsManaged"] = self.isManaged!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Action") && dict["Action"] != nil {
                    self.action = dict["Action"] as! String
                }
                if dict.keys.contains("ChildType") && dict["ChildType"] != nil {
                    self.childType = dict["ChildType"] as! String
                }
                if dict.keys.contains("IsManaged") && dict["IsManaged"] != nil {
                    self.isManaged = dict["IsManaged"] as! Bool
                }
            }
        }
        public var acceleratorId: String?

        public var destinationId: String?

        public var endpointGroupId: String?

        public var fromPort: Int32?

        public var listenerId: String?

        public var protocols: [String]?

        public var serviceId: String?

        public var serviceManaged: Bool?

        public var serviceManagedInfos: [ListCustomRoutingEndpointGroupDestinationsResponseBody.Destinations.ServiceManagedInfos]?

        public var toPort: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.acceleratorId != nil {
                map["AcceleratorId"] = self.acceleratorId!
            }
            if self.destinationId != nil {
                map["DestinationId"] = self.destinationId!
            }
            if self.endpointGroupId != nil {
                map["EndpointGroupId"] = self.endpointGroupId!
            }
            if self.fromPort != nil {
                map["FromPort"] = self.fromPort!
            }
            if self.listenerId != nil {
                map["ListenerId"] = self.listenerId!
            }
            if self.protocols != nil {
                map["Protocols"] = self.protocols!
            }
            if self.serviceId != nil {
                map["ServiceId"] = self.serviceId!
            }
            if self.serviceManaged != nil {
                map["ServiceManaged"] = self.serviceManaged!
            }
            if self.serviceManagedInfos != nil {
                var tmp : [Any] = []
                for k in self.serviceManagedInfos! {
                    tmp.append(k.toMap())
                }
                map["ServiceManagedInfos"] = tmp
            }
            if self.toPort != nil {
                map["ToPort"] = self.toPort!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AcceleratorId") && dict["AcceleratorId"] != nil {
                self.acceleratorId = dict["AcceleratorId"] as! String
            }
            if dict.keys.contains("DestinationId") && dict["DestinationId"] != nil {
                self.destinationId = dict["DestinationId"] as! String
            }
            if dict.keys.contains("EndpointGroupId") && dict["EndpointGroupId"] != nil {
                self.endpointGroupId = dict["EndpointGroupId"] as! String
            }
            if dict.keys.contains("FromPort") && dict["FromPort"] != nil {
                self.fromPort = dict["FromPort"] as! Int32
            }
            if dict.keys.contains("ListenerId") && dict["ListenerId"] != nil {
                self.listenerId = dict["ListenerId"] as! String
            }
            if dict.keys.contains("Protocols") && dict["Protocols"] != nil {
                self.protocols = dict["Protocols"] as! [String]
            }
            if dict.keys.contains("ServiceId") && dict["ServiceId"] != nil {
                self.serviceId = dict["ServiceId"] as! String
            }
            if dict.keys.contains("ServiceManaged") && dict["ServiceManaged"] != nil {
                self.serviceManaged = dict["ServiceManaged"] as! Bool
            }
            if dict.keys.contains("ServiceManagedInfos") && dict["ServiceManagedInfos"] != nil {
                var tmp : [ListCustomRoutingEndpointGroupDestinationsResponseBody.Destinations.ServiceManagedInfos] = []
                for v in dict["ServiceManagedInfos"] as! [Any] {
                    var model = ListCustomRoutingEndpointGroupDestinationsResponseBody.Destinations.ServiceManagedInfos()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.serviceManagedInfos = tmp
            }
            if dict.keys.contains("ToPort") && dict["ToPort"] != nil {
                self.toPort = dict["ToPort"] as! Int32
            }
        }
    }
    public var destinations: [ListCustomRoutingEndpointGroupDestinationsResponseBody.Destinations]?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.destinations != nil {
            var tmp : [Any] = []
            for k in self.destinations! {
                tmp.append(k.toMap())
            }
            map["Destinations"] = tmp
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Destinations") && dict["Destinations"] != nil {
            var tmp : [ListCustomRoutingEndpointGroupDestinationsResponseBody.Destinations] = []
            for v in dict["Destinations"] as! [Any] {
                var model = ListCustomRoutingEndpointGroupDestinationsResponseBody.Destinations()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.destinations = tmp
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class ListCustomRoutingEndpointGroupDestinationsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListCustomRoutingEndpointGroupDestinationsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListCustomRoutingEndpointGroupDestinationsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListCustomRoutingEndpointGroupsRequest : Tea.TeaModel {
    public var acceleratorId: String?

    public var accessLogSwitch: String?

    public var endpointGroupId: String?

    public var listenerId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceleratorId != nil {
            map["AcceleratorId"] = self.acceleratorId!
        }
        if self.accessLogSwitch != nil {
            map["AccessLogSwitch"] = self.accessLogSwitch!
        }
        if self.endpointGroupId != nil {
            map["EndpointGroupId"] = self.endpointGroupId!
        }
        if self.listenerId != nil {
            map["ListenerId"] = self.listenerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceleratorId") && dict["AcceleratorId"] != nil {
            self.acceleratorId = dict["AcceleratorId"] as! String
        }
        if dict.keys.contains("AccessLogSwitch") && dict["AccessLogSwitch"] != nil {
            self.accessLogSwitch = dict["AccessLogSwitch"] as! String
        }
        if dict.keys.contains("EndpointGroupId") && dict["EndpointGroupId"] != nil {
            self.endpointGroupId = dict["EndpointGroupId"] as! String
        }
        if dict.keys.contains("ListenerId") && dict["ListenerId"] != nil {
            self.listenerId = dict["ListenerId"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class ListCustomRoutingEndpointGroupsResponseBody : Tea.TeaModel {
    public class EndpointGroups : Tea.TeaModel {
        public class ServiceManagedInfos : Tea.TeaModel {
            public var action: String?

            public var childType: String?

            public var isManaged: Bool?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.action != nil {
                    map["Action"] = self.action!
                }
                if self.childType != nil {
                    map["ChildType"] = self.childType!
                }
                if self.isManaged != nil {
                    map["IsManaged"] = self.isManaged!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Action") && dict["Action"] != nil {
                    self.action = dict["Action"] as! String
                }
                if dict.keys.contains("ChildType") && dict["ChildType"] != nil {
                    self.childType = dict["ChildType"] as! String
                }
                if dict.keys.contains("IsManaged") && dict["IsManaged"] != nil {
                    self.isManaged = dict["IsManaged"] as! Bool
                }
            }
        }
        public var acceleratorId: String?

        public var description_: String?

        public var endpointGroupId: String?

        public var endpointGroupIpList: [String]?

        public var endpointGroupRegion: String?

        public var endpointGroupUnconfirmedIpList: [String]?

        public var listenerId: String?

        public var name: String?

        public var serviceId: String?

        public var serviceManaged: Bool?

        public var serviceManagedInfos: [ListCustomRoutingEndpointGroupsResponseBody.EndpointGroups.ServiceManagedInfos]?

        public var state: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.acceleratorId != nil {
                map["AcceleratorId"] = self.acceleratorId!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.endpointGroupId != nil {
                map["EndpointGroupId"] = self.endpointGroupId!
            }
            if self.endpointGroupIpList != nil {
                map["EndpointGroupIpList"] = self.endpointGroupIpList!
            }
            if self.endpointGroupRegion != nil {
                map["EndpointGroupRegion"] = self.endpointGroupRegion!
            }
            if self.endpointGroupUnconfirmedIpList != nil {
                map["EndpointGroupUnconfirmedIpList"] = self.endpointGroupUnconfirmedIpList!
            }
            if self.listenerId != nil {
                map["ListenerId"] = self.listenerId!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.serviceId != nil {
                map["ServiceId"] = self.serviceId!
            }
            if self.serviceManaged != nil {
                map["ServiceManaged"] = self.serviceManaged!
            }
            if self.serviceManagedInfos != nil {
                var tmp : [Any] = []
                for k in self.serviceManagedInfos! {
                    tmp.append(k.toMap())
                }
                map["ServiceManagedInfos"] = tmp
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AcceleratorId") && dict["AcceleratorId"] != nil {
                self.acceleratorId = dict["AcceleratorId"] as! String
            }
            if dict.keys.contains("Description") && dict["Description"] != nil {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("EndpointGroupId") && dict["EndpointGroupId"] != nil {
                self.endpointGroupId = dict["EndpointGroupId"] as! String
            }
            if dict.keys.contains("EndpointGroupIpList") && dict["EndpointGroupIpList"] != nil {
                self.endpointGroupIpList = dict["EndpointGroupIpList"] as! [String]
            }
            if dict.keys.contains("EndpointGroupRegion") && dict["EndpointGroupRegion"] != nil {
                self.endpointGroupRegion = dict["EndpointGroupRegion"] as! String
            }
            if dict.keys.contains("EndpointGroupUnconfirmedIpList") && dict["EndpointGroupUnconfirmedIpList"] != nil {
                self.endpointGroupUnconfirmedIpList = dict["EndpointGroupUnconfirmedIpList"] as! [String]
            }
            if dict.keys.contains("ListenerId") && dict["ListenerId"] != nil {
                self.listenerId = dict["ListenerId"] as! String
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("ServiceId") && dict["ServiceId"] != nil {
                self.serviceId = dict["ServiceId"] as! String
            }
            if dict.keys.contains("ServiceManaged") && dict["ServiceManaged"] != nil {
                self.serviceManaged = dict["ServiceManaged"] as! Bool
            }
            if dict.keys.contains("ServiceManagedInfos") && dict["ServiceManagedInfos"] != nil {
                var tmp : [ListCustomRoutingEndpointGroupsResponseBody.EndpointGroups.ServiceManagedInfos] = []
                for v in dict["ServiceManagedInfos"] as! [Any] {
                    var model = ListCustomRoutingEndpointGroupsResponseBody.EndpointGroups.ServiceManagedInfos()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.serviceManagedInfos = tmp
            }
            if dict.keys.contains("State") && dict["State"] != nil {
                self.state = dict["State"] as! String
            }
        }
    }
    public var endpointGroups: [ListCustomRoutingEndpointGroupsResponseBody.EndpointGroups]?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endpointGroups != nil {
            var tmp : [Any] = []
            for k in self.endpointGroups! {
                tmp.append(k.toMap())
            }
            map["EndpointGroups"] = tmp
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndpointGroups") && dict["EndpointGroups"] != nil {
            var tmp : [ListCustomRoutingEndpointGroupsResponseBody.EndpointGroups] = []
            for v in dict["EndpointGroups"] as! [Any] {
                var model = ListCustomRoutingEndpointGroupsResponseBody.EndpointGroups()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.endpointGroups = tmp
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class ListCustomRoutingEndpointGroupsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListCustomRoutingEndpointGroupsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListCustomRoutingEndpointGroupsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListCustomRoutingEndpointTrafficPoliciesRequest : Tea.TeaModel {
    public var acceleratorId: String?

    public var address: String?

    public var endpointGroupId: String?

    public var endpointId: String?

    public var listenerId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceleratorId != nil {
            map["AcceleratorId"] = self.acceleratorId!
        }
        if self.address != nil {
            map["Address"] = self.address!
        }
        if self.endpointGroupId != nil {
            map["EndpointGroupId"] = self.endpointGroupId!
        }
        if self.endpointId != nil {
            map["EndpointId"] = self.endpointId!
        }
        if self.listenerId != nil {
            map["ListenerId"] = self.listenerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceleratorId") && dict["AcceleratorId"] != nil {
            self.acceleratorId = dict["AcceleratorId"] as! String
        }
        if dict.keys.contains("Address") && dict["Address"] != nil {
            self.address = dict["Address"] as! String
        }
        if dict.keys.contains("EndpointGroupId") && dict["EndpointGroupId"] != nil {
            self.endpointGroupId = dict["EndpointGroupId"] as! String
        }
        if dict.keys.contains("EndpointId") && dict["EndpointId"] != nil {
            self.endpointId = dict["EndpointId"] as! String
        }
        if dict.keys.contains("ListenerId") && dict["ListenerId"] != nil {
            self.listenerId = dict["ListenerId"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class ListCustomRoutingEndpointTrafficPoliciesResponseBody : Tea.TeaModel {
    public class Policies : Tea.TeaModel {
        public class PortRanges : Tea.TeaModel {
            public var fromPort: Int32?

            public var toPort: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.fromPort != nil {
                    map["FromPort"] = self.fromPort!
                }
                if self.toPort != nil {
                    map["ToPort"] = self.toPort!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("FromPort") && dict["FromPort"] != nil {
                    self.fromPort = dict["FromPort"] as! Int32
                }
                if dict.keys.contains("ToPort") && dict["ToPort"] != nil {
                    self.toPort = dict["ToPort"] as! Int32
                }
            }
        }
        public class ServiceManagedInfos : Tea.TeaModel {
            public var action: String?

            public var childType: String?

            public var isManaged: Bool?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.action != nil {
                    map["Action"] = self.action!
                }
                if self.childType != nil {
                    map["ChildType"] = self.childType!
                }
                if self.isManaged != nil {
                    map["IsManaged"] = self.isManaged!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Action") && dict["Action"] != nil {
                    self.action = dict["Action"] as! String
                }
                if dict.keys.contains("ChildType") && dict["ChildType"] != nil {
                    self.childType = dict["ChildType"] as! String
                }
                if dict.keys.contains("IsManaged") && dict["IsManaged"] != nil {
                    self.isManaged = dict["IsManaged"] as! Bool
                }
            }
        }
        public var acceleratorId: String?

        public var address: String?

        public var endpointGroupId: String?

        public var endpointId: String?

        public var listenerId: String?

        public var policyId: String?

        public var portRanges: [ListCustomRoutingEndpointTrafficPoliciesResponseBody.Policies.PortRanges]?

        public var serviceId: String?

        public var serviceManaged: Bool?

        public var serviceManagedInfos: [ListCustomRoutingEndpointTrafficPoliciesResponseBody.Policies.ServiceManagedInfos]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.acceleratorId != nil {
                map["AcceleratorId"] = self.acceleratorId!
            }
            if self.address != nil {
                map["Address"] = self.address!
            }
            if self.endpointGroupId != nil {
                map["EndpointGroupId"] = self.endpointGroupId!
            }
            if self.endpointId != nil {
                map["EndpointId"] = self.endpointId!
            }
            if self.listenerId != nil {
                map["ListenerId"] = self.listenerId!
            }
            if self.policyId != nil {
                map["PolicyId"] = self.policyId!
            }
            if self.portRanges != nil {
                var tmp : [Any] = []
                for k in self.portRanges! {
                    tmp.append(k.toMap())
                }
                map["PortRanges"] = tmp
            }
            if self.serviceId != nil {
                map["ServiceId"] = self.serviceId!
            }
            if self.serviceManaged != nil {
                map["ServiceManaged"] = self.serviceManaged!
            }
            if self.serviceManagedInfos != nil {
                var tmp : [Any] = []
                for k in self.serviceManagedInfos! {
                    tmp.append(k.toMap())
                }
                map["ServiceManagedInfos"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AcceleratorId") && dict["AcceleratorId"] != nil {
                self.acceleratorId = dict["AcceleratorId"] as! String
            }
            if dict.keys.contains("Address") && dict["Address"] != nil {
                self.address = dict["Address"] as! String
            }
            if dict.keys.contains("EndpointGroupId") && dict["EndpointGroupId"] != nil {
                self.endpointGroupId = dict["EndpointGroupId"] as! String
            }
            if dict.keys.contains("EndpointId") && dict["EndpointId"] != nil {
                self.endpointId = dict["EndpointId"] as! String
            }
            if dict.keys.contains("ListenerId") && dict["ListenerId"] != nil {
                self.listenerId = dict["ListenerId"] as! String
            }
            if dict.keys.contains("PolicyId") && dict["PolicyId"] != nil {
                self.policyId = dict["PolicyId"] as! String
            }
            if dict.keys.contains("PortRanges") && dict["PortRanges"] != nil {
                var tmp : [ListCustomRoutingEndpointTrafficPoliciesResponseBody.Policies.PortRanges] = []
                for v in dict["PortRanges"] as! [Any] {
                    var model = ListCustomRoutingEndpointTrafficPoliciesResponseBody.Policies.PortRanges()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.portRanges = tmp
            }
            if dict.keys.contains("ServiceId") && dict["ServiceId"] != nil {
                self.serviceId = dict["ServiceId"] as! String
            }
            if dict.keys.contains("ServiceManaged") && dict["ServiceManaged"] != nil {
                self.serviceManaged = dict["ServiceManaged"] as! Bool
            }
            if dict.keys.contains("ServiceManagedInfos") && dict["ServiceManagedInfos"] != nil {
                var tmp : [ListCustomRoutingEndpointTrafficPoliciesResponseBody.Policies.ServiceManagedInfos] = []
                for v in dict["ServiceManagedInfos"] as! [Any] {
                    var model = ListCustomRoutingEndpointTrafficPoliciesResponseBody.Policies.ServiceManagedInfos()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.serviceManagedInfos = tmp
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var policies: [ListCustomRoutingEndpointTrafficPoliciesResponseBody.Policies]?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.policies != nil {
            var tmp : [Any] = []
            for k in self.policies! {
                tmp.append(k.toMap())
            }
            map["Policies"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("Policies") && dict["Policies"] != nil {
            var tmp : [ListCustomRoutingEndpointTrafficPoliciesResponseBody.Policies] = []
            for v in dict["Policies"] as! [Any] {
                var model = ListCustomRoutingEndpointTrafficPoliciesResponseBody.Policies()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.policies = tmp
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class ListCustomRoutingEndpointTrafficPoliciesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListCustomRoutingEndpointTrafficPoliciesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListCustomRoutingEndpointTrafficPoliciesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListCustomRoutingEndpointsRequest : Tea.TeaModel {
    public var acceleratorId: String?

    public var endpointGroupId: String?

    public var listenerId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceleratorId != nil {
            map["AcceleratorId"] = self.acceleratorId!
        }
        if self.endpointGroupId != nil {
            map["EndpointGroupId"] = self.endpointGroupId!
        }
        if self.listenerId != nil {
            map["ListenerId"] = self.listenerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceleratorId") && dict["AcceleratorId"] != nil {
            self.acceleratorId = dict["AcceleratorId"] as! String
        }
        if dict.keys.contains("EndpointGroupId") && dict["EndpointGroupId"] != nil {
            self.endpointGroupId = dict["EndpointGroupId"] as! String
        }
        if dict.keys.contains("ListenerId") && dict["ListenerId"] != nil {
            self.listenerId = dict["ListenerId"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class ListCustomRoutingEndpointsResponseBody : Tea.TeaModel {
    public class Endpoints : Tea.TeaModel {
        public class ServiceManagedInfos : Tea.TeaModel {
            public var action: String?

            public var childType: String?

            public var isManaged: Bool?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.action != nil {
                    map["Action"] = self.action!
                }
                if self.childType != nil {
                    map["ChildType"] = self.childType!
                }
                if self.isManaged != nil {
                    map["IsManaged"] = self.isManaged!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Action") && dict["Action"] != nil {
                    self.action = dict["Action"] as! String
                }
                if dict.keys.contains("ChildType") && dict["ChildType"] != nil {
                    self.childType = dict["ChildType"] as! String
                }
                if dict.keys.contains("IsManaged") && dict["IsManaged"] != nil {
                    self.isManaged = dict["IsManaged"] as! Bool
                }
            }
        }
        public var acceleratorId: String?

        public var endpoint: String?

        public var endpointGroupId: String?

        public var endpointId: String?

        public var listenerId: String?

        public var serviceId: String?

        public var serviceManaged: Bool?

        public var serviceManagedInfos: [ListCustomRoutingEndpointsResponseBody.Endpoints.ServiceManagedInfos]?

        public var trafficToEndpointPolicy: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.acceleratorId != nil {
                map["AcceleratorId"] = self.acceleratorId!
            }
            if self.endpoint != nil {
                map["Endpoint"] = self.endpoint!
            }
            if self.endpointGroupId != nil {
                map["EndpointGroupId"] = self.endpointGroupId!
            }
            if self.endpointId != nil {
                map["EndpointId"] = self.endpointId!
            }
            if self.listenerId != nil {
                map["ListenerId"] = self.listenerId!
            }
            if self.serviceId != nil {
                map["ServiceId"] = self.serviceId!
            }
            if self.serviceManaged != nil {
                map["ServiceManaged"] = self.serviceManaged!
            }
            if self.serviceManagedInfos != nil {
                var tmp : [Any] = []
                for k in self.serviceManagedInfos! {
                    tmp.append(k.toMap())
                }
                map["ServiceManagedInfos"] = tmp
            }
            if self.trafficToEndpointPolicy != nil {
                map["TrafficToEndpointPolicy"] = self.trafficToEndpointPolicy!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AcceleratorId") && dict["AcceleratorId"] != nil {
                self.acceleratorId = dict["AcceleratorId"] as! String
            }
            if dict.keys.contains("Endpoint") && dict["Endpoint"] != nil {
                self.endpoint = dict["Endpoint"] as! String
            }
            if dict.keys.contains("EndpointGroupId") && dict["EndpointGroupId"] != nil {
                self.endpointGroupId = dict["EndpointGroupId"] as! String
            }
            if dict.keys.contains("EndpointId") && dict["EndpointId"] != nil {
                self.endpointId = dict["EndpointId"] as! String
            }
            if dict.keys.contains("ListenerId") && dict["ListenerId"] != nil {
                self.listenerId = dict["ListenerId"] as! String
            }
            if dict.keys.contains("ServiceId") && dict["ServiceId"] != nil {
                self.serviceId = dict["ServiceId"] as! String
            }
            if dict.keys.contains("ServiceManaged") && dict["ServiceManaged"] != nil {
                self.serviceManaged = dict["ServiceManaged"] as! Bool
            }
            if dict.keys.contains("ServiceManagedInfos") && dict["ServiceManagedInfos"] != nil {
                var tmp : [ListCustomRoutingEndpointsResponseBody.Endpoints.ServiceManagedInfos] = []
                for v in dict["ServiceManagedInfos"] as! [Any] {
                    var model = ListCustomRoutingEndpointsResponseBody.Endpoints.ServiceManagedInfos()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.serviceManagedInfos = tmp
            }
            if dict.keys.contains("TrafficToEndpointPolicy") && dict["TrafficToEndpointPolicy"] != nil {
                self.trafficToEndpointPolicy = dict["TrafficToEndpointPolicy"] as! String
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var endpoints: [ListCustomRoutingEndpointsResponseBody.Endpoints]?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endpoints != nil {
            var tmp : [Any] = []
            for k in self.endpoints! {
                tmp.append(k.toMap())
            }
            map["Endpoints"] = tmp
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Endpoints") && dict["Endpoints"] != nil {
            var tmp : [ListCustomRoutingEndpointsResponseBody.Endpoints] = []
            for v in dict["Endpoints"] as! [Any] {
                var model = ListCustomRoutingEndpointsResponseBody.Endpoints()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.endpoints = tmp
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class ListCustomRoutingEndpointsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListCustomRoutingEndpointsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListCustomRoutingEndpointsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListCustomRoutingPortMappingsRequest : Tea.TeaModel {
    public var acceleratorId: String?

    public var endpointGroupId: String?

    public var listenerId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceleratorId != nil {
            map["AcceleratorId"] = self.acceleratorId!
        }
        if self.endpointGroupId != nil {
            map["EndpointGroupId"] = self.endpointGroupId!
        }
        if self.listenerId != nil {
            map["ListenerId"] = self.listenerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceleratorId") && dict["AcceleratorId"] != nil {
            self.acceleratorId = dict["AcceleratorId"] as! String
        }
        if dict.keys.contains("EndpointGroupId") && dict["EndpointGroupId"] != nil {
            self.endpointGroupId = dict["EndpointGroupId"] as! String
        }
        if dict.keys.contains("ListenerId") && dict["ListenerId"] != nil {
            self.listenerId = dict["ListenerId"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class ListCustomRoutingPortMappingsResponseBody : Tea.TeaModel {
    public class PortMappings : Tea.TeaModel {
        public class DestinationSocketAddress : Tea.TeaModel {
            public var ipAddress: String?

            public var port: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.ipAddress != nil {
                    map["IpAddress"] = self.ipAddress!
                }
                if self.port != nil {
                    map["Port"] = self.port!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("IpAddress") && dict["IpAddress"] != nil {
                    self.ipAddress = dict["IpAddress"] as! String
                }
                if dict.keys.contains("Port") && dict["Port"] != nil {
                    self.port = dict["Port"] as! Int32
                }
            }
        }
        public var acceleratorId: String?

        public var acceleratorPort: Int32?

        public var destinationSocketAddress: ListCustomRoutingPortMappingsResponseBody.PortMappings.DestinationSocketAddress?

        public var destinationTrafficState: String?

        public var endpointGroupId: String?

        public var endpointGroupRegion: String?

        public var endpointId: String?

        public var listenerId: String?

        public var protocols: [String]?

        public var vswitch: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.destinationSocketAddress?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.acceleratorId != nil {
                map["AcceleratorId"] = self.acceleratorId!
            }
            if self.acceleratorPort != nil {
                map["AcceleratorPort"] = self.acceleratorPort!
            }
            if self.destinationSocketAddress != nil {
                map["DestinationSocketAddress"] = self.destinationSocketAddress?.toMap()
            }
            if self.destinationTrafficState != nil {
                map["DestinationTrafficState"] = self.destinationTrafficState!
            }
            if self.endpointGroupId != nil {
                map["EndpointGroupId"] = self.endpointGroupId!
            }
            if self.endpointGroupRegion != nil {
                map["EndpointGroupRegion"] = self.endpointGroupRegion!
            }
            if self.endpointId != nil {
                map["EndpointId"] = self.endpointId!
            }
            if self.listenerId != nil {
                map["ListenerId"] = self.listenerId!
            }
            if self.protocols != nil {
                map["Protocols"] = self.protocols!
            }
            if self.vswitch != nil {
                map["Vswitch"] = self.vswitch!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AcceleratorId") && dict["AcceleratorId"] != nil {
                self.acceleratorId = dict["AcceleratorId"] as! String
            }
            if dict.keys.contains("AcceleratorPort") && dict["AcceleratorPort"] != nil {
                self.acceleratorPort = dict["AcceleratorPort"] as! Int32
            }
            if dict.keys.contains("DestinationSocketAddress") && dict["DestinationSocketAddress"] != nil {
                var model = ListCustomRoutingPortMappingsResponseBody.PortMappings.DestinationSocketAddress()
                model.fromMap(dict["DestinationSocketAddress"] as! [String: Any])
                self.destinationSocketAddress = model
            }
            if dict.keys.contains("DestinationTrafficState") && dict["DestinationTrafficState"] != nil {
                self.destinationTrafficState = dict["DestinationTrafficState"] as! String
            }
            if dict.keys.contains("EndpointGroupId") && dict["EndpointGroupId"] != nil {
                self.endpointGroupId = dict["EndpointGroupId"] as! String
            }
            if dict.keys.contains("EndpointGroupRegion") && dict["EndpointGroupRegion"] != nil {
                self.endpointGroupRegion = dict["EndpointGroupRegion"] as! String
            }
            if dict.keys.contains("EndpointId") && dict["EndpointId"] != nil {
                self.endpointId = dict["EndpointId"] as! String
            }
            if dict.keys.contains("ListenerId") && dict["ListenerId"] != nil {
                self.listenerId = dict["ListenerId"] as! String
            }
            if dict.keys.contains("Protocols") && dict["Protocols"] != nil {
                self.protocols = dict["Protocols"] as! [String]
            }
            if dict.keys.contains("Vswitch") && dict["Vswitch"] != nil {
                self.vswitch = dict["Vswitch"] as! String
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var portMappings: [ListCustomRoutingPortMappingsResponseBody.PortMappings]?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.portMappings != nil {
            var tmp : [Any] = []
            for k in self.portMappings! {
                tmp.append(k.toMap())
            }
            map["PortMappings"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("PortMappings") && dict["PortMappings"] != nil {
            var tmp : [ListCustomRoutingPortMappingsResponseBody.PortMappings] = []
            for v in dict["PortMappings"] as! [Any] {
                var model = ListCustomRoutingPortMappingsResponseBody.PortMappings()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.portMappings = tmp
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class ListCustomRoutingPortMappingsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListCustomRoutingPortMappingsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListCustomRoutingPortMappingsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListCustomRoutingPortMappingsByDestinationRequest : Tea.TeaModel {
    public var destinationAddress: String?

    public var endpointId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.destinationAddress != nil {
            map["DestinationAddress"] = self.destinationAddress!
        }
        if self.endpointId != nil {
            map["EndpointId"] = self.endpointId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DestinationAddress") && dict["DestinationAddress"] != nil {
            self.destinationAddress = dict["DestinationAddress"] as! String
        }
        if dict.keys.contains("EndpointId") && dict["EndpointId"] != nil {
            self.endpointId = dict["EndpointId"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class ListCustomRoutingPortMappingsByDestinationResponseBody : Tea.TeaModel {
    public class PortMappings : Tea.TeaModel {
        public class DestinationSocketAddress : Tea.TeaModel {
            public var ipAddress: String?

            public var port: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.ipAddress != nil {
                    map["IpAddress"] = self.ipAddress!
                }
                if self.port != nil {
                    map["Port"] = self.port!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("IpAddress") && dict["IpAddress"] != nil {
                    self.ipAddress = dict["IpAddress"] as! String
                }
                if dict.keys.contains("Port") && dict["Port"] != nil {
                    self.port = dict["Port"] as! Int32
                }
            }
        }
        public var acceleratorId: String?

        public var acceleratorPort: Int32?

        public var destinationSocketAddress: ListCustomRoutingPortMappingsByDestinationResponseBody.PortMappings.DestinationSocketAddress?

        public var destinationTrafficState: String?

        public var endpointGroupId: String?

        public var endpointGroupRegion: String?

        public var endpointId: String?

        public var listenerId: String?

        public var protocols: [String]?

        public var vswitch: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.destinationSocketAddress?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.acceleratorId != nil {
                map["AcceleratorId"] = self.acceleratorId!
            }
            if self.acceleratorPort != nil {
                map["AcceleratorPort"] = self.acceleratorPort!
            }
            if self.destinationSocketAddress != nil {
                map["DestinationSocketAddress"] = self.destinationSocketAddress?.toMap()
            }
            if self.destinationTrafficState != nil {
                map["DestinationTrafficState"] = self.destinationTrafficState!
            }
            if self.endpointGroupId != nil {
                map["EndpointGroupId"] = self.endpointGroupId!
            }
            if self.endpointGroupRegion != nil {
                map["EndpointGroupRegion"] = self.endpointGroupRegion!
            }
            if self.endpointId != nil {
                map["EndpointId"] = self.endpointId!
            }
            if self.listenerId != nil {
                map["ListenerId"] = self.listenerId!
            }
            if self.protocols != nil {
                map["Protocols"] = self.protocols!
            }
            if self.vswitch != nil {
                map["Vswitch"] = self.vswitch!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AcceleratorId") && dict["AcceleratorId"] != nil {
                self.acceleratorId = dict["AcceleratorId"] as! String
            }
            if dict.keys.contains("AcceleratorPort") && dict["AcceleratorPort"] != nil {
                self.acceleratorPort = dict["AcceleratorPort"] as! Int32
            }
            if dict.keys.contains("DestinationSocketAddress") && dict["DestinationSocketAddress"] != nil {
                var model = ListCustomRoutingPortMappingsByDestinationResponseBody.PortMappings.DestinationSocketAddress()
                model.fromMap(dict["DestinationSocketAddress"] as! [String: Any])
                self.destinationSocketAddress = model
            }
            if dict.keys.contains("DestinationTrafficState") && dict["DestinationTrafficState"] != nil {
                self.destinationTrafficState = dict["DestinationTrafficState"] as! String
            }
            if dict.keys.contains("EndpointGroupId") && dict["EndpointGroupId"] != nil {
                self.endpointGroupId = dict["EndpointGroupId"] as! String
            }
            if dict.keys.contains("EndpointGroupRegion") && dict["EndpointGroupRegion"] != nil {
                self.endpointGroupRegion = dict["EndpointGroupRegion"] as! String
            }
            if dict.keys.contains("EndpointId") && dict["EndpointId"] != nil {
                self.endpointId = dict["EndpointId"] as! String
            }
            if dict.keys.contains("ListenerId") && dict["ListenerId"] != nil {
                self.listenerId = dict["ListenerId"] as! String
            }
            if dict.keys.contains("Protocols") && dict["Protocols"] != nil {
                self.protocols = dict["Protocols"] as! [String]
            }
            if dict.keys.contains("Vswitch") && dict["Vswitch"] != nil {
                self.vswitch = dict["Vswitch"] as! String
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var portMappings: [ListCustomRoutingPortMappingsByDestinationResponseBody.PortMappings]?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.portMappings != nil {
            var tmp : [Any] = []
            for k in self.portMappings! {
                tmp.append(k.toMap())
            }
            map["PortMappings"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("PortMappings") && dict["PortMappings"] != nil {
            var tmp : [ListCustomRoutingPortMappingsByDestinationResponseBody.PortMappings] = []
            for v in dict["PortMappings"] as! [Any] {
                var model = ListCustomRoutingPortMappingsByDestinationResponseBody.PortMappings()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.portMappings = tmp
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class ListCustomRoutingPortMappingsByDestinationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListCustomRoutingPortMappingsByDestinationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListCustomRoutingPortMappingsByDestinationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListDomainsRequest : Tea.TeaModel {
    public var acceleratorId: String?

    public var domain: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var state: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceleratorId != nil {
            map["AcceleratorId"] = self.acceleratorId!
        }
        if self.domain != nil {
            map["Domain"] = self.domain!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.state != nil {
            map["State"] = self.state!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceleratorId") && dict["AcceleratorId"] != nil {
            self.acceleratorId = dict["AcceleratorId"] as! String
        }
        if dict.keys.contains("Domain") && dict["Domain"] != nil {
            self.domain = dict["Domain"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("State") && dict["State"] != nil {
            self.state = dict["State"] as! String
        }
    }
}

public class ListDomainsResponseBody : Tea.TeaModel {
    public class Domains : Tea.TeaModel {
        public class Accelerators : Tea.TeaModel {
            public class ServiceManagedInfos : Tea.TeaModel {
                public var action: String?

                public var childType: String?

                public var isManaged: Bool?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.action != nil {
                        map["Action"] = self.action!
                    }
                    if self.childType != nil {
                        map["ChildType"] = self.childType!
                    }
                    if self.isManaged != nil {
                        map["IsManaged"] = self.isManaged!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Action") && dict["Action"] != nil {
                        self.action = dict["Action"] as! String
                    }
                    if dict.keys.contains("ChildType") && dict["ChildType"] != nil {
                        self.childType = dict["ChildType"] as! String
                    }
                    if dict.keys.contains("IsManaged") && dict["IsManaged"] != nil {
                        self.isManaged = dict["IsManaged"] as! Bool
                    }
                }
            }
            public var acceleratorId: String?

            public var name: String?

            public var serviceId: String?

            public var serviceManaged: Bool?

            public var serviceManagedInfos: [ListDomainsResponseBody.Domains.Accelerators.ServiceManagedInfos]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.acceleratorId != nil {
                    map["AcceleratorId"] = self.acceleratorId!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.serviceId != nil {
                    map["ServiceId"] = self.serviceId!
                }
                if self.serviceManaged != nil {
                    map["ServiceManaged"] = self.serviceManaged!
                }
                if self.serviceManagedInfos != nil {
                    var tmp : [Any] = []
                    for k in self.serviceManagedInfos! {
                        tmp.append(k.toMap())
                    }
                    map["ServiceManagedInfos"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AcceleratorId") && dict["AcceleratorId"] != nil {
                    self.acceleratorId = dict["AcceleratorId"] as! String
                }
                if dict.keys.contains("Name") && dict["Name"] != nil {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("ServiceId") && dict["ServiceId"] != nil {
                    self.serviceId = dict["ServiceId"] as! String
                }
                if dict.keys.contains("ServiceManaged") && dict["ServiceManaged"] != nil {
                    self.serviceManaged = dict["ServiceManaged"] as! Bool
                }
                if dict.keys.contains("ServiceManagedInfos") && dict["ServiceManagedInfos"] != nil {
                    var tmp : [ListDomainsResponseBody.Domains.Accelerators.ServiceManagedInfos] = []
                    for v in dict["ServiceManagedInfos"] as! [Any] {
                        var model = ListDomainsResponseBody.Domains.Accelerators.ServiceManagedInfos()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.serviceManagedInfos = tmp
                }
            }
        }
        public var accelerators: [ListDomainsResponseBody.Domains.Accelerators]?

        public var domain: String?

        public var state: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accelerators != nil {
                var tmp : [Any] = []
                for k in self.accelerators! {
                    tmp.append(k.toMap())
                }
                map["Accelerators"] = tmp
            }
            if self.domain != nil {
                map["Domain"] = self.domain!
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Accelerators") && dict["Accelerators"] != nil {
                var tmp : [ListDomainsResponseBody.Domains.Accelerators] = []
                for v in dict["Accelerators"] as! [Any] {
                    var model = ListDomainsResponseBody.Domains.Accelerators()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.accelerators = tmp
            }
            if dict.keys.contains("Domain") && dict["Domain"] != nil {
                self.domain = dict["Domain"] as! String
            }
            if dict.keys.contains("State") && dict["State"] != nil {
                self.state = dict["State"] as! String
            }
        }
    }
    public var domains: [ListDomainsResponseBody.Domains]?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domains != nil {
            var tmp : [Any] = []
            for k in self.domains! {
                tmp.append(k.toMap())
            }
            map["Domains"] = tmp
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Domains") && dict["Domains"] != nil {
            var tmp : [ListDomainsResponseBody.Domains] = []
            for v in dict["Domains"] as! [Any] {
                var model = ListDomainsResponseBody.Domains()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.domains = tmp
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class ListDomainsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListDomainsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListDomainsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListEndpointGroupIpAddressCidrBlocksRequest : Tea.TeaModel {
    public var endpointGroupRegion: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endpointGroupRegion != nil {
            map["EndpointGroupRegion"] = self.endpointGroupRegion!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndpointGroupRegion") && dict["EndpointGroupRegion"] != nil {
            self.endpointGroupRegion = dict["EndpointGroupRegion"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class ListEndpointGroupIpAddressCidrBlocksResponseBody : Tea.TeaModel {
    public var endpointGroupRegion: String?

    public var ipAddressCidrBlocks: [String]?

    public var requestId: String?

    public var resourceGroupId: String?

    public var state: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endpointGroupRegion != nil {
            map["EndpointGroupRegion"] = self.endpointGroupRegion!
        }
        if self.ipAddressCidrBlocks != nil {
            map["IpAddressCidrBlocks"] = self.ipAddressCidrBlocks!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.state != nil {
            map["State"] = self.state!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndpointGroupRegion") && dict["EndpointGroupRegion"] != nil {
            self.endpointGroupRegion = dict["EndpointGroupRegion"] as! String
        }
        if dict.keys.contains("IpAddressCidrBlocks") && dict["IpAddressCidrBlocks"] != nil {
            self.ipAddressCidrBlocks = dict["IpAddressCidrBlocks"] as! [String]
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") && dict["ResourceGroupId"] != nil {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("State") && dict["State"] != nil {
            self.state = dict["State"] as! String
        }
    }
}

public class ListEndpointGroupIpAddressCidrBlocksResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListEndpointGroupIpAddressCidrBlocksResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListEndpointGroupIpAddressCidrBlocksResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListEndpointGroupsRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") && dict["Key"] != nil {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") && dict["Value"] != nil {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var acceleratorId: String?

    public var accessLogSwitch: String?

    public var endpointGroupId: String?

    public var endpointGroupType: String?

    public var listenerId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var tag: [ListEndpointGroupsRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceleratorId != nil {
            map["AcceleratorId"] = self.acceleratorId!
        }
        if self.accessLogSwitch != nil {
            map["AccessLogSwitch"] = self.accessLogSwitch!
        }
        if self.endpointGroupId != nil {
            map["EndpointGroupId"] = self.endpointGroupId!
        }
        if self.endpointGroupType != nil {
            map["EndpointGroupType"] = self.endpointGroupType!
        }
        if self.listenerId != nil {
            map["ListenerId"] = self.listenerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceleratorId") && dict["AcceleratorId"] != nil {
            self.acceleratorId = dict["AcceleratorId"] as! String
        }
        if dict.keys.contains("AccessLogSwitch") && dict["AccessLogSwitch"] != nil {
            self.accessLogSwitch = dict["AccessLogSwitch"] as! String
        }
        if dict.keys.contains("EndpointGroupId") && dict["EndpointGroupId"] != nil {
            self.endpointGroupId = dict["EndpointGroupId"] as! String
        }
        if dict.keys.contains("EndpointGroupType") && dict["EndpointGroupType"] != nil {
            self.endpointGroupType = dict["EndpointGroupType"] as! String
        }
        if dict.keys.contains("ListenerId") && dict["ListenerId"] != nil {
            self.listenerId = dict["ListenerId"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("Tag") && dict["Tag"] != nil {
            var tmp : [ListEndpointGroupsRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = ListEndpointGroupsRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
    }
}

public class ListEndpointGroupsResponseBody : Tea.TeaModel {
    public class EndpointGroups : Tea.TeaModel {
        public class EndpointConfigurations : Tea.TeaModel {
            public var enableClientIPPreservation: Bool?

            public var endpoint: String?

            public var endpointId: String?

            public var probePort: Int32?

            public var probeProtocol: String?

            public var subAddress: String?

            public var type: String?

            public var weight: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.enableClientIPPreservation != nil {
                    map["EnableClientIPPreservation"] = self.enableClientIPPreservation!
                }
                if self.endpoint != nil {
                    map["Endpoint"] = self.endpoint!
                }
                if self.endpointId != nil {
                    map["EndpointId"] = self.endpointId!
                }
                if self.probePort != nil {
                    map["ProbePort"] = self.probePort!
                }
                if self.probeProtocol != nil {
                    map["ProbeProtocol"] = self.probeProtocol!
                }
                if self.subAddress != nil {
                    map["SubAddress"] = self.subAddress!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.weight != nil {
                    map["Weight"] = self.weight!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("EnableClientIPPreservation") && dict["EnableClientIPPreservation"] != nil {
                    self.enableClientIPPreservation = dict["EnableClientIPPreservation"] as! Bool
                }
                if dict.keys.contains("Endpoint") && dict["Endpoint"] != nil {
                    self.endpoint = dict["Endpoint"] as! String
                }
                if dict.keys.contains("EndpointId") && dict["EndpointId"] != nil {
                    self.endpointId = dict["EndpointId"] as! String
                }
                if dict.keys.contains("ProbePort") && dict["ProbePort"] != nil {
                    self.probePort = dict["ProbePort"] as! Int32
                }
                if dict.keys.contains("ProbeProtocol") && dict["ProbeProtocol"] != nil {
                    self.probeProtocol = dict["ProbeProtocol"] as! String
                }
                if dict.keys.contains("SubAddress") && dict["SubAddress"] != nil {
                    self.subAddress = dict["SubAddress"] as! String
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("Weight") && dict["Weight"] != nil {
                    self.weight = dict["Weight"] as! Int32
                }
            }
        }
        public class PortOverrides : Tea.TeaModel {
            public var endpointPort: Int32?

            public var listenerPort: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.endpointPort != nil {
                    map["EndpointPort"] = self.endpointPort!
                }
                if self.listenerPort != nil {
                    map["ListenerPort"] = self.listenerPort!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("EndpointPort") && dict["EndpointPort"] != nil {
                    self.endpointPort = dict["EndpointPort"] as! Int32
                }
                if dict.keys.contains("ListenerPort") && dict["ListenerPort"] != nil {
                    self.listenerPort = dict["ListenerPort"] as! Int32
                }
            }
        }
        public class ServiceManagedInfos : Tea.TeaModel {
            public var action: String?

            public var childType: String?

            public var isManaged: Bool?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.action != nil {
                    map["Action"] = self.action!
                }
                if self.childType != nil {
                    map["ChildType"] = self.childType!
                }
                if self.isManaged != nil {
                    map["IsManaged"] = self.isManaged!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Action") && dict["Action"] != nil {
                    self.action = dict["Action"] as! String
                }
                if dict.keys.contains("ChildType") && dict["ChildType"] != nil {
                    self.childType = dict["ChildType"] as! String
                }
                if dict.keys.contains("IsManaged") && dict["IsManaged"] != nil {
                    self.isManaged = dict["IsManaged"] as! Bool
                }
            }
        }
        public class Tags : Tea.TeaModel {
            public var key: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Key") && dict["Key"] != nil {
                    self.key = dict["Key"] as! String
                }
                if dict.keys.contains("Value") && dict["Value"] != nil {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public var acceleratorId: String?

        public var description_: String?

        public var endpointConfigurations: [ListEndpointGroupsResponseBody.EndpointGroups.EndpointConfigurations]?

        public var endpointGroupId: String?

        public var endpointGroupIpList: [String]?

        public var endpointGroupRegion: String?

        public var endpointGroupType: String?

        public var endpointGroupUnconfirmedIpList: [String]?

        public var endpointRequestProtocol: String?

        public var forwardingRuleIds: [String]?

        public var healthCheckEnabled: Bool?

        public var healthCheckIntervalSeconds: Int32?

        public var healthCheckPath: String?

        public var healthCheckPort: Int32?

        public var healthCheckProtocol: String?

        public var listenerId: String?

        public var name: String?

        public var portOverrides: [ListEndpointGroupsResponseBody.EndpointGroups.PortOverrides]?

        public var serviceId: String?

        public var serviceManaged: Bool?

        public var serviceManagedInfos: [ListEndpointGroupsResponseBody.EndpointGroups.ServiceManagedInfos]?

        public var state: String?

        public var tags: [ListEndpointGroupsResponseBody.EndpointGroups.Tags]?

        public var thresholdCount: Int32?

        public var trafficPercentage: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.acceleratorId != nil {
                map["AcceleratorId"] = self.acceleratorId!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.endpointConfigurations != nil {
                var tmp : [Any] = []
                for k in self.endpointConfigurations! {
                    tmp.append(k.toMap())
                }
                map["EndpointConfigurations"] = tmp
            }
            if self.endpointGroupId != nil {
                map["EndpointGroupId"] = self.endpointGroupId!
            }
            if self.endpointGroupIpList != nil {
                map["EndpointGroupIpList"] = self.endpointGroupIpList!
            }
            if self.endpointGroupRegion != nil {
                map["EndpointGroupRegion"] = self.endpointGroupRegion!
            }
            if self.endpointGroupType != nil {
                map["EndpointGroupType"] = self.endpointGroupType!
            }
            if self.endpointGroupUnconfirmedIpList != nil {
                map["EndpointGroupUnconfirmedIpList"] = self.endpointGroupUnconfirmedIpList!
            }
            if self.endpointRequestProtocol != nil {
                map["EndpointRequestProtocol"] = self.endpointRequestProtocol!
            }
            if self.forwardingRuleIds != nil {
                map["ForwardingRuleIds"] = self.forwardingRuleIds!
            }
            if self.healthCheckEnabled != nil {
                map["HealthCheckEnabled"] = self.healthCheckEnabled!
            }
            if self.healthCheckIntervalSeconds != nil {
                map["HealthCheckIntervalSeconds"] = self.healthCheckIntervalSeconds!
            }
            if self.healthCheckPath != nil {
                map["HealthCheckPath"] = self.healthCheckPath!
            }
            if self.healthCheckPort != nil {
                map["HealthCheckPort"] = self.healthCheckPort!
            }
            if self.healthCheckProtocol != nil {
                map["HealthCheckProtocol"] = self.healthCheckProtocol!
            }
            if self.listenerId != nil {
                map["ListenerId"] = self.listenerId!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.portOverrides != nil {
                var tmp : [Any] = []
                for k in self.portOverrides! {
                    tmp.append(k.toMap())
                }
                map["PortOverrides"] = tmp
            }
            if self.serviceId != nil {
                map["ServiceId"] = self.serviceId!
            }
            if self.serviceManaged != nil {
                map["ServiceManaged"] = self.serviceManaged!
            }
            if self.serviceManagedInfos != nil {
                var tmp : [Any] = []
                for k in self.serviceManagedInfos! {
                    tmp.append(k.toMap())
                }
                map["ServiceManagedInfos"] = tmp
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            if self.tags != nil {
                var tmp : [Any] = []
                for k in self.tags! {
                    tmp.append(k.toMap())
                }
                map["Tags"] = tmp
            }
            if self.thresholdCount != nil {
                map["ThresholdCount"] = self.thresholdCount!
            }
            if self.trafficPercentage != nil {
                map["TrafficPercentage"] = self.trafficPercentage!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AcceleratorId") && dict["AcceleratorId"] != nil {
                self.acceleratorId = dict["AcceleratorId"] as! String
            }
            if dict.keys.contains("Description") && dict["Description"] != nil {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("EndpointConfigurations") && dict["EndpointConfigurations"] != nil {
                var tmp : [ListEndpointGroupsResponseBody.EndpointGroups.EndpointConfigurations] = []
                for v in dict["EndpointConfigurations"] as! [Any] {
                    var model = ListEndpointGroupsResponseBody.EndpointGroups.EndpointConfigurations()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.endpointConfigurations = tmp
            }
            if dict.keys.contains("EndpointGroupId") && dict["EndpointGroupId"] != nil {
                self.endpointGroupId = dict["EndpointGroupId"] as! String
            }
            if dict.keys.contains("EndpointGroupIpList") && dict["EndpointGroupIpList"] != nil {
                self.endpointGroupIpList = dict["EndpointGroupIpList"] as! [String]
            }
            if dict.keys.contains("EndpointGroupRegion") && dict["EndpointGroupRegion"] != nil {
                self.endpointGroupRegion = dict["EndpointGroupRegion"] as! String
            }
            if dict.keys.contains("EndpointGroupType") && dict["EndpointGroupType"] != nil {
                self.endpointGroupType = dict["EndpointGroupType"] as! String
            }
            if dict.keys.contains("EndpointGroupUnconfirmedIpList") && dict["EndpointGroupUnconfirmedIpList"] != nil {
                self.endpointGroupUnconfirmedIpList = dict["EndpointGroupUnconfirmedIpList"] as! [String]
            }
            if dict.keys.contains("EndpointRequestProtocol") && dict["EndpointRequestProtocol"] != nil {
                self.endpointRequestProtocol = dict["EndpointRequestProtocol"] as! String
            }
            if dict.keys.contains("ForwardingRuleIds") && dict["ForwardingRuleIds"] != nil {
                self.forwardingRuleIds = dict["ForwardingRuleIds"] as! [String]
            }
            if dict.keys.contains("HealthCheckEnabled") && dict["HealthCheckEnabled"] != nil {
                self.healthCheckEnabled = dict["HealthCheckEnabled"] as! Bool
            }
            if dict.keys.contains("HealthCheckIntervalSeconds") && dict["HealthCheckIntervalSeconds"] != nil {
                self.healthCheckIntervalSeconds = dict["HealthCheckIntervalSeconds"] as! Int32
            }
            if dict.keys.contains("HealthCheckPath") && dict["HealthCheckPath"] != nil {
                self.healthCheckPath = dict["HealthCheckPath"] as! String
            }
            if dict.keys.contains("HealthCheckPort") && dict["HealthCheckPort"] != nil {
                self.healthCheckPort = dict["HealthCheckPort"] as! Int32
            }
            if dict.keys.contains("HealthCheckProtocol") && dict["HealthCheckProtocol"] != nil {
                self.healthCheckProtocol = dict["HealthCheckProtocol"] as! String
            }
            if dict.keys.contains("ListenerId") && dict["ListenerId"] != nil {
                self.listenerId = dict["ListenerId"] as! String
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("PortOverrides") && dict["PortOverrides"] != nil {
                var tmp : [ListEndpointGroupsResponseBody.EndpointGroups.PortOverrides] = []
                for v in dict["PortOverrides"] as! [Any] {
                    var model = ListEndpointGroupsResponseBody.EndpointGroups.PortOverrides()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.portOverrides = tmp
            }
            if dict.keys.contains("ServiceId") && dict["ServiceId"] != nil {
                self.serviceId = dict["ServiceId"] as! String
            }
            if dict.keys.contains("ServiceManaged") && dict["ServiceManaged"] != nil {
                self.serviceManaged = dict["ServiceManaged"] as! Bool
            }
            if dict.keys.contains("ServiceManagedInfos") && dict["ServiceManagedInfos"] != nil {
                var tmp : [ListEndpointGroupsResponseBody.EndpointGroups.ServiceManagedInfos] = []
                for v in dict["ServiceManagedInfos"] as! [Any] {
                    var model = ListEndpointGroupsResponseBody.EndpointGroups.ServiceManagedInfos()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.serviceManagedInfos = tmp
            }
            if dict.keys.contains("State") && dict["State"] != nil {
                self.state = dict["State"] as! String
            }
            if dict.keys.contains("Tags") && dict["Tags"] != nil {
                var tmp : [ListEndpointGroupsResponseBody.EndpointGroups.Tags] = []
                for v in dict["Tags"] as! [Any] {
                    var model = ListEndpointGroupsResponseBody.EndpointGroups.Tags()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.tags = tmp
            }
            if dict.keys.contains("ThresholdCount") && dict["ThresholdCount"] != nil {
                self.thresholdCount = dict["ThresholdCount"] as! Int32
            }
            if dict.keys.contains("TrafficPercentage") && dict["TrafficPercentage"] != nil {
                self.trafficPercentage = dict["TrafficPercentage"] as! Int32
            }
        }
    }
    public var endpointGroups: [ListEndpointGroupsResponseBody.EndpointGroups]?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endpointGroups != nil {
            var tmp : [Any] = []
            for k in self.endpointGroups! {
                tmp.append(k.toMap())
            }
            map["EndpointGroups"] = tmp
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndpointGroups") && dict["EndpointGroups"] != nil {
            var tmp : [ListEndpointGroupsResponseBody.EndpointGroups] = []
            for v in dict["EndpointGroups"] as! [Any] {
                var model = ListEndpointGroupsResponseBody.EndpointGroups()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.endpointGroups = tmp
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class ListEndpointGroupsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListEndpointGroupsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListEndpointGroupsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListForwardingRulesRequest : Tea.TeaModel {
    public var acceleratorId: String?

    public var clientToken: String?

    public var forwardingRuleId: String?

    public var listenerId: String?

    public var maxResults: Int32?

    public var nextToken: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceleratorId != nil {
            map["AcceleratorId"] = self.acceleratorId!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.forwardingRuleId != nil {
            map["ForwardingRuleId"] = self.forwardingRuleId!
        }
        if self.listenerId != nil {
            map["ListenerId"] = self.listenerId!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceleratorId") && dict["AcceleratorId"] != nil {
            self.acceleratorId = dict["AcceleratorId"] as! String
        }
        if dict.keys.contains("ClientToken") && dict["ClientToken"] != nil {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("ForwardingRuleId") && dict["ForwardingRuleId"] != nil {
            self.forwardingRuleId = dict["ForwardingRuleId"] as! String
        }
        if dict.keys.contains("ListenerId") && dict["ListenerId"] != nil {
            self.listenerId = dict["ListenerId"] as! String
        }
        if dict.keys.contains("MaxResults") && dict["MaxResults"] != nil {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") && dict["NextToken"] != nil {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class ListForwardingRulesResponseBody : Tea.TeaModel {
    public class ForwardingRules : Tea.TeaModel {
        public class RuleActions : Tea.TeaModel {
            public class ForwardGroupConfig : Tea.TeaModel {
                public class ServerGroupTuples : Tea.TeaModel {
                    public var endpointGroupId: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.endpointGroupId != nil {
                            map["EndpointGroupId"] = self.endpointGroupId!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("EndpointGroupId") && dict["EndpointGroupId"] != nil {
                            self.endpointGroupId = dict["EndpointGroupId"] as! String
                        }
                    }
                }
                public var serverGroupTuples: [ListForwardingRulesResponseBody.ForwardingRules.RuleActions.ForwardGroupConfig.ServerGroupTuples]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.serverGroupTuples != nil {
                        var tmp : [Any] = []
                        for k in self.serverGroupTuples! {
                            tmp.append(k.toMap())
                        }
                        map["ServerGroupTuples"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ServerGroupTuples") && dict["ServerGroupTuples"] != nil {
                        var tmp : [ListForwardingRulesResponseBody.ForwardingRules.RuleActions.ForwardGroupConfig.ServerGroupTuples] = []
                        for v in dict["ServerGroupTuples"] as! [Any] {
                            var model = ListForwardingRulesResponseBody.ForwardingRules.RuleActions.ForwardGroupConfig.ServerGroupTuples()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.serverGroupTuples = tmp
                    }
                }
            }
            public var forwardGroupConfig: ListForwardingRulesResponseBody.ForwardingRules.RuleActions.ForwardGroupConfig?

            public var order: Int32?

            public var ruleActionType: String?

            public var ruleActionValue: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.forwardGroupConfig?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.forwardGroupConfig != nil {
                    map["ForwardGroupConfig"] = self.forwardGroupConfig?.toMap()
                }
                if self.order != nil {
                    map["Order"] = self.order!
                }
                if self.ruleActionType != nil {
                    map["RuleActionType"] = self.ruleActionType!
                }
                if self.ruleActionValue != nil {
                    map["RuleActionValue"] = self.ruleActionValue!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ForwardGroupConfig") && dict["ForwardGroupConfig"] != nil {
                    var model = ListForwardingRulesResponseBody.ForwardingRules.RuleActions.ForwardGroupConfig()
                    model.fromMap(dict["ForwardGroupConfig"] as! [String: Any])
                    self.forwardGroupConfig = model
                }
                if dict.keys.contains("Order") && dict["Order"] != nil {
                    self.order = dict["Order"] as! Int32
                }
                if dict.keys.contains("RuleActionType") && dict["RuleActionType"] != nil {
                    self.ruleActionType = dict["RuleActionType"] as! String
                }
                if dict.keys.contains("RuleActionValue") && dict["RuleActionValue"] != nil {
                    self.ruleActionValue = dict["RuleActionValue"] as! String
                }
            }
        }
        public class RuleConditions : Tea.TeaModel {
            public class HostConfig : Tea.TeaModel {
                public var values: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.values != nil {
                        map["Values"] = self.values!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Values") && dict["Values"] != nil {
                        self.values = dict["Values"] as! [String]
                    }
                }
            }
            public class PathConfig : Tea.TeaModel {
                public var values: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.values != nil {
                        map["Values"] = self.values!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Values") && dict["Values"] != nil {
                        self.values = dict["Values"] as! [String]
                    }
                }
            }
            public var hostConfig: ListForwardingRulesResponseBody.ForwardingRules.RuleConditions.HostConfig?

            public var pathConfig: ListForwardingRulesResponseBody.ForwardingRules.RuleConditions.PathConfig?

            public var ruleConditionType: String?

            public var ruleConditionValue: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.hostConfig?.validate()
                try self.pathConfig?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.hostConfig != nil {
                    map["HostConfig"] = self.hostConfig?.toMap()
                }
                if self.pathConfig != nil {
                    map["PathConfig"] = self.pathConfig?.toMap()
                }
                if self.ruleConditionType != nil {
                    map["RuleConditionType"] = self.ruleConditionType!
                }
                if self.ruleConditionValue != nil {
                    map["RuleConditionValue"] = self.ruleConditionValue!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("HostConfig") && dict["HostConfig"] != nil {
                    var model = ListForwardingRulesResponseBody.ForwardingRules.RuleConditions.HostConfig()
                    model.fromMap(dict["HostConfig"] as! [String: Any])
                    self.hostConfig = model
                }
                if dict.keys.contains("PathConfig") && dict["PathConfig"] != nil {
                    var model = ListForwardingRulesResponseBody.ForwardingRules.RuleConditions.PathConfig()
                    model.fromMap(dict["PathConfig"] as! [String: Any])
                    self.pathConfig = model
                }
                if dict.keys.contains("RuleConditionType") && dict["RuleConditionType"] != nil {
                    self.ruleConditionType = dict["RuleConditionType"] as! String
                }
                if dict.keys.contains("RuleConditionValue") && dict["RuleConditionValue"] != nil {
                    self.ruleConditionValue = dict["RuleConditionValue"] as! String
                }
            }
        }
        public class ServiceManagedInfos : Tea.TeaModel {
            public var action: String?

            public var childType: String?

            public var isManaged: Bool?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.action != nil {
                    map["Action"] = self.action!
                }
                if self.childType != nil {
                    map["ChildType"] = self.childType!
                }
                if self.isManaged != nil {
                    map["IsManaged"] = self.isManaged!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Action") && dict["Action"] != nil {
                    self.action = dict["Action"] as! String
                }
                if dict.keys.contains("ChildType") && dict["ChildType"] != nil {
                    self.childType = dict["ChildType"] as! String
                }
                if dict.keys.contains("IsManaged") && dict["IsManaged"] != nil {
                    self.isManaged = dict["IsManaged"] as! Bool
                }
            }
        }
        public var forwardingRuleDirection: String?

        public var forwardingRuleId: String?

        public var forwardingRuleName: String?

        public var forwardingRuleStatus: String?

        public var listenerId: String?

        public var priority: Int32?

        public var ruleActions: [ListForwardingRulesResponseBody.ForwardingRules.RuleActions]?

        public var ruleConditions: [ListForwardingRulesResponseBody.ForwardingRules.RuleConditions]?

        public var serviceId: String?

        public var serviceManaged: Bool?

        public var serviceManagedInfos: [ListForwardingRulesResponseBody.ForwardingRules.ServiceManagedInfos]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.forwardingRuleDirection != nil {
                map["ForwardingRuleDirection"] = self.forwardingRuleDirection!
            }
            if self.forwardingRuleId != nil {
                map["ForwardingRuleId"] = self.forwardingRuleId!
            }
            if self.forwardingRuleName != nil {
                map["ForwardingRuleName"] = self.forwardingRuleName!
            }
            if self.forwardingRuleStatus != nil {
                map["ForwardingRuleStatus"] = self.forwardingRuleStatus!
            }
            if self.listenerId != nil {
                map["ListenerId"] = self.listenerId!
            }
            if self.priority != nil {
                map["Priority"] = self.priority!
            }
            if self.ruleActions != nil {
                var tmp : [Any] = []
                for k in self.ruleActions! {
                    tmp.append(k.toMap())
                }
                map["RuleActions"] = tmp
            }
            if self.ruleConditions != nil {
                var tmp : [Any] = []
                for k in self.ruleConditions! {
                    tmp.append(k.toMap())
                }
                map["RuleConditions"] = tmp
            }
            if self.serviceId != nil {
                map["ServiceId"] = self.serviceId!
            }
            if self.serviceManaged != nil {
                map["ServiceManaged"] = self.serviceManaged!
            }
            if self.serviceManagedInfos != nil {
                var tmp : [Any] = []
                for k in self.serviceManagedInfos! {
                    tmp.append(k.toMap())
                }
                map["ServiceManagedInfos"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ForwardingRuleDirection") && dict["ForwardingRuleDirection"] != nil {
                self.forwardingRuleDirection = dict["ForwardingRuleDirection"] as! String
            }
            if dict.keys.contains("ForwardingRuleId") && dict["ForwardingRuleId"] != nil {
                self.forwardingRuleId = dict["ForwardingRuleId"] as! String
            }
            if dict.keys.contains("ForwardingRuleName") && dict["ForwardingRuleName"] != nil {
                self.forwardingRuleName = dict["ForwardingRuleName"] as! String
            }
            if dict.keys.contains("ForwardingRuleStatus") && dict["ForwardingRuleStatus"] != nil {
                self.forwardingRuleStatus = dict["ForwardingRuleStatus"] as! String
            }
            if dict.keys.contains("ListenerId") && dict["ListenerId"] != nil {
                self.listenerId = dict["ListenerId"] as! String
            }
            if dict.keys.contains("Priority") && dict["Priority"] != nil {
                self.priority = dict["Priority"] as! Int32
            }
            if dict.keys.contains("RuleActions") && dict["RuleActions"] != nil {
                var tmp : [ListForwardingRulesResponseBody.ForwardingRules.RuleActions] = []
                for v in dict["RuleActions"] as! [Any] {
                    var model = ListForwardingRulesResponseBody.ForwardingRules.RuleActions()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.ruleActions = tmp
            }
            if dict.keys.contains("RuleConditions") && dict["RuleConditions"] != nil {
                var tmp : [ListForwardingRulesResponseBody.ForwardingRules.RuleConditions] = []
                for v in dict["RuleConditions"] as! [Any] {
                    var model = ListForwardingRulesResponseBody.ForwardingRules.RuleConditions()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.ruleConditions = tmp
            }
            if dict.keys.contains("ServiceId") && dict["ServiceId"] != nil {
                self.serviceId = dict["ServiceId"] as! String
            }
            if dict.keys.contains("ServiceManaged") && dict["ServiceManaged"] != nil {
                self.serviceManaged = dict["ServiceManaged"] as! Bool
            }
            if dict.keys.contains("ServiceManagedInfos") && dict["ServiceManagedInfos"] != nil {
                var tmp : [ListForwardingRulesResponseBody.ForwardingRules.ServiceManagedInfos] = []
                for v in dict["ServiceManagedInfos"] as! [Any] {
                    var model = ListForwardingRulesResponseBody.ForwardingRules.ServiceManagedInfos()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.serviceManagedInfos = tmp
            }
        }
    }
    public var forwardingRules: [ListForwardingRulesResponseBody.ForwardingRules]?

    public var maxResults: Int32?

    public var nextToken: String?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.forwardingRules != nil {
            var tmp : [Any] = []
            for k in self.forwardingRules! {
                tmp.append(k.toMap())
            }
            map["ForwardingRules"] = tmp
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ForwardingRules") && dict["ForwardingRules"] != nil {
            var tmp : [ListForwardingRulesResponseBody.ForwardingRules] = []
            for v in dict["ForwardingRules"] as! [Any] {
                var model = ListForwardingRulesResponseBody.ForwardingRules()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.forwardingRules = tmp
        }
        if dict.keys.contains("MaxResults") && dict["MaxResults"] != nil {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") && dict["NextToken"] != nil {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class ListForwardingRulesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListForwardingRulesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListForwardingRulesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListIpSetsRequest : Tea.TeaModel {
    public var acceleratorId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceleratorId != nil {
            map["AcceleratorId"] = self.acceleratorId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceleratorId") && dict["AcceleratorId"] != nil {
            self.acceleratorId = dict["AcceleratorId"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class ListIpSetsResponseBody : Tea.TeaModel {
    public class IpSets : Tea.TeaModel {
        public class ServiceManagedInfos : Tea.TeaModel {
            public var action: String?

            public var childType: String?

            public var isManaged: Bool?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.action != nil {
                    map["Action"] = self.action!
                }
                if self.childType != nil {
                    map["ChildType"] = self.childType!
                }
                if self.isManaged != nil {
                    map["IsManaged"] = self.isManaged!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Action") && dict["Action"] != nil {
                    self.action = dict["Action"] as! String
                }
                if dict.keys.contains("ChildType") && dict["ChildType"] != nil {
                    self.childType = dict["ChildType"] as! String
                }
                if dict.keys.contains("IsManaged") && dict["IsManaged"] != nil {
                    self.isManaged = dict["IsManaged"] as! Bool
                }
            }
        }
        public var accelerateRegionId: String?

        public var bandwidth: Int32?

        public var ipAddressList: [String]?

        public var ipSetId: String?

        public var ipVersion: String?

        public var ispType: String?

        public var serviceId: String?

        public var serviceManaged: Bool?

        public var serviceManagedInfos: [ListIpSetsResponseBody.IpSets.ServiceManagedInfos]?

        public var state: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accelerateRegionId != nil {
                map["AccelerateRegionId"] = self.accelerateRegionId!
            }
            if self.bandwidth != nil {
                map["Bandwidth"] = self.bandwidth!
            }
            if self.ipAddressList != nil {
                map["IpAddressList"] = self.ipAddressList!
            }
            if self.ipSetId != nil {
                map["IpSetId"] = self.ipSetId!
            }
            if self.ipVersion != nil {
                map["IpVersion"] = self.ipVersion!
            }
            if self.ispType != nil {
                map["IspType"] = self.ispType!
            }
            if self.serviceId != nil {
                map["ServiceId"] = self.serviceId!
            }
            if self.serviceManaged != nil {
                map["ServiceManaged"] = self.serviceManaged!
            }
            if self.serviceManagedInfos != nil {
                var tmp : [Any] = []
                for k in self.serviceManagedInfos! {
                    tmp.append(k.toMap())
                }
                map["ServiceManagedInfos"] = tmp
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AccelerateRegionId") && dict["AccelerateRegionId"] != nil {
                self.accelerateRegionId = dict["AccelerateRegionId"] as! String
            }
            if dict.keys.contains("Bandwidth") && dict["Bandwidth"] != nil {
                self.bandwidth = dict["Bandwidth"] as! Int32
            }
            if dict.keys.contains("IpAddressList") && dict["IpAddressList"] != nil {
                self.ipAddressList = dict["IpAddressList"] as! [String]
            }
            if dict.keys.contains("IpSetId") && dict["IpSetId"] != nil {
                self.ipSetId = dict["IpSetId"] as! String
            }
            if dict.keys.contains("IpVersion") && dict["IpVersion"] != nil {
                self.ipVersion = dict["IpVersion"] as! String
            }
            if dict.keys.contains("IspType") && dict["IspType"] != nil {
                self.ispType = dict["IspType"] as! String
            }
            if dict.keys.contains("ServiceId") && dict["ServiceId"] != nil {
                self.serviceId = dict["ServiceId"] as! String
            }
            if dict.keys.contains("ServiceManaged") && dict["ServiceManaged"] != nil {
                self.serviceManaged = dict["ServiceManaged"] as! Bool
            }
            if dict.keys.contains("ServiceManagedInfos") && dict["ServiceManagedInfos"] != nil {
                var tmp : [ListIpSetsResponseBody.IpSets.ServiceManagedInfos] = []
                for v in dict["ServiceManagedInfos"] as! [Any] {
                    var model = ListIpSetsResponseBody.IpSets.ServiceManagedInfos()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.serviceManagedInfos = tmp
            }
            if dict.keys.contains("State") && dict["State"] != nil {
                self.state = dict["State"] as! String
            }
        }
    }
    public var ipSets: [ListIpSetsResponseBody.IpSets]?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ipSets != nil {
            var tmp : [Any] = []
            for k in self.ipSets! {
                tmp.append(k.toMap())
            }
            map["IpSets"] = tmp
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("IpSets") && dict["IpSets"] != nil {
            var tmp : [ListIpSetsResponseBody.IpSets] = []
            for v in dict["IpSets"] as! [Any] {
                var model = ListIpSetsResponseBody.IpSets()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.ipSets = tmp
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class ListIpSetsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListIpSetsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListIpSetsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListIspTypesRequest : Tea.TeaModel {
    public var acceleratorId: String?

    public var acceleratorType: String?

    public var businessRegionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceleratorId != nil {
            map["AcceleratorId"] = self.acceleratorId!
        }
        if self.acceleratorType != nil {
            map["AcceleratorType"] = self.acceleratorType!
        }
        if self.businessRegionId != nil {
            map["BusinessRegionId"] = self.businessRegionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceleratorId") && dict["AcceleratorId"] != nil {
            self.acceleratorId = dict["AcceleratorId"] as! String
        }
        if dict.keys.contains("AcceleratorType") && dict["AcceleratorType"] != nil {
            self.acceleratorType = dict["AcceleratorType"] as! String
        }
        if dict.keys.contains("BusinessRegionId") && dict["BusinessRegionId"] != nil {
            self.businessRegionId = dict["BusinessRegionId"] as! String
        }
    }
}

public class ListIspTypesResponseBody : Tea.TeaModel {
    public var ispTypeList: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ispTypeList != nil {
            map["IspTypeList"] = self.ispTypeList!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("IspTypeList") && dict["IspTypeList"] != nil {
            self.ispTypeList = dict["IspTypeList"] as! [String]
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListIspTypesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListIspTypesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListIspTypesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListListenerCertificatesRequest : Tea.TeaModel {
    public var acceleratorId: String?

    public var listenerId: String?

    public var maxResults: Int32?

    public var nextToken: String?

    public var regionId: String?

    public var role: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceleratorId != nil {
            map["AcceleratorId"] = self.acceleratorId!
        }
        if self.listenerId != nil {
            map["ListenerId"] = self.listenerId!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.role != nil {
            map["Role"] = self.role!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceleratorId") && dict["AcceleratorId"] != nil {
            self.acceleratorId = dict["AcceleratorId"] as! String
        }
        if dict.keys.contains("ListenerId") && dict["ListenerId"] != nil {
            self.listenerId = dict["ListenerId"] as! String
        }
        if dict.keys.contains("MaxResults") && dict["MaxResults"] != nil {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") && dict["NextToken"] != nil {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("Role") && dict["Role"] != nil {
            self.role = dict["Role"] as! String
        }
    }
}

public class ListListenerCertificatesResponseBody : Tea.TeaModel {
    public class Certificates : Tea.TeaModel {
        public var certificateId: String?

        public var domain: String?

        public var isDefault: Bool?

        public var state: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.certificateId != nil {
                map["CertificateId"] = self.certificateId!
            }
            if self.domain != nil {
                map["Domain"] = self.domain!
            }
            if self.isDefault != nil {
                map["IsDefault"] = self.isDefault!
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CertificateId") && dict["CertificateId"] != nil {
                self.certificateId = dict["CertificateId"] as! String
            }
            if dict.keys.contains("Domain") && dict["Domain"] != nil {
                self.domain = dict["Domain"] as! String
            }
            if dict.keys.contains("IsDefault") && dict["IsDefault"] != nil {
                self.isDefault = dict["IsDefault"] as! Bool
            }
            if dict.keys.contains("State") && dict["State"] != nil {
                self.state = dict["State"] as! String
            }
        }
    }
    public var certificates: [ListListenerCertificatesResponseBody.Certificates]?

    public var maxResults: Int32?

    public var nextToken: String?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.certificates != nil {
            var tmp : [Any] = []
            for k in self.certificates! {
                tmp.append(k.toMap())
            }
            map["Certificates"] = tmp
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Certificates") && dict["Certificates"] != nil {
            var tmp : [ListListenerCertificatesResponseBody.Certificates] = []
            for v in dict["Certificates"] as! [Any] {
                var model = ListListenerCertificatesResponseBody.Certificates()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.certificates = tmp
        }
        if dict.keys.contains("MaxResults") && dict["MaxResults"] != nil {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") && dict["NextToken"] != nil {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class ListListenerCertificatesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListListenerCertificatesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListListenerCertificatesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListListenersRequest : Tea.TeaModel {
    public var acceleratorId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceleratorId != nil {
            map["AcceleratorId"] = self.acceleratorId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceleratorId") && dict["AcceleratorId"] != nil {
            self.acceleratorId = dict["AcceleratorId"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class ListListenersResponseBody : Tea.TeaModel {
    public class Listeners : Tea.TeaModel {
        public class BackendPorts : Tea.TeaModel {
            public var fromPort: String?

            public var toPort: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.fromPort != nil {
                    map["FromPort"] = self.fromPort!
                }
                if self.toPort != nil {
                    map["ToPort"] = self.toPort!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("FromPort") && dict["FromPort"] != nil {
                    self.fromPort = dict["FromPort"] as! String
                }
                if dict.keys.contains("ToPort") && dict["ToPort"] != nil {
                    self.toPort = dict["ToPort"] as! String
                }
            }
        }
        public class Certificates : Tea.TeaModel {
            public var id: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Id") && dict["Id"] != nil {
                    self.id = dict["Id"] as! String
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public class PortRanges : Tea.TeaModel {
            public var fromPort: Int32?

            public var toPort: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.fromPort != nil {
                    map["FromPort"] = self.fromPort!
                }
                if self.toPort != nil {
                    map["ToPort"] = self.toPort!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("FromPort") && dict["FromPort"] != nil {
                    self.fromPort = dict["FromPort"] as! Int32
                }
                if dict.keys.contains("ToPort") && dict["ToPort"] != nil {
                    self.toPort = dict["ToPort"] as! Int32
                }
            }
        }
        public class ServiceManagedInfos : Tea.TeaModel {
            public var action: String?

            public var childType: String?

            public var isManaged: Bool?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.action != nil {
                    map["Action"] = self.action!
                }
                if self.childType != nil {
                    map["ChildType"] = self.childType!
                }
                if self.isManaged != nil {
                    map["IsManaged"] = self.isManaged!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Action") && dict["Action"] != nil {
                    self.action = dict["Action"] as! String
                }
                if dict.keys.contains("ChildType") && dict["ChildType"] != nil {
                    self.childType = dict["ChildType"] as! String
                }
                if dict.keys.contains("IsManaged") && dict["IsManaged"] != nil {
                    self.isManaged = dict["IsManaged"] as! Bool
                }
            }
        }
        public class XForwardedForConfig : Tea.TeaModel {
            public var XForwardedForGaApEnabled: Bool?

            public var XForwardedForGaIdEnabled: Bool?

            public var XForwardedForPortEnabled: Bool?

            public var XForwardedForProtoEnabled: Bool?

            public var XRealIpEnabled: Bool?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.XForwardedForGaApEnabled != nil {
                    map["XForwardedForGaApEnabled"] = self.XForwardedForGaApEnabled!
                }
                if self.XForwardedForGaIdEnabled != nil {
                    map["XForwardedForGaIdEnabled"] = self.XForwardedForGaIdEnabled!
                }
                if self.XForwardedForPortEnabled != nil {
                    map["XForwardedForPortEnabled"] = self.XForwardedForPortEnabled!
                }
                if self.XForwardedForProtoEnabled != nil {
                    map["XForwardedForProtoEnabled"] = self.XForwardedForProtoEnabled!
                }
                if self.XRealIpEnabled != nil {
                    map["XRealIpEnabled"] = self.XRealIpEnabled!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("XForwardedForGaApEnabled") && dict["XForwardedForGaApEnabled"] != nil {
                    self.XForwardedForGaApEnabled = dict["XForwardedForGaApEnabled"] as! Bool
                }
                if dict.keys.contains("XForwardedForGaIdEnabled") && dict["XForwardedForGaIdEnabled"] != nil {
                    self.XForwardedForGaIdEnabled = dict["XForwardedForGaIdEnabled"] as! Bool
                }
                if dict.keys.contains("XForwardedForPortEnabled") && dict["XForwardedForPortEnabled"] != nil {
                    self.XForwardedForPortEnabled = dict["XForwardedForPortEnabled"] as! Bool
                }
                if dict.keys.contains("XForwardedForProtoEnabled") && dict["XForwardedForProtoEnabled"] != nil {
                    self.XForwardedForProtoEnabled = dict["XForwardedForProtoEnabled"] as! Bool
                }
                if dict.keys.contains("XRealIpEnabled") && dict["XRealIpEnabled"] != nil {
                    self.XRealIpEnabled = dict["XRealIpEnabled"] as! Bool
                }
            }
        }
        public var acceleratorId: String?

        public var backendPorts: [ListListenersResponseBody.Listeners.BackendPorts]?

        public var certificates: [ListListenersResponseBody.Listeners.Certificates]?

        public var clientAffinity: String?

        public var createTime: Int64?

        public var description_: String?

        public var idleTimeout: Int32?

        public var listenerId: String?

        public var name: String?

        public var portRanges: [ListListenersResponseBody.Listeners.PortRanges]?

        public var protocol_: String?

        public var proxyProtocol: Bool?

        public var requestTimeout: Int32?

        public var securityPolicyId: String?

        public var serviceId: String?

        public var serviceManaged: Bool?

        public var serviceManagedInfos: [ListListenersResponseBody.Listeners.ServiceManagedInfos]?

        public var state: String?

        public var type: String?

        public var XForwardedForConfig: ListListenersResponseBody.Listeners.XForwardedForConfig?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.XForwardedForConfig?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.acceleratorId != nil {
                map["AcceleratorId"] = self.acceleratorId!
            }
            if self.backendPorts != nil {
                var tmp : [Any] = []
                for k in self.backendPorts! {
                    tmp.append(k.toMap())
                }
                map["BackendPorts"] = tmp
            }
            if self.certificates != nil {
                var tmp : [Any] = []
                for k in self.certificates! {
                    tmp.append(k.toMap())
                }
                map["Certificates"] = tmp
            }
            if self.clientAffinity != nil {
                map["ClientAffinity"] = self.clientAffinity!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.idleTimeout != nil {
                map["IdleTimeout"] = self.idleTimeout!
            }
            if self.listenerId != nil {
                map["ListenerId"] = self.listenerId!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.portRanges != nil {
                var tmp : [Any] = []
                for k in self.portRanges! {
                    tmp.append(k.toMap())
                }
                map["PortRanges"] = tmp
            }
            if self.protocol_ != nil {
                map["Protocol"] = self.protocol_!
            }
            if self.proxyProtocol != nil {
                map["ProxyProtocol"] = self.proxyProtocol!
            }
            if self.requestTimeout != nil {
                map["RequestTimeout"] = self.requestTimeout!
            }
            if self.securityPolicyId != nil {
                map["SecurityPolicyId"] = self.securityPolicyId!
            }
            if self.serviceId != nil {
                map["ServiceId"] = self.serviceId!
            }
            if self.serviceManaged != nil {
                map["ServiceManaged"] = self.serviceManaged!
            }
            if self.serviceManagedInfos != nil {
                var tmp : [Any] = []
                for k in self.serviceManagedInfos! {
                    tmp.append(k.toMap())
                }
                map["ServiceManagedInfos"] = tmp
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.XForwardedForConfig != nil {
                map["XForwardedForConfig"] = self.XForwardedForConfig?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AcceleratorId") && dict["AcceleratorId"] != nil {
                self.acceleratorId = dict["AcceleratorId"] as! String
            }
            if dict.keys.contains("BackendPorts") && dict["BackendPorts"] != nil {
                var tmp : [ListListenersResponseBody.Listeners.BackendPorts] = []
                for v in dict["BackendPorts"] as! [Any] {
                    var model = ListListenersResponseBody.Listeners.BackendPorts()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.backendPorts = tmp
            }
            if dict.keys.contains("Certificates") && dict["Certificates"] != nil {
                var tmp : [ListListenersResponseBody.Listeners.Certificates] = []
                for v in dict["Certificates"] as! [Any] {
                    var model = ListListenersResponseBody.Listeners.Certificates()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.certificates = tmp
            }
            if dict.keys.contains("ClientAffinity") && dict["ClientAffinity"] != nil {
                self.clientAffinity = dict["ClientAffinity"] as! String
            }
            if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                self.createTime = dict["CreateTime"] as! Int64
            }
            if dict.keys.contains("Description") && dict["Description"] != nil {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("IdleTimeout") && dict["IdleTimeout"] != nil {
                self.idleTimeout = dict["IdleTimeout"] as! Int32
            }
            if dict.keys.contains("ListenerId") && dict["ListenerId"] != nil {
                self.listenerId = dict["ListenerId"] as! String
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("PortRanges") && dict["PortRanges"] != nil {
                var tmp : [ListListenersResponseBody.Listeners.PortRanges] = []
                for v in dict["PortRanges"] as! [Any] {
                    var model = ListListenersResponseBody.Listeners.PortRanges()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.portRanges = tmp
            }
            if dict.keys.contains("Protocol") && dict["Protocol"] != nil {
                self.protocol_ = dict["Protocol"] as! String
            }
            if dict.keys.contains("ProxyProtocol") && dict["ProxyProtocol"] != nil {
                self.proxyProtocol = dict["ProxyProtocol"] as! Bool
            }
            if dict.keys.contains("RequestTimeout") && dict["RequestTimeout"] != nil {
                self.requestTimeout = dict["RequestTimeout"] as! Int32
            }
            if dict.keys.contains("SecurityPolicyId") && dict["SecurityPolicyId"] != nil {
                self.securityPolicyId = dict["SecurityPolicyId"] as! String
            }
            if dict.keys.contains("ServiceId") && dict["ServiceId"] != nil {
                self.serviceId = dict["ServiceId"] as! String
            }
            if dict.keys.contains("ServiceManaged") && dict["ServiceManaged"] != nil {
                self.serviceManaged = dict["ServiceManaged"] as! Bool
            }
            if dict.keys.contains("ServiceManagedInfos") && dict["ServiceManagedInfos"] != nil {
                var tmp : [ListListenersResponseBody.Listeners.ServiceManagedInfos] = []
                for v in dict["ServiceManagedInfos"] as! [Any] {
                    var model = ListListenersResponseBody.Listeners.ServiceManagedInfos()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.serviceManagedInfos = tmp
            }
            if dict.keys.contains("State") && dict["State"] != nil {
                self.state = dict["State"] as! String
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
            if dict.keys.contains("XForwardedForConfig") && dict["XForwardedForConfig"] != nil {
                var model = ListListenersResponseBody.Listeners.XForwardedForConfig()
                model.fromMap(dict["XForwardedForConfig"] as! [String: Any])
                self.XForwardedForConfig = model
            }
        }
    }
    public var listeners: [ListListenersResponseBody.Listeners]?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.listeners != nil {
            var tmp : [Any] = []
            for k in self.listeners! {
                tmp.append(k.toMap())
            }
            map["Listeners"] = tmp
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Listeners") && dict["Listeners"] != nil {
            var tmp : [ListListenersResponseBody.Listeners] = []
            for v in dict["Listeners"] as! [Any] {
                var model = ListListenersResponseBody.Listeners()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.listeners = tmp
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class ListListenersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListListenersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListListenersResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListSpareIpsRequest : Tea.TeaModel {
    public var acceleratorId: String?

    public var clientToken: String?

    public var dryRun: Bool?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceleratorId != nil {
            map["AcceleratorId"] = self.acceleratorId!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceleratorId") && dict["AcceleratorId"] != nil {
            self.acceleratorId = dict["AcceleratorId"] as! String
        }
        if dict.keys.contains("ClientToken") && dict["ClientToken"] != nil {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("DryRun") && dict["DryRun"] != nil {
            self.dryRun = dict["DryRun"] as! Bool
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class ListSpareIpsResponseBody : Tea.TeaModel {
    public class SpareIps : Tea.TeaModel {
        public var spareIp: String?

        public var state: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.spareIp != nil {
                map["SpareIp"] = self.spareIp!
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("SpareIp") && dict["SpareIp"] != nil {
                self.spareIp = dict["SpareIp"] as! String
            }
            if dict.keys.contains("State") && dict["State"] != nil {
                self.state = dict["State"] as! String
            }
        }
    }
    public var requestId: String?

    public var spareIps: [ListSpareIpsResponseBody.SpareIps]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.spareIps != nil {
            var tmp : [Any] = []
            for k in self.spareIps! {
                tmp.append(k.toMap())
            }
            map["SpareIps"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SpareIps") && dict["SpareIps"] != nil {
            var tmp : [ListSpareIpsResponseBody.SpareIps] = []
            for v in dict["SpareIps"] as! [Any] {
                var model = ListSpareIpsResponseBody.SpareIps()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.spareIps = tmp
        }
    }
}

public class ListSpareIpsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListSpareIpsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListSpareIpsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListSystemSecurityPoliciesRequest : Tea.TeaModel {
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class ListSystemSecurityPoliciesResponseBody : Tea.TeaModel {
    public class SecurityPolicies : Tea.TeaModel {
        public var ciphers: [String]?

        public var securityPolicyId: String?

        public var tlsVersions: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ciphers != nil {
                map["Ciphers"] = self.ciphers!
            }
            if self.securityPolicyId != nil {
                map["SecurityPolicyId"] = self.securityPolicyId!
            }
            if self.tlsVersions != nil {
                map["TlsVersions"] = self.tlsVersions!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Ciphers") && dict["Ciphers"] != nil {
                self.ciphers = dict["Ciphers"] as! [String]
            }
            if dict.keys.contains("SecurityPolicyId") && dict["SecurityPolicyId"] != nil {
                self.securityPolicyId = dict["SecurityPolicyId"] as! String
            }
            if dict.keys.contains("TlsVersions") && dict["TlsVersions"] != nil {
                self.tlsVersions = dict["TlsVersions"] as! [String]
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var securityPolicies: [ListSystemSecurityPoliciesResponseBody.SecurityPolicies]?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.securityPolicies != nil {
            var tmp : [Any] = []
            for k in self.securityPolicies! {
                tmp.append(k.toMap())
            }
            map["SecurityPolicies"] = tmp
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SecurityPolicies") && dict["SecurityPolicies"] != nil {
            var tmp : [ListSystemSecurityPoliciesResponseBody.SecurityPolicies] = []
            for v in dict["SecurityPolicies"] as! [Any] {
                var model = ListSystemSecurityPoliciesResponseBody.SecurityPolicies()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.securityPolicies = tmp
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class ListSystemSecurityPoliciesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListSystemSecurityPoliciesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListSystemSecurityPoliciesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListTagResourcesRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") && dict["Key"] != nil {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") && dict["Value"] != nil {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var clientToken: String?

    public var nextToken: String?

    public var regionId: String?

    public var resourceId: [String]?

    public var resourceType: String?

    public var tag: [ListTagResourcesRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") && dict["ClientToken"] != nil {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("NextToken") && dict["NextToken"] != nil {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceId") && dict["ResourceId"] != nil {
            self.resourceId = dict["ResourceId"] as! [String]
        }
        if dict.keys.contains("ResourceType") && dict["ResourceType"] != nil {
            self.resourceType = dict["ResourceType"] as! String
        }
        if dict.keys.contains("Tag") && dict["Tag"] != nil {
            var tmp : [ListTagResourcesRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = ListTagResourcesRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
    }
}

public class ListTagResourcesResponseBody : Tea.TeaModel {
    public class TagResources : Tea.TeaModel {
        public class TagResource : Tea.TeaModel {
            public var resourceId: String?

            public var resourceType: String?

            public var tagKey: String?

            public var tagValue: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.resourceId != nil {
                    map["ResourceId"] = self.resourceId!
                }
                if self.resourceType != nil {
                    map["ResourceType"] = self.resourceType!
                }
                if self.tagKey != nil {
                    map["TagKey"] = self.tagKey!
                }
                if self.tagValue != nil {
                    map["TagValue"] = self.tagValue!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ResourceId") && dict["ResourceId"] != nil {
                    self.resourceId = dict["ResourceId"] as! String
                }
                if dict.keys.contains("ResourceType") && dict["ResourceType"] != nil {
                    self.resourceType = dict["ResourceType"] as! String
                }
                if dict.keys.contains("TagKey") && dict["TagKey"] != nil {
                    self.tagKey = dict["TagKey"] as! String
                }
                if dict.keys.contains("TagValue") && dict["TagValue"] != nil {
                    self.tagValue = dict["TagValue"] as! String
                }
            }
        }
        public var tagResource: [ListTagResourcesResponseBody.TagResources.TagResource]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tagResource != nil {
                var tmp : [Any] = []
                for k in self.tagResource! {
                    tmp.append(k.toMap())
                }
                map["TagResource"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("TagResource") && dict["TagResource"] != nil {
                var tmp : [ListTagResourcesResponseBody.TagResources.TagResource] = []
                for v in dict["TagResource"] as! [Any] {
                    var model = ListTagResourcesResponseBody.TagResources.TagResource()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.tagResource = tmp
            }
        }
    }
    public var nextToken: String?

    public var requestId: String?

    public var tagResources: ListTagResourcesResponseBody.TagResources?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tagResources?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.tagResources != nil {
            map["TagResources"] = self.tagResources?.toMap()
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NextToken") && dict["NextToken"] != nil {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TagResources") && dict["TagResources"] != nil {
            var model = ListTagResourcesResponseBody.TagResources()
            model.fromMap(dict["TagResources"] as! [String: Any])
            self.tagResources = model
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class ListTagResourcesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListTagResourcesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListTagResourcesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class OpenAcceleratorServiceRequest : Tea.TeaModel {
    public var clientToken: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") && dict["ClientToken"] != nil {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class OpenAcceleratorServiceResponseBody : Tea.TeaModel {
    public var code: String?

    public var message: String?

    public var orderId: Int64?

    public var requestId: String?

    public var success: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("OrderId") && dict["OrderId"] != nil {
            self.orderId = dict["OrderId"] as! Int64
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! String
        }
    }
}

public class OpenAcceleratorServiceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: OpenAcceleratorServiceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = OpenAcceleratorServiceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class QueryCrossBorderApprovalStatusRequest : Tea.TeaModel {
    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class QueryCrossBorderApprovalStatusResponseBody : Tea.TeaModel {
    public var approvalStatus: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.approvalStatus != nil {
            map["ApprovalStatus"] = self.approvalStatus!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApprovalStatus") && dict["ApprovalStatus"] != nil {
            self.approvalStatus = dict["ApprovalStatus"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class QueryCrossBorderApprovalStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: QueryCrossBorderApprovalStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = QueryCrossBorderApprovalStatusResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RemoveEntriesFromAclRequest : Tea.TeaModel {
    public class AclEntries : Tea.TeaModel {
        public var entry: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.entry != nil {
                map["Entry"] = self.entry!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Entry") && dict["Entry"] != nil {
                self.entry = dict["Entry"] as! String
            }
        }
    }
    public var aclEntries: [RemoveEntriesFromAclRequest.AclEntries]?

    public var aclId: String?

    public var clientToken: String?

    public var dryRun: Bool?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aclEntries != nil {
            var tmp : [Any] = []
            for k in self.aclEntries! {
                tmp.append(k.toMap())
            }
            map["AclEntries"] = tmp
        }
        if self.aclId != nil {
            map["AclId"] = self.aclId!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AclEntries") && dict["AclEntries"] != nil {
            var tmp : [RemoveEntriesFromAclRequest.AclEntries] = []
            for v in dict["AclEntries"] as! [Any] {
                var model = RemoveEntriesFromAclRequest.AclEntries()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.aclEntries = tmp
        }
        if dict.keys.contains("AclId") && dict["AclId"] != nil {
            self.aclId = dict["AclId"] as! String
        }
        if dict.keys.contains("ClientToken") && dict["ClientToken"] != nil {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("DryRun") && dict["DryRun"] != nil {
            self.dryRun = dict["DryRun"] as! Bool
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class RemoveEntriesFromAclResponseBody : Tea.TeaModel {
    public var aclId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aclId != nil {
            map["AclId"] = self.aclId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AclId") && dict["AclId"] != nil {
            self.aclId = dict["AclId"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class RemoveEntriesFromAclResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RemoveEntriesFromAclResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = RemoveEntriesFromAclResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ReplaceBandwidthPackageRequest : Tea.TeaModel {
    public var acceleratorId: String?

    public var bandwidthPackageId: String?

    public var regionId: String?

    public var targetBandwidthPackageId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceleratorId != nil {
            map["AcceleratorId"] = self.acceleratorId!
        }
        if self.bandwidthPackageId != nil {
            map["BandwidthPackageId"] = self.bandwidthPackageId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.targetBandwidthPackageId != nil {
            map["TargetBandwidthPackageId"] = self.targetBandwidthPackageId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceleratorId") && dict["AcceleratorId"] != nil {
            self.acceleratorId = dict["AcceleratorId"] as! String
        }
        if dict.keys.contains("BandwidthPackageId") && dict["BandwidthPackageId"] != nil {
            self.bandwidthPackageId = dict["BandwidthPackageId"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("TargetBandwidthPackageId") && dict["TargetBandwidthPackageId"] != nil {
            self.targetBandwidthPackageId = dict["TargetBandwidthPackageId"] as! String
        }
    }
}

public class ReplaceBandwidthPackageResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ReplaceBandwidthPackageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ReplaceBandwidthPackageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ReplaceBandwidthPackageResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class TagResourcesRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") && dict["Key"] != nil {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") && dict["Value"] != nil {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var clientToken: String?

    public var regionId: String?

    public var resourceId: [String]?

    public var resourceType: String?

    public var tag: [TagResourcesRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") && dict["ClientToken"] != nil {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceId") && dict["ResourceId"] != nil {
            self.resourceId = dict["ResourceId"] as! [String]
        }
        if dict.keys.contains("ResourceType") && dict["ResourceType"] != nil {
            self.resourceType = dict["ResourceType"] as! String
        }
        if dict.keys.contains("Tag") && dict["Tag"] != nil {
            var tmp : [TagResourcesRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = TagResourcesRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
    }
}

public class TagResourcesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class TagResourcesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: TagResourcesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = TagResourcesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UntagResourcesRequest : Tea.TeaModel {
    public var all: Bool?

    public var clientToken: String?

    public var regionId: String?

    public var resourceId: [String]?

    public var resourceType: String?

    public var tagKey: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.all != nil {
            map["All"] = self.all!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.tagKey != nil {
            map["TagKey"] = self.tagKey!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("All") && dict["All"] != nil {
            self.all = dict["All"] as! Bool
        }
        if dict.keys.contains("ClientToken") && dict["ClientToken"] != nil {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceId") && dict["ResourceId"] != nil {
            self.resourceId = dict["ResourceId"] as! [String]
        }
        if dict.keys.contains("ResourceType") && dict["ResourceType"] != nil {
            self.resourceType = dict["ResourceType"] as! String
        }
        if dict.keys.contains("TagKey") && dict["TagKey"] != nil {
            self.tagKey = dict["TagKey"] as! [String]
        }
    }
}

public class UntagResourcesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UntagResourcesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UntagResourcesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UntagResourcesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateAcceleratorRequest : Tea.TeaModel {
    public var acceleratorId: String?

    public var autoPay: Bool?

    public var autoUseCoupon: Bool?

    public var clientToken: String?

    public var description_: String?

    public var name: String?

    public var regionId: String?

    public var spec: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceleratorId != nil {
            map["AcceleratorId"] = self.acceleratorId!
        }
        if self.autoPay != nil {
            map["AutoPay"] = self.autoPay!
        }
        if self.autoUseCoupon != nil {
            map["AutoUseCoupon"] = self.autoUseCoupon!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.spec != nil {
            map["Spec"] = self.spec!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceleratorId") && dict["AcceleratorId"] != nil {
            self.acceleratorId = dict["AcceleratorId"] as! String
        }
        if dict.keys.contains("AutoPay") && dict["AutoPay"] != nil {
            self.autoPay = dict["AutoPay"] as! Bool
        }
        if dict.keys.contains("AutoUseCoupon") && dict["AutoUseCoupon"] != nil {
            self.autoUseCoupon = dict["AutoUseCoupon"] as! Bool
        }
        if dict.keys.contains("ClientToken") && dict["ClientToken"] != nil {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("Spec") && dict["Spec"] != nil {
            self.spec = dict["Spec"] as! String
        }
    }
}

public class UpdateAcceleratorResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateAcceleratorResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateAcceleratorResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateAcceleratorResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateAcceleratorAutoRenewAttributeRequest : Tea.TeaModel {
    public var acceleratorId: String?

    public var autoRenew: Bool?

    public var autoRenewDuration: Int32?

    public var clientToken: String?

    public var name: String?

    public var regionId: String?

    public var renewalStatus: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceleratorId != nil {
            map["AcceleratorId"] = self.acceleratorId!
        }
        if self.autoRenew != nil {
            map["AutoRenew"] = self.autoRenew!
        }
        if self.autoRenewDuration != nil {
            map["AutoRenewDuration"] = self.autoRenewDuration!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.renewalStatus != nil {
            map["RenewalStatus"] = self.renewalStatus!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceleratorId") && dict["AcceleratorId"] != nil {
            self.acceleratorId = dict["AcceleratorId"] as! String
        }
        if dict.keys.contains("AutoRenew") && dict["AutoRenew"] != nil {
            self.autoRenew = dict["AutoRenew"] as! Bool
        }
        if dict.keys.contains("AutoRenewDuration") && dict["AutoRenewDuration"] != nil {
            self.autoRenewDuration = dict["AutoRenewDuration"] as! Int32
        }
        if dict.keys.contains("ClientToken") && dict["ClientToken"] != nil {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("RenewalStatus") && dict["RenewalStatus"] != nil {
            self.renewalStatus = dict["RenewalStatus"] as! String
        }
    }
}

public class UpdateAcceleratorAutoRenewAttributeResponseBody : Tea.TeaModel {
    public var acceleratorId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceleratorId != nil {
            map["AcceleratorId"] = self.acceleratorId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceleratorId") && dict["AcceleratorId"] != nil {
            self.acceleratorId = dict["AcceleratorId"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateAcceleratorAutoRenewAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateAcceleratorAutoRenewAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateAcceleratorAutoRenewAttributeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateAcceleratorConfirmRequest : Tea.TeaModel {
    public var acceleratorId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceleratorId != nil {
            map["AcceleratorId"] = self.acceleratorId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceleratorId") && dict["AcceleratorId"] != nil {
            self.acceleratorId = dict["AcceleratorId"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class UpdateAcceleratorConfirmResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateAcceleratorConfirmResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateAcceleratorConfirmResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateAcceleratorConfirmResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateAcceleratorCrossBorderModeRequest : Tea.TeaModel {
    public var acceleratorId: String?

    public var clientToken: String?

    public var crossBorderMode: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceleratorId != nil {
            map["AcceleratorId"] = self.acceleratorId!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.crossBorderMode != nil {
            map["CrossBorderMode"] = self.crossBorderMode!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceleratorId") && dict["AcceleratorId"] != nil {
            self.acceleratorId = dict["AcceleratorId"] as! String
        }
        if dict.keys.contains("ClientToken") && dict["ClientToken"] != nil {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("CrossBorderMode") && dict["CrossBorderMode"] != nil {
            self.crossBorderMode = dict["CrossBorderMode"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class UpdateAcceleratorCrossBorderModeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateAcceleratorCrossBorderModeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateAcceleratorCrossBorderModeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateAcceleratorCrossBorderModeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateAcceleratorCrossBorderStatusRequest : Tea.TeaModel {
    public var acceleratorId: String?

    public var clientToken: String?

    public var crossBorderStatus: Bool?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceleratorId != nil {
            map["AcceleratorId"] = self.acceleratorId!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.crossBorderStatus != nil {
            map["CrossBorderStatus"] = self.crossBorderStatus!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceleratorId") && dict["AcceleratorId"] != nil {
            self.acceleratorId = dict["AcceleratorId"] as! String
        }
        if dict.keys.contains("ClientToken") && dict["ClientToken"] != nil {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("CrossBorderStatus") && dict["CrossBorderStatus"] != nil {
            self.crossBorderStatus = dict["CrossBorderStatus"] as! Bool
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class UpdateAcceleratorCrossBorderStatusResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateAcceleratorCrossBorderStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateAcceleratorCrossBorderStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateAcceleratorCrossBorderStatusResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateAclAttributeRequest : Tea.TeaModel {
    public var aclId: String?

    public var aclName: String?

    public var clientToken: String?

    public var dryRun: Bool?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aclId != nil {
            map["AclId"] = self.aclId!
        }
        if self.aclName != nil {
            map["AclName"] = self.aclName!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AclId") && dict["AclId"] != nil {
            self.aclId = dict["AclId"] as! String
        }
        if dict.keys.contains("AclName") && dict["AclName"] != nil {
            self.aclName = dict["AclName"] as! String
        }
        if dict.keys.contains("ClientToken") && dict["ClientToken"] != nil {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("DryRun") && dict["DryRun"] != nil {
            self.dryRun = dict["DryRun"] as! Bool
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class UpdateAclAttributeResponseBody : Tea.TeaModel {
    public var aclId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.aclId != nil {
            map["AclId"] = self.aclId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AclId") && dict["AclId"] != nil {
            self.aclId = dict["AclId"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateAclAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateAclAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateAclAttributeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateAdditionalCertificateWithListenerRequest : Tea.TeaModel {
    public var acceleratorId: String?

    public var certificateId: String?

    public var clientToken: String?

    public var domain: String?

    public var dryRun: Bool?

    public var listenerId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceleratorId != nil {
            map["AcceleratorId"] = self.acceleratorId!
        }
        if self.certificateId != nil {
            map["CertificateId"] = self.certificateId!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.domain != nil {
            map["Domain"] = self.domain!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.listenerId != nil {
            map["ListenerId"] = self.listenerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceleratorId") && dict["AcceleratorId"] != nil {
            self.acceleratorId = dict["AcceleratorId"] as! String
        }
        if dict.keys.contains("CertificateId") && dict["CertificateId"] != nil {
            self.certificateId = dict["CertificateId"] as! String
        }
        if dict.keys.contains("ClientToken") && dict["ClientToken"] != nil {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("Domain") && dict["Domain"] != nil {
            self.domain = dict["Domain"] as! String
        }
        if dict.keys.contains("DryRun") && dict["DryRun"] != nil {
            self.dryRun = dict["DryRun"] as! Bool
        }
        if dict.keys.contains("ListenerId") && dict["ListenerId"] != nil {
            self.listenerId = dict["ListenerId"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class UpdateAdditionalCertificateWithListenerResponseBody : Tea.TeaModel {
    public var listenerId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.listenerId != nil {
            map["ListenerId"] = self.listenerId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ListenerId") && dict["ListenerId"] != nil {
            self.listenerId = dict["ListenerId"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateAdditionalCertificateWithListenerResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateAdditionalCertificateWithListenerResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateAdditionalCertificateWithListenerResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateApplicationMonitorRequest : Tea.TeaModel {
    public var address: String?

    public var clientToken: String?

    public var detectEnable: Bool?

    public var detectThreshold: Int32?

    public var detectTimes: Int32?

    public var listenerId: String?

    public var optionsJson: String?

    public var regionId: String?

    public var silenceTime: Int32?

    public var taskId: String?

    public var taskName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.address != nil {
            map["Address"] = self.address!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.detectEnable != nil {
            map["DetectEnable"] = self.detectEnable!
        }
        if self.detectThreshold != nil {
            map["DetectThreshold"] = self.detectThreshold!
        }
        if self.detectTimes != nil {
            map["DetectTimes"] = self.detectTimes!
        }
        if self.listenerId != nil {
            map["ListenerId"] = self.listenerId!
        }
        if self.optionsJson != nil {
            map["OptionsJson"] = self.optionsJson!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.silenceTime != nil {
            map["SilenceTime"] = self.silenceTime!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        if self.taskName != nil {
            map["TaskName"] = self.taskName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Address") && dict["Address"] != nil {
            self.address = dict["Address"] as! String
        }
        if dict.keys.contains("ClientToken") && dict["ClientToken"] != nil {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("DetectEnable") && dict["DetectEnable"] != nil {
            self.detectEnable = dict["DetectEnable"] as! Bool
        }
        if dict.keys.contains("DetectThreshold") && dict["DetectThreshold"] != nil {
            self.detectThreshold = dict["DetectThreshold"] as! Int32
        }
        if dict.keys.contains("DetectTimes") && dict["DetectTimes"] != nil {
            self.detectTimes = dict["DetectTimes"] as! Int32
        }
        if dict.keys.contains("ListenerId") && dict["ListenerId"] != nil {
            self.listenerId = dict["ListenerId"] as! String
        }
        if dict.keys.contains("OptionsJson") && dict["OptionsJson"] != nil {
            self.optionsJson = dict["OptionsJson"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("SilenceTime") && dict["SilenceTime"] != nil {
            self.silenceTime = dict["SilenceTime"] as! Int32
        }
        if dict.keys.contains("TaskId") && dict["TaskId"] != nil {
            self.taskId = dict["TaskId"] as! String
        }
        if dict.keys.contains("TaskName") && dict["TaskName"] != nil {
            self.taskName = dict["TaskName"] as! String
        }
    }
}

public class UpdateApplicationMonitorResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateApplicationMonitorResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateApplicationMonitorResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateApplicationMonitorResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateBandwidthPackagaAutoRenewAttributeRequest : Tea.TeaModel {
    public var autoRenew: Bool?

    public var autoRenewDuration: Int32?

    public var clientToken: String?

    public var instanceId: String?

    public var name: String?

    public var regionId: String?

    public var renewalStatus: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.autoRenew != nil {
            map["AutoRenew"] = self.autoRenew!
        }
        if self.autoRenewDuration != nil {
            map["AutoRenewDuration"] = self.autoRenewDuration!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.renewalStatus != nil {
            map["RenewalStatus"] = self.renewalStatus!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AutoRenew") && dict["AutoRenew"] != nil {
            self.autoRenew = dict["AutoRenew"] as! Bool
        }
        if dict.keys.contains("AutoRenewDuration") && dict["AutoRenewDuration"] != nil {
            self.autoRenewDuration = dict["AutoRenewDuration"] as! Int32
        }
        if dict.keys.contains("ClientToken") && dict["ClientToken"] != nil {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("RenewalStatus") && dict["RenewalStatus"] != nil {
            self.renewalStatus = dict["RenewalStatus"] as! String
        }
    }
}

public class UpdateBandwidthPackagaAutoRenewAttributeResponseBody : Tea.TeaModel {
    public var instanceId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateBandwidthPackagaAutoRenewAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateBandwidthPackagaAutoRenewAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateBandwidthPackagaAutoRenewAttributeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateBandwidthPackageRequest : Tea.TeaModel {
    public var autoPay: Bool?

    public var autoUseCoupon: Bool?

    public var bandwidth: Int32?

    public var bandwidthPackageId: String?

    public var bandwidthType: String?

    public var description_: String?

    public var name: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.autoPay != nil {
            map["AutoPay"] = self.autoPay!
        }
        if self.autoUseCoupon != nil {
            map["AutoUseCoupon"] = self.autoUseCoupon!
        }
        if self.bandwidth != nil {
            map["Bandwidth"] = self.bandwidth!
        }
        if self.bandwidthPackageId != nil {
            map["BandwidthPackageId"] = self.bandwidthPackageId!
        }
        if self.bandwidthType != nil {
            map["BandwidthType"] = self.bandwidthType!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AutoPay") && dict["AutoPay"] != nil {
            self.autoPay = dict["AutoPay"] as! Bool
        }
        if dict.keys.contains("AutoUseCoupon") && dict["AutoUseCoupon"] != nil {
            self.autoUseCoupon = dict["AutoUseCoupon"] as! Bool
        }
        if dict.keys.contains("Bandwidth") && dict["Bandwidth"] != nil {
            self.bandwidth = dict["Bandwidth"] as! Int32
        }
        if dict.keys.contains("BandwidthPackageId") && dict["BandwidthPackageId"] != nil {
            self.bandwidthPackageId = dict["BandwidthPackageId"] as! String
        }
        if dict.keys.contains("BandwidthType") && dict["BandwidthType"] != nil {
            self.bandwidthType = dict["BandwidthType"] as! String
        }
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class UpdateBandwidthPackageResponseBody : Tea.TeaModel {
    public var bandwidthPackage: String?

    public var description_: String?

    public var name: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bandwidthPackage != nil {
            map["BandwidthPackage"] = self.bandwidthPackage!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BandwidthPackage") && dict["BandwidthPackage"] != nil {
            self.bandwidthPackage = dict["BandwidthPackage"] as! String
        }
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateBandwidthPackageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateBandwidthPackageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateBandwidthPackageResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateBasicAcceleratorRequest : Tea.TeaModel {
    public var acceleratorId: String?

    public var clientToken: String?

    public var description_: String?

    public var name: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceleratorId != nil {
            map["AcceleratorId"] = self.acceleratorId!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceleratorId") && dict["AcceleratorId"] != nil {
            self.acceleratorId = dict["AcceleratorId"] as! String
        }
        if dict.keys.contains("ClientToken") && dict["ClientToken"] != nil {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class UpdateBasicAcceleratorResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateBasicAcceleratorResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateBasicAcceleratorResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateBasicAcceleratorResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateBasicEndpointRequest : Tea.TeaModel {
    public var clientToken: String?

    public var endpointGroupId: String?

    public var endpointId: String?

    public var name: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.endpointGroupId != nil {
            map["EndpointGroupId"] = self.endpointGroupId!
        }
        if self.endpointId != nil {
            map["EndpointId"] = self.endpointId!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") && dict["ClientToken"] != nil {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("EndpointGroupId") && dict["EndpointGroupId"] != nil {
            self.endpointGroupId = dict["EndpointGroupId"] as! String
        }
        if dict.keys.contains("EndpointId") && dict["EndpointId"] != nil {
            self.endpointId = dict["EndpointId"] as! String
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class UpdateBasicEndpointResponseBody : Tea.TeaModel {
    public var endpointGroupId: String?

    public var endpointId: String?

    public var name: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endpointGroupId != nil {
            map["EndpointGroupId"] = self.endpointGroupId!
        }
        if self.endpointId != nil {
            map["EndpointId"] = self.endpointId!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndpointGroupId") && dict["EndpointGroupId"] != nil {
            self.endpointGroupId = dict["EndpointGroupId"] as! String
        }
        if dict.keys.contains("EndpointId") && dict["EndpointId"] != nil {
            self.endpointId = dict["EndpointId"] as! String
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateBasicEndpointResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateBasicEndpointResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateBasicEndpointResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateBasicEndpointGroupRequest : Tea.TeaModel {
    public var clientToken: String?

    public var description_: String?

    public var endpointAddress: String?

    public var endpointGroupId: String?

    public var endpointSubAddress: String?

    public var endpointType: String?

    public var name: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.endpointAddress != nil {
            map["EndpointAddress"] = self.endpointAddress!
        }
        if self.endpointGroupId != nil {
            map["EndpointGroupId"] = self.endpointGroupId!
        }
        if self.endpointSubAddress != nil {
            map["EndpointSubAddress"] = self.endpointSubAddress!
        }
        if self.endpointType != nil {
            map["EndpointType"] = self.endpointType!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") && dict["ClientToken"] != nil {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("EndpointAddress") && dict["EndpointAddress"] != nil {
            self.endpointAddress = dict["EndpointAddress"] as! String
        }
        if dict.keys.contains("EndpointGroupId") && dict["EndpointGroupId"] != nil {
            self.endpointGroupId = dict["EndpointGroupId"] as! String
        }
        if dict.keys.contains("EndpointSubAddress") && dict["EndpointSubAddress"] != nil {
            self.endpointSubAddress = dict["EndpointSubAddress"] as! String
        }
        if dict.keys.contains("EndpointType") && dict["EndpointType"] != nil {
            self.endpointType = dict["EndpointType"] as! String
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class UpdateBasicEndpointGroupResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateBasicEndpointGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateBasicEndpointGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateBasicEndpointGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateBasicIpSetRequest : Tea.TeaModel {
    public var bandwidth: Int32?

    public var clientToken: String?

    public var ipSetId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bandwidth != nil {
            map["Bandwidth"] = self.bandwidth!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ipSetId != nil {
            map["IpSetId"] = self.ipSetId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Bandwidth") && dict["Bandwidth"] != nil {
            self.bandwidth = dict["Bandwidth"] as! Int32
        }
        if dict.keys.contains("ClientToken") && dict["ClientToken"] != nil {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("IpSetId") && dict["IpSetId"] != nil {
            self.ipSetId = dict["IpSetId"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class UpdateBasicIpSetResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateBasicIpSetResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateBasicIpSetResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateBasicIpSetResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateCustomRoutingEndpointGroupAttributeRequest : Tea.TeaModel {
    public var clientToken: String?

    public var description_: String?

    public var endpointGroupId: String?

    public var name: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.endpointGroupId != nil {
            map["EndpointGroupId"] = self.endpointGroupId!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") && dict["ClientToken"] != nil {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("EndpointGroupId") && dict["EndpointGroupId"] != nil {
            self.endpointGroupId = dict["EndpointGroupId"] as! String
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class UpdateCustomRoutingEndpointGroupAttributeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateCustomRoutingEndpointGroupAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateCustomRoutingEndpointGroupAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateCustomRoutingEndpointGroupAttributeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateCustomRoutingEndpointGroupDestinationsRequest : Tea.TeaModel {
    public class DestinationConfigurations : Tea.TeaModel {
        public var destinationId: String?

        public var fromPort: Int32?

        public var protocols: [String]?

        public var toPort: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.destinationId != nil {
                map["DestinationId"] = self.destinationId!
            }
            if self.fromPort != nil {
                map["FromPort"] = self.fromPort!
            }
            if self.protocols != nil {
                map["Protocols"] = self.protocols!
            }
            if self.toPort != nil {
                map["ToPort"] = self.toPort!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DestinationId") && dict["DestinationId"] != nil {
                self.destinationId = dict["DestinationId"] as! String
            }
            if dict.keys.contains("FromPort") && dict["FromPort"] != nil {
                self.fromPort = dict["FromPort"] as! Int32
            }
            if dict.keys.contains("Protocols") && dict["Protocols"] != nil {
                self.protocols = dict["Protocols"] as! [String]
            }
            if dict.keys.contains("ToPort") && dict["ToPort"] != nil {
                self.toPort = dict["ToPort"] as! Int32
            }
        }
    }
    public var clientToken: String?

    public var destinationConfigurations: [UpdateCustomRoutingEndpointGroupDestinationsRequest.DestinationConfigurations]?

    public var dryRun: Bool?

    public var endpointGroupId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.destinationConfigurations != nil {
            var tmp : [Any] = []
            for k in self.destinationConfigurations! {
                tmp.append(k.toMap())
            }
            map["DestinationConfigurations"] = tmp
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.endpointGroupId != nil {
            map["EndpointGroupId"] = self.endpointGroupId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") && dict["ClientToken"] != nil {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("DestinationConfigurations") && dict["DestinationConfigurations"] != nil {
            var tmp : [UpdateCustomRoutingEndpointGroupDestinationsRequest.DestinationConfigurations] = []
            for v in dict["DestinationConfigurations"] as! [Any] {
                var model = UpdateCustomRoutingEndpointGroupDestinationsRequest.DestinationConfigurations()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.destinationConfigurations = tmp
        }
        if dict.keys.contains("DryRun") && dict["DryRun"] != nil {
            self.dryRun = dict["DryRun"] as! Bool
        }
        if dict.keys.contains("EndpointGroupId") && dict["EndpointGroupId"] != nil {
            self.endpointGroupId = dict["EndpointGroupId"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class UpdateCustomRoutingEndpointGroupDestinationsResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateCustomRoutingEndpointGroupDestinationsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateCustomRoutingEndpointGroupDestinationsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateCustomRoutingEndpointGroupDestinationsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateCustomRoutingEndpointTrafficPoliciesRequest : Tea.TeaModel {
    public class PolicyConfigurations : Tea.TeaModel {
        public class PortRanges : Tea.TeaModel {
            public var fromPort: Int32?

            public var toPort: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.fromPort != nil {
                    map["FromPort"] = self.fromPort!
                }
                if self.toPort != nil {
                    map["ToPort"] = self.toPort!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("FromPort") && dict["FromPort"] != nil {
                    self.fromPort = dict["FromPort"] as! Int32
                }
                if dict.keys.contains("ToPort") && dict["ToPort"] != nil {
                    self.toPort = dict["ToPort"] as! Int32
                }
            }
        }
        public var address: String?

        public var policyId: String?

        public var portRanges: [UpdateCustomRoutingEndpointTrafficPoliciesRequest.PolicyConfigurations.PortRanges]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.address != nil {
                map["Address"] = self.address!
            }
            if self.policyId != nil {
                map["PolicyId"] = self.policyId!
            }
            if self.portRanges != nil {
                var tmp : [Any] = []
                for k in self.portRanges! {
                    tmp.append(k.toMap())
                }
                map["PortRanges"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Address") && dict["Address"] != nil {
                self.address = dict["Address"] as! String
            }
            if dict.keys.contains("PolicyId") && dict["PolicyId"] != nil {
                self.policyId = dict["PolicyId"] as! String
            }
            if dict.keys.contains("PortRanges") && dict["PortRanges"] != nil {
                var tmp : [UpdateCustomRoutingEndpointTrafficPoliciesRequest.PolicyConfigurations.PortRanges] = []
                for v in dict["PortRanges"] as! [Any] {
                    var model = UpdateCustomRoutingEndpointTrafficPoliciesRequest.PolicyConfigurations.PortRanges()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.portRanges = tmp
            }
        }
    }
    public var clientToken: String?

    public var endpointId: String?

    public var policyConfigurations: [UpdateCustomRoutingEndpointTrafficPoliciesRequest.PolicyConfigurations]?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.endpointId != nil {
            map["EndpointId"] = self.endpointId!
        }
        if self.policyConfigurations != nil {
            var tmp : [Any] = []
            for k in self.policyConfigurations! {
                tmp.append(k.toMap())
            }
            map["PolicyConfigurations"] = tmp
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") && dict["ClientToken"] != nil {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("EndpointId") && dict["EndpointId"] != nil {
            self.endpointId = dict["EndpointId"] as! String
        }
        if dict.keys.contains("PolicyConfigurations") && dict["PolicyConfigurations"] != nil {
            var tmp : [UpdateCustomRoutingEndpointTrafficPoliciesRequest.PolicyConfigurations] = []
            for v in dict["PolicyConfigurations"] as! [Any] {
                var model = UpdateCustomRoutingEndpointTrafficPoliciesRequest.PolicyConfigurations()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.policyConfigurations = tmp
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class UpdateCustomRoutingEndpointTrafficPoliciesResponseBody : Tea.TeaModel {
    public var policyIds: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.policyIds != nil {
            map["PolicyIds"] = self.policyIds!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PolicyIds") && dict["PolicyIds"] != nil {
            self.policyIds = dict["PolicyIds"] as! [String]
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateCustomRoutingEndpointTrafficPoliciesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateCustomRoutingEndpointTrafficPoliciesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateCustomRoutingEndpointTrafficPoliciesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateCustomRoutingEndpointsRequest : Tea.TeaModel {
    public class EndpointConfigurations : Tea.TeaModel {
        public class PolicyConfigurations : Tea.TeaModel {
            public class PortRanges : Tea.TeaModel {
                public var fromPort: String?

                public var toPort: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.fromPort != nil {
                        map["FromPort"] = self.fromPort!
                    }
                    if self.toPort != nil {
                        map["ToPort"] = self.toPort!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("FromPort") && dict["FromPort"] != nil {
                        self.fromPort = dict["FromPort"] as! String
                    }
                    if dict.keys.contains("ToPort") && dict["ToPort"] != nil {
                        self.toPort = dict["ToPort"] as! String
                    }
                }
            }
            public var address: String?

            public var portRanges: [UpdateCustomRoutingEndpointsRequest.EndpointConfigurations.PolicyConfigurations.PortRanges]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.address != nil {
                    map["Address"] = self.address!
                }
                if self.portRanges != nil {
                    var tmp : [Any] = []
                    for k in self.portRanges! {
                        tmp.append(k.toMap())
                    }
                    map["PortRanges"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Address") && dict["Address"] != nil {
                    self.address = dict["Address"] as! String
                }
                if dict.keys.contains("PortRanges") && dict["PortRanges"] != nil {
                    var tmp : [UpdateCustomRoutingEndpointsRequest.EndpointConfigurations.PolicyConfigurations.PortRanges] = []
                    for v in dict["PortRanges"] as! [Any] {
                        var model = UpdateCustomRoutingEndpointsRequest.EndpointConfigurations.PolicyConfigurations.PortRanges()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.portRanges = tmp
                }
            }
        }
        public var endpointId: String?

        public var policyConfigurations: [UpdateCustomRoutingEndpointsRequest.EndpointConfigurations.PolicyConfigurations]?

        public var trafficToEndpointPolicy: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.endpointId != nil {
                map["EndpointId"] = self.endpointId!
            }
            if self.policyConfigurations != nil {
                var tmp : [Any] = []
                for k in self.policyConfigurations! {
                    tmp.append(k.toMap())
                }
                map["PolicyConfigurations"] = tmp
            }
            if self.trafficToEndpointPolicy != nil {
                map["TrafficToEndpointPolicy"] = self.trafficToEndpointPolicy!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EndpointId") && dict["EndpointId"] != nil {
                self.endpointId = dict["EndpointId"] as! String
            }
            if dict.keys.contains("PolicyConfigurations") && dict["PolicyConfigurations"] != nil {
                var tmp : [UpdateCustomRoutingEndpointsRequest.EndpointConfigurations.PolicyConfigurations] = []
                for v in dict["PolicyConfigurations"] as! [Any] {
                    var model = UpdateCustomRoutingEndpointsRequest.EndpointConfigurations.PolicyConfigurations()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.policyConfigurations = tmp
            }
            if dict.keys.contains("TrafficToEndpointPolicy") && dict["TrafficToEndpointPolicy"] != nil {
                self.trafficToEndpointPolicy = dict["TrafficToEndpointPolicy"] as! String
            }
        }
    }
    public var clientToken: String?

    public var endpointConfigurations: [UpdateCustomRoutingEndpointsRequest.EndpointConfigurations]?

    public var endpointGroupId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.endpointConfigurations != nil {
            var tmp : [Any] = []
            for k in self.endpointConfigurations! {
                tmp.append(k.toMap())
            }
            map["EndpointConfigurations"] = tmp
        }
        if self.endpointGroupId != nil {
            map["EndpointGroupId"] = self.endpointGroupId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") && dict["ClientToken"] != nil {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("EndpointConfigurations") && dict["EndpointConfigurations"] != nil {
            var tmp : [UpdateCustomRoutingEndpointsRequest.EndpointConfigurations] = []
            for v in dict["EndpointConfigurations"] as! [Any] {
                var model = UpdateCustomRoutingEndpointsRequest.EndpointConfigurations()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.endpointConfigurations = tmp
        }
        if dict.keys.contains("EndpointGroupId") && dict["EndpointGroupId"] != nil {
            self.endpointGroupId = dict["EndpointGroupId"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class UpdateCustomRoutingEndpointsResponseBody : Tea.TeaModel {
    public var endpointIds: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endpointIds != nil {
            map["EndpointIds"] = self.endpointIds!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndpointIds") && dict["EndpointIds"] != nil {
            self.endpointIds = dict["EndpointIds"] as! [String]
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateCustomRoutingEndpointsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateCustomRoutingEndpointsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateCustomRoutingEndpointsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateDomainRequest : Tea.TeaModel {
    public var domain: String?

    public var regionId: String?

    public var targetDomain: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domain != nil {
            map["Domain"] = self.domain!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.targetDomain != nil {
            map["TargetDomain"] = self.targetDomain!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Domain") && dict["Domain"] != nil {
            self.domain = dict["Domain"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("TargetDomain") && dict["TargetDomain"] != nil {
            self.targetDomain = dict["TargetDomain"] as! String
        }
    }
}

public class UpdateDomainResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateDomainResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateDomainResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateDomainResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateDomainStateRequest : Tea.TeaModel {
    public var domain: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domain != nil {
            map["Domain"] = self.domain!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Domain") && dict["Domain"] != nil {
            self.domain = dict["Domain"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class UpdateDomainStateResponseBody : Tea.TeaModel {
    public var domain: String?

    public var requestId: String?

    public var state: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domain != nil {
            map["Domain"] = self.domain!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.state != nil {
            map["State"] = self.state!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Domain") && dict["Domain"] != nil {
            self.domain = dict["Domain"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("State") && dict["State"] != nil {
            self.state = dict["State"] as! String
        }
    }
}

public class UpdateDomainStateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateDomainStateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateDomainStateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateEndpointGroupRequest : Tea.TeaModel {
    public class EndpointConfigurations : Tea.TeaModel {
        public var enableClientIPPreservation: Bool?

        public var enableProxyProtocol: Bool?

        public var endpoint: String?

        public var subAddress: String?

        public var type: String?

        public var weight: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.enableClientIPPreservation != nil {
                map["EnableClientIPPreservation"] = self.enableClientIPPreservation!
            }
            if self.enableProxyProtocol != nil {
                map["EnableProxyProtocol"] = self.enableProxyProtocol!
            }
            if self.endpoint != nil {
                map["Endpoint"] = self.endpoint!
            }
            if self.subAddress != nil {
                map["SubAddress"] = self.subAddress!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.weight != nil {
                map["Weight"] = self.weight!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EnableClientIPPreservation") && dict["EnableClientIPPreservation"] != nil {
                self.enableClientIPPreservation = dict["EnableClientIPPreservation"] as! Bool
            }
            if dict.keys.contains("EnableProxyProtocol") && dict["EnableProxyProtocol"] != nil {
                self.enableProxyProtocol = dict["EnableProxyProtocol"] as! Bool
            }
            if dict.keys.contains("Endpoint") && dict["Endpoint"] != nil {
                self.endpoint = dict["Endpoint"] as! String
            }
            if dict.keys.contains("SubAddress") && dict["SubAddress"] != nil {
                self.subAddress = dict["SubAddress"] as! String
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
            if dict.keys.contains("Weight") && dict["Weight"] != nil {
                self.weight = dict["Weight"] as! Int32
            }
        }
    }
    public class PortOverrides : Tea.TeaModel {
        public var endpointPort: Int32?

        public var listenerPort: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.endpointPort != nil {
                map["EndpointPort"] = self.endpointPort!
            }
            if self.listenerPort != nil {
                map["ListenerPort"] = self.listenerPort!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EndpointPort") && dict["EndpointPort"] != nil {
                self.endpointPort = dict["EndpointPort"] as! Int32
            }
            if dict.keys.contains("ListenerPort") && dict["ListenerPort"] != nil {
                self.listenerPort = dict["ListenerPort"] as! Int32
            }
        }
    }
    public var clientToken: String?

    public var description_: String?

    public var endpointConfigurations: [UpdateEndpointGroupRequest.EndpointConfigurations]?

    public var endpointGroupId: String?

    public var endpointGroupRegion: String?

    public var endpointRequestProtocol: String?

    public var healthCheckEnabled: Bool?

    public var healthCheckIntervalSeconds: Int32?

    public var healthCheckPath: String?

    public var healthCheckPort: Int32?

    public var healthCheckProtocol: String?

    public var name: String?

    public var portOverrides: [UpdateEndpointGroupRequest.PortOverrides]?

    public var regionId: String?

    public var thresholdCount: Int32?

    public var trafficPercentage: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.endpointConfigurations != nil {
            var tmp : [Any] = []
            for k in self.endpointConfigurations! {
                tmp.append(k.toMap())
            }
            map["EndpointConfigurations"] = tmp
        }
        if self.endpointGroupId != nil {
            map["EndpointGroupId"] = self.endpointGroupId!
        }
        if self.endpointGroupRegion != nil {
            map["EndpointGroupRegion"] = self.endpointGroupRegion!
        }
        if self.endpointRequestProtocol != nil {
            map["EndpointRequestProtocol"] = self.endpointRequestProtocol!
        }
        if self.healthCheckEnabled != nil {
            map["HealthCheckEnabled"] = self.healthCheckEnabled!
        }
        if self.healthCheckIntervalSeconds != nil {
            map["HealthCheckIntervalSeconds"] = self.healthCheckIntervalSeconds!
        }
        if self.healthCheckPath != nil {
            map["HealthCheckPath"] = self.healthCheckPath!
        }
        if self.healthCheckPort != nil {
            map["HealthCheckPort"] = self.healthCheckPort!
        }
        if self.healthCheckProtocol != nil {
            map["HealthCheckProtocol"] = self.healthCheckProtocol!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.portOverrides != nil {
            var tmp : [Any] = []
            for k in self.portOverrides! {
                tmp.append(k.toMap())
            }
            map["PortOverrides"] = tmp
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.thresholdCount != nil {
            map["ThresholdCount"] = self.thresholdCount!
        }
        if self.trafficPercentage != nil {
            map["TrafficPercentage"] = self.trafficPercentage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") && dict["ClientToken"] != nil {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("EndpointConfigurations") && dict["EndpointConfigurations"] != nil {
            var tmp : [UpdateEndpointGroupRequest.EndpointConfigurations] = []
            for v in dict["EndpointConfigurations"] as! [Any] {
                var model = UpdateEndpointGroupRequest.EndpointConfigurations()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.endpointConfigurations = tmp
        }
        if dict.keys.contains("EndpointGroupId") && dict["EndpointGroupId"] != nil {
            self.endpointGroupId = dict["EndpointGroupId"] as! String
        }
        if dict.keys.contains("EndpointGroupRegion") && dict["EndpointGroupRegion"] != nil {
            self.endpointGroupRegion = dict["EndpointGroupRegion"] as! String
        }
        if dict.keys.contains("EndpointRequestProtocol") && dict["EndpointRequestProtocol"] != nil {
            self.endpointRequestProtocol = dict["EndpointRequestProtocol"] as! String
        }
        if dict.keys.contains("HealthCheckEnabled") && dict["HealthCheckEnabled"] != nil {
            self.healthCheckEnabled = dict["HealthCheckEnabled"] as! Bool
        }
        if dict.keys.contains("HealthCheckIntervalSeconds") && dict["HealthCheckIntervalSeconds"] != nil {
            self.healthCheckIntervalSeconds = dict["HealthCheckIntervalSeconds"] as! Int32
        }
        if dict.keys.contains("HealthCheckPath") && dict["HealthCheckPath"] != nil {
            self.healthCheckPath = dict["HealthCheckPath"] as! String
        }
        if dict.keys.contains("HealthCheckPort") && dict["HealthCheckPort"] != nil {
            self.healthCheckPort = dict["HealthCheckPort"] as! Int32
        }
        if dict.keys.contains("HealthCheckProtocol") && dict["HealthCheckProtocol"] != nil {
            self.healthCheckProtocol = dict["HealthCheckProtocol"] as! String
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("PortOverrides") && dict["PortOverrides"] != nil {
            var tmp : [UpdateEndpointGroupRequest.PortOverrides] = []
            for v in dict["PortOverrides"] as! [Any] {
                var model = UpdateEndpointGroupRequest.PortOverrides()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.portOverrides = tmp
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ThresholdCount") && dict["ThresholdCount"] != nil {
            self.thresholdCount = dict["ThresholdCount"] as! Int32
        }
        if dict.keys.contains("TrafficPercentage") && dict["TrafficPercentage"] != nil {
            self.trafficPercentage = dict["TrafficPercentage"] as! Int32
        }
    }
}

public class UpdateEndpointGroupResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateEndpointGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateEndpointGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateEndpointGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateEndpointGroupAttributeRequest : Tea.TeaModel {
    public var clientToken: String?

    public var description_: String?

    public var endpointGroupId: String?

    public var name: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.endpointGroupId != nil {
            map["EndpointGroupId"] = self.endpointGroupId!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") && dict["ClientToken"] != nil {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("EndpointGroupId") && dict["EndpointGroupId"] != nil {
            self.endpointGroupId = dict["EndpointGroupId"] as! String
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class UpdateEndpointGroupAttributeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateEndpointGroupAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateEndpointGroupAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateEndpointGroupAttributeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateEndpointGroupsRequest : Tea.TeaModel {
    public class EndpointGroupConfigurations : Tea.TeaModel {
        public class EndpointConfigurations : Tea.TeaModel {
            public var endpoint: String?

            public var subAddress: String?

            public var type: String?

            public var weight: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.endpoint != nil {
                    map["Endpoint"] = self.endpoint!
                }
                if self.subAddress != nil {
                    map["SubAddress"] = self.subAddress!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.weight != nil {
                    map["Weight"] = self.weight!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Endpoint") && dict["Endpoint"] != nil {
                    self.endpoint = dict["Endpoint"] as! String
                }
                if dict.keys.contains("SubAddress") && dict["SubAddress"] != nil {
                    self.subAddress = dict["SubAddress"] as! String
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("Weight") && dict["Weight"] != nil {
                    self.weight = dict["Weight"] as! Int64
                }
            }
        }
        public class PortOverrides : Tea.TeaModel {
            public var endpointPort: Int64?

            public var listenerPort: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.endpointPort != nil {
                    map["EndpointPort"] = self.endpointPort!
                }
                if self.listenerPort != nil {
                    map["ListenerPort"] = self.listenerPort!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("EndpointPort") && dict["EndpointPort"] != nil {
                    self.endpointPort = dict["EndpointPort"] as! Int64
                }
                if dict.keys.contains("ListenerPort") && dict["ListenerPort"] != nil {
                    self.listenerPort = dict["ListenerPort"] as! Int64
                }
            }
        }
        public var enableClientIPPreservationProxyProtocol: Bool?

        public var enableClientIPPreservationToa: Bool?

        public var endpointConfigurations: [UpdateEndpointGroupsRequest.EndpointGroupConfigurations.EndpointConfigurations]?

        public var endpointGroupDescription: String?

        public var endpointGroupId: String?

        public var endpointGroupName: String?

        public var endpointRequestProtocol: String?

        public var healthCheckEnabled: Bool?

        public var healthCheckIntervalSeconds: Int64?

        public var healthCheckPath: String?

        public var healthCheckPort: Int64?

        public var healthCheckProtocol: String?

        public var portOverrides: [UpdateEndpointGroupsRequest.EndpointGroupConfigurations.PortOverrides]?

        public var thresholdCount: Int64?

        public var trafficPercentage: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.enableClientIPPreservationProxyProtocol != nil {
                map["EnableClientIPPreservationProxyProtocol"] = self.enableClientIPPreservationProxyProtocol!
            }
            if self.enableClientIPPreservationToa != nil {
                map["EnableClientIPPreservationToa"] = self.enableClientIPPreservationToa!
            }
            if self.endpointConfigurations != nil {
                var tmp : [Any] = []
                for k in self.endpointConfigurations! {
                    tmp.append(k.toMap())
                }
                map["EndpointConfigurations"] = tmp
            }
            if self.endpointGroupDescription != nil {
                map["EndpointGroupDescription"] = self.endpointGroupDescription!
            }
            if self.endpointGroupId != nil {
                map["EndpointGroupId"] = self.endpointGroupId!
            }
            if self.endpointGroupName != nil {
                map["EndpointGroupName"] = self.endpointGroupName!
            }
            if self.endpointRequestProtocol != nil {
                map["EndpointRequestProtocol"] = self.endpointRequestProtocol!
            }
            if self.healthCheckEnabled != nil {
                map["HealthCheckEnabled"] = self.healthCheckEnabled!
            }
            if self.healthCheckIntervalSeconds != nil {
                map["HealthCheckIntervalSeconds"] = self.healthCheckIntervalSeconds!
            }
            if self.healthCheckPath != nil {
                map["HealthCheckPath"] = self.healthCheckPath!
            }
            if self.healthCheckPort != nil {
                map["HealthCheckPort"] = self.healthCheckPort!
            }
            if self.healthCheckProtocol != nil {
                map["HealthCheckProtocol"] = self.healthCheckProtocol!
            }
            if self.portOverrides != nil {
                var tmp : [Any] = []
                for k in self.portOverrides! {
                    tmp.append(k.toMap())
                }
                map["PortOverrides"] = tmp
            }
            if self.thresholdCount != nil {
                map["ThresholdCount"] = self.thresholdCount!
            }
            if self.trafficPercentage != nil {
                map["TrafficPercentage"] = self.trafficPercentage!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EnableClientIPPreservationProxyProtocol") && dict["EnableClientIPPreservationProxyProtocol"] != nil {
                self.enableClientIPPreservationProxyProtocol = dict["EnableClientIPPreservationProxyProtocol"] as! Bool
            }
            if dict.keys.contains("EnableClientIPPreservationToa") && dict["EnableClientIPPreservationToa"] != nil {
                self.enableClientIPPreservationToa = dict["EnableClientIPPreservationToa"] as! Bool
            }
            if dict.keys.contains("EndpointConfigurations") && dict["EndpointConfigurations"] != nil {
                var tmp : [UpdateEndpointGroupsRequest.EndpointGroupConfigurations.EndpointConfigurations] = []
                for v in dict["EndpointConfigurations"] as! [Any] {
                    var model = UpdateEndpointGroupsRequest.EndpointGroupConfigurations.EndpointConfigurations()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.endpointConfigurations = tmp
            }
            if dict.keys.contains("EndpointGroupDescription") && dict["EndpointGroupDescription"] != nil {
                self.endpointGroupDescription = dict["EndpointGroupDescription"] as! String
            }
            if dict.keys.contains("EndpointGroupId") && dict["EndpointGroupId"] != nil {
                self.endpointGroupId = dict["EndpointGroupId"] as! String
            }
            if dict.keys.contains("EndpointGroupName") && dict["EndpointGroupName"] != nil {
                self.endpointGroupName = dict["EndpointGroupName"] as! String
            }
            if dict.keys.contains("EndpointRequestProtocol") && dict["EndpointRequestProtocol"] != nil {
                self.endpointRequestProtocol = dict["EndpointRequestProtocol"] as! String
            }
            if dict.keys.contains("HealthCheckEnabled") && dict["HealthCheckEnabled"] != nil {
                self.healthCheckEnabled = dict["HealthCheckEnabled"] as! Bool
            }
            if dict.keys.contains("HealthCheckIntervalSeconds") && dict["HealthCheckIntervalSeconds"] != nil {
                self.healthCheckIntervalSeconds = dict["HealthCheckIntervalSeconds"] as! Int64
            }
            if dict.keys.contains("HealthCheckPath") && dict["HealthCheckPath"] != nil {
                self.healthCheckPath = dict["HealthCheckPath"] as! String
            }
            if dict.keys.contains("HealthCheckPort") && dict["HealthCheckPort"] != nil {
                self.healthCheckPort = dict["HealthCheckPort"] as! Int64
            }
            if dict.keys.contains("HealthCheckProtocol") && dict["HealthCheckProtocol"] != nil {
                self.healthCheckProtocol = dict["HealthCheckProtocol"] as! String
            }
            if dict.keys.contains("PortOverrides") && dict["PortOverrides"] != nil {
                var tmp : [UpdateEndpointGroupsRequest.EndpointGroupConfigurations.PortOverrides] = []
                for v in dict["PortOverrides"] as! [Any] {
                    var model = UpdateEndpointGroupsRequest.EndpointGroupConfigurations.PortOverrides()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.portOverrides = tmp
            }
            if dict.keys.contains("ThresholdCount") && dict["ThresholdCount"] != nil {
                self.thresholdCount = dict["ThresholdCount"] as! Int64
            }
            if dict.keys.contains("TrafficPercentage") && dict["TrafficPercentage"] != nil {
                self.trafficPercentage = dict["TrafficPercentage"] as! Int64
            }
        }
    }
    public var clientToken: String?

    public var dryRun: Bool?

    public var endpointGroupConfigurations: [UpdateEndpointGroupsRequest.EndpointGroupConfigurations]?

    public var listenerId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.endpointGroupConfigurations != nil {
            var tmp : [Any] = []
            for k in self.endpointGroupConfigurations! {
                tmp.append(k.toMap())
            }
            map["EndpointGroupConfigurations"] = tmp
        }
        if self.listenerId != nil {
            map["ListenerId"] = self.listenerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") && dict["ClientToken"] != nil {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("DryRun") && dict["DryRun"] != nil {
            self.dryRun = dict["DryRun"] as! Bool
        }
        if dict.keys.contains("EndpointGroupConfigurations") && dict["EndpointGroupConfigurations"] != nil {
            var tmp : [UpdateEndpointGroupsRequest.EndpointGroupConfigurations] = []
            for v in dict["EndpointGroupConfigurations"] as! [Any] {
                var model = UpdateEndpointGroupsRequest.EndpointGroupConfigurations()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.endpointGroupConfigurations = tmp
        }
        if dict.keys.contains("ListenerId") && dict["ListenerId"] != nil {
            self.listenerId = dict["ListenerId"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class UpdateEndpointGroupsResponseBody : Tea.TeaModel {
    public var endpointGroupIds: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endpointGroupIds != nil {
            map["EndpointGroupIds"] = self.endpointGroupIds!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndpointGroupIds") && dict["EndpointGroupIds"] != nil {
            self.endpointGroupIds = dict["EndpointGroupIds"] as! [String]
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateEndpointGroupsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateEndpointGroupsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateEndpointGroupsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateForwardingRulesRequest : Tea.TeaModel {
    public class ForwardingRules : Tea.TeaModel {
        public class RuleActions : Tea.TeaModel {
            public class ForwardGroupConfig : Tea.TeaModel {
                public class ServerGroupTuples : Tea.TeaModel {
                    public var endpointGroupId: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.endpointGroupId != nil {
                            map["EndpointGroupId"] = self.endpointGroupId!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("EndpointGroupId") && dict["EndpointGroupId"] != nil {
                            self.endpointGroupId = dict["EndpointGroupId"] as! String
                        }
                    }
                }
                public var serverGroupTuples: [UpdateForwardingRulesRequest.ForwardingRules.RuleActions.ForwardGroupConfig.ServerGroupTuples]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.serverGroupTuples != nil {
                        var tmp : [Any] = []
                        for k in self.serverGroupTuples! {
                            tmp.append(k.toMap())
                        }
                        map["ServerGroupTuples"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ServerGroupTuples") && dict["ServerGroupTuples"] != nil {
                        var tmp : [UpdateForwardingRulesRequest.ForwardingRules.RuleActions.ForwardGroupConfig.ServerGroupTuples] = []
                        for v in dict["ServerGroupTuples"] as! [Any] {
                            var model = UpdateForwardingRulesRequest.ForwardingRules.RuleActions.ForwardGroupConfig.ServerGroupTuples()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.serverGroupTuples = tmp
                    }
                }
            }
            public var forwardGroupConfig: UpdateForwardingRulesRequest.ForwardingRules.RuleActions.ForwardGroupConfig?

            public var order: Int32?

            public var ruleActionType: String?

            public var ruleActionValue: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.forwardGroupConfig?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.forwardGroupConfig != nil {
                    map["ForwardGroupConfig"] = self.forwardGroupConfig?.toMap()
                }
                if self.order != nil {
                    map["Order"] = self.order!
                }
                if self.ruleActionType != nil {
                    map["RuleActionType"] = self.ruleActionType!
                }
                if self.ruleActionValue != nil {
                    map["RuleActionValue"] = self.ruleActionValue!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ForwardGroupConfig") && dict["ForwardGroupConfig"] != nil {
                    var model = UpdateForwardingRulesRequest.ForwardingRules.RuleActions.ForwardGroupConfig()
                    model.fromMap(dict["ForwardGroupConfig"] as! [String: Any])
                    self.forwardGroupConfig = model
                }
                if dict.keys.contains("Order") && dict["Order"] != nil {
                    self.order = dict["Order"] as! Int32
                }
                if dict.keys.contains("RuleActionType") && dict["RuleActionType"] != nil {
                    self.ruleActionType = dict["RuleActionType"] as! String
                }
                if dict.keys.contains("RuleActionValue") && dict["RuleActionValue"] != nil {
                    self.ruleActionValue = dict["RuleActionValue"] as! String
                }
            }
        }
        public class RuleConditions : Tea.TeaModel {
            public class HostConfig : Tea.TeaModel {
                public var values: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.values != nil {
                        map["Values"] = self.values!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Values") && dict["Values"] != nil {
                        self.values = dict["Values"] as! [String]
                    }
                }
            }
            public class PathConfig : Tea.TeaModel {
                public var values: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.values != nil {
                        map["Values"] = self.values!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Values") && dict["Values"] != nil {
                        self.values = dict["Values"] as! [String]
                    }
                }
            }
            public var hostConfig: UpdateForwardingRulesRequest.ForwardingRules.RuleConditions.HostConfig?

            public var pathConfig: UpdateForwardingRulesRequest.ForwardingRules.RuleConditions.PathConfig?

            public var ruleConditionType: String?

            public var ruleConditionValue: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.hostConfig?.validate()
                try self.pathConfig?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.hostConfig != nil {
                    map["HostConfig"] = self.hostConfig?.toMap()
                }
                if self.pathConfig != nil {
                    map["PathConfig"] = self.pathConfig?.toMap()
                }
                if self.ruleConditionType != nil {
                    map["RuleConditionType"] = self.ruleConditionType!
                }
                if self.ruleConditionValue != nil {
                    map["RuleConditionValue"] = self.ruleConditionValue!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("HostConfig") && dict["HostConfig"] != nil {
                    var model = UpdateForwardingRulesRequest.ForwardingRules.RuleConditions.HostConfig()
                    model.fromMap(dict["HostConfig"] as! [String: Any])
                    self.hostConfig = model
                }
                if dict.keys.contains("PathConfig") && dict["PathConfig"] != nil {
                    var model = UpdateForwardingRulesRequest.ForwardingRules.RuleConditions.PathConfig()
                    model.fromMap(dict["PathConfig"] as! [String: Any])
                    self.pathConfig = model
                }
                if dict.keys.contains("RuleConditionType") && dict["RuleConditionType"] != nil {
                    self.ruleConditionType = dict["RuleConditionType"] as! String
                }
                if dict.keys.contains("RuleConditionValue") && dict["RuleConditionValue"] != nil {
                    self.ruleConditionValue = dict["RuleConditionValue"] as! String
                }
            }
        }
        public var forwardingRuleId: String?

        public var forwardingRuleName: String?

        public var priority: Int32?

        public var ruleActions: [UpdateForwardingRulesRequest.ForwardingRules.RuleActions]?

        public var ruleConditions: [UpdateForwardingRulesRequest.ForwardingRules.RuleConditions]?

        public var ruleDirection: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.forwardingRuleId != nil {
                map["ForwardingRuleId"] = self.forwardingRuleId!
            }
            if self.forwardingRuleName != nil {
                map["ForwardingRuleName"] = self.forwardingRuleName!
            }
            if self.priority != nil {
                map["Priority"] = self.priority!
            }
            if self.ruleActions != nil {
                var tmp : [Any] = []
                for k in self.ruleActions! {
                    tmp.append(k.toMap())
                }
                map["RuleActions"] = tmp
            }
            if self.ruleConditions != nil {
                var tmp : [Any] = []
                for k in self.ruleConditions! {
                    tmp.append(k.toMap())
                }
                map["RuleConditions"] = tmp
            }
            if self.ruleDirection != nil {
                map["RuleDirection"] = self.ruleDirection!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ForwardingRuleId") && dict["ForwardingRuleId"] != nil {
                self.forwardingRuleId = dict["ForwardingRuleId"] as! String
            }
            if dict.keys.contains("ForwardingRuleName") && dict["ForwardingRuleName"] != nil {
                self.forwardingRuleName = dict["ForwardingRuleName"] as! String
            }
            if dict.keys.contains("Priority") && dict["Priority"] != nil {
                self.priority = dict["Priority"] as! Int32
            }
            if dict.keys.contains("RuleActions") && dict["RuleActions"] != nil {
                var tmp : [UpdateForwardingRulesRequest.ForwardingRules.RuleActions] = []
                for v in dict["RuleActions"] as! [Any] {
                    var model = UpdateForwardingRulesRequest.ForwardingRules.RuleActions()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.ruleActions = tmp
            }
            if dict.keys.contains("RuleConditions") && dict["RuleConditions"] != nil {
                var tmp : [UpdateForwardingRulesRequest.ForwardingRules.RuleConditions] = []
                for v in dict["RuleConditions"] as! [Any] {
                    var model = UpdateForwardingRulesRequest.ForwardingRules.RuleConditions()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.ruleConditions = tmp
            }
            if dict.keys.contains("RuleDirection") && dict["RuleDirection"] != nil {
                self.ruleDirection = dict["RuleDirection"] as! String
            }
        }
    }
    public var acceleratorId: String?

    public var clientToken: String?

    public var forwardingRules: [UpdateForwardingRulesRequest.ForwardingRules]?

    public var listenerId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceleratorId != nil {
            map["AcceleratorId"] = self.acceleratorId!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.forwardingRules != nil {
            var tmp : [Any] = []
            for k in self.forwardingRules! {
                tmp.append(k.toMap())
            }
            map["ForwardingRules"] = tmp
        }
        if self.listenerId != nil {
            map["ListenerId"] = self.listenerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceleratorId") && dict["AcceleratorId"] != nil {
            self.acceleratorId = dict["AcceleratorId"] as! String
        }
        if dict.keys.contains("ClientToken") && dict["ClientToken"] != nil {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("ForwardingRules") && dict["ForwardingRules"] != nil {
            var tmp : [UpdateForwardingRulesRequest.ForwardingRules] = []
            for v in dict["ForwardingRules"] as! [Any] {
                var model = UpdateForwardingRulesRequest.ForwardingRules()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.forwardingRules = tmp
        }
        if dict.keys.contains("ListenerId") && dict["ListenerId"] != nil {
            self.listenerId = dict["ListenerId"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class UpdateForwardingRulesResponseBody : Tea.TeaModel {
    public class ForwardingRules : Tea.TeaModel {
        public var forwardingRuleId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.forwardingRuleId != nil {
                map["ForwardingRuleId"] = self.forwardingRuleId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ForwardingRuleId") && dict["ForwardingRuleId"] != nil {
                self.forwardingRuleId = dict["ForwardingRuleId"] as! String
            }
        }
    }
    public var forwardingRules: [UpdateForwardingRulesResponseBody.ForwardingRules]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.forwardingRules != nil {
            var tmp : [Any] = []
            for k in self.forwardingRules! {
                tmp.append(k.toMap())
            }
            map["ForwardingRules"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ForwardingRules") && dict["ForwardingRules"] != nil {
            var tmp : [UpdateForwardingRulesResponseBody.ForwardingRules] = []
            for v in dict["ForwardingRules"] as! [Any] {
                var model = UpdateForwardingRulesResponseBody.ForwardingRules()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.forwardingRules = tmp
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateForwardingRulesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateForwardingRulesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateForwardingRulesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateIpSetRequest : Tea.TeaModel {
    public var bandwidth: Int32?

    public var clientToken: String?

    public var ipSetId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bandwidth != nil {
            map["Bandwidth"] = self.bandwidth!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ipSetId != nil {
            map["IpSetId"] = self.ipSetId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Bandwidth") && dict["Bandwidth"] != nil {
            self.bandwidth = dict["Bandwidth"] as! Int32
        }
        if dict.keys.contains("ClientToken") && dict["ClientToken"] != nil {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("IpSetId") && dict["IpSetId"] != nil {
            self.ipSetId = dict["IpSetId"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class UpdateIpSetResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateIpSetResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateIpSetResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateIpSetResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateIpSetsRequest : Tea.TeaModel {
    public class IpSets : Tea.TeaModel {
        public var bandwidth: Int32?

        public var ipSetId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.bandwidth != nil {
                map["Bandwidth"] = self.bandwidth!
            }
            if self.ipSetId != nil {
                map["IpSetId"] = self.ipSetId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Bandwidth") && dict["Bandwidth"] != nil {
                self.bandwidth = dict["Bandwidth"] as! Int32
            }
            if dict.keys.contains("IpSetId") && dict["IpSetId"] != nil {
                self.ipSetId = dict["IpSetId"] as! String
            }
        }
    }
    public var ipSets: [UpdateIpSetsRequest.IpSets]?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ipSets != nil {
            var tmp : [Any] = []
            for k in self.ipSets! {
                tmp.append(k.toMap())
            }
            map["IpSets"] = tmp
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("IpSets") && dict["IpSets"] != nil {
            var tmp : [UpdateIpSetsRequest.IpSets] = []
            for v in dict["IpSets"] as! [Any] {
                var model = UpdateIpSetsRequest.IpSets()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.ipSets = tmp
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class UpdateIpSetsResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateIpSetsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateIpSetsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateIpSetsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateListenerRequest : Tea.TeaModel {
    public class BackendPorts : Tea.TeaModel {
        public var fromPort: Int32?

        public var toPort: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.fromPort != nil {
                map["FromPort"] = self.fromPort!
            }
            if self.toPort != nil {
                map["ToPort"] = self.toPort!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("FromPort") && dict["FromPort"] != nil {
                self.fromPort = dict["FromPort"] as! Int32
            }
            if dict.keys.contains("ToPort") && dict["ToPort"] != nil {
                self.toPort = dict["ToPort"] as! Int32
            }
        }
    }
    public class Certificates : Tea.TeaModel {
        public var id: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.id != nil {
                map["Id"] = self.id!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Id") && dict["Id"] != nil {
                self.id = dict["Id"] as! String
            }
        }
    }
    public class PortRanges : Tea.TeaModel {
        public var fromPort: Int32?

        public var toPort: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.fromPort != nil {
                map["FromPort"] = self.fromPort!
            }
            if self.toPort != nil {
                map["ToPort"] = self.toPort!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("FromPort") && dict["FromPort"] != nil {
                self.fromPort = dict["FromPort"] as! Int32
            }
            if dict.keys.contains("ToPort") && dict["ToPort"] != nil {
                self.toPort = dict["ToPort"] as! Int32
            }
        }
    }
    public class XForwardedForConfig : Tea.TeaModel {
        public var XForwardedForGaApEnabled: Bool?

        public var XForwardedForGaIdEnabled: Bool?

        public var XForwardedForPortEnabled: Bool?

        public var XForwardedForProtoEnabled: Bool?

        public var XRealIpEnabled: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.XForwardedForGaApEnabled != nil {
                map["XForwardedForGaApEnabled"] = self.XForwardedForGaApEnabled!
            }
            if self.XForwardedForGaIdEnabled != nil {
                map["XForwardedForGaIdEnabled"] = self.XForwardedForGaIdEnabled!
            }
            if self.XForwardedForPortEnabled != nil {
                map["XForwardedForPortEnabled"] = self.XForwardedForPortEnabled!
            }
            if self.XForwardedForProtoEnabled != nil {
                map["XForwardedForProtoEnabled"] = self.XForwardedForProtoEnabled!
            }
            if self.XRealIpEnabled != nil {
                map["XRealIpEnabled"] = self.XRealIpEnabled!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("XForwardedForGaApEnabled") && dict["XForwardedForGaApEnabled"] != nil {
                self.XForwardedForGaApEnabled = dict["XForwardedForGaApEnabled"] as! Bool
            }
            if dict.keys.contains("XForwardedForGaIdEnabled") && dict["XForwardedForGaIdEnabled"] != nil {
                self.XForwardedForGaIdEnabled = dict["XForwardedForGaIdEnabled"] as! Bool
            }
            if dict.keys.contains("XForwardedForPortEnabled") && dict["XForwardedForPortEnabled"] != nil {
                self.XForwardedForPortEnabled = dict["XForwardedForPortEnabled"] as! Bool
            }
            if dict.keys.contains("XForwardedForProtoEnabled") && dict["XForwardedForProtoEnabled"] != nil {
                self.XForwardedForProtoEnabled = dict["XForwardedForProtoEnabled"] as! Bool
            }
            if dict.keys.contains("XRealIpEnabled") && dict["XRealIpEnabled"] != nil {
                self.XRealIpEnabled = dict["XRealIpEnabled"] as! Bool
            }
        }
    }
    public var backendPorts: [UpdateListenerRequest.BackendPorts]?

    public var certificates: [UpdateListenerRequest.Certificates]?

    public var clientAffinity: String?

    public var clientToken: String?

    public var description_: String?

    public var idleTimeout: Int32?

    public var listenerId: String?

    public var name: String?

    public var portRanges: [UpdateListenerRequest.PortRanges]?

    public var protocol_: String?

    public var proxyProtocol: String?

    public var regionId: String?

    public var requestTimeout: Int32?

    public var securityPolicyId: String?

    public var XForwardedForConfig: UpdateListenerRequest.XForwardedForConfig?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.XForwardedForConfig?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.backendPorts != nil {
            var tmp : [Any] = []
            for k in self.backendPorts! {
                tmp.append(k.toMap())
            }
            map["BackendPorts"] = tmp
        }
        if self.certificates != nil {
            var tmp : [Any] = []
            for k in self.certificates! {
                tmp.append(k.toMap())
            }
            map["Certificates"] = tmp
        }
        if self.clientAffinity != nil {
            map["ClientAffinity"] = self.clientAffinity!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.idleTimeout != nil {
            map["IdleTimeout"] = self.idleTimeout!
        }
        if self.listenerId != nil {
            map["ListenerId"] = self.listenerId!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.portRanges != nil {
            var tmp : [Any] = []
            for k in self.portRanges! {
                tmp.append(k.toMap())
            }
            map["PortRanges"] = tmp
        }
        if self.protocol_ != nil {
            map["Protocol"] = self.protocol_!
        }
        if self.proxyProtocol != nil {
            map["ProxyProtocol"] = self.proxyProtocol!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.requestTimeout != nil {
            map["RequestTimeout"] = self.requestTimeout!
        }
        if self.securityPolicyId != nil {
            map["SecurityPolicyId"] = self.securityPolicyId!
        }
        if self.XForwardedForConfig != nil {
            map["XForwardedForConfig"] = self.XForwardedForConfig?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BackendPorts") && dict["BackendPorts"] != nil {
            var tmp : [UpdateListenerRequest.BackendPorts] = []
            for v in dict["BackendPorts"] as! [Any] {
                var model = UpdateListenerRequest.BackendPorts()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.backendPorts = tmp
        }
        if dict.keys.contains("Certificates") && dict["Certificates"] != nil {
            var tmp : [UpdateListenerRequest.Certificates] = []
            for v in dict["Certificates"] as! [Any] {
                var model = UpdateListenerRequest.Certificates()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.certificates = tmp
        }
        if dict.keys.contains("ClientAffinity") && dict["ClientAffinity"] != nil {
            self.clientAffinity = dict["ClientAffinity"] as! String
        }
        if dict.keys.contains("ClientToken") && dict["ClientToken"] != nil {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("IdleTimeout") && dict["IdleTimeout"] != nil {
            self.idleTimeout = dict["IdleTimeout"] as! Int32
        }
        if dict.keys.contains("ListenerId") && dict["ListenerId"] != nil {
            self.listenerId = dict["ListenerId"] as! String
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("PortRanges") && dict["PortRanges"] != nil {
            var tmp : [UpdateListenerRequest.PortRanges] = []
            for v in dict["PortRanges"] as! [Any] {
                var model = UpdateListenerRequest.PortRanges()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.portRanges = tmp
        }
        if dict.keys.contains("Protocol") && dict["Protocol"] != nil {
            self.protocol_ = dict["Protocol"] as! String
        }
        if dict.keys.contains("ProxyProtocol") && dict["ProxyProtocol"] != nil {
            self.proxyProtocol = dict["ProxyProtocol"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("RequestTimeout") && dict["RequestTimeout"] != nil {
            self.requestTimeout = dict["RequestTimeout"] as! Int32
        }
        if dict.keys.contains("SecurityPolicyId") && dict["SecurityPolicyId"] != nil {
            self.securityPolicyId = dict["SecurityPolicyId"] as! String
        }
        if dict.keys.contains("XForwardedForConfig") && dict["XForwardedForConfig"] != nil {
            var model = UpdateListenerRequest.XForwardedForConfig()
            model.fromMap(dict["XForwardedForConfig"] as! [String: Any])
            self.XForwardedForConfig = model
        }
    }
}

public class UpdateListenerResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateListenerResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateListenerResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateListenerResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateServiceManagedControlRequest : Tea.TeaModel {
    public var clientToken: String?

    public var regionId: String?

    public var resourceId: String?

    public var resourceType: String?

    public var serviceManaged: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.serviceManaged != nil {
            map["ServiceManaged"] = self.serviceManaged!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") && dict["ClientToken"] != nil {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceId") && dict["ResourceId"] != nil {
            self.resourceId = dict["ResourceId"] as! String
        }
        if dict.keys.contains("ResourceType") && dict["ResourceType"] != nil {
            self.resourceType = dict["ResourceType"] as! String
        }
        if dict.keys.contains("ServiceManaged") && dict["ServiceManaged"] != nil {
            self.serviceManaged = dict["ServiceManaged"] as! Bool
        }
    }
}

public class UpdateServiceManagedControlResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateServiceManagedControlResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateServiceManagedControlResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateServiceManagedControlResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}
