import Foundation
import Tea
import TeaUtils
import AlibabacloudOpenApi
import AlibabaCloudOpenApiUtil
import AlibabacloudEndpointUtil

public class DataPropertiesValue : Tea.TeaModel {
    public var displayName: String?

    public var description_: String?

    public var name: String?

    public var dataType: String?

    public var pattern: String?

    public var patternErrorMessage: String?

    public var minLength: Int32?

    public var maxLength: Int32?

    public var minimum: Double?

    public var maximum: Double?

    public var required_: Bool?

    public var system: Bool?

    public var disabled: Bool?

    public var array: Bool?

    public var readOnly: Bool?

    public var editorType: String?

    public var attributes: String?

    public var displayOrder: Int32?

    public var createdTime: Int64?

    public var updatedTime: Int64?

    public var creator: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.displayName != nil {
            map["DisplayName"] = self.displayName!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.dataType != nil {
            map["DataType"] = self.dataType!
        }
        if self.pattern != nil {
            map["Pattern"] = self.pattern!
        }
        if self.patternErrorMessage != nil {
            map["PatternErrorMessage"] = self.patternErrorMessage!
        }
        if self.minLength != nil {
            map["MinLength"] = self.minLength!
        }
        if self.maxLength != nil {
            map["MaxLength"] = self.maxLength!
        }
        if self.minimum != nil {
            map["Minimum"] = self.minimum!
        }
        if self.maximum != nil {
            map["Maximum"] = self.maximum!
        }
        if self.required_ != nil {
            map["Required"] = self.required_!
        }
        if self.system != nil {
            map["System"] = self.system!
        }
        if self.disabled != nil {
            map["Disabled"] = self.disabled!
        }
        if self.array != nil {
            map["Array"] = self.array!
        }
        if self.readOnly != nil {
            map["ReadOnly"] = self.readOnly!
        }
        if self.editorType != nil {
            map["EditorType"] = self.editorType!
        }
        if self.attributes != nil {
            map["Attributes"] = self.attributes!
        }
        if self.displayOrder != nil {
            map["DisplayOrder"] = self.displayOrder!
        }
        if self.createdTime != nil {
            map["CreatedTime"] = self.createdTime!
        }
        if self.updatedTime != nil {
            map["UpdatedTime"] = self.updatedTime!
        }
        if self.creator != nil {
            map["Creator"] = self.creator!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DisplayName") {
            self.displayName = dict["DisplayName"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("DataType") {
            self.dataType = dict["DataType"] as! String
        }
        if dict.keys.contains("Pattern") {
            self.pattern = dict["Pattern"] as! String
        }
        if dict.keys.contains("PatternErrorMessage") {
            self.patternErrorMessage = dict["PatternErrorMessage"] as! String
        }
        if dict.keys.contains("MinLength") {
            self.minLength = dict["MinLength"] as! Int32
        }
        if dict.keys.contains("MaxLength") {
            self.maxLength = dict["MaxLength"] as! Int32
        }
        if dict.keys.contains("Minimum") {
            self.minimum = dict["Minimum"] as! Double
        }
        if dict.keys.contains("Maximum") {
            self.maximum = dict["Maximum"] as! Double
        }
        if dict.keys.contains("Required") {
            self.required_ = dict["Required"] as! Bool
        }
        if dict.keys.contains("System") {
            self.system = dict["System"] as! Bool
        }
        if dict.keys.contains("Disabled") {
            self.disabled = dict["Disabled"] as! Bool
        }
        if dict.keys.contains("Array") {
            self.array = dict["Array"] as! Bool
        }
        if dict.keys.contains("ReadOnly") {
            self.readOnly = dict["ReadOnly"] as! Bool
        }
        if dict.keys.contains("EditorType") {
            self.editorType = dict["EditorType"] as! String
        }
        if dict.keys.contains("Attributes") {
            self.attributes = dict["Attributes"] as! String
        }
        if dict.keys.contains("DisplayOrder") {
            self.displayOrder = dict["DisplayOrder"] as! Int32
        }
        if dict.keys.contains("CreatedTime") {
            self.createdTime = dict["CreatedTime"] as! Int64
        }
        if dict.keys.contains("UpdatedTime") {
            self.updatedTime = dict["UpdatedTime"] as! Int64
        }
        if dict.keys.contains("Creator") {
            self.creator = dict["Creator"] as! String
        }
    }
}

public class DataSchemaPropertiesValue : Tea.TeaModel {
    public var displayName: String?

    public var description_: String?

    public var name: String?

    public var dataType: String?

    public var pattern: String?

    public var patternErrorMessage: String?

    public var minLength: Int32?

    public var maxLength: Int32?

    public var minimum: Double?

    public var maximum: Double?

    public var required_: Bool?

    public var system: Bool?

    public var disabled: Bool?

    public var array: Bool?

    public var readOnly: Bool?

    public var editorType: String?

    public var attributes: String?

    public var displayOrder: Int32?

    public var createdTime: Int64?

    public var updatedTime: Int64?

    public var creator: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.displayName != nil {
            map["DisplayName"] = self.displayName!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.dataType != nil {
            map["DataType"] = self.dataType!
        }
        if self.pattern != nil {
            map["Pattern"] = self.pattern!
        }
        if self.patternErrorMessage != nil {
            map["PatternErrorMessage"] = self.patternErrorMessage!
        }
        if self.minLength != nil {
            map["MinLength"] = self.minLength!
        }
        if self.maxLength != nil {
            map["MaxLength"] = self.maxLength!
        }
        if self.minimum != nil {
            map["Minimum"] = self.minimum!
        }
        if self.maximum != nil {
            map["Maximum"] = self.maximum!
        }
        if self.required_ != nil {
            map["Required"] = self.required_!
        }
        if self.system != nil {
            map["System"] = self.system!
        }
        if self.disabled != nil {
            map["Disabled"] = self.disabled!
        }
        if self.array != nil {
            map["Array"] = self.array!
        }
        if self.readOnly != nil {
            map["ReadOnly"] = self.readOnly!
        }
        if self.editorType != nil {
            map["EditorType"] = self.editorType!
        }
        if self.attributes != nil {
            map["Attributes"] = self.attributes!
        }
        if self.displayOrder != nil {
            map["DisplayOrder"] = self.displayOrder!
        }
        if self.createdTime != nil {
            map["CreatedTime"] = self.createdTime!
        }
        if self.updatedTime != nil {
            map["UpdatedTime"] = self.updatedTime!
        }
        if self.creator != nil {
            map["Creator"] = self.creator!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DisplayName") {
            self.displayName = dict["DisplayName"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("DataType") {
            self.dataType = dict["DataType"] as! String
        }
        if dict.keys.contains("Pattern") {
            self.pattern = dict["Pattern"] as! String
        }
        if dict.keys.contains("PatternErrorMessage") {
            self.patternErrorMessage = dict["PatternErrorMessage"] as! String
        }
        if dict.keys.contains("MinLength") {
            self.minLength = dict["MinLength"] as! Int32
        }
        if dict.keys.contains("MaxLength") {
            self.maxLength = dict["MaxLength"] as! Int32
        }
        if dict.keys.contains("Minimum") {
            self.minimum = dict["Minimum"] as! Double
        }
        if dict.keys.contains("Maximum") {
            self.maximum = dict["Maximum"] as! Double
        }
        if dict.keys.contains("Required") {
            self.required_ = dict["Required"] as! Bool
        }
        if dict.keys.contains("System") {
            self.system = dict["System"] as! Bool
        }
        if dict.keys.contains("Disabled") {
            self.disabled = dict["Disabled"] as! Bool
        }
        if dict.keys.contains("Array") {
            self.array = dict["Array"] as! Bool
        }
        if dict.keys.contains("ReadOnly") {
            self.readOnly = dict["ReadOnly"] as! Bool
        }
        if dict.keys.contains("EditorType") {
            self.editorType = dict["EditorType"] as! String
        }
        if dict.keys.contains("Attributes") {
            self.attributes = dict["Attributes"] as! String
        }
        if dict.keys.contains("DisplayOrder") {
            self.displayOrder = dict["DisplayOrder"] as! Int32
        }
        if dict.keys.contains("CreatedTime") {
            self.createdTime = dict["CreatedTime"] as! Int64
        }
        if dict.keys.contains("UpdatedTime") {
            self.updatedTime = dict["UpdatedTime"] as! Int64
        }
        if dict.keys.contains("Creator") {
            self.creator = dict["Creator"] as! String
        }
    }
}

public class AbortCampaignRequest : Tea.TeaModel {
    public var campaignId: String?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.campaignId != nil {
            map["CampaignId"] = self.campaignId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CampaignId") {
            self.campaignId = dict["CampaignId"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
    }
}

public class AbortCampaignResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpStatusCode: String?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AbortCampaignResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AbortCampaignResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AbortCampaignResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AcceptChatRequest : Tea.TeaModel {
    public var instanceId: String?

    public var jobId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
    }
}

public class AcceptChatResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AcceptChatResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AcceptChatResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AcceptChatResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddBlacklistCallTaggingRequest : Tea.TeaModel {
    public var instanceId: String?

    public var jobId: String?

    public var number: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.number != nil {
            map["Number"] = self.number!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("Number") {
            self.number = dict["Number"] as! String
        }
    }
}

public class AddBlacklistCallTaggingResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AddBlacklistCallTaggingResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddBlacklistCallTaggingResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddBlacklistCallTaggingResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddCasesRequest : Tea.TeaModel {
    public class CaseList : Tea.TeaModel {
        public var caller: String?

        public var customVariables: String?

        public var maskedCallee: String?

        public var phoneNumber: String?

        public var referenceId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.caller != nil {
                map["Caller"] = self.caller!
            }
            if self.customVariables != nil {
                map["CustomVariables"] = self.customVariables!
            }
            if self.maskedCallee != nil {
                map["MaskedCallee"] = self.maskedCallee!
            }
            if self.phoneNumber != nil {
                map["PhoneNumber"] = self.phoneNumber!
            }
            if self.referenceId != nil {
                map["ReferenceId"] = self.referenceId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Caller") {
                self.caller = dict["Caller"] as! String
            }
            if dict.keys.contains("CustomVariables") {
                self.customVariables = dict["CustomVariables"] as! String
            }
            if dict.keys.contains("MaskedCallee") {
                self.maskedCallee = dict["MaskedCallee"] as! String
            }
            if dict.keys.contains("PhoneNumber") {
                self.phoneNumber = dict["PhoneNumber"] as! String
            }
            if dict.keys.contains("ReferenceId") {
                self.referenceId = dict["ReferenceId"] as! String
            }
        }
    }
    public var campaignId: String?

    public var caseList: [AddCasesRequest.CaseList]?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.campaignId != nil {
            map["CampaignId"] = self.campaignId!
        }
        if self.caseList != nil {
            var tmp : [Any] = []
            for k in self.caseList! {
                tmp.append(k.toMap())
            }
            map["CaseList"] = tmp
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CampaignId") {
            self.campaignId = dict["CampaignId"] as! String
        }
        if dict.keys.contains("CaseList") {
            var tmp : [AddCasesRequest.CaseList] = []
            for v in dict["CaseList"] as! [Any] {
                var model = AddCasesRequest.CaseList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.caseList = tmp
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
    }
}

public class AddCasesShrinkRequest : Tea.TeaModel {
    public var campaignId: String?

    public var caseListShrink: String?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.campaignId != nil {
            map["CampaignId"] = self.campaignId!
        }
        if self.caseListShrink != nil {
            map["CaseList"] = self.caseListShrink!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CampaignId") {
            self.campaignId = dict["CampaignId"] as! String
        }
        if dict.keys.contains("CaseList") {
            self.caseListShrink = dict["CaseList"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
    }
}

public class AddCasesResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpStatusCode: String?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AddCasesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddCasesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddCasesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddNumbersToSkillGroupRequest : Tea.TeaModel {
    public var instNumberGroupIdList: String?

    public var instanceId: String?

    public var numberList: String?

    public var skillGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instNumberGroupIdList != nil {
            map["InstNumberGroupIdList"] = self.instNumberGroupIdList!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.numberList != nil {
            map["NumberList"] = self.numberList!
        }
        if self.skillGroupId != nil {
            map["SkillGroupId"] = self.skillGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstNumberGroupIdList") {
            self.instNumberGroupIdList = dict["InstNumberGroupIdList"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("NumberList") {
            self.numberList = dict["NumberList"] as! String
        }
        if dict.keys.contains("SkillGroupId") {
            self.skillGroupId = dict["SkillGroupId"] as! String
        }
    }
}

public class AddNumbersToSkillGroupResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AddNumbersToSkillGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddNumbersToSkillGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddNumbersToSkillGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddPersonalNumbersToUserRequest : Tea.TeaModel {
    public var instanceId: String?

    public var numberList: String?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.numberList != nil {
            map["NumberList"] = self.numberList!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("NumberList") {
            self.numberList = dict["NumberList"] as! String
        }
        if dict.keys.contains("UserId") {
            self.userId = dict["UserId"] as! String
        }
    }
}

public class AddPersonalNumbersToUserResponseBody : Tea.TeaModel {
    public var code: String?

    public var data: [String]?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! [String]
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AddPersonalNumbersToUserResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddPersonalNumbersToUserResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddPersonalNumbersToUserResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddPhoneNumberToSkillGroupsRequest : Tea.TeaModel {
    public var instanceId: String?

    public var number: String?

    public var skillGroupIdList: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.number != nil {
            map["Number"] = self.number!
        }
        if self.skillGroupIdList != nil {
            map["SkillGroupIdList"] = self.skillGroupIdList!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Number") {
            self.number = dict["Number"] as! String
        }
        if dict.keys.contains("SkillGroupIdList") {
            self.skillGroupIdList = dict["SkillGroupIdList"] as! String
        }
    }
}

public class AddPhoneNumberToSkillGroupsResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AddPhoneNumberToSkillGroupsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddPhoneNumberToSkillGroupsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddPhoneNumberToSkillGroupsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddPhoneNumbersRequest : Tea.TeaModel {
    public var contactFlowId: String?

    public var instanceId: String?

    public var numberGroupId: String?

    public var numberList: String?

    public var usage: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.contactFlowId != nil {
            map["ContactFlowId"] = self.contactFlowId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.numberGroupId != nil {
            map["NumberGroupId"] = self.numberGroupId!
        }
        if self.numberList != nil {
            map["NumberList"] = self.numberList!
        }
        if self.usage != nil {
            map["Usage"] = self.usage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ContactFlowId") {
            self.contactFlowId = dict["ContactFlowId"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("NumberGroupId") {
            self.numberGroupId = dict["NumberGroupId"] as! String
        }
        if dict.keys.contains("NumberList") {
            self.numberList = dict["NumberList"] as! String
        }
        if dict.keys.contains("Usage") {
            self.usage = dict["Usage"] as! String
        }
    }
}

public class AddPhoneNumbersResponseBody : Tea.TeaModel {
    public var code: String?

    public var data: [String]?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! [String]
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AddPhoneNumbersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddPhoneNumbersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddPhoneNumbersResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddSchemaPropertyRequest : Tea.TeaModel {
    public class Property : Tea.TeaModel {
        public var array: Bool?

        public var attributes: String?

        public var dataType: String?

        public var description_: String?

        public var disabled: Bool?

        public var displayName: String?

        public var displayOrder: Int32?

        public var editorType: String?

        public var maxLength: Int32?

        public var maximum: Double?

        public var minLength: Int32?

        public var minimum: Double?

        public var name: String?

        public var pattern: String?

        public var patternErrorMessage: String?

        public var readOnly: Bool?

        public var required_: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.array != nil {
                map["Array"] = self.array!
            }
            if self.attributes != nil {
                map["Attributes"] = self.attributes!
            }
            if self.dataType != nil {
                map["DataType"] = self.dataType!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.disabled != nil {
                map["Disabled"] = self.disabled!
            }
            if self.displayName != nil {
                map["DisplayName"] = self.displayName!
            }
            if self.displayOrder != nil {
                map["DisplayOrder"] = self.displayOrder!
            }
            if self.editorType != nil {
                map["EditorType"] = self.editorType!
            }
            if self.maxLength != nil {
                map["MaxLength"] = self.maxLength!
            }
            if self.maximum != nil {
                map["Maximum"] = self.maximum!
            }
            if self.minLength != nil {
                map["MinLength"] = self.minLength!
            }
            if self.minimum != nil {
                map["Minimum"] = self.minimum!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.pattern != nil {
                map["Pattern"] = self.pattern!
            }
            if self.patternErrorMessage != nil {
                map["PatternErrorMessage"] = self.patternErrorMessage!
            }
            if self.readOnly != nil {
                map["ReadOnly"] = self.readOnly!
            }
            if self.required_ != nil {
                map["Required"] = self.required_!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Array") {
                self.array = dict["Array"] as! Bool
            }
            if dict.keys.contains("Attributes") {
                self.attributes = dict["Attributes"] as! String
            }
            if dict.keys.contains("DataType") {
                self.dataType = dict["DataType"] as! String
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("Disabled") {
                self.disabled = dict["Disabled"] as! Bool
            }
            if dict.keys.contains("DisplayName") {
                self.displayName = dict["DisplayName"] as! String
            }
            if dict.keys.contains("DisplayOrder") {
                self.displayOrder = dict["DisplayOrder"] as! Int32
            }
            if dict.keys.contains("EditorType") {
                self.editorType = dict["EditorType"] as! String
            }
            if dict.keys.contains("MaxLength") {
                self.maxLength = dict["MaxLength"] as! Int32
            }
            if dict.keys.contains("Maximum") {
                self.maximum = dict["Maximum"] as! Double
            }
            if dict.keys.contains("MinLength") {
                self.minLength = dict["MinLength"] as! Int32
            }
            if dict.keys.contains("Minimum") {
                self.minimum = dict["Minimum"] as! Double
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Pattern") {
                self.pattern = dict["Pattern"] as! String
            }
            if dict.keys.contains("PatternErrorMessage") {
                self.patternErrorMessage = dict["PatternErrorMessage"] as! String
            }
            if dict.keys.contains("ReadOnly") {
                self.readOnly = dict["ReadOnly"] as! Bool
            }
            if dict.keys.contains("Required") {
                self.required_ = dict["Required"] as! Bool
            }
        }
    }
    public var instanceId: String?

    public var property: AddSchemaPropertyRequest.Property?

    public var requestId: String?

    public var schemaId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.property?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.property != nil {
            map["Property"] = self.property?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.schemaId != nil {
            map["SchemaId"] = self.schemaId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Property") {
            var model = AddSchemaPropertyRequest.Property()
            model.fromMap(dict["Property"] as! [String: Any])
            self.property = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SchemaId") {
            self.schemaId = dict["SchemaId"] as! String
        }
    }
}

public class AddSchemaPropertyShrinkRequest : Tea.TeaModel {
    public var instanceId: String?

    public var propertyShrink: String?

    public var requestId: String?

    public var schemaId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.propertyShrink != nil {
            map["Property"] = self.propertyShrink!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.schemaId != nil {
            map["SchemaId"] = self.schemaId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Property") {
            self.propertyShrink = dict["Property"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SchemaId") {
            self.schemaId = dict["SchemaId"] as! String
        }
    }
}

public class AddSchemaPropertyResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var params: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.params != nil {
            map["Params"] = self.params!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Params") {
            self.params = dict["Params"] as! [String]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AddSchemaPropertyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddSchemaPropertyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddSchemaPropertyResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddSkillGroupsToUserRequest : Tea.TeaModel {
    public var instanceId: String?

    public var skillLevelList: String?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.skillLevelList != nil {
            map["SkillLevelList"] = self.skillLevelList!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("SkillLevelList") {
            self.skillLevelList = dict["SkillLevelList"] as! String
        }
        if dict.keys.contains("UserId") {
            self.userId = dict["UserId"] as! String
        }
    }
}

public class AddSkillGroupsToUserResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AddSkillGroupsToUserResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddSkillGroupsToUserResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddSkillGroupsToUserResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddTicketTaskRequest : Tea.TeaModel {
    public var assignee: String?

    public var comment: String?

    public var instanceId: String?

    public var position: String?

    public var taskId: String?

    public var ticketId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.assignee != nil {
            map["Assignee"] = self.assignee!
        }
        if self.comment != nil {
            map["Comment"] = self.comment!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.position != nil {
            map["Position"] = self.position!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        if self.ticketId != nil {
            map["TicketId"] = self.ticketId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Assignee") {
            self.assignee = dict["Assignee"] as! String
        }
        if dict.keys.contains("Comment") {
            self.comment = dict["Comment"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Position") {
            self.position = dict["Position"] as! String
        }
        if dict.keys.contains("TaskId") {
            self.taskId = dict["TaskId"] as! String
        }
        if dict.keys.contains("TicketId") {
            self.ticketId = dict["TicketId"] as! String
        }
    }
}

public class AddTicketTaskResponseBody : Tea.TeaModel {
    public var code: String?

    public var data: Any?

    public var httpStatusCode: Int32?

    public var message: String?

    public var params: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.params != nil {
            map["Params"] = self.params!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Any
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Params") {
            self.params = dict["Params"] as! [String]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AddTicketTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddTicketTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddTicketTaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddUsersToSkillGroupRequest : Tea.TeaModel {
    public var instanceId: String?

    public var skillGroupId: String?

    public var userSkillLevelList: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.skillGroupId != nil {
            map["SkillGroupId"] = self.skillGroupId!
        }
        if self.userSkillLevelList != nil {
            map["UserSkillLevelList"] = self.userSkillLevelList!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("SkillGroupId") {
            self.skillGroupId = dict["SkillGroupId"] as! String
        }
        if dict.keys.contains("UserSkillLevelList") {
            self.userSkillLevelList = dict["UserSkillLevelList"] as! String
        }
    }
}

public class AddUsersToSkillGroupResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AddUsersToSkillGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddUsersToSkillGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddUsersToSkillGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AnalyzeConversationRequest : Tea.TeaModel {
    public var contactId: String?

    public var fieldListJson: String?

    public var instanceId: String?

    public var taskListJson: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.contactId != nil {
            map["ContactId"] = self.contactId!
        }
        if self.fieldListJson != nil {
            map["FieldListJson"] = self.fieldListJson!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.taskListJson != nil {
            map["TaskListJson"] = self.taskListJson!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ContactId") {
            self.contactId = dict["ContactId"] as! String
        }
        if dict.keys.contains("FieldListJson") {
            self.fieldListJson = dict["FieldListJson"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("TaskListJson") {
            self.taskListJson = dict["TaskListJson"] as! String
        }
    }
}

public class AnalyzeConversationResponseBody : Tea.TeaModel {
    public var code: String?

    public var data: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AnalyzeConversationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AnalyzeConversationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AnalyzeConversationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AnswerCallRequest : Tea.TeaModel {
    public var deviceId: String?

    public var instanceId: String?

    public var jobId: String?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.deviceId != nil {
            map["DeviceId"] = self.deviceId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DeviceId") {
            self.deviceId = dict["DeviceId"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("UserId") {
            self.userId = dict["UserId"] as! String
        }
    }
}

public class AnswerCallResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class CallContext : Tea.TeaModel {
            public class ChannelContexts : Tea.TeaModel {
                public var callType: String?

                public var channelId: String?

                public var channelState: String?

                public var channelVariables: String?

                public var destination: String?

                public var index: Int64?

                public var jobId: String?

                public var originator: String?

                public var releaseInitiator: String?

                public var releaseReason: String?

                public var skillGroupId: String?

                public var timestamp: Int64?

                public var userExtension: String?

                public var userId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.callType != nil {
                        map["CallType"] = self.callType!
                    }
                    if self.channelId != nil {
                        map["ChannelId"] = self.channelId!
                    }
                    if self.channelState != nil {
                        map["ChannelState"] = self.channelState!
                    }
                    if self.channelVariables != nil {
                        map["ChannelVariables"] = self.channelVariables!
                    }
                    if self.destination != nil {
                        map["Destination"] = self.destination!
                    }
                    if self.index != nil {
                        map["Index"] = self.index!
                    }
                    if self.jobId != nil {
                        map["JobId"] = self.jobId!
                    }
                    if self.originator != nil {
                        map["Originator"] = self.originator!
                    }
                    if self.releaseInitiator != nil {
                        map["ReleaseInitiator"] = self.releaseInitiator!
                    }
                    if self.releaseReason != nil {
                        map["ReleaseReason"] = self.releaseReason!
                    }
                    if self.skillGroupId != nil {
                        map["SkillGroupId"] = self.skillGroupId!
                    }
                    if self.timestamp != nil {
                        map["Timestamp"] = self.timestamp!
                    }
                    if self.userExtension != nil {
                        map["UserExtension"] = self.userExtension!
                    }
                    if self.userId != nil {
                        map["UserId"] = self.userId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("CallType") {
                        self.callType = dict["CallType"] as! String
                    }
                    if dict.keys.contains("ChannelId") {
                        self.channelId = dict["ChannelId"] as! String
                    }
                    if dict.keys.contains("ChannelState") {
                        self.channelState = dict["ChannelState"] as! String
                    }
                    if dict.keys.contains("ChannelVariables") {
                        self.channelVariables = dict["ChannelVariables"] as! String
                    }
                    if dict.keys.contains("Destination") {
                        self.destination = dict["Destination"] as! String
                    }
                    if dict.keys.contains("Index") {
                        self.index = dict["Index"] as! Int64
                    }
                    if dict.keys.contains("JobId") {
                        self.jobId = dict["JobId"] as! String
                    }
                    if dict.keys.contains("Originator") {
                        self.originator = dict["Originator"] as! String
                    }
                    if dict.keys.contains("ReleaseInitiator") {
                        self.releaseInitiator = dict["ReleaseInitiator"] as! String
                    }
                    if dict.keys.contains("ReleaseReason") {
                        self.releaseReason = dict["ReleaseReason"] as! String
                    }
                    if dict.keys.contains("SkillGroupId") {
                        self.skillGroupId = dict["SkillGroupId"] as! String
                    }
                    if dict.keys.contains("Timestamp") {
                        self.timestamp = dict["Timestamp"] as! Int64
                    }
                    if dict.keys.contains("UserExtension") {
                        self.userExtension = dict["UserExtension"] as! String
                    }
                    if dict.keys.contains("UserId") {
                        self.userId = dict["UserId"] as! String
                    }
                }
            }
            public var callType: String?

            public var channelContexts: [AnswerCallResponseBody.Data.CallContext.ChannelContexts]?

            public var instanceId: String?

            public var jobId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.callType != nil {
                    map["CallType"] = self.callType!
                }
                if self.channelContexts != nil {
                    var tmp : [Any] = []
                    for k in self.channelContexts! {
                        tmp.append(k.toMap())
                    }
                    map["ChannelContexts"] = tmp
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.jobId != nil {
                    map["JobId"] = self.jobId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CallType") {
                    self.callType = dict["CallType"] as! String
                }
                if dict.keys.contains("ChannelContexts") {
                    var tmp : [AnswerCallResponseBody.Data.CallContext.ChannelContexts] = []
                    for v in dict["ChannelContexts"] as! [Any] {
                        var model = AnswerCallResponseBody.Data.CallContext.ChannelContexts()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.channelContexts = tmp
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("JobId") {
                    self.jobId = dict["JobId"] as! String
                }
            }
        }
        public class UserContext : Tea.TeaModel {
            public var breakCode: String?

            public var deviceId: String?

            public var extension_: String?

            public var heartbeat: Int64?

            public var instanceId: String?

            public var jobId: String?

            public var mobile: String?

            public var outboundScenario: Bool?

            public var reserved: Int64?

            public var signedSkillGroupIdList: [String]?

            public var userId: String?

            public var userState: String?

            public var workMode: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.breakCode != nil {
                    map["BreakCode"] = self.breakCode!
                }
                if self.deviceId != nil {
                    map["DeviceId"] = self.deviceId!
                }
                if self.extension_ != nil {
                    map["Extension"] = self.extension_!
                }
                if self.heartbeat != nil {
                    map["Heartbeat"] = self.heartbeat!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.jobId != nil {
                    map["JobId"] = self.jobId!
                }
                if self.mobile != nil {
                    map["Mobile"] = self.mobile!
                }
                if self.outboundScenario != nil {
                    map["OutboundScenario"] = self.outboundScenario!
                }
                if self.reserved != nil {
                    map["Reserved"] = self.reserved!
                }
                if self.signedSkillGroupIdList != nil {
                    map["SignedSkillGroupIdList"] = self.signedSkillGroupIdList!
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                if self.userState != nil {
                    map["UserState"] = self.userState!
                }
                if self.workMode != nil {
                    map["WorkMode"] = self.workMode!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BreakCode") {
                    self.breakCode = dict["BreakCode"] as! String
                }
                if dict.keys.contains("DeviceId") {
                    self.deviceId = dict["DeviceId"] as! String
                }
                if dict.keys.contains("Extension") {
                    self.extension_ = dict["Extension"] as! String
                }
                if dict.keys.contains("Heartbeat") {
                    self.heartbeat = dict["Heartbeat"] as! Int64
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("JobId") {
                    self.jobId = dict["JobId"] as! String
                }
                if dict.keys.contains("Mobile") {
                    self.mobile = dict["Mobile"] as! String
                }
                if dict.keys.contains("OutboundScenario") {
                    self.outboundScenario = dict["OutboundScenario"] as! Bool
                }
                if dict.keys.contains("Reserved") {
                    self.reserved = dict["Reserved"] as! Int64
                }
                if dict.keys.contains("SignedSkillGroupIdList") {
                    self.signedSkillGroupIdList = dict["SignedSkillGroupIdList"] as! [String]
                }
                if dict.keys.contains("UserId") {
                    self.userId = dict["UserId"] as! String
                }
                if dict.keys.contains("UserState") {
                    self.userState = dict["UserState"] as! String
                }
                if dict.keys.contains("WorkMode") {
                    self.workMode = dict["WorkMode"] as! String
                }
            }
        }
        public var callContext: AnswerCallResponseBody.Data.CallContext?

        public var contextId: Int64?

        public var userContext: AnswerCallResponseBody.Data.UserContext?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.callContext?.validate()
            try self.userContext?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.callContext != nil {
                map["CallContext"] = self.callContext?.toMap()
            }
            if self.contextId != nil {
                map["ContextId"] = self.contextId!
            }
            if self.userContext != nil {
                map["UserContext"] = self.userContext?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CallContext") {
                var model = AnswerCallResponseBody.Data.CallContext()
                model.fromMap(dict["CallContext"] as! [String: Any])
                self.callContext = model
            }
            if dict.keys.contains("ContextId") {
                self.contextId = dict["ContextId"] as! Int64
            }
            if dict.keys.contains("UserContext") {
                var model = AnswerCallResponseBody.Data.UserContext()
                model.fromMap(dict["UserContext"] as! [String: Any])
                self.userContext = model
            }
        }
    }
    public var code: String?

    public var data: AnswerCallResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var params: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.params != nil {
            map["Params"] = self.params!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = AnswerCallResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Params") {
            self.params = dict["Params"] as! [String]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AnswerCallResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AnswerCallResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AnswerCallResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AppendCasesRequest : Tea.TeaModel {
    public class Body : Tea.TeaModel {
        public var agentId: String?

        public var caller: String?

        public var customVariables: String?

        public var maskedCallee: String?

        public var phoneNumber: String?

        public var referenceId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.agentId != nil {
                map["AgentId"] = self.agentId!
            }
            if self.caller != nil {
                map["Caller"] = self.caller!
            }
            if self.customVariables != nil {
                map["CustomVariables"] = self.customVariables!
            }
            if self.maskedCallee != nil {
                map["MaskedCallee"] = self.maskedCallee!
            }
            if self.phoneNumber != nil {
                map["PhoneNumber"] = self.phoneNumber!
            }
            if self.referenceId != nil {
                map["ReferenceId"] = self.referenceId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AgentId") {
                self.agentId = dict["AgentId"] as! String
            }
            if dict.keys.contains("Caller") {
                self.caller = dict["Caller"] as! String
            }
            if dict.keys.contains("CustomVariables") {
                self.customVariables = dict["CustomVariables"] as! String
            }
            if dict.keys.contains("MaskedCallee") {
                self.maskedCallee = dict["MaskedCallee"] as! String
            }
            if dict.keys.contains("PhoneNumber") {
                self.phoneNumber = dict["PhoneNumber"] as! String
            }
            if dict.keys.contains("ReferenceId") {
                self.referenceId = dict["ReferenceId"] as! String
            }
        }
    }
    public var campaignId: String?

    public var instanceId: String?

    public var body: [AppendCasesRequest.Body]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.campaignId != nil {
            map["CampaignId"] = self.campaignId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.body != nil {
            var tmp : [Any] = []
            for k in self.body! {
                tmp.append(k.toMap())
            }
            map["body"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CampaignId") {
            self.campaignId = dict["CampaignId"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("body") {
            var tmp : [AppendCasesRequest.Body] = []
            for v in dict["body"] as! [Any] {
                var model = AppendCasesRequest.Body()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.body = tmp
        }
    }
}

public class AppendCasesShrinkRequest : Tea.TeaModel {
    public var campaignId: String?

    public var instanceId: String?

    public var bodyShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.campaignId != nil {
            map["CampaignId"] = self.campaignId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.bodyShrink != nil {
            map["body"] = self.bodyShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CampaignId") {
            self.campaignId = dict["CampaignId"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("body") {
            self.bodyShrink = dict["body"] as! String
        }
    }
}

public class AppendCasesResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpStatusCode: String?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AppendCasesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AppendCasesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AppendCasesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AssignUsersRequest : Tea.TeaModel {
    public var instanceId: String?

    public var ramIdList: String?

    public var roleId: String?

    public var skillLevelList: String?

    public var workMode: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.ramIdList != nil {
            map["RamIdList"] = self.ramIdList!
        }
        if self.roleId != nil {
            map["RoleId"] = self.roleId!
        }
        if self.skillLevelList != nil {
            map["SkillLevelList"] = self.skillLevelList!
        }
        if self.workMode != nil {
            map["WorkMode"] = self.workMode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("RamIdList") {
            self.ramIdList = dict["RamIdList"] as! String
        }
        if dict.keys.contains("RoleId") {
            self.roleId = dict["RoleId"] as! String
        }
        if dict.keys.contains("SkillLevelList") {
            self.skillLevelList = dict["SkillLevelList"] as! String
        }
        if dict.keys.contains("WorkMode") {
            self.workMode = dict["WorkMode"] as! String
        }
    }
}

public class AssignUsersResponseBody : Tea.TeaModel {
    public var code: String?

    public var data: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var workflowId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.workflowId != nil {
            map["WorkflowId"] = self.workflowId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("WorkflowId") {
            self.workflowId = dict["WorkflowId"] as! String
        }
    }
}

public class AssignUsersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AssignUsersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AssignUsersResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class BargeInCallRequest : Tea.TeaModel {
    public var bargedUserId: String?

    public var deviceId: String?

    public var instanceId: String?

    public var jobId: String?

    public var timeoutSeconds: Int32?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bargedUserId != nil {
            map["BargedUserId"] = self.bargedUserId!
        }
        if self.deviceId != nil {
            map["DeviceId"] = self.deviceId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.timeoutSeconds != nil {
            map["TimeoutSeconds"] = self.timeoutSeconds!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BargedUserId") {
            self.bargedUserId = dict["BargedUserId"] as! String
        }
        if dict.keys.contains("DeviceId") {
            self.deviceId = dict["DeviceId"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("TimeoutSeconds") {
            self.timeoutSeconds = dict["TimeoutSeconds"] as! Int32
        }
        if dict.keys.contains("UserId") {
            self.userId = dict["UserId"] as! String
        }
    }
}

public class BargeInCallResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class CallContext : Tea.TeaModel {
            public class ChannelContexts : Tea.TeaModel {
                public var callType: String?

                public var channelFlags: String?

                public var channelId: String?

                public var channelState: String?

                public var destination: String?

                public var index: Int32?

                public var jobId: String?

                public var originator: String?

                public var releaseInitiator: String?

                public var releaseReason: String?

                public var skillGroupId: String?

                public var timestamp: Int64?

                public var userExtension: String?

                public var userId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.callType != nil {
                        map["CallType"] = self.callType!
                    }
                    if self.channelFlags != nil {
                        map["ChannelFlags"] = self.channelFlags!
                    }
                    if self.channelId != nil {
                        map["ChannelId"] = self.channelId!
                    }
                    if self.channelState != nil {
                        map["ChannelState"] = self.channelState!
                    }
                    if self.destination != nil {
                        map["Destination"] = self.destination!
                    }
                    if self.index != nil {
                        map["Index"] = self.index!
                    }
                    if self.jobId != nil {
                        map["JobId"] = self.jobId!
                    }
                    if self.originator != nil {
                        map["Originator"] = self.originator!
                    }
                    if self.releaseInitiator != nil {
                        map["ReleaseInitiator"] = self.releaseInitiator!
                    }
                    if self.releaseReason != nil {
                        map["ReleaseReason"] = self.releaseReason!
                    }
                    if self.skillGroupId != nil {
                        map["SkillGroupId"] = self.skillGroupId!
                    }
                    if self.timestamp != nil {
                        map["Timestamp"] = self.timestamp!
                    }
                    if self.userExtension != nil {
                        map["UserExtension"] = self.userExtension!
                    }
                    if self.userId != nil {
                        map["UserId"] = self.userId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("CallType") {
                        self.callType = dict["CallType"] as! String
                    }
                    if dict.keys.contains("ChannelFlags") {
                        self.channelFlags = dict["ChannelFlags"] as! String
                    }
                    if dict.keys.contains("ChannelId") {
                        self.channelId = dict["ChannelId"] as! String
                    }
                    if dict.keys.contains("ChannelState") {
                        self.channelState = dict["ChannelState"] as! String
                    }
                    if dict.keys.contains("Destination") {
                        self.destination = dict["Destination"] as! String
                    }
                    if dict.keys.contains("Index") {
                        self.index = dict["Index"] as! Int32
                    }
                    if dict.keys.contains("JobId") {
                        self.jobId = dict["JobId"] as! String
                    }
                    if dict.keys.contains("Originator") {
                        self.originator = dict["Originator"] as! String
                    }
                    if dict.keys.contains("ReleaseInitiator") {
                        self.releaseInitiator = dict["ReleaseInitiator"] as! String
                    }
                    if dict.keys.contains("ReleaseReason") {
                        self.releaseReason = dict["ReleaseReason"] as! String
                    }
                    if dict.keys.contains("SkillGroupId") {
                        self.skillGroupId = dict["SkillGroupId"] as! String
                    }
                    if dict.keys.contains("Timestamp") {
                        self.timestamp = dict["Timestamp"] as! Int64
                    }
                    if dict.keys.contains("UserExtension") {
                        self.userExtension = dict["UserExtension"] as! String
                    }
                    if dict.keys.contains("UserId") {
                        self.userId = dict["UserId"] as! String
                    }
                }
            }
            public var callType: String?

            public var channelContexts: [BargeInCallResponseBody.Data.CallContext.ChannelContexts]?

            public var instanceId: String?

            public var jobId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.callType != nil {
                    map["CallType"] = self.callType!
                }
                if self.channelContexts != nil {
                    var tmp : [Any] = []
                    for k in self.channelContexts! {
                        tmp.append(k.toMap())
                    }
                    map["ChannelContexts"] = tmp
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.jobId != nil {
                    map["JobId"] = self.jobId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CallType") {
                    self.callType = dict["CallType"] as! String
                }
                if dict.keys.contains("ChannelContexts") {
                    var tmp : [BargeInCallResponseBody.Data.CallContext.ChannelContexts] = []
                    for v in dict["ChannelContexts"] as! [Any] {
                        var model = BargeInCallResponseBody.Data.CallContext.ChannelContexts()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.channelContexts = tmp
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("JobId") {
                    self.jobId = dict["JobId"] as! String
                }
            }
        }
        public class UserContext : Tea.TeaModel {
            public var breakCode: String?

            public var deviceId: String?

            public var extension_: String?

            public var heartbeat: Int64?

            public var instanceId: String?

            public var jobId: String?

            public var mobile: String?

            public var outboundScenario: Bool?

            public var reserved: Int64?

            public var signedSkillGroupIdList: [String]?

            public var userId: String?

            public var userState: String?

            public var workMode: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.breakCode != nil {
                    map["BreakCode"] = self.breakCode!
                }
                if self.deviceId != nil {
                    map["DeviceId"] = self.deviceId!
                }
                if self.extension_ != nil {
                    map["Extension"] = self.extension_!
                }
                if self.heartbeat != nil {
                    map["Heartbeat"] = self.heartbeat!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.jobId != nil {
                    map["JobId"] = self.jobId!
                }
                if self.mobile != nil {
                    map["Mobile"] = self.mobile!
                }
                if self.outboundScenario != nil {
                    map["OutboundScenario"] = self.outboundScenario!
                }
                if self.reserved != nil {
                    map["Reserved"] = self.reserved!
                }
                if self.signedSkillGroupIdList != nil {
                    map["SignedSkillGroupIdList"] = self.signedSkillGroupIdList!
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                if self.userState != nil {
                    map["UserState"] = self.userState!
                }
                if self.workMode != nil {
                    map["WorkMode"] = self.workMode!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BreakCode") {
                    self.breakCode = dict["BreakCode"] as! String
                }
                if dict.keys.contains("DeviceId") {
                    self.deviceId = dict["DeviceId"] as! String
                }
                if dict.keys.contains("Extension") {
                    self.extension_ = dict["Extension"] as! String
                }
                if dict.keys.contains("Heartbeat") {
                    self.heartbeat = dict["Heartbeat"] as! Int64
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("JobId") {
                    self.jobId = dict["JobId"] as! String
                }
                if dict.keys.contains("Mobile") {
                    self.mobile = dict["Mobile"] as! String
                }
                if dict.keys.contains("OutboundScenario") {
                    self.outboundScenario = dict["OutboundScenario"] as! Bool
                }
                if dict.keys.contains("Reserved") {
                    self.reserved = dict["Reserved"] as! Int64
                }
                if dict.keys.contains("SignedSkillGroupIdList") {
                    self.signedSkillGroupIdList = dict["SignedSkillGroupIdList"] as! [String]
                }
                if dict.keys.contains("UserId") {
                    self.userId = dict["UserId"] as! String
                }
                if dict.keys.contains("UserState") {
                    self.userState = dict["UserState"] as! String
                }
                if dict.keys.contains("WorkMode") {
                    self.workMode = dict["WorkMode"] as! String
                }
            }
        }
        public var callContext: BargeInCallResponseBody.Data.CallContext?

        public var userContext: BargeInCallResponseBody.Data.UserContext?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.callContext?.validate()
            try self.userContext?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.callContext != nil {
                map["CallContext"] = self.callContext?.toMap()
            }
            if self.userContext != nil {
                map["UserContext"] = self.userContext?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CallContext") {
                var model = BargeInCallResponseBody.Data.CallContext()
                model.fromMap(dict["CallContext"] as! [String: Any])
                self.callContext = model
            }
            if dict.keys.contains("UserContext") {
                var model = BargeInCallResponseBody.Data.UserContext()
                model.fromMap(dict["UserContext"] as! [String: Any])
                self.userContext = model
            }
        }
    }
    public var code: String?

    public var data: BargeInCallResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var params: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.params != nil {
            map["Params"] = self.params!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = BargeInCallResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Params") {
            self.params = dict["Params"] as! [String]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class BargeInCallResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: BargeInCallResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = BargeInCallResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class BlindTransferRequest : Tea.TeaModel {
    public var callPriority: Int32?

    public var contactFlowVariables: String?

    public var deviceId: String?

    public var instanceId: String?

    public var jobId: String?

    public var queuingOverflowThreshold: Int64?

    public var queuingTimeoutSeconds: Int64?

    public var routingType: String?

    public var strategyName: String?

    public var strategyParams: String?

    public var tags: String?

    public var timeoutSeconds: Int32?

    public var transferee: String?

    public var transfereeType: String?

    public var transferor: String?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.callPriority != nil {
            map["CallPriority"] = self.callPriority!
        }
        if self.contactFlowVariables != nil {
            map["ContactFlowVariables"] = self.contactFlowVariables!
        }
        if self.deviceId != nil {
            map["DeviceId"] = self.deviceId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.queuingOverflowThreshold != nil {
            map["QueuingOverflowThreshold"] = self.queuingOverflowThreshold!
        }
        if self.queuingTimeoutSeconds != nil {
            map["QueuingTimeoutSeconds"] = self.queuingTimeoutSeconds!
        }
        if self.routingType != nil {
            map["RoutingType"] = self.routingType!
        }
        if self.strategyName != nil {
            map["StrategyName"] = self.strategyName!
        }
        if self.strategyParams != nil {
            map["StrategyParams"] = self.strategyParams!
        }
        if self.tags != nil {
            map["Tags"] = self.tags!
        }
        if self.timeoutSeconds != nil {
            map["TimeoutSeconds"] = self.timeoutSeconds!
        }
        if self.transferee != nil {
            map["Transferee"] = self.transferee!
        }
        if self.transfereeType != nil {
            map["TransfereeType"] = self.transfereeType!
        }
        if self.transferor != nil {
            map["Transferor"] = self.transferor!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CallPriority") {
            self.callPriority = dict["CallPriority"] as! Int32
        }
        if dict.keys.contains("ContactFlowVariables") {
            self.contactFlowVariables = dict["ContactFlowVariables"] as! String
        }
        if dict.keys.contains("DeviceId") {
            self.deviceId = dict["DeviceId"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("QueuingOverflowThreshold") {
            self.queuingOverflowThreshold = dict["QueuingOverflowThreshold"] as! Int64
        }
        if dict.keys.contains("QueuingTimeoutSeconds") {
            self.queuingTimeoutSeconds = dict["QueuingTimeoutSeconds"] as! Int64
        }
        if dict.keys.contains("RoutingType") {
            self.routingType = dict["RoutingType"] as! String
        }
        if dict.keys.contains("StrategyName") {
            self.strategyName = dict["StrategyName"] as! String
        }
        if dict.keys.contains("StrategyParams") {
            self.strategyParams = dict["StrategyParams"] as! String
        }
        if dict.keys.contains("Tags") {
            self.tags = dict["Tags"] as! String
        }
        if dict.keys.contains("TimeoutSeconds") {
            self.timeoutSeconds = dict["TimeoutSeconds"] as! Int32
        }
        if dict.keys.contains("Transferee") {
            self.transferee = dict["Transferee"] as! String
        }
        if dict.keys.contains("TransfereeType") {
            self.transfereeType = dict["TransfereeType"] as! String
        }
        if dict.keys.contains("Transferor") {
            self.transferor = dict["Transferor"] as! String
        }
        if dict.keys.contains("UserId") {
            self.userId = dict["UserId"] as! String
        }
    }
}

public class BlindTransferResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class CallContext : Tea.TeaModel {
            public class ChannelContexts : Tea.TeaModel {
                public var callType: String?

                public var channelFlags: String?

                public var channelId: String?

                public var channelState: String?

                public var destination: String?

                public var jobId: String?

                public var originator: String?

                public var releaseInitiator: String?

                public var releaseReason: String?

                public var timestamp: Int64?

                public var userExtension: String?

                public var userId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.callType != nil {
                        map["CallType"] = self.callType!
                    }
                    if self.channelFlags != nil {
                        map["ChannelFlags"] = self.channelFlags!
                    }
                    if self.channelId != nil {
                        map["ChannelId"] = self.channelId!
                    }
                    if self.channelState != nil {
                        map["ChannelState"] = self.channelState!
                    }
                    if self.destination != nil {
                        map["Destination"] = self.destination!
                    }
                    if self.jobId != nil {
                        map["JobId"] = self.jobId!
                    }
                    if self.originator != nil {
                        map["Originator"] = self.originator!
                    }
                    if self.releaseInitiator != nil {
                        map["ReleaseInitiator"] = self.releaseInitiator!
                    }
                    if self.releaseReason != nil {
                        map["ReleaseReason"] = self.releaseReason!
                    }
                    if self.timestamp != nil {
                        map["Timestamp"] = self.timestamp!
                    }
                    if self.userExtension != nil {
                        map["UserExtension"] = self.userExtension!
                    }
                    if self.userId != nil {
                        map["UserId"] = self.userId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("CallType") {
                        self.callType = dict["CallType"] as! String
                    }
                    if dict.keys.contains("ChannelFlags") {
                        self.channelFlags = dict["ChannelFlags"] as! String
                    }
                    if dict.keys.contains("ChannelId") {
                        self.channelId = dict["ChannelId"] as! String
                    }
                    if dict.keys.contains("ChannelState") {
                        self.channelState = dict["ChannelState"] as! String
                    }
                    if dict.keys.contains("Destination") {
                        self.destination = dict["Destination"] as! String
                    }
                    if dict.keys.contains("JobId") {
                        self.jobId = dict["JobId"] as! String
                    }
                    if dict.keys.contains("Originator") {
                        self.originator = dict["Originator"] as! String
                    }
                    if dict.keys.contains("ReleaseInitiator") {
                        self.releaseInitiator = dict["ReleaseInitiator"] as! String
                    }
                    if dict.keys.contains("ReleaseReason") {
                        self.releaseReason = dict["ReleaseReason"] as! String
                    }
                    if dict.keys.contains("Timestamp") {
                        self.timestamp = dict["Timestamp"] as! Int64
                    }
                    if dict.keys.contains("UserExtension") {
                        self.userExtension = dict["UserExtension"] as! String
                    }
                    if dict.keys.contains("UserId") {
                        self.userId = dict["UserId"] as! String
                    }
                }
            }
            public var callType: String?

            public var channelContexts: [BlindTransferResponseBody.Data.CallContext.ChannelContexts]?

            public var instanceId: String?

            public var jobId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.callType != nil {
                    map["CallType"] = self.callType!
                }
                if self.channelContexts != nil {
                    var tmp : [Any] = []
                    for k in self.channelContexts! {
                        tmp.append(k.toMap())
                    }
                    map["ChannelContexts"] = tmp
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.jobId != nil {
                    map["JobId"] = self.jobId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CallType") {
                    self.callType = dict["CallType"] as! String
                }
                if dict.keys.contains("ChannelContexts") {
                    var tmp : [BlindTransferResponseBody.Data.CallContext.ChannelContexts] = []
                    for v in dict["ChannelContexts"] as! [Any] {
                        var model = BlindTransferResponseBody.Data.CallContext.ChannelContexts()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.channelContexts = tmp
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("JobId") {
                    self.jobId = dict["JobId"] as! String
                }
            }
        }
        public class UserContext : Tea.TeaModel {
            public var breakCode: String?

            public var deviceId: String?

            public var extension_: String?

            public var heartbeat: Int64?

            public var instanceId: String?

            public var jobId: String?

            public var mobile: String?

            public var outboundScenario: Bool?

            public var reserved: Int64?

            public var signedSkillGroupIdList: [String]?

            public var userId: String?

            public var userState: String?

            public var workMode: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.breakCode != nil {
                    map["BreakCode"] = self.breakCode!
                }
                if self.deviceId != nil {
                    map["DeviceId"] = self.deviceId!
                }
                if self.extension_ != nil {
                    map["Extension"] = self.extension_!
                }
                if self.heartbeat != nil {
                    map["Heartbeat"] = self.heartbeat!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.jobId != nil {
                    map["JobId"] = self.jobId!
                }
                if self.mobile != nil {
                    map["Mobile"] = self.mobile!
                }
                if self.outboundScenario != nil {
                    map["OutboundScenario"] = self.outboundScenario!
                }
                if self.reserved != nil {
                    map["Reserved"] = self.reserved!
                }
                if self.signedSkillGroupIdList != nil {
                    map["SignedSkillGroupIdList"] = self.signedSkillGroupIdList!
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                if self.userState != nil {
                    map["UserState"] = self.userState!
                }
                if self.workMode != nil {
                    map["WorkMode"] = self.workMode!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BreakCode") {
                    self.breakCode = dict["BreakCode"] as! String
                }
                if dict.keys.contains("DeviceId") {
                    self.deviceId = dict["DeviceId"] as! String
                }
                if dict.keys.contains("Extension") {
                    self.extension_ = dict["Extension"] as! String
                }
                if dict.keys.contains("Heartbeat") {
                    self.heartbeat = dict["Heartbeat"] as! Int64
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("JobId") {
                    self.jobId = dict["JobId"] as! String
                }
                if dict.keys.contains("Mobile") {
                    self.mobile = dict["Mobile"] as! String
                }
                if dict.keys.contains("OutboundScenario") {
                    self.outboundScenario = dict["OutboundScenario"] as! Bool
                }
                if dict.keys.contains("Reserved") {
                    self.reserved = dict["Reserved"] as! Int64
                }
                if dict.keys.contains("SignedSkillGroupIdList") {
                    self.signedSkillGroupIdList = dict["SignedSkillGroupIdList"] as! [String]
                }
                if dict.keys.contains("UserId") {
                    self.userId = dict["UserId"] as! String
                }
                if dict.keys.contains("UserState") {
                    self.userState = dict["UserState"] as! String
                }
                if dict.keys.contains("WorkMode") {
                    self.workMode = dict["WorkMode"] as! String
                }
            }
        }
        public var callContext: BlindTransferResponseBody.Data.CallContext?

        public var contextId: Int64?

        public var userContext: BlindTransferResponseBody.Data.UserContext?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.callContext?.validate()
            try self.userContext?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.callContext != nil {
                map["CallContext"] = self.callContext?.toMap()
            }
            if self.contextId != nil {
                map["ContextId"] = self.contextId!
            }
            if self.userContext != nil {
                map["UserContext"] = self.userContext?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CallContext") {
                var model = BlindTransferResponseBody.Data.CallContext()
                model.fromMap(dict["CallContext"] as! [String: Any])
                self.callContext = model
            }
            if dict.keys.contains("ContextId") {
                self.contextId = dict["ContextId"] as! Int64
            }
            if dict.keys.contains("UserContext") {
                var model = BlindTransferResponseBody.Data.UserContext()
                model.fromMap(dict["UserContext"] as! [String: Any])
                self.userContext = model
            }
        }
    }
    public var code: String?

    public var data: BlindTransferResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var params: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.params != nil {
            map["Params"] = self.params!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = BlindTransferResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Params") {
            self.params = dict["Params"] as! [String]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class BlindTransferResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: BlindTransferResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = BlindTransferResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class BridgeRtcCallRequest : Tea.TeaModel {
    public var callee: String?

    public var caller: String?

    public var deviceId: String?

    public var instanceId: String?

    public var serviceProvider: String?

    public var tags: String?

    public var timeoutSeconds: Int32?

    public var userId: String?

    public var videoEnabled: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.callee != nil {
            map["Callee"] = self.callee!
        }
        if self.caller != nil {
            map["Caller"] = self.caller!
        }
        if self.deviceId != nil {
            map["DeviceId"] = self.deviceId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.serviceProvider != nil {
            map["ServiceProvider"] = self.serviceProvider!
        }
        if self.tags != nil {
            map["Tags"] = self.tags!
        }
        if self.timeoutSeconds != nil {
            map["TimeoutSeconds"] = self.timeoutSeconds!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        if self.videoEnabled != nil {
            map["VideoEnabled"] = self.videoEnabled!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Callee") {
            self.callee = dict["Callee"] as! String
        }
        if dict.keys.contains("Caller") {
            self.caller = dict["Caller"] as! String
        }
        if dict.keys.contains("DeviceId") {
            self.deviceId = dict["DeviceId"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("ServiceProvider") {
            self.serviceProvider = dict["ServiceProvider"] as! String
        }
        if dict.keys.contains("Tags") {
            self.tags = dict["Tags"] as! String
        }
        if dict.keys.contains("TimeoutSeconds") {
            self.timeoutSeconds = dict["TimeoutSeconds"] as! Int32
        }
        if dict.keys.contains("UserId") {
            self.userId = dict["UserId"] as! String
        }
        if dict.keys.contains("VideoEnabled") {
            self.videoEnabled = dict["VideoEnabled"] as! Bool
        }
    }
}

public class BridgeRtcCallResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var instanceId: String?

        public var jobId: String?

        public var tokenInfo: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            if self.tokenInfo != nil {
                map["TokenInfo"] = self.tokenInfo!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("InstanceId") {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("JobId") {
                self.jobId = dict["JobId"] as! String
            }
            if dict.keys.contains("TokenInfo") {
                self.tokenInfo = dict["TokenInfo"] as! String
            }
        }
    }
    public var code: String?

    public var data: BridgeRtcCallResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var params: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.params != nil {
            map["Params"] = self.params!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = BridgeRtcCallResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Params") {
            self.params = dict["Params"] as! [String]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class BridgeRtcCallResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: BridgeRtcCallResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = BridgeRtcCallResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CancelAttendedTransferRequest : Tea.TeaModel {
    public var deviceId: String?

    public var instanceId: String?

    public var jobId: String?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.deviceId != nil {
            map["DeviceId"] = self.deviceId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DeviceId") {
            self.deviceId = dict["DeviceId"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("UserId") {
            self.userId = dict["UserId"] as! String
        }
    }
}

public class CancelAttendedTransferResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class CallContext : Tea.TeaModel {
            public class ChannelContexts : Tea.TeaModel {
                public var callType: String?

                public var channelFlags: String?

                public var channelId: String?

                public var channelState: String?

                public var destination: String?

                public var index: Int32?

                public var jobId: String?

                public var originator: String?

                public var releaseInitiator: String?

                public var releaseReason: String?

                public var timestamp: Int64?

                public var userExtension: String?

                public var userId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.callType != nil {
                        map["CallType"] = self.callType!
                    }
                    if self.channelFlags != nil {
                        map["ChannelFlags"] = self.channelFlags!
                    }
                    if self.channelId != nil {
                        map["ChannelId"] = self.channelId!
                    }
                    if self.channelState != nil {
                        map["ChannelState"] = self.channelState!
                    }
                    if self.destination != nil {
                        map["Destination"] = self.destination!
                    }
                    if self.index != nil {
                        map["Index"] = self.index!
                    }
                    if self.jobId != nil {
                        map["JobId"] = self.jobId!
                    }
                    if self.originator != nil {
                        map["Originator"] = self.originator!
                    }
                    if self.releaseInitiator != nil {
                        map["ReleaseInitiator"] = self.releaseInitiator!
                    }
                    if self.releaseReason != nil {
                        map["ReleaseReason"] = self.releaseReason!
                    }
                    if self.timestamp != nil {
                        map["Timestamp"] = self.timestamp!
                    }
                    if self.userExtension != nil {
                        map["UserExtension"] = self.userExtension!
                    }
                    if self.userId != nil {
                        map["UserId"] = self.userId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("CallType") {
                        self.callType = dict["CallType"] as! String
                    }
                    if dict.keys.contains("ChannelFlags") {
                        self.channelFlags = dict["ChannelFlags"] as! String
                    }
                    if dict.keys.contains("ChannelId") {
                        self.channelId = dict["ChannelId"] as! String
                    }
                    if dict.keys.contains("ChannelState") {
                        self.channelState = dict["ChannelState"] as! String
                    }
                    if dict.keys.contains("Destination") {
                        self.destination = dict["Destination"] as! String
                    }
                    if dict.keys.contains("Index") {
                        self.index = dict["Index"] as! Int32
                    }
                    if dict.keys.contains("JobId") {
                        self.jobId = dict["JobId"] as! String
                    }
                    if dict.keys.contains("Originator") {
                        self.originator = dict["Originator"] as! String
                    }
                    if dict.keys.contains("ReleaseInitiator") {
                        self.releaseInitiator = dict["ReleaseInitiator"] as! String
                    }
                    if dict.keys.contains("ReleaseReason") {
                        self.releaseReason = dict["ReleaseReason"] as! String
                    }
                    if dict.keys.contains("Timestamp") {
                        self.timestamp = dict["Timestamp"] as! Int64
                    }
                    if dict.keys.contains("UserExtension") {
                        self.userExtension = dict["UserExtension"] as! String
                    }
                    if dict.keys.contains("UserId") {
                        self.userId = dict["UserId"] as! String
                    }
                }
            }
            public var callType: String?

            public var channelContexts: [CancelAttendedTransferResponseBody.Data.CallContext.ChannelContexts]?

            public var instanceId: String?

            public var jobId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.callType != nil {
                    map["CallType"] = self.callType!
                }
                if self.channelContexts != nil {
                    var tmp : [Any] = []
                    for k in self.channelContexts! {
                        tmp.append(k.toMap())
                    }
                    map["ChannelContexts"] = tmp
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.jobId != nil {
                    map["JobId"] = self.jobId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CallType") {
                    self.callType = dict["CallType"] as! String
                }
                if dict.keys.contains("ChannelContexts") {
                    var tmp : [CancelAttendedTransferResponseBody.Data.CallContext.ChannelContexts] = []
                    for v in dict["ChannelContexts"] as! [Any] {
                        var model = CancelAttendedTransferResponseBody.Data.CallContext.ChannelContexts()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.channelContexts = tmp
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("JobId") {
                    self.jobId = dict["JobId"] as! String
                }
            }
        }
        public class UserContext : Tea.TeaModel {
            public var breakCode: String?

            public var deviceId: String?

            public var extension_: String?

            public var heartbeat: Int64?

            public var instanceId: String?

            public var jobId: String?

            public var mobile: String?

            public var outboundScenario: Bool?

            public var reserved: Int64?

            public var signedSkillGroupIdList: [String]?

            public var userId: String?

            public var userState: String?

            public var workMode: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.breakCode != nil {
                    map["BreakCode"] = self.breakCode!
                }
                if self.deviceId != nil {
                    map["DeviceId"] = self.deviceId!
                }
                if self.extension_ != nil {
                    map["Extension"] = self.extension_!
                }
                if self.heartbeat != nil {
                    map["Heartbeat"] = self.heartbeat!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.jobId != nil {
                    map["JobId"] = self.jobId!
                }
                if self.mobile != nil {
                    map["Mobile"] = self.mobile!
                }
                if self.outboundScenario != nil {
                    map["OutboundScenario"] = self.outboundScenario!
                }
                if self.reserved != nil {
                    map["Reserved"] = self.reserved!
                }
                if self.signedSkillGroupIdList != nil {
                    map["SignedSkillGroupIdList"] = self.signedSkillGroupIdList!
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                if self.userState != nil {
                    map["UserState"] = self.userState!
                }
                if self.workMode != nil {
                    map["WorkMode"] = self.workMode!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BreakCode") {
                    self.breakCode = dict["BreakCode"] as! String
                }
                if dict.keys.contains("DeviceId") {
                    self.deviceId = dict["DeviceId"] as! String
                }
                if dict.keys.contains("Extension") {
                    self.extension_ = dict["Extension"] as! String
                }
                if dict.keys.contains("Heartbeat") {
                    self.heartbeat = dict["Heartbeat"] as! Int64
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("JobId") {
                    self.jobId = dict["JobId"] as! String
                }
                if dict.keys.contains("Mobile") {
                    self.mobile = dict["Mobile"] as! String
                }
                if dict.keys.contains("OutboundScenario") {
                    self.outboundScenario = dict["OutboundScenario"] as! Bool
                }
                if dict.keys.contains("Reserved") {
                    self.reserved = dict["Reserved"] as! Int64
                }
                if dict.keys.contains("SignedSkillGroupIdList") {
                    self.signedSkillGroupIdList = dict["SignedSkillGroupIdList"] as! [String]
                }
                if dict.keys.contains("UserId") {
                    self.userId = dict["UserId"] as! String
                }
                if dict.keys.contains("UserState") {
                    self.userState = dict["UserState"] as! String
                }
                if dict.keys.contains("WorkMode") {
                    self.workMode = dict["WorkMode"] as! String
                }
            }
        }
        public var callContext: CancelAttendedTransferResponseBody.Data.CallContext?

        public var contextId: Int64?

        public var userContext: CancelAttendedTransferResponseBody.Data.UserContext?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.callContext?.validate()
            try self.userContext?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.callContext != nil {
                map["CallContext"] = self.callContext?.toMap()
            }
            if self.contextId != nil {
                map["ContextId"] = self.contextId!
            }
            if self.userContext != nil {
                map["UserContext"] = self.userContext?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CallContext") {
                var model = CancelAttendedTransferResponseBody.Data.CallContext()
                model.fromMap(dict["CallContext"] as! [String: Any])
                self.callContext = model
            }
            if dict.keys.contains("ContextId") {
                self.contextId = dict["ContextId"] as! Int64
            }
            if dict.keys.contains("UserContext") {
                var model = CancelAttendedTransferResponseBody.Data.UserContext()
                model.fromMap(dict["UserContext"] as! [String: Any])
                self.userContext = model
            }
        }
    }
    public var code: String?

    public var data: CancelAttendedTransferResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var params: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.params != nil {
            map["Params"] = self.params!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = CancelAttendedTransferResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Params") {
            self.params = dict["Params"] as! [String]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CancelAttendedTransferResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CancelAttendedTransferResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CancelAttendedTransferResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ChangeVisibilityRequest : Tea.TeaModel {
    public var instanceId: String?

    public var invisible: Bool?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.invisible != nil {
            map["Invisible"] = self.invisible!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Invisible") {
            self.invisible = dict["Invisible"] as! Bool
        }
        if dict.keys.contains("UserId") {
            self.userId = dict["UserId"] as! String
        }
    }
}

public class ChangeVisibilityResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var breakCode: String?

        public var deviceId: String?

        public var extension_: String?

        public var instanceId: String?

        public var jobId: String?

        public var outboundScenario: Bool?

        public var signedSkillGroupIdList: [String]?

        public var userId: String?

        public var userState: String?

        public var workMode: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.breakCode != nil {
                map["BreakCode"] = self.breakCode!
            }
            if self.deviceId != nil {
                map["DeviceId"] = self.deviceId!
            }
            if self.extension_ != nil {
                map["Extension"] = self.extension_!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            if self.outboundScenario != nil {
                map["OutboundScenario"] = self.outboundScenario!
            }
            if self.signedSkillGroupIdList != nil {
                map["SignedSkillGroupIdList"] = self.signedSkillGroupIdList!
            }
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            if self.userState != nil {
                map["UserState"] = self.userState!
            }
            if self.workMode != nil {
                map["WorkMode"] = self.workMode!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BreakCode") {
                self.breakCode = dict["BreakCode"] as! String
            }
            if dict.keys.contains("DeviceId") {
                self.deviceId = dict["DeviceId"] as! String
            }
            if dict.keys.contains("Extension") {
                self.extension_ = dict["Extension"] as! String
            }
            if dict.keys.contains("InstanceId") {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("JobId") {
                self.jobId = dict["JobId"] as! String
            }
            if dict.keys.contains("OutboundScenario") {
                self.outboundScenario = dict["OutboundScenario"] as! Bool
            }
            if dict.keys.contains("SignedSkillGroupIdList") {
                self.signedSkillGroupIdList = dict["SignedSkillGroupIdList"] as! [String]
            }
            if dict.keys.contains("UserId") {
                self.userId = dict["UserId"] as! String
            }
            if dict.keys.contains("UserState") {
                self.userState = dict["UserState"] as! String
            }
            if dict.keys.contains("WorkMode") {
                self.workMode = dict["WorkMode"] as! String
            }
        }
    }
    public var code: String?

    public var data: ChangeVisibilityResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var params: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.params != nil {
            map["Params"] = self.params!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = ChangeVisibilityResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Params") {
            self.params = dict["Params"] as! [String]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ChangeVisibilityResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ChangeVisibilityResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ChangeVisibilityResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ChangeWorkModeRequest : Tea.TeaModel {
    public var deviceId: String?

    public var instanceId: String?

    public var mobile: String?

    public var signedSkillGroupIdList: String?

    public var userId: String?

    public var workMode: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.deviceId != nil {
            map["DeviceId"] = self.deviceId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.mobile != nil {
            map["Mobile"] = self.mobile!
        }
        if self.signedSkillGroupIdList != nil {
            map["SignedSkillGroupIdList"] = self.signedSkillGroupIdList!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        if self.workMode != nil {
            map["WorkMode"] = self.workMode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DeviceId") {
            self.deviceId = dict["DeviceId"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Mobile") {
            self.mobile = dict["Mobile"] as! String
        }
        if dict.keys.contains("SignedSkillGroupIdList") {
            self.signedSkillGroupIdList = dict["SignedSkillGroupIdList"] as! String
        }
        if dict.keys.contains("UserId") {
            self.userId = dict["UserId"] as! String
        }
        if dict.keys.contains("WorkMode") {
            self.workMode = dict["WorkMode"] as! String
        }
    }
}

public class ChangeWorkModeResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var breakCode: String?

        public var deviceId: String?

        public var extension_: String?

        public var instanceId: String?

        public var jobId: String?

        public var outboundScenario: Bool?

        public var signedSkillGroupIdList: [String]?

        public var userId: String?

        public var userState: String?

        public var workMode: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.breakCode != nil {
                map["BreakCode"] = self.breakCode!
            }
            if self.deviceId != nil {
                map["DeviceId"] = self.deviceId!
            }
            if self.extension_ != nil {
                map["Extension"] = self.extension_!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            if self.outboundScenario != nil {
                map["OutboundScenario"] = self.outboundScenario!
            }
            if self.signedSkillGroupIdList != nil {
                map["SignedSkillGroupIdList"] = self.signedSkillGroupIdList!
            }
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            if self.userState != nil {
                map["UserState"] = self.userState!
            }
            if self.workMode != nil {
                map["WorkMode"] = self.workMode!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BreakCode") {
                self.breakCode = dict["BreakCode"] as! String
            }
            if dict.keys.contains("DeviceId") {
                self.deviceId = dict["DeviceId"] as! String
            }
            if dict.keys.contains("Extension") {
                self.extension_ = dict["Extension"] as! String
            }
            if dict.keys.contains("InstanceId") {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("JobId") {
                self.jobId = dict["JobId"] as! String
            }
            if dict.keys.contains("OutboundScenario") {
                self.outboundScenario = dict["OutboundScenario"] as! Bool
            }
            if dict.keys.contains("SignedSkillGroupIdList") {
                self.signedSkillGroupIdList = dict["SignedSkillGroupIdList"] as! [String]
            }
            if dict.keys.contains("UserId") {
                self.userId = dict["UserId"] as! String
            }
            if dict.keys.contains("UserState") {
                self.userState = dict["UserState"] as! String
            }
            if dict.keys.contains("WorkMode") {
                self.workMode = dict["WorkMode"] as! String
            }
        }
    }
    public var code: String?

    public var data: ChangeWorkModeResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var params: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.params != nil {
            map["Params"] = self.params!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = ChangeWorkModeResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Params") {
            self.params = dict["Params"] as! [String]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ChangeWorkModeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ChangeWorkModeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ChangeWorkModeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ClaimChatRequest : Tea.TeaModel {
    public var instanceId: String?

    public var jobId: String?

    public var skillGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.skillGroupId != nil {
            map["SkillGroupId"] = self.skillGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("SkillGroupId") {
            self.skillGroupId = dict["SkillGroupId"] as! String
        }
    }
}

public class ClaimChatResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class ChatContexts : Tea.TeaModel {
            public var accessChannelId: String?

            public var accessChannelName: String?

            public var accessChannelType: String?

            public var beingAssigned: Bool?

            public var callVariables: String?

            public var chatType: String?

            public var instanceId: String?

            public var jobId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.accessChannelId != nil {
                    map["AccessChannelId"] = self.accessChannelId!
                }
                if self.accessChannelName != nil {
                    map["AccessChannelName"] = self.accessChannelName!
                }
                if self.accessChannelType != nil {
                    map["AccessChannelType"] = self.accessChannelType!
                }
                if self.beingAssigned != nil {
                    map["BeingAssigned"] = self.beingAssigned!
                }
                if self.callVariables != nil {
                    map["CallVariables"] = self.callVariables!
                }
                if self.chatType != nil {
                    map["ChatType"] = self.chatType!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.jobId != nil {
                    map["JobId"] = self.jobId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AccessChannelId") {
                    self.accessChannelId = dict["AccessChannelId"] as! String
                }
                if dict.keys.contains("AccessChannelName") {
                    self.accessChannelName = dict["AccessChannelName"] as! String
                }
                if dict.keys.contains("AccessChannelType") {
                    self.accessChannelType = dict["AccessChannelType"] as! String
                }
                if dict.keys.contains("BeingAssigned") {
                    self.beingAssigned = dict["BeingAssigned"] as! Bool
                }
                if dict.keys.contains("CallVariables") {
                    self.callVariables = dict["CallVariables"] as! String
                }
                if dict.keys.contains("ChatType") {
                    self.chatType = dict["ChatType"] as! String
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("JobId") {
                    self.jobId = dict["JobId"] as! String
                }
            }
        }
        public class UserContext : Tea.TeaModel {
            public var breakCode: String?

            public var deviceId: String?

            public var deviceState: String?

            public var extension_: String?

            public var heartbeat: Int64?

            public var instanceId: String?

            public var jobId: String?

            public var mobile: String?

            public var outboundScenario: Bool?

            public var reserved: Int64?

            public var signedSkillGroupIdList: [String]?

            public var userId: String?

            public var userState: String?

            public var workMode: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.breakCode != nil {
                    map["BreakCode"] = self.breakCode!
                }
                if self.deviceId != nil {
                    map["DeviceId"] = self.deviceId!
                }
                if self.deviceState != nil {
                    map["DeviceState"] = self.deviceState!
                }
                if self.extension_ != nil {
                    map["Extension"] = self.extension_!
                }
                if self.heartbeat != nil {
                    map["Heartbeat"] = self.heartbeat!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.jobId != nil {
                    map["JobId"] = self.jobId!
                }
                if self.mobile != nil {
                    map["Mobile"] = self.mobile!
                }
                if self.outboundScenario != nil {
                    map["OutboundScenario"] = self.outboundScenario!
                }
                if self.reserved != nil {
                    map["Reserved"] = self.reserved!
                }
                if self.signedSkillGroupIdList != nil {
                    map["SignedSkillGroupIdList"] = self.signedSkillGroupIdList!
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                if self.userState != nil {
                    map["UserState"] = self.userState!
                }
                if self.workMode != nil {
                    map["WorkMode"] = self.workMode!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BreakCode") {
                    self.breakCode = dict["BreakCode"] as! String
                }
                if dict.keys.contains("DeviceId") {
                    self.deviceId = dict["DeviceId"] as! String
                }
                if dict.keys.contains("DeviceState") {
                    self.deviceState = dict["DeviceState"] as! String
                }
                if dict.keys.contains("Extension") {
                    self.extension_ = dict["Extension"] as! String
                }
                if dict.keys.contains("Heartbeat") {
                    self.heartbeat = dict["Heartbeat"] as! Int64
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("JobId") {
                    self.jobId = dict["JobId"] as! String
                }
                if dict.keys.contains("Mobile") {
                    self.mobile = dict["Mobile"] as! String
                }
                if dict.keys.contains("OutboundScenario") {
                    self.outboundScenario = dict["OutboundScenario"] as! Bool
                }
                if dict.keys.contains("Reserved") {
                    self.reserved = dict["Reserved"] as! Int64
                }
                if dict.keys.contains("SignedSkillGroupIdList") {
                    self.signedSkillGroupIdList = dict["SignedSkillGroupIdList"] as! [String]
                }
                if dict.keys.contains("UserId") {
                    self.userId = dict["UserId"] as! String
                }
                if dict.keys.contains("UserState") {
                    self.userState = dict["UserState"] as! String
                }
                if dict.keys.contains("WorkMode") {
                    self.workMode = dict["WorkMode"] as! String
                }
            }
        }
        public var chatContexts: [ClaimChatResponseBody.Data.ChatContexts]?

        public var contextId: Int64?

        public var userContext: ClaimChatResponseBody.Data.UserContext?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.userContext?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.chatContexts != nil {
                var tmp : [Any] = []
                for k in self.chatContexts! {
                    tmp.append(k.toMap())
                }
                map["ChatContexts"] = tmp
            }
            if self.contextId != nil {
                map["ContextId"] = self.contextId!
            }
            if self.userContext != nil {
                map["UserContext"] = self.userContext?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ChatContexts") {
                var tmp : [ClaimChatResponseBody.Data.ChatContexts] = []
                for v in dict["ChatContexts"] as! [Any] {
                    var model = ClaimChatResponseBody.Data.ChatContexts()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.chatContexts = tmp
            }
            if dict.keys.contains("ContextId") {
                self.contextId = dict["ContextId"] as! Int64
            }
            if dict.keys.contains("UserContext") {
                var model = ClaimChatResponseBody.Data.UserContext()
                model.fromMap(dict["UserContext"] as! [String: Any])
                self.userContext = model
            }
        }
    }
    public var code: String?

    public var data: ClaimChatResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var params: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.params != nil {
            map["Params"] = self.params!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = ClaimChatResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Params") {
            self.params = dict["Params"] as! [String]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ClaimChatResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ClaimChatResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ClaimChatResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CoachCallRequest : Tea.TeaModel {
    public var coachedUserId: String?

    public var deviceId: String?

    public var instanceId: String?

    public var jobId: String?

    public var timeoutSeconds: Int32?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.coachedUserId != nil {
            map["CoachedUserId"] = self.coachedUserId!
        }
        if self.deviceId != nil {
            map["DeviceId"] = self.deviceId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.timeoutSeconds != nil {
            map["TimeoutSeconds"] = self.timeoutSeconds!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CoachedUserId") {
            self.coachedUserId = dict["CoachedUserId"] as! String
        }
        if dict.keys.contains("DeviceId") {
            self.deviceId = dict["DeviceId"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("TimeoutSeconds") {
            self.timeoutSeconds = dict["TimeoutSeconds"] as! Int32
        }
        if dict.keys.contains("UserId") {
            self.userId = dict["UserId"] as! String
        }
    }
}

public class CoachCallResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class CallContext : Tea.TeaModel {
            public class ChannelContexts : Tea.TeaModel {
                public var callType: String?

                public var channelFlags: String?

                public var channelId: String?

                public var channelState: String?

                public var destination: String?

                public var index: Int32?

                public var jobId: String?

                public var originator: String?

                public var releaseInitiator: String?

                public var releaseReason: String?

                public var skillGroupId: String?

                public var timestamp: Int64?

                public var userExtension: String?

                public var userId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.callType != nil {
                        map["CallType"] = self.callType!
                    }
                    if self.channelFlags != nil {
                        map["ChannelFlags"] = self.channelFlags!
                    }
                    if self.channelId != nil {
                        map["ChannelId"] = self.channelId!
                    }
                    if self.channelState != nil {
                        map["ChannelState"] = self.channelState!
                    }
                    if self.destination != nil {
                        map["Destination"] = self.destination!
                    }
                    if self.index != nil {
                        map["Index"] = self.index!
                    }
                    if self.jobId != nil {
                        map["JobId"] = self.jobId!
                    }
                    if self.originator != nil {
                        map["Originator"] = self.originator!
                    }
                    if self.releaseInitiator != nil {
                        map["ReleaseInitiator"] = self.releaseInitiator!
                    }
                    if self.releaseReason != nil {
                        map["ReleaseReason"] = self.releaseReason!
                    }
                    if self.skillGroupId != nil {
                        map["SkillGroupId"] = self.skillGroupId!
                    }
                    if self.timestamp != nil {
                        map["Timestamp"] = self.timestamp!
                    }
                    if self.userExtension != nil {
                        map["UserExtension"] = self.userExtension!
                    }
                    if self.userId != nil {
                        map["UserId"] = self.userId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("CallType") {
                        self.callType = dict["CallType"] as! String
                    }
                    if dict.keys.contains("ChannelFlags") {
                        self.channelFlags = dict["ChannelFlags"] as! String
                    }
                    if dict.keys.contains("ChannelId") {
                        self.channelId = dict["ChannelId"] as! String
                    }
                    if dict.keys.contains("ChannelState") {
                        self.channelState = dict["ChannelState"] as! String
                    }
                    if dict.keys.contains("Destination") {
                        self.destination = dict["Destination"] as! String
                    }
                    if dict.keys.contains("Index") {
                        self.index = dict["Index"] as! Int32
                    }
                    if dict.keys.contains("JobId") {
                        self.jobId = dict["JobId"] as! String
                    }
                    if dict.keys.contains("Originator") {
                        self.originator = dict["Originator"] as! String
                    }
                    if dict.keys.contains("ReleaseInitiator") {
                        self.releaseInitiator = dict["ReleaseInitiator"] as! String
                    }
                    if dict.keys.contains("ReleaseReason") {
                        self.releaseReason = dict["ReleaseReason"] as! String
                    }
                    if dict.keys.contains("SkillGroupId") {
                        self.skillGroupId = dict["SkillGroupId"] as! String
                    }
                    if dict.keys.contains("Timestamp") {
                        self.timestamp = dict["Timestamp"] as! Int64
                    }
                    if dict.keys.contains("UserExtension") {
                        self.userExtension = dict["UserExtension"] as! String
                    }
                    if dict.keys.contains("UserId") {
                        self.userId = dict["UserId"] as! String
                    }
                }
            }
            public var callType: String?

            public var channelContexts: [CoachCallResponseBody.Data.CallContext.ChannelContexts]?

            public var instanceId: String?

            public var jobId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.callType != nil {
                    map["CallType"] = self.callType!
                }
                if self.channelContexts != nil {
                    var tmp : [Any] = []
                    for k in self.channelContexts! {
                        tmp.append(k.toMap())
                    }
                    map["ChannelContexts"] = tmp
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.jobId != nil {
                    map["JobId"] = self.jobId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CallType") {
                    self.callType = dict["CallType"] as! String
                }
                if dict.keys.contains("ChannelContexts") {
                    var tmp : [CoachCallResponseBody.Data.CallContext.ChannelContexts] = []
                    for v in dict["ChannelContexts"] as! [Any] {
                        var model = CoachCallResponseBody.Data.CallContext.ChannelContexts()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.channelContexts = tmp
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("JobId") {
                    self.jobId = dict["JobId"] as! String
                }
            }
        }
        public class UserContext : Tea.TeaModel {
            public var breakCode: String?

            public var deviceId: String?

            public var deviceState: String?

            public var extension_: String?

            public var heartbeat: Int64?

            public var instanceId: String?

            public var jobId: String?

            public var mobile: String?

            public var outboundScenario: Bool?

            public var reserved: Int64?

            public var signedSkillGroupIdList: [String]?

            public var userId: String?

            public var userState: String?

            public var workMode: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.breakCode != nil {
                    map["BreakCode"] = self.breakCode!
                }
                if self.deviceId != nil {
                    map["DeviceId"] = self.deviceId!
                }
                if self.deviceState != nil {
                    map["DeviceState"] = self.deviceState!
                }
                if self.extension_ != nil {
                    map["Extension"] = self.extension_!
                }
                if self.heartbeat != nil {
                    map["Heartbeat"] = self.heartbeat!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.jobId != nil {
                    map["JobId"] = self.jobId!
                }
                if self.mobile != nil {
                    map["Mobile"] = self.mobile!
                }
                if self.outboundScenario != nil {
                    map["OutboundScenario"] = self.outboundScenario!
                }
                if self.reserved != nil {
                    map["Reserved"] = self.reserved!
                }
                if self.signedSkillGroupIdList != nil {
                    map["SignedSkillGroupIdList"] = self.signedSkillGroupIdList!
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                if self.userState != nil {
                    map["UserState"] = self.userState!
                }
                if self.workMode != nil {
                    map["WorkMode"] = self.workMode!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BreakCode") {
                    self.breakCode = dict["BreakCode"] as! String
                }
                if dict.keys.contains("DeviceId") {
                    self.deviceId = dict["DeviceId"] as! String
                }
                if dict.keys.contains("DeviceState") {
                    self.deviceState = dict["DeviceState"] as! String
                }
                if dict.keys.contains("Extension") {
                    self.extension_ = dict["Extension"] as! String
                }
                if dict.keys.contains("Heartbeat") {
                    self.heartbeat = dict["Heartbeat"] as! Int64
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("JobId") {
                    self.jobId = dict["JobId"] as! String
                }
                if dict.keys.contains("Mobile") {
                    self.mobile = dict["Mobile"] as! String
                }
                if dict.keys.contains("OutboundScenario") {
                    self.outboundScenario = dict["OutboundScenario"] as! Bool
                }
                if dict.keys.contains("Reserved") {
                    self.reserved = dict["Reserved"] as! Int64
                }
                if dict.keys.contains("SignedSkillGroupIdList") {
                    self.signedSkillGroupIdList = dict["SignedSkillGroupIdList"] as! [String]
                }
                if dict.keys.contains("UserId") {
                    self.userId = dict["UserId"] as! String
                }
                if dict.keys.contains("UserState") {
                    self.userState = dict["UserState"] as! String
                }
                if dict.keys.contains("WorkMode") {
                    self.workMode = dict["WorkMode"] as! String
                }
            }
        }
        public var callContext: CoachCallResponseBody.Data.CallContext?

        public var userContext: CoachCallResponseBody.Data.UserContext?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.callContext?.validate()
            try self.userContext?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.callContext != nil {
                map["CallContext"] = self.callContext?.toMap()
            }
            if self.userContext != nil {
                map["UserContext"] = self.userContext?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CallContext") {
                var model = CoachCallResponseBody.Data.CallContext()
                model.fromMap(dict["CallContext"] as! [String: Any])
                self.callContext = model
            }
            if dict.keys.contains("UserContext") {
                var model = CoachCallResponseBody.Data.UserContext()
                model.fromMap(dict["UserContext"] as! [String: Any])
                self.userContext = model
            }
        }
    }
    public var code: String?

    public var data: CoachCallResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var params: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.params != nil {
            map["Params"] = self.params!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = CoachCallResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Params") {
            self.params = dict["Params"] as! [String]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CoachCallResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CoachCallResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CoachCallResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CommitContactFlowRequest : Tea.TeaModel {
    public var contactFlowId: String?

    public var definition: String?

    public var description_: String?

    public var draftId: String?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.contactFlowId != nil {
            map["ContactFlowId"] = self.contactFlowId!
        }
        if self.definition != nil {
            map["Definition"] = self.definition!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.draftId != nil {
            map["DraftId"] = self.draftId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ContactFlowId") {
            self.contactFlowId = dict["ContactFlowId"] as! String
        }
        if dict.keys.contains("Definition") {
            self.definition = dict["Definition"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("DraftId") {
            self.draftId = dict["DraftId"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
    }
}

public class CommitContactFlowResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CommitContactFlowResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CommitContactFlowResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CommitContactFlowResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CompleteAttendedTransferRequest : Tea.TeaModel {
    public var deviceId: String?

    public var instanceId: String?

    public var jobId: String?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.deviceId != nil {
            map["DeviceId"] = self.deviceId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DeviceId") {
            self.deviceId = dict["DeviceId"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("UserId") {
            self.userId = dict["UserId"] as! String
        }
    }
}

public class CompleteAttendedTransferResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class CallContext : Tea.TeaModel {
            public class ChannelContexts : Tea.TeaModel {
                public var callType: String?

                public var channelFlags: String?

                public var channelId: String?

                public var channelState: String?

                public var destination: String?

                public var index: Int32?

                public var jobId: String?

                public var originator: String?

                public var releaseInitiator: String?

                public var releaseReason: String?

                public var skillGroupId: String?

                public var timestamp: Int64?

                public var userExtension: String?

                public var userId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.callType != nil {
                        map["CallType"] = self.callType!
                    }
                    if self.channelFlags != nil {
                        map["ChannelFlags"] = self.channelFlags!
                    }
                    if self.channelId != nil {
                        map["ChannelId"] = self.channelId!
                    }
                    if self.channelState != nil {
                        map["ChannelState"] = self.channelState!
                    }
                    if self.destination != nil {
                        map["Destination"] = self.destination!
                    }
                    if self.index != nil {
                        map["Index"] = self.index!
                    }
                    if self.jobId != nil {
                        map["JobId"] = self.jobId!
                    }
                    if self.originator != nil {
                        map["Originator"] = self.originator!
                    }
                    if self.releaseInitiator != nil {
                        map["ReleaseInitiator"] = self.releaseInitiator!
                    }
                    if self.releaseReason != nil {
                        map["ReleaseReason"] = self.releaseReason!
                    }
                    if self.skillGroupId != nil {
                        map["SkillGroupId"] = self.skillGroupId!
                    }
                    if self.timestamp != nil {
                        map["Timestamp"] = self.timestamp!
                    }
                    if self.userExtension != nil {
                        map["UserExtension"] = self.userExtension!
                    }
                    if self.userId != nil {
                        map["UserId"] = self.userId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("CallType") {
                        self.callType = dict["CallType"] as! String
                    }
                    if dict.keys.contains("ChannelFlags") {
                        self.channelFlags = dict["ChannelFlags"] as! String
                    }
                    if dict.keys.contains("ChannelId") {
                        self.channelId = dict["ChannelId"] as! String
                    }
                    if dict.keys.contains("ChannelState") {
                        self.channelState = dict["ChannelState"] as! String
                    }
                    if dict.keys.contains("Destination") {
                        self.destination = dict["Destination"] as! String
                    }
                    if dict.keys.contains("Index") {
                        self.index = dict["Index"] as! Int32
                    }
                    if dict.keys.contains("JobId") {
                        self.jobId = dict["JobId"] as! String
                    }
                    if dict.keys.contains("Originator") {
                        self.originator = dict["Originator"] as! String
                    }
                    if dict.keys.contains("ReleaseInitiator") {
                        self.releaseInitiator = dict["ReleaseInitiator"] as! String
                    }
                    if dict.keys.contains("ReleaseReason") {
                        self.releaseReason = dict["ReleaseReason"] as! String
                    }
                    if dict.keys.contains("SkillGroupId") {
                        self.skillGroupId = dict["SkillGroupId"] as! String
                    }
                    if dict.keys.contains("Timestamp") {
                        self.timestamp = dict["Timestamp"] as! Int64
                    }
                    if dict.keys.contains("UserExtension") {
                        self.userExtension = dict["UserExtension"] as! String
                    }
                    if dict.keys.contains("UserId") {
                        self.userId = dict["UserId"] as! String
                    }
                }
            }
            public var callType: String?

            public var channelContexts: [CompleteAttendedTransferResponseBody.Data.CallContext.ChannelContexts]?

            public var instanceId: String?

            public var jobId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.callType != nil {
                    map["CallType"] = self.callType!
                }
                if self.channelContexts != nil {
                    var tmp : [Any] = []
                    for k in self.channelContexts! {
                        tmp.append(k.toMap())
                    }
                    map["ChannelContexts"] = tmp
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.jobId != nil {
                    map["JobId"] = self.jobId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CallType") {
                    self.callType = dict["CallType"] as! String
                }
                if dict.keys.contains("ChannelContexts") {
                    var tmp : [CompleteAttendedTransferResponseBody.Data.CallContext.ChannelContexts] = []
                    for v in dict["ChannelContexts"] as! [Any] {
                        var model = CompleteAttendedTransferResponseBody.Data.CallContext.ChannelContexts()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.channelContexts = tmp
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("JobId") {
                    self.jobId = dict["JobId"] as! String
                }
            }
        }
        public class UserContext : Tea.TeaModel {
            public var breakCode: String?

            public var deviceId: String?

            public var extension_: String?

            public var heartbeat: Int64?

            public var instanceId: String?

            public var jobId: String?

            public var mobile: String?

            public var outboundScenario: Bool?

            public var reserved: Int64?

            public var signedSkillGroupIdList: [String]?

            public var userId: String?

            public var userState: String?

            public var workMode: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.breakCode != nil {
                    map["BreakCode"] = self.breakCode!
                }
                if self.deviceId != nil {
                    map["DeviceId"] = self.deviceId!
                }
                if self.extension_ != nil {
                    map["Extension"] = self.extension_!
                }
                if self.heartbeat != nil {
                    map["Heartbeat"] = self.heartbeat!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.jobId != nil {
                    map["JobId"] = self.jobId!
                }
                if self.mobile != nil {
                    map["Mobile"] = self.mobile!
                }
                if self.outboundScenario != nil {
                    map["OutboundScenario"] = self.outboundScenario!
                }
                if self.reserved != nil {
                    map["Reserved"] = self.reserved!
                }
                if self.signedSkillGroupIdList != nil {
                    map["SignedSkillGroupIdList"] = self.signedSkillGroupIdList!
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                if self.userState != nil {
                    map["UserState"] = self.userState!
                }
                if self.workMode != nil {
                    map["WorkMode"] = self.workMode!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BreakCode") {
                    self.breakCode = dict["BreakCode"] as! String
                }
                if dict.keys.contains("DeviceId") {
                    self.deviceId = dict["DeviceId"] as! String
                }
                if dict.keys.contains("Extension") {
                    self.extension_ = dict["Extension"] as! String
                }
                if dict.keys.contains("Heartbeat") {
                    self.heartbeat = dict["Heartbeat"] as! Int64
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("JobId") {
                    self.jobId = dict["JobId"] as! String
                }
                if dict.keys.contains("Mobile") {
                    self.mobile = dict["Mobile"] as! String
                }
                if dict.keys.contains("OutboundScenario") {
                    self.outboundScenario = dict["OutboundScenario"] as! Bool
                }
                if dict.keys.contains("Reserved") {
                    self.reserved = dict["Reserved"] as! Int64
                }
                if dict.keys.contains("SignedSkillGroupIdList") {
                    self.signedSkillGroupIdList = dict["SignedSkillGroupIdList"] as! [String]
                }
                if dict.keys.contains("UserId") {
                    self.userId = dict["UserId"] as! String
                }
                if dict.keys.contains("UserState") {
                    self.userState = dict["UserState"] as! String
                }
                if dict.keys.contains("WorkMode") {
                    self.workMode = dict["WorkMode"] as! String
                }
            }
        }
        public var callContext: CompleteAttendedTransferResponseBody.Data.CallContext?

        public var contextId: Int64?

        public var userContext: CompleteAttendedTransferResponseBody.Data.UserContext?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.callContext?.validate()
            try self.userContext?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.callContext != nil {
                map["CallContext"] = self.callContext?.toMap()
            }
            if self.contextId != nil {
                map["ContextId"] = self.contextId!
            }
            if self.userContext != nil {
                map["UserContext"] = self.userContext?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CallContext") {
                var model = CompleteAttendedTransferResponseBody.Data.CallContext()
                model.fromMap(dict["CallContext"] as! [String: Any])
                self.callContext = model
            }
            if dict.keys.contains("ContextId") {
                self.contextId = dict["ContextId"] as! Int64
            }
            if dict.keys.contains("UserContext") {
                var model = CompleteAttendedTransferResponseBody.Data.UserContext()
                model.fromMap(dict["UserContext"] as! [String: Any])
                self.userContext = model
            }
        }
    }
    public var code: String?

    public var data: CompleteAttendedTransferResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var params: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.params != nil {
            map["Params"] = self.params!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = CompleteAttendedTransferResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Params") {
            self.params = dict["Params"] as! [String]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CompleteAttendedTransferResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CompleteAttendedTransferResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CompleteAttendedTransferResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateAudioFileRequest : Tea.TeaModel {
    public var audioFileName: String?

    public var instanceId: String?

    public var name: String?

    public var ossFileKey: String?

    public var usage: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.audioFileName != nil {
            map["AudioFileName"] = self.audioFileName!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.ossFileKey != nil {
            map["OssFileKey"] = self.ossFileKey!
        }
        if self.usage != nil {
            map["Usage"] = self.usage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AudioFileName") {
            self.audioFileName = dict["AudioFileName"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("OssFileKey") {
            self.ossFileKey = dict["OssFileKey"] as! String
        }
        if dict.keys.contains("Usage") {
            self.usage = dict["Usage"] as! String
        }
    }
}

public class CreateAudioFileResponseBody : Tea.TeaModel {
    public var code: String?

    public var data: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateAudioFileResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateAudioFileResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateAudioFileResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateCallTagsRequest : Tea.TeaModel {
    public var callTagNameList: String?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.callTagNameList != nil {
            map["CallTagNameList"] = self.callTagNameList!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CallTagNameList") {
            self.callTagNameList = dict["CallTagNameList"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
    }
}

public class CreateCallTagsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var item: String?

        public var reason: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.item != nil {
                map["Item"] = self.item!
            }
            if self.reason != nil {
                map["Reason"] = self.reason!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Item") {
                self.item = dict["Item"] as! String
            }
            if dict.keys.contains("Reason") {
                self.reason = dict["Reason"] as! String
            }
        }
    }
    public var code: String?

    public var data: [CreateCallTagsResponseBody.Data]?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var tmp : [CreateCallTagsResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = CreateCallTagsResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateCallTagsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateCallTagsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateCallTagsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateCampaignRequest : Tea.TeaModel {
    public class CaseList : Tea.TeaModel {
        public var customVariables: String?

        public var phoneNumber: String?

        public var referenceId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.customVariables != nil {
                map["CustomVariables"] = self.customVariables!
            }
            if self.phoneNumber != nil {
                map["PhoneNumber"] = self.phoneNumber!
            }
            if self.referenceId != nil {
                map["ReferenceId"] = self.referenceId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CustomVariables") {
                self.customVariables = dict["CustomVariables"] as! String
            }
            if dict.keys.contains("PhoneNumber") {
                self.phoneNumber = dict["PhoneNumber"] as! String
            }
            if dict.keys.contains("ReferenceId") {
                self.referenceId = dict["ReferenceId"] as! String
            }
        }
    }
    public var callableTime: String?

    public var caseFileKey: String?

    public var caseList: [CreateCampaignRequest.CaseList]?

    public var contactFlowId: String?

    public var endTime: String?

    public var executingUntilTimeout: Bool?

    public var instanceId: String?

    public var maxAttemptCount: Int64?

    public var minAttemptInterval: Int64?

    public var name: String?

    public var queueId: String?

    public var simulation: Bool?

    public var simulationParameters: String?

    public var startTime: String?

    public var strategyParameters: String?

    public var strategyType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.callableTime != nil {
            map["CallableTime"] = self.callableTime!
        }
        if self.caseFileKey != nil {
            map["CaseFileKey"] = self.caseFileKey!
        }
        if self.caseList != nil {
            var tmp : [Any] = []
            for k in self.caseList! {
                tmp.append(k.toMap())
            }
            map["CaseList"] = tmp
        }
        if self.contactFlowId != nil {
            map["ContactFlowId"] = self.contactFlowId!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.executingUntilTimeout != nil {
            map["ExecutingUntilTimeout"] = self.executingUntilTimeout!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.maxAttemptCount != nil {
            map["MaxAttemptCount"] = self.maxAttemptCount!
        }
        if self.minAttemptInterval != nil {
            map["MinAttemptInterval"] = self.minAttemptInterval!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.queueId != nil {
            map["QueueId"] = self.queueId!
        }
        if self.simulation != nil {
            map["Simulation"] = self.simulation!
        }
        if self.simulationParameters != nil {
            map["SimulationParameters"] = self.simulationParameters!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.strategyParameters != nil {
            map["StrategyParameters"] = self.strategyParameters!
        }
        if self.strategyType != nil {
            map["StrategyType"] = self.strategyType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CallableTime") {
            self.callableTime = dict["CallableTime"] as! String
        }
        if dict.keys.contains("CaseFileKey") {
            self.caseFileKey = dict["CaseFileKey"] as! String
        }
        if dict.keys.contains("CaseList") {
            var tmp : [CreateCampaignRequest.CaseList] = []
            for v in dict["CaseList"] as! [Any] {
                var model = CreateCampaignRequest.CaseList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.caseList = tmp
        }
        if dict.keys.contains("ContactFlowId") {
            self.contactFlowId = dict["ContactFlowId"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("ExecutingUntilTimeout") {
            self.executingUntilTimeout = dict["ExecutingUntilTimeout"] as! Bool
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("MaxAttemptCount") {
            self.maxAttemptCount = dict["MaxAttemptCount"] as! Int64
        }
        if dict.keys.contains("MinAttemptInterval") {
            self.minAttemptInterval = dict["MinAttemptInterval"] as! Int64
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("QueueId") {
            self.queueId = dict["QueueId"] as! String
        }
        if dict.keys.contains("Simulation") {
            self.simulation = dict["Simulation"] as! Bool
        }
        if dict.keys.contains("SimulationParameters") {
            self.simulationParameters = dict["SimulationParameters"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
        if dict.keys.contains("StrategyParameters") {
            self.strategyParameters = dict["StrategyParameters"] as! String
        }
        if dict.keys.contains("StrategyType") {
            self.strategyType = dict["StrategyType"] as! String
        }
    }
}

public class CreateCampaignShrinkRequest : Tea.TeaModel {
    public var callableTime: String?

    public var caseFileKey: String?

    public var caseListShrink: String?

    public var contactFlowId: String?

    public var endTime: String?

    public var executingUntilTimeout: Bool?

    public var instanceId: String?

    public var maxAttemptCount: Int64?

    public var minAttemptInterval: Int64?

    public var name: String?

    public var queueId: String?

    public var simulation: Bool?

    public var simulationParameters: String?

    public var startTime: String?

    public var strategyParameters: String?

    public var strategyType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.callableTime != nil {
            map["CallableTime"] = self.callableTime!
        }
        if self.caseFileKey != nil {
            map["CaseFileKey"] = self.caseFileKey!
        }
        if self.caseListShrink != nil {
            map["CaseList"] = self.caseListShrink!
        }
        if self.contactFlowId != nil {
            map["ContactFlowId"] = self.contactFlowId!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.executingUntilTimeout != nil {
            map["ExecutingUntilTimeout"] = self.executingUntilTimeout!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.maxAttemptCount != nil {
            map["MaxAttemptCount"] = self.maxAttemptCount!
        }
        if self.minAttemptInterval != nil {
            map["MinAttemptInterval"] = self.minAttemptInterval!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.queueId != nil {
            map["QueueId"] = self.queueId!
        }
        if self.simulation != nil {
            map["Simulation"] = self.simulation!
        }
        if self.simulationParameters != nil {
            map["SimulationParameters"] = self.simulationParameters!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.strategyParameters != nil {
            map["StrategyParameters"] = self.strategyParameters!
        }
        if self.strategyType != nil {
            map["StrategyType"] = self.strategyType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CallableTime") {
            self.callableTime = dict["CallableTime"] as! String
        }
        if dict.keys.contains("CaseFileKey") {
            self.caseFileKey = dict["CaseFileKey"] as! String
        }
        if dict.keys.contains("CaseList") {
            self.caseListShrink = dict["CaseList"] as! String
        }
        if dict.keys.contains("ContactFlowId") {
            self.contactFlowId = dict["ContactFlowId"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("ExecutingUntilTimeout") {
            self.executingUntilTimeout = dict["ExecutingUntilTimeout"] as! Bool
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("MaxAttemptCount") {
            self.maxAttemptCount = dict["MaxAttemptCount"] as! Int64
        }
        if dict.keys.contains("MinAttemptInterval") {
            self.minAttemptInterval = dict["MinAttemptInterval"] as! Int64
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("QueueId") {
            self.queueId = dict["QueueId"] as! String
        }
        if dict.keys.contains("Simulation") {
            self.simulation = dict["Simulation"] as! Bool
        }
        if dict.keys.contains("SimulationParameters") {
            self.simulationParameters = dict["SimulationParameters"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
        if dict.keys.contains("StrategyParameters") {
            self.strategyParameters = dict["StrategyParameters"] as! String
        }
        if dict.keys.contains("StrategyType") {
            self.strategyType = dict["StrategyType"] as! String
        }
    }
}

public class CreateCampaignResponseBody : Tea.TeaModel {
    public var code: String?

    public var data: String?

    public var httpStatusCode: Int64?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int64
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateCampaignResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateCampaignResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateCampaignResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateContactFlowRequest : Tea.TeaModel {
    public var definition: String?

    public var description_: String?

    public var instanceId: String?

    public var name: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.definition != nil {
            map["Definition"] = self.definition!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Definition") {
            self.definition = dict["Definition"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
    }
}

public class CreateContactFlowResponseBody : Tea.TeaModel {
    public var code: String?

    public var data: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateContactFlowResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateContactFlowResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateContactFlowResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateCustomCallTaggingRequest : Tea.TeaModel {
    public var customNumberList: String?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.customNumberList != nil {
            map["CustomNumberList"] = self.customNumberList!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CustomNumberList") {
            self.customNumberList = dict["CustomNumberList"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
    }
}

public class CreateCustomCallTaggingResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var item: String?

        public var reason: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.item != nil {
                map["Item"] = self.item!
            }
            if self.reason != nil {
                map["Reason"] = self.reason!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Item") {
                self.item = dict["Item"] as! String
            }
            if dict.keys.contains("Reason") {
                self.reason = dict["Reason"] as! String
            }
        }
    }
    public var code: String?

    public var data: [CreateCustomCallTaggingResponseBody.Data]?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var tmp : [CreateCustomCallTaggingResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = CreateCustomCallTaggingResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateCustomCallTaggingResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateCustomCallTaggingResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateCustomCallTaggingResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateInstanceRequest : Tea.TeaModel {
    public var adminRamIdList: String?

    public var description_: String?

    public var domainName: String?

    public var name: String?

    public var numberList: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.adminRamIdList != nil {
            map["AdminRamIdList"] = self.adminRamIdList!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.numberList != nil {
            map["NumberList"] = self.numberList!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AdminRamIdList") {
            self.adminRamIdList = dict["AdminRamIdList"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("DomainName") {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("NumberList") {
            self.numberList = dict["NumberList"] as! String
        }
    }
}

public class CreateInstanceResponseBody : Tea.TeaModel {
    public var code: String?

    public var data: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateSchemaRequest : Tea.TeaModel {
    public class Properties : Tea.TeaModel {
        public var array: Bool?

        public var attributes: String?

        public var dataType: String?

        public var description_: String?

        public var disabled: Bool?

        public var displayName: String?

        public var displayOrder: Int32?

        public var editorType: String?

        public var maxLength: Int32?

        public var maximum: Double?

        public var minLength: Int32?

        public var minimum: Double?

        public var name: String?

        public var pattern: String?

        public var patternErrorMessage: String?

        public var readOnly: Bool?

        public var required_: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.array != nil {
                map["Array"] = self.array!
            }
            if self.attributes != nil {
                map["Attributes"] = self.attributes!
            }
            if self.dataType != nil {
                map["DataType"] = self.dataType!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.disabled != nil {
                map["Disabled"] = self.disabled!
            }
            if self.displayName != nil {
                map["DisplayName"] = self.displayName!
            }
            if self.displayOrder != nil {
                map["DisplayOrder"] = self.displayOrder!
            }
            if self.editorType != nil {
                map["EditorType"] = self.editorType!
            }
            if self.maxLength != nil {
                map["MaxLength"] = self.maxLength!
            }
            if self.maximum != nil {
                map["Maximum"] = self.maximum!
            }
            if self.minLength != nil {
                map["MinLength"] = self.minLength!
            }
            if self.minimum != nil {
                map["Minimum"] = self.minimum!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.pattern != nil {
                map["Pattern"] = self.pattern!
            }
            if self.patternErrorMessage != nil {
                map["PatternErrorMessage"] = self.patternErrorMessage!
            }
            if self.readOnly != nil {
                map["ReadOnly"] = self.readOnly!
            }
            if self.required_ != nil {
                map["Required"] = self.required_!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Array") {
                self.array = dict["Array"] as! Bool
            }
            if dict.keys.contains("Attributes") {
                self.attributes = dict["Attributes"] as! String
            }
            if dict.keys.contains("DataType") {
                self.dataType = dict["DataType"] as! String
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("Disabled") {
                self.disabled = dict["Disabled"] as! Bool
            }
            if dict.keys.contains("DisplayName") {
                self.displayName = dict["DisplayName"] as! String
            }
            if dict.keys.contains("DisplayOrder") {
                self.displayOrder = dict["DisplayOrder"] as! Int32
            }
            if dict.keys.contains("EditorType") {
                self.editorType = dict["EditorType"] as! String
            }
            if dict.keys.contains("MaxLength") {
                self.maxLength = dict["MaxLength"] as! Int32
            }
            if dict.keys.contains("Maximum") {
                self.maximum = dict["Maximum"] as! Double
            }
            if dict.keys.contains("MinLength") {
                self.minLength = dict["MinLength"] as! Int32
            }
            if dict.keys.contains("Minimum") {
                self.minimum = dict["Minimum"] as! Double
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Pattern") {
                self.pattern = dict["Pattern"] as! String
            }
            if dict.keys.contains("PatternErrorMessage") {
                self.patternErrorMessage = dict["PatternErrorMessage"] as! String
            }
            if dict.keys.contains("ReadOnly") {
                self.readOnly = dict["ReadOnly"] as! Bool
            }
            if dict.keys.contains("Required") {
                self.required_ = dict["Required"] as! Bool
            }
        }
    }
    public var description_: String?

    public var id: String?

    public var instanceId: String?

    public var properties: [CreateSchemaRequest.Properties]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.properties != nil {
            var tmp : [Any] = []
            for k in self.properties! {
                tmp.append(k.toMap())
            }
            map["Properties"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Properties") {
            var tmp : [CreateSchemaRequest.Properties] = []
            for v in dict["Properties"] as! [Any] {
                var model = CreateSchemaRequest.Properties()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.properties = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateSchemaShrinkRequest : Tea.TeaModel {
    public var description_: String?

    public var id: String?

    public var instanceId: String?

    public var propertiesShrink: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.propertiesShrink != nil {
            map["Properties"] = self.propertiesShrink!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("Id") {
            self.id = dict["Id"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Properties") {
            self.propertiesShrink = dict["Properties"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateSchemaResponseBody : Tea.TeaModel {
    public var code: String?

    public var data: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var params: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.params != nil {
            map["Params"] = self.params!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Params") {
            self.params = dict["Params"] as! [String]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateSchemaResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateSchemaResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateSchemaResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateSkillGroupRequest : Tea.TeaModel {
    public var description_: String?

    public var displayName: String?

    public var instanceId: String?

    public var mediaType: String?

    public var name: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.displayName != nil {
            map["DisplayName"] = self.displayName!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.mediaType != nil {
            map["MediaType"] = self.mediaType!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("DisplayName") {
            self.displayName = dict["DisplayName"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("MediaType") {
            self.mediaType = dict["MediaType"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
    }
}

public class CreateSkillGroupResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var description_: String?

        public var instanceId: String?

        public var mediaType: String?

        public var name: String?

        public var skillGroupId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.mediaType != nil {
                map["MediaType"] = self.mediaType!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.skillGroupId != nil {
                map["SkillGroupId"] = self.skillGroupId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("InstanceId") {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("MediaType") {
                self.mediaType = dict["MediaType"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("SkillGroupId") {
                self.skillGroupId = dict["SkillGroupId"] as! String
            }
        }
    }
    public var code: String?

    public var data: CreateSkillGroupResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = CreateSkillGroupResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateSkillGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateSkillGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateSkillGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateTicketRequest : Tea.TeaModel {
    public var contactId: String?

    public var context: String?

    public var customerId: String?

    public var instanceId: String?

    public var source: String?

    public var templateId: String?

    public var title: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.contactId != nil {
            map["ContactId"] = self.contactId!
        }
        if self.context != nil {
            map["Context"] = self.context!
        }
        if self.customerId != nil {
            map["CustomerId"] = self.customerId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.source != nil {
            map["Source"] = self.source!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        if self.title != nil {
            map["Title"] = self.title!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ContactId") {
            self.contactId = dict["ContactId"] as! String
        }
        if dict.keys.contains("Context") {
            self.context = dict["Context"] as! String
        }
        if dict.keys.contains("CustomerId") {
            self.customerId = dict["CustomerId"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Source") {
            self.source = dict["Source"] as! String
        }
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
        if dict.keys.contains("Title") {
            self.title = dict["Title"] as! String
        }
    }
}

public class CreateTicketResponseBody : Tea.TeaModel {
    public var code: String?

    public var data: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateTicketResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateTicketResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateTicketResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateUserRequest : Tea.TeaModel {
    public var avatarUrl: String?

    public var displayId: String?

    public var displayName: String?

    public var email: String?

    public var instanceId: String?

    public var loginName: String?

    public var mobile: String?

    public var nickname: String?

    public var resetPassword: Bool?

    public var roleId: String?

    public var skillLevelList: String?

    public var workMode: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.avatarUrl != nil {
            map["AvatarUrl"] = self.avatarUrl!
        }
        if self.displayId != nil {
            map["DisplayId"] = self.displayId!
        }
        if self.displayName != nil {
            map["DisplayName"] = self.displayName!
        }
        if self.email != nil {
            map["Email"] = self.email!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.loginName != nil {
            map["LoginName"] = self.loginName!
        }
        if self.mobile != nil {
            map["Mobile"] = self.mobile!
        }
        if self.nickname != nil {
            map["Nickname"] = self.nickname!
        }
        if self.resetPassword != nil {
            map["ResetPassword"] = self.resetPassword!
        }
        if self.roleId != nil {
            map["RoleId"] = self.roleId!
        }
        if self.skillLevelList != nil {
            map["SkillLevelList"] = self.skillLevelList!
        }
        if self.workMode != nil {
            map["WorkMode"] = self.workMode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AvatarUrl") {
            self.avatarUrl = dict["AvatarUrl"] as! String
        }
        if dict.keys.contains("DisplayId") {
            self.displayId = dict["DisplayId"] as! String
        }
        if dict.keys.contains("DisplayName") {
            self.displayName = dict["DisplayName"] as! String
        }
        if dict.keys.contains("Email") {
            self.email = dict["Email"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("LoginName") {
            self.loginName = dict["LoginName"] as! String
        }
        if dict.keys.contains("Mobile") {
            self.mobile = dict["Mobile"] as! String
        }
        if dict.keys.contains("Nickname") {
            self.nickname = dict["Nickname"] as! String
        }
        if dict.keys.contains("ResetPassword") {
            self.resetPassword = dict["ResetPassword"] as! Bool
        }
        if dict.keys.contains("RoleId") {
            self.roleId = dict["RoleId"] as! String
        }
        if dict.keys.contains("SkillLevelList") {
            self.skillLevelList = dict["SkillLevelList"] as! String
        }
        if dict.keys.contains("WorkMode") {
            self.workMode = dict["WorkMode"] as! String
        }
    }
}

public class CreateUserResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var avatarUrl: String?

        public var displayName: String?

        public var email: String?

        public var extension_: String?

        public var loginName: String?

        public var mobile: String?

        public var nickname: String?

        public var userId: String?

        public var workMode: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.avatarUrl != nil {
                map["AvatarUrl"] = self.avatarUrl!
            }
            if self.displayName != nil {
                map["DisplayName"] = self.displayName!
            }
            if self.email != nil {
                map["Email"] = self.email!
            }
            if self.extension_ != nil {
                map["Extension"] = self.extension_!
            }
            if self.loginName != nil {
                map["LoginName"] = self.loginName!
            }
            if self.mobile != nil {
                map["Mobile"] = self.mobile!
            }
            if self.nickname != nil {
                map["Nickname"] = self.nickname!
            }
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            if self.workMode != nil {
                map["WorkMode"] = self.workMode!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AvatarUrl") {
                self.avatarUrl = dict["AvatarUrl"] as! String
            }
            if dict.keys.contains("DisplayName") {
                self.displayName = dict["DisplayName"] as! String
            }
            if dict.keys.contains("Email") {
                self.email = dict["Email"] as! String
            }
            if dict.keys.contains("Extension") {
                self.extension_ = dict["Extension"] as! String
            }
            if dict.keys.contains("LoginName") {
                self.loginName = dict["LoginName"] as! String
            }
            if dict.keys.contains("Mobile") {
                self.mobile = dict["Mobile"] as! String
            }
            if dict.keys.contains("Nickname") {
                self.nickname = dict["Nickname"] as! String
            }
            if dict.keys.contains("UserId") {
                self.userId = dict["UserId"] as! String
            }
            if dict.keys.contains("WorkMode") {
                self.workMode = dict["WorkMode"] as! String
            }
        }
    }
    public var code: String?

    public var data: CreateUserResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var params: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.params != nil {
            map["Params"] = self.params!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = CreateUserResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Params") {
            self.params = dict["Params"] as! [String]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateUserResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateUserResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateUserResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteAudioFileRequest : Tea.TeaModel {
    public var audioResourceId: String?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.audioResourceId != nil {
            map["AudioResourceId"] = self.audioResourceId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AudioResourceId") {
            self.audioResourceId = dict["AudioResourceId"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
    }
}

public class DeleteAudioFileResponseBody : Tea.TeaModel {
    public var code: String?

    public var data: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteAudioFileResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteAudioFileResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteAudioFileResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteCallTagRequest : Tea.TeaModel {
    public var instanceId: String?

    public var tagName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.tagName != nil {
            map["TagName"] = self.tagName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("TagName") {
            self.tagName = dict["TagName"] as! String
        }
    }
}

public class DeleteCallTagResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteCallTagResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteCallTagResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteCallTagResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteContactFlowRequest : Tea.TeaModel {
    public var contactFlowId: String?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.contactFlowId != nil {
            map["ContactFlowId"] = self.contactFlowId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ContactFlowId") {
            self.contactFlowId = dict["ContactFlowId"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
    }
}

public class DeleteContactFlowResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteContactFlowResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteContactFlowResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteContactFlowResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteCustomCallTaggingRequest : Tea.TeaModel {
    public var instanceId: String?

    public var number: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.number != nil {
            map["Number"] = self.number!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Number") {
            self.number = dict["Number"] as! String
        }
    }
}

public class DeleteCustomCallTaggingResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteCustomCallTaggingResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteCustomCallTaggingResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteCustomCallTaggingResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteDocumentRequest : Tea.TeaModel {
    public var documentId: String?

    public var instanceId: String?

    public var requestId: String?

    public var schemaId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.documentId != nil {
            map["DocumentId"] = self.documentId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.schemaId != nil {
            map["SchemaId"] = self.schemaId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DocumentId") {
            self.documentId = dict["DocumentId"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SchemaId") {
            self.schemaId = dict["SchemaId"] as! String
        }
    }
}

public class DeleteDocumentResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var params: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.params != nil {
            map["Params"] = self.params!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Params") {
            self.params = dict["Params"] as! [String]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteDocumentResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteDocumentResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteDocumentResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteDocumentsRequest : Tea.TeaModel {
    public var documentIds: [String]?

    public var instanceId: String?

    public var requestId: String?

    public var schemaId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.documentIds != nil {
            map["DocumentIds"] = self.documentIds!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.schemaId != nil {
            map["SchemaId"] = self.schemaId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DocumentIds") {
            self.documentIds = dict["DocumentIds"] as! [String]
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SchemaId") {
            self.schemaId = dict["SchemaId"] as! String
        }
    }
}

public class DeleteDocumentsShrinkRequest : Tea.TeaModel {
    public var documentIdsShrink: String?

    public var instanceId: String?

    public var requestId: String?

    public var schemaId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.documentIdsShrink != nil {
            map["DocumentIds"] = self.documentIdsShrink!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.schemaId != nil {
            map["SchemaId"] = self.schemaId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DocumentIds") {
            self.documentIdsShrink = dict["DocumentIds"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SchemaId") {
            self.schemaId = dict["SchemaId"] as! String
        }
    }
}

public class DeleteDocumentsResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var params: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.params != nil {
            map["Params"] = self.params!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Params") {
            self.params = dict["Params"] as! [String]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteDocumentsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteDocumentsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteDocumentsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteSchemaRequest : Tea.TeaModel {
    public var instanceId: String?

    public var requestId: String?

    public var schemaId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.schemaId != nil {
            map["SchemaId"] = self.schemaId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SchemaId") {
            self.schemaId = dict["SchemaId"] as! String
        }
    }
}

public class DeleteSchemaResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var params: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.params != nil {
            map["Params"] = self.params!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Params") {
            self.params = dict["Params"] as! [String]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteSchemaResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteSchemaResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteSchemaResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteSchemaPropertyRequest : Tea.TeaModel {
    public var instanceId: String?

    public var propertyName: String?

    public var requestId: String?

    public var schemaId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.propertyName != nil {
            map["PropertyName"] = self.propertyName!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.schemaId != nil {
            map["SchemaId"] = self.schemaId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("PropertyName") {
            self.propertyName = dict["PropertyName"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SchemaId") {
            self.schemaId = dict["SchemaId"] as! String
        }
    }
}

public class DeleteSchemaPropertyResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var params: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.params != nil {
            map["Params"] = self.params!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Params") {
            self.params = dict["Params"] as! [String]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteSchemaPropertyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteSchemaPropertyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteSchemaPropertyResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteSkillGroupRequest : Tea.TeaModel {
    public var force: Bool?

    public var instanceId: String?

    public var skillGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.force != nil {
            map["Force"] = self.force!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.skillGroupId != nil {
            map["SkillGroupId"] = self.skillGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Force") {
            self.force = dict["Force"] as! Bool
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("SkillGroupId") {
            self.skillGroupId = dict["SkillGroupId"] as! String
        }
    }
}

public class DeleteSkillGroupResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteSkillGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteSkillGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteSkillGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteTicketRequest : Tea.TeaModel {
    public var instanceId: String?

    public var ticketId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.ticketId != nil {
            map["TicketId"] = self.ticketId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("TicketId") {
            self.ticketId = dict["TicketId"] as! String
        }
    }
}

public class DeleteTicketResponseBody : Tea.TeaModel {
    public var code: String?

    public var data: Any?

    public var httpStatusCode: Int32?

    public var message: String?

    public var params: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.params != nil {
            map["Params"] = self.params!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Any
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Params") {
            self.params = dict["Params"] as! [String]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteTicketResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteTicketResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteTicketResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteTicketTemplateRequest : Tea.TeaModel {
    public var instanceId: String?

    public var templateId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
    }
}

public class DeleteTicketTemplateResponseBody : Tea.TeaModel {
    public var code: String?

    public var data: Any?

    public var httpStatusCode: Int32?

    public var message: String?

    public var params: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.params != nil {
            map["Params"] = self.params!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Any
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Params") {
            self.params = dict["Params"] as! [String]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteTicketTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteTicketTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteTicketTemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DisableSchemaPropertyRequest : Tea.TeaModel {
    public var instanceId: String?

    public var propertyName: String?

    public var requestId: String?

    public var schemaId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.propertyName != nil {
            map["PropertyName"] = self.propertyName!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.schemaId != nil {
            map["SchemaId"] = self.schemaId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("PropertyName") {
            self.propertyName = dict["PropertyName"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SchemaId") {
            self.schemaId = dict["SchemaId"] as! String
        }
    }
}

public class DisableSchemaPropertyResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var params: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.params != nil {
            map["Params"] = self.params!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Params") {
            self.params = dict["Params"] as! [String]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DisableSchemaPropertyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DisableSchemaPropertyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DisableSchemaPropertyResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DisableTicketTemplateRequest : Tea.TeaModel {
    public var instanceId: String?

    public var templateId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
    }
}

public class DisableTicketTemplateResponseBody : Tea.TeaModel {
    public var code: String?

    public var data: Any?

    public var httpStatusCode: Int32?

    public var message: String?

    public var params: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.params != nil {
            map["Params"] = self.params!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Any
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Params") {
            self.params = dict["Params"] as! [String]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DisableTicketTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DisableTicketTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DisableTicketTemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DiscardEditingContactFlowRequest : Tea.TeaModel {
    public var contactFlowId: String?

    public var draftId: String?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.contactFlowId != nil {
            map["ContactFlowId"] = self.contactFlowId!
        }
        if self.draftId != nil {
            map["DraftId"] = self.draftId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ContactFlowId") {
            self.contactFlowId = dict["ContactFlowId"] as! String
        }
        if dict.keys.contains("DraftId") {
            self.draftId = dict["DraftId"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
    }
}

public class DiscardEditingContactFlowResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DiscardEditingContactFlowResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DiscardEditingContactFlowResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DiscardEditingContactFlowResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class EnableSchemaPropertyRequest : Tea.TeaModel {
    public var instanceId: String?

    public var propertyName: String?

    public var requestId: String?

    public var schemaId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.propertyName != nil {
            map["PropertyName"] = self.propertyName!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.schemaId != nil {
            map["SchemaId"] = self.schemaId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("PropertyName") {
            self.propertyName = dict["PropertyName"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SchemaId") {
            self.schemaId = dict["SchemaId"] as! String
        }
    }
}

public class EnableSchemaPropertyResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var params: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.params != nil {
            map["Params"] = self.params!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Params") {
            self.params = dict["Params"] as! [String]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class EnableSchemaPropertyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: EnableSchemaPropertyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = EnableSchemaPropertyResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class EnableTicketTemplateRequest : Tea.TeaModel {
    public var instanceId: String?

    public var templateId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
    }
}

public class EnableTicketTemplateResponseBody : Tea.TeaModel {
    public var code: String?

    public var data: Any?

    public var httpStatusCode: Int32?

    public var message: String?

    public var params: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.params != nil {
            map["Params"] = self.params!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Any
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Params") {
            self.params = dict["Params"] as! [String]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class EnableTicketTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: EnableTicketTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = EnableTicketTemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class EndConferenceRequest : Tea.TeaModel {
    public var instanceId: String?

    public var jobId: String?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("UserId") {
            self.userId = dict["UserId"] as! String
        }
    }
}

public class EndConferenceResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class CallContext : Tea.TeaModel {
            public class ChannelContexts : Tea.TeaModel {
                public var callType: String?

                public var channelId: String?

                public var channelState: String?

                public var destination: String?

                public var jobId: String?

                public var originator: String?

                public var releaseInitiator: String?

                public var releaseReason: String?

                public var timestamp: Int64?

                public var userExtension: String?

                public var userId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.callType != nil {
                        map["CallType"] = self.callType!
                    }
                    if self.channelId != nil {
                        map["ChannelId"] = self.channelId!
                    }
                    if self.channelState != nil {
                        map["ChannelState"] = self.channelState!
                    }
                    if self.destination != nil {
                        map["Destination"] = self.destination!
                    }
                    if self.jobId != nil {
                        map["JobId"] = self.jobId!
                    }
                    if self.originator != nil {
                        map["Originator"] = self.originator!
                    }
                    if self.releaseInitiator != nil {
                        map["ReleaseInitiator"] = self.releaseInitiator!
                    }
                    if self.releaseReason != nil {
                        map["ReleaseReason"] = self.releaseReason!
                    }
                    if self.timestamp != nil {
                        map["Timestamp"] = self.timestamp!
                    }
                    if self.userExtension != nil {
                        map["UserExtension"] = self.userExtension!
                    }
                    if self.userId != nil {
                        map["UserId"] = self.userId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("CallType") {
                        self.callType = dict["CallType"] as! String
                    }
                    if dict.keys.contains("ChannelId") {
                        self.channelId = dict["ChannelId"] as! String
                    }
                    if dict.keys.contains("ChannelState") {
                        self.channelState = dict["ChannelState"] as! String
                    }
                    if dict.keys.contains("Destination") {
                        self.destination = dict["Destination"] as! String
                    }
                    if dict.keys.contains("JobId") {
                        self.jobId = dict["JobId"] as! String
                    }
                    if dict.keys.contains("Originator") {
                        self.originator = dict["Originator"] as! String
                    }
                    if dict.keys.contains("ReleaseInitiator") {
                        self.releaseInitiator = dict["ReleaseInitiator"] as! String
                    }
                    if dict.keys.contains("ReleaseReason") {
                        self.releaseReason = dict["ReleaseReason"] as! String
                    }
                    if dict.keys.contains("Timestamp") {
                        self.timestamp = dict["Timestamp"] as! Int64
                    }
                    if dict.keys.contains("UserExtension") {
                        self.userExtension = dict["UserExtension"] as! String
                    }
                    if dict.keys.contains("UserId") {
                        self.userId = dict["UserId"] as! String
                    }
                }
            }
            public var channelContexts: [EndConferenceResponseBody.Data.CallContext.ChannelContexts]?

            public var instanceId: String?

            public var jobId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.channelContexts != nil {
                    var tmp : [Any] = []
                    for k in self.channelContexts! {
                        tmp.append(k.toMap())
                    }
                    map["ChannelContexts"] = tmp
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.jobId != nil {
                    map["JobId"] = self.jobId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ChannelContexts") {
                    var tmp : [EndConferenceResponseBody.Data.CallContext.ChannelContexts] = []
                    for v in dict["ChannelContexts"] as! [Any] {
                        var model = EndConferenceResponseBody.Data.CallContext.ChannelContexts()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.channelContexts = tmp
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("JobId") {
                    self.jobId = dict["JobId"] as! String
                }
            }
        }
        public class UserContext : Tea.TeaModel {
            public var breakCode: String?

            public var deviceId: String?

            public var deviceState: String?

            public var extension_: String?

            public var instanceId: String?

            public var jobId: String?

            public var outboundScenario: Bool?

            public var signedSkillGroupIdList: [String]?

            public var userId: String?

            public var userState: String?

            public var workMode: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.breakCode != nil {
                    map["BreakCode"] = self.breakCode!
                }
                if self.deviceId != nil {
                    map["DeviceId"] = self.deviceId!
                }
                if self.deviceState != nil {
                    map["DeviceState"] = self.deviceState!
                }
                if self.extension_ != nil {
                    map["Extension"] = self.extension_!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.jobId != nil {
                    map["JobId"] = self.jobId!
                }
                if self.outboundScenario != nil {
                    map["OutboundScenario"] = self.outboundScenario!
                }
                if self.signedSkillGroupIdList != nil {
                    map["SignedSkillGroupIdList"] = self.signedSkillGroupIdList!
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                if self.userState != nil {
                    map["UserState"] = self.userState!
                }
                if self.workMode != nil {
                    map["WorkMode"] = self.workMode!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BreakCode") {
                    self.breakCode = dict["BreakCode"] as! String
                }
                if dict.keys.contains("DeviceId") {
                    self.deviceId = dict["DeviceId"] as! String
                }
                if dict.keys.contains("DeviceState") {
                    self.deviceState = dict["DeviceState"] as! String
                }
                if dict.keys.contains("Extension") {
                    self.extension_ = dict["Extension"] as! String
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("JobId") {
                    self.jobId = dict["JobId"] as! String
                }
                if dict.keys.contains("OutboundScenario") {
                    self.outboundScenario = dict["OutboundScenario"] as! Bool
                }
                if dict.keys.contains("SignedSkillGroupIdList") {
                    self.signedSkillGroupIdList = dict["SignedSkillGroupIdList"] as! [String]
                }
                if dict.keys.contains("UserId") {
                    self.userId = dict["UserId"] as! String
                }
                if dict.keys.contains("UserState") {
                    self.userState = dict["UserState"] as! String
                }
                if dict.keys.contains("WorkMode") {
                    self.workMode = dict["WorkMode"] as! String
                }
            }
        }
        public var callContext: EndConferenceResponseBody.Data.CallContext?

        public var contextId: Int64?

        public var userContext: EndConferenceResponseBody.Data.UserContext?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.callContext?.validate()
            try self.userContext?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.callContext != nil {
                map["CallContext"] = self.callContext?.toMap()
            }
            if self.contextId != nil {
                map["ContextId"] = self.contextId!
            }
            if self.userContext != nil {
                map["UserContext"] = self.userContext?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CallContext") {
                var model = EndConferenceResponseBody.Data.CallContext()
                model.fromMap(dict["CallContext"] as! [String: Any])
                self.callContext = model
            }
            if dict.keys.contains("ContextId") {
                self.contextId = dict["ContextId"] as! Int64
            }
            if dict.keys.contains("UserContext") {
                var model = EndConferenceResponseBody.Data.UserContext()
                model.fromMap(dict["UserContext"] as! [String: Any])
                self.userContext = model
            }
        }
    }
    public var code: String?

    public var data: EndConferenceResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var params: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.params != nil {
            map["Params"] = self.params!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = EndConferenceResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Params") {
            self.params = dict["Params"] as! [String]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class EndConferenceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: EndConferenceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = EndConferenceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ExportCustomCallTaggingRequest : Tea.TeaModel {
    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
    }
}

public class ExportCustomCallTaggingResponseBody : Tea.TeaModel {
    public var code: String?

    public var data: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ExportCustomCallTaggingResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ExportCustomCallTaggingResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ExportCustomCallTaggingResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ExportDoNotCallNumbersRequest : Tea.TeaModel {
    public var instanceId: String?

    public var scope: String?

    public var searchPattern: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.scope != nil {
            map["Scope"] = self.scope!
        }
        if self.searchPattern != nil {
            map["SearchPattern"] = self.searchPattern!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Scope") {
            self.scope = dict["Scope"] as! String
        }
        if dict.keys.contains("SearchPattern") {
            self.searchPattern = dict["SearchPattern"] as! String
        }
    }
}

public class ExportDoNotCallNumbersResponseBody : Tea.TeaModel {
    public var code: String?

    public var data: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var params: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.params != nil {
            map["Params"] = self.params!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Params") {
            self.params = dict["Params"] as! [String]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ExportDoNotCallNumbersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ExportDoNotCallNumbersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ExportDoNotCallNumbersResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class FinishTicketTaskRequest : Tea.TeaModel {
    public var comment: String?

    public var instanceId: String?

    public var taskId: String?

    public var ticketId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.comment != nil {
            map["Comment"] = self.comment!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        if self.ticketId != nil {
            map["TicketId"] = self.ticketId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Comment") {
            self.comment = dict["Comment"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("TaskId") {
            self.taskId = dict["TaskId"] as! String
        }
        if dict.keys.contains("TicketId") {
            self.ticketId = dict["TicketId"] as! String
        }
    }
}

public class FinishTicketTaskResponseBody : Tea.TeaModel {
    public var code: String?

    public var data: Any?

    public var httpStatusCode: Int32?

    public var message: String?

    public var params: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.params != nil {
            map["Params"] = self.params!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Any
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Params") {
            self.params = dict["Params"] as! [String]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class FinishTicketTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: FinishTicketTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = FinishTicketTaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetAccessChannelOfStagingRequest : Tea.TeaModel {
    public var searchPattern: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.searchPattern != nil {
            map["SearchPattern"] = self.searchPattern!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("SearchPattern") {
            self.searchPattern = dict["SearchPattern"] as! String
        }
    }
}

public class GetAccessChannelOfStagingResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var token: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.token != nil {
                map["Token"] = self.token!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Token") {
                self.token = dict["Token"] as! String
            }
        }
    }
    public var code: String?

    public var data: GetAccessChannelOfStagingResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = GetAccessChannelOfStagingResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetAccessChannelOfStagingResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetAccessChannelOfStagingResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetAccessChannelOfStagingResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetAudioFileRequest : Tea.TeaModel {
    public var audioResourceId: String?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.audioResourceId != nil {
            map["AudioResourceId"] = self.audioResourceId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AudioResourceId") {
            self.audioResourceId = dict["AudioResourceId"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
    }
}

public class GetAudioFileResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var audioFileName: String?

        public var audioResourceId: String?

        public var createdTime: String?

        public var instanceId: String?

        public var name: String?

        public var ossFileKey: String?

        public var updatedTime: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.audioFileName != nil {
                map["AudioFileName"] = self.audioFileName!
            }
            if self.audioResourceId != nil {
                map["AudioResourceId"] = self.audioResourceId!
            }
            if self.createdTime != nil {
                map["CreatedTime"] = self.createdTime!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.ossFileKey != nil {
                map["OssFileKey"] = self.ossFileKey!
            }
            if self.updatedTime != nil {
                map["UpdatedTime"] = self.updatedTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AudioFileName") {
                self.audioFileName = dict["AudioFileName"] as! String
            }
            if dict.keys.contains("AudioResourceId") {
                self.audioResourceId = dict["AudioResourceId"] as! String
            }
            if dict.keys.contains("CreatedTime") {
                self.createdTime = dict["CreatedTime"] as! String
            }
            if dict.keys.contains("InstanceId") {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("OssFileKey") {
                self.ossFileKey = dict["OssFileKey"] as! String
            }
            if dict.keys.contains("UpdatedTime") {
                self.updatedTime = dict["UpdatedTime"] as! String
            }
        }
    }
    public var code: String?

    public var data: GetAudioFileResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = GetAudioFileResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetAudioFileResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetAudioFileResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetAudioFileResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetAudioFileDownloadUrlRequest : Tea.TeaModel {
    public var audioResourceId: String?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.audioResourceId != nil {
            map["AudioResourceId"] = self.audioResourceId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AudioResourceId") {
            self.audioResourceId = dict["AudioResourceId"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
    }
}

public class GetAudioFileDownloadUrlResponseBody : Tea.TeaModel {
    public var code: String?

    public var data: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetAudioFileDownloadUrlResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetAudioFileDownloadUrlResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetAudioFileDownloadUrlResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetAudioFileUploadParametersRequest : Tea.TeaModel {
    public var audioFileName: String?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.audioFileName != nil {
            map["AudioFileName"] = self.audioFileName!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AudioFileName") {
            self.audioFileName = dict["AudioFileName"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
    }
}

public class GetAudioFileUploadParametersResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var accessKeyId: String?

        public var expireTime: Int32?

        public var filePath: String?

        public var host: String?

        public var policy: String?

        public var signature: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accessKeyId != nil {
                map["AccessKeyId"] = self.accessKeyId!
            }
            if self.expireTime != nil {
                map["ExpireTime"] = self.expireTime!
            }
            if self.filePath != nil {
                map["FilePath"] = self.filePath!
            }
            if self.host != nil {
                map["Host"] = self.host!
            }
            if self.policy != nil {
                map["Policy"] = self.policy!
            }
            if self.signature != nil {
                map["Signature"] = self.signature!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AccessKeyId") {
                self.accessKeyId = dict["AccessKeyId"] as! String
            }
            if dict.keys.contains("ExpireTime") {
                self.expireTime = dict["ExpireTime"] as! Int32
            }
            if dict.keys.contains("FilePath") {
                self.filePath = dict["FilePath"] as! String
            }
            if dict.keys.contains("Host") {
                self.host = dict["Host"] as! String
            }
            if dict.keys.contains("Policy") {
                self.policy = dict["Policy"] as! String
            }
            if dict.keys.contains("Signature") {
                self.signature = dict["Signature"] as! String
            }
        }
    }
    public var code: String?

    public var data: GetAudioFileUploadParametersResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = GetAudioFileUploadParametersResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetAudioFileUploadParametersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetAudioFileUploadParametersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetAudioFileUploadParametersResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetCallDetailRecordRequest : Tea.TeaModel {
    public var contactId: String?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.contactId != nil {
            map["ContactId"] = self.contactId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ContactId") {
            self.contactId = dict["ContactId"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
    }
}

public class GetCallDetailRecordResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class AgentEvents : Tea.TeaModel {
            public class EventSequence : Tea.TeaModel {
                public var duration: Int64?

                public var event: String?

                public var eventTime: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.duration != nil {
                        map["Duration"] = self.duration!
                    }
                    if self.event != nil {
                        map["Event"] = self.event!
                    }
                    if self.eventTime != nil {
                        map["EventTime"] = self.eventTime!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Duration") {
                        self.duration = dict["Duration"] as! Int64
                    }
                    if dict.keys.contains("Event") {
                        self.event = dict["Event"] as! String
                    }
                    if dict.keys.contains("EventTime") {
                        self.eventTime = dict["EventTime"] as! Int64
                    }
                }
            }
            public var agentId: String?

            public var agentName: String?

            public var eventSequence: [GetCallDetailRecordResponseBody.Data.AgentEvents.EventSequence]?

            public var skillGroupId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.agentId != nil {
                    map["AgentId"] = self.agentId!
                }
                if self.agentName != nil {
                    map["AgentName"] = self.agentName!
                }
                if self.eventSequence != nil {
                    var tmp : [Any] = []
                    for k in self.eventSequence! {
                        tmp.append(k.toMap())
                    }
                    map["EventSequence"] = tmp
                }
                if self.skillGroupId != nil {
                    map["SkillGroupId"] = self.skillGroupId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AgentId") {
                    self.agentId = dict["AgentId"] as! String
                }
                if dict.keys.contains("AgentName") {
                    self.agentName = dict["AgentName"] as! String
                }
                if dict.keys.contains("EventSequence") {
                    var tmp : [GetCallDetailRecordResponseBody.Data.AgentEvents.EventSequence] = []
                    for v in dict["EventSequence"] as! [Any] {
                        var model = GetCallDetailRecordResponseBody.Data.AgentEvents.EventSequence()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.eventSequence = tmp
                }
                if dict.keys.contains("SkillGroupId") {
                    self.skillGroupId = dict["SkillGroupId"] as! String
                }
            }
        }
        public class CustomerEvents : Tea.TeaModel {
            public class EventSequence : Tea.TeaModel {
                public var event: String?

                public var eventTime: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.event != nil {
                        map["Event"] = self.event!
                    }
                    if self.eventTime != nil {
                        map["EventTime"] = self.eventTime!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Event") {
                        self.event = dict["Event"] as! String
                    }
                    if dict.keys.contains("EventTime") {
                        self.eventTime = dict["EventTime"] as! Int64
                    }
                }
            }
            public var customerId: String?

            public var eventSequence: [GetCallDetailRecordResponseBody.Data.CustomerEvents.EventSequence]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.customerId != nil {
                    map["CustomerId"] = self.customerId!
                }
                if self.eventSequence != nil {
                    var tmp : [Any] = []
                    for k in self.eventSequence! {
                        tmp.append(k.toMap())
                    }
                    map["EventSequence"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CustomerId") {
                    self.customerId = dict["CustomerId"] as! String
                }
                if dict.keys.contains("EventSequence") {
                    var tmp : [GetCallDetailRecordResponseBody.Data.CustomerEvents.EventSequence] = []
                    for v in dict["EventSequence"] as! [Any] {
                        var model = GetCallDetailRecordResponseBody.Data.CustomerEvents.EventSequence()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.eventSequence = tmp
                }
            }
        }
        public class IvrEvents : Tea.TeaModel {
            public class EventSequence : Tea.TeaModel {
                public var event: String?

                public var eventTime: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.event != nil {
                        map["Event"] = self.event!
                    }
                    if self.eventTime != nil {
                        map["EventTime"] = self.eventTime!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Event") {
                        self.event = dict["Event"] as! String
                    }
                    if dict.keys.contains("EventTime") {
                        self.eventTime = dict["EventTime"] as! Int64
                    }
                }
            }
            public var eventSequence: [GetCallDetailRecordResponseBody.Data.IvrEvents.EventSequence]?

            public var flowId: String?

            public var flowType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.eventSequence != nil {
                    var tmp : [Any] = []
                    for k in self.eventSequence! {
                        tmp.append(k.toMap())
                    }
                    map["EventSequence"] = tmp
                }
                if self.flowId != nil {
                    map["FlowId"] = self.flowId!
                }
                if self.flowType != nil {
                    map["FlowType"] = self.flowType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("EventSequence") {
                    var tmp : [GetCallDetailRecordResponseBody.Data.IvrEvents.EventSequence] = []
                    for v in dict["EventSequence"] as! [Any] {
                        var model = GetCallDetailRecordResponseBody.Data.IvrEvents.EventSequence()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.eventSequence = tmp
                }
                if dict.keys.contains("FlowId") {
                    self.flowId = dict["FlowId"] as! String
                }
                if dict.keys.contains("FlowType") {
                    self.flowType = dict["FlowType"] as! String
                }
            }
        }
        public class QueueEvents : Tea.TeaModel {
            public class EventSequence : Tea.TeaModel {
                public var event: String?

                public var eventTime: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.event != nil {
                        map["Event"] = self.event!
                    }
                    if self.eventTime != nil {
                        map["EventTime"] = self.eventTime!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Event") {
                        self.event = dict["Event"] as! String
                    }
                    if dict.keys.contains("EventTime") {
                        self.eventTime = dict["EventTime"] as! Int64
                    }
                }
            }
            public var eventSequence: [GetCallDetailRecordResponseBody.Data.QueueEvents.EventSequence]?

            public var flowId: String?

            public var queueId: String?

            public var queueName: String?

            public var queueType: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.eventSequence != nil {
                    var tmp : [Any] = []
                    for k in self.eventSequence! {
                        tmp.append(k.toMap())
                    }
                    map["EventSequence"] = tmp
                }
                if self.flowId != nil {
                    map["FlowId"] = self.flowId!
                }
                if self.queueId != nil {
                    map["QueueId"] = self.queueId!
                }
                if self.queueName != nil {
                    map["QueueName"] = self.queueName!
                }
                if self.queueType != nil {
                    map["QueueType"] = self.queueType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("EventSequence") {
                    var tmp : [GetCallDetailRecordResponseBody.Data.QueueEvents.EventSequence] = []
                    for v in dict["EventSequence"] as! [Any] {
                        var model = GetCallDetailRecordResponseBody.Data.QueueEvents.EventSequence()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.eventSequence = tmp
                }
                if dict.keys.contains("FlowId") {
                    self.flowId = dict["FlowId"] as! String
                }
                if dict.keys.contains("QueueId") {
                    self.queueId = dict["QueueId"] as! String
                }
                if dict.keys.contains("QueueName") {
                    self.queueName = dict["QueueName"] as! String
                }
                if dict.keys.contains("QueueType") {
                    self.queueType = dict["QueueType"] as! Int32
                }
            }
        }
        public var agentEvents: [GetCallDetailRecordResponseBody.Data.AgentEvents]?

        public var agentIds: String?

        public var agentNames: String?

        public var callDuration: Int64?

        public var calledNumber: String?

        public var calleeLocation: String?

        public var callerLocation: String?

        public var callingNumber: String?

        public var contactDisposition: String?

        public var contactId: String?

        public var contactType: String?

        public var customerEvents: [GetCallDetailRecordResponseBody.Data.CustomerEvents]?

        public var earlyMediaState: String?

        public var establishedTime: Int64?

        public var instanceId: String?

        public var ivrEvents: [GetCallDetailRecordResponseBody.Data.IvrEvents]?

        public var queueEvents: [GetCallDetailRecordResponseBody.Data.QueueEvents]?

        public var recordingReady: Bool?

        public var releaseInitiator: String?

        public var releaseReason: String?

        public var releaseTime: Int64?

        public var satisfaction: Int32?

        public var satisfactionSurveyChannel: String?

        public var satisfactionSurveyOffered: Bool?

        public var skillGroupIds: String?

        public var skillGroupNames: String?

        public var startTime: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.agentEvents != nil {
                var tmp : [Any] = []
                for k in self.agentEvents! {
                    tmp.append(k.toMap())
                }
                map["AgentEvents"] = tmp
            }
            if self.agentIds != nil {
                map["AgentIds"] = self.agentIds!
            }
            if self.agentNames != nil {
                map["AgentNames"] = self.agentNames!
            }
            if self.callDuration != nil {
                map["CallDuration"] = self.callDuration!
            }
            if self.calledNumber != nil {
                map["CalledNumber"] = self.calledNumber!
            }
            if self.calleeLocation != nil {
                map["CalleeLocation"] = self.calleeLocation!
            }
            if self.callerLocation != nil {
                map["CallerLocation"] = self.callerLocation!
            }
            if self.callingNumber != nil {
                map["CallingNumber"] = self.callingNumber!
            }
            if self.contactDisposition != nil {
                map["ContactDisposition"] = self.contactDisposition!
            }
            if self.contactId != nil {
                map["ContactId"] = self.contactId!
            }
            if self.contactType != nil {
                map["ContactType"] = self.contactType!
            }
            if self.customerEvents != nil {
                var tmp : [Any] = []
                for k in self.customerEvents! {
                    tmp.append(k.toMap())
                }
                map["CustomerEvents"] = tmp
            }
            if self.earlyMediaState != nil {
                map["EarlyMediaState"] = self.earlyMediaState!
            }
            if self.establishedTime != nil {
                map["EstablishedTime"] = self.establishedTime!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.ivrEvents != nil {
                var tmp : [Any] = []
                for k in self.ivrEvents! {
                    tmp.append(k.toMap())
                }
                map["IvrEvents"] = tmp
            }
            if self.queueEvents != nil {
                var tmp : [Any] = []
                for k in self.queueEvents! {
                    tmp.append(k.toMap())
                }
                map["QueueEvents"] = tmp
            }
            if self.recordingReady != nil {
                map["RecordingReady"] = self.recordingReady!
            }
            if self.releaseInitiator != nil {
                map["ReleaseInitiator"] = self.releaseInitiator!
            }
            if self.releaseReason != nil {
                map["ReleaseReason"] = self.releaseReason!
            }
            if self.releaseTime != nil {
                map["ReleaseTime"] = self.releaseTime!
            }
            if self.satisfaction != nil {
                map["Satisfaction"] = self.satisfaction!
            }
            if self.satisfactionSurveyChannel != nil {
                map["SatisfactionSurveyChannel"] = self.satisfactionSurveyChannel!
            }
            if self.satisfactionSurveyOffered != nil {
                map["SatisfactionSurveyOffered"] = self.satisfactionSurveyOffered!
            }
            if self.skillGroupIds != nil {
                map["SkillGroupIds"] = self.skillGroupIds!
            }
            if self.skillGroupNames != nil {
                map["SkillGroupNames"] = self.skillGroupNames!
            }
            if self.startTime != nil {
                map["StartTime"] = self.startTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AgentEvents") {
                var tmp : [GetCallDetailRecordResponseBody.Data.AgentEvents] = []
                for v in dict["AgentEvents"] as! [Any] {
                    var model = GetCallDetailRecordResponseBody.Data.AgentEvents()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.agentEvents = tmp
            }
            if dict.keys.contains("AgentIds") {
                self.agentIds = dict["AgentIds"] as! String
            }
            if dict.keys.contains("AgentNames") {
                self.agentNames = dict["AgentNames"] as! String
            }
            if dict.keys.contains("CallDuration") {
                self.callDuration = dict["CallDuration"] as! Int64
            }
            if dict.keys.contains("CalledNumber") {
                self.calledNumber = dict["CalledNumber"] as! String
            }
            if dict.keys.contains("CalleeLocation") {
                self.calleeLocation = dict["CalleeLocation"] as! String
            }
            if dict.keys.contains("CallerLocation") {
                self.callerLocation = dict["CallerLocation"] as! String
            }
            if dict.keys.contains("CallingNumber") {
                self.callingNumber = dict["CallingNumber"] as! String
            }
            if dict.keys.contains("ContactDisposition") {
                self.contactDisposition = dict["ContactDisposition"] as! String
            }
            if dict.keys.contains("ContactId") {
                self.contactId = dict["ContactId"] as! String
            }
            if dict.keys.contains("ContactType") {
                self.contactType = dict["ContactType"] as! String
            }
            if dict.keys.contains("CustomerEvents") {
                var tmp : [GetCallDetailRecordResponseBody.Data.CustomerEvents] = []
                for v in dict["CustomerEvents"] as! [Any] {
                    var model = GetCallDetailRecordResponseBody.Data.CustomerEvents()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.customerEvents = tmp
            }
            if dict.keys.contains("EarlyMediaState") {
                self.earlyMediaState = dict["EarlyMediaState"] as! String
            }
            if dict.keys.contains("EstablishedTime") {
                self.establishedTime = dict["EstablishedTime"] as! Int64
            }
            if dict.keys.contains("InstanceId") {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("IvrEvents") {
                var tmp : [GetCallDetailRecordResponseBody.Data.IvrEvents] = []
                for v in dict["IvrEvents"] as! [Any] {
                    var model = GetCallDetailRecordResponseBody.Data.IvrEvents()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.ivrEvents = tmp
            }
            if dict.keys.contains("QueueEvents") {
                var tmp : [GetCallDetailRecordResponseBody.Data.QueueEvents] = []
                for v in dict["QueueEvents"] as! [Any] {
                    var model = GetCallDetailRecordResponseBody.Data.QueueEvents()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.queueEvents = tmp
            }
            if dict.keys.contains("RecordingReady") {
                self.recordingReady = dict["RecordingReady"] as! Bool
            }
            if dict.keys.contains("ReleaseInitiator") {
                self.releaseInitiator = dict["ReleaseInitiator"] as! String
            }
            if dict.keys.contains("ReleaseReason") {
                self.releaseReason = dict["ReleaseReason"] as! String
            }
            if dict.keys.contains("ReleaseTime") {
                self.releaseTime = dict["ReleaseTime"] as! Int64
            }
            if dict.keys.contains("Satisfaction") {
                self.satisfaction = dict["Satisfaction"] as! Int32
            }
            if dict.keys.contains("SatisfactionSurveyChannel") {
                self.satisfactionSurveyChannel = dict["SatisfactionSurveyChannel"] as! String
            }
            if dict.keys.contains("SatisfactionSurveyOffered") {
                self.satisfactionSurveyOffered = dict["SatisfactionSurveyOffered"] as! Bool
            }
            if dict.keys.contains("SkillGroupIds") {
                self.skillGroupIds = dict["SkillGroupIds"] as! String
            }
            if dict.keys.contains("SkillGroupNames") {
                self.skillGroupNames = dict["SkillGroupNames"] as! String
            }
            if dict.keys.contains("StartTime") {
                self.startTime = dict["StartTime"] as! Int64
            }
        }
    }
    public var code: String?

    public var data: GetCallDetailRecordResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = GetCallDetailRecordResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetCallDetailRecordResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetCallDetailRecordResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetCallDetailRecordResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetCampaignRequest : Tea.TeaModel {
    public var campaignId: String?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.campaignId != nil {
            map["CampaignId"] = self.campaignId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CampaignId") {
            self.campaignId = dict["CampaignId"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
    }
}

public class GetCampaignResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var actualEndTime: Int64?

        public var actualStartTime: Int64?

        public var campaignId: String?

        public var casesAborted: Int64?

        public var casesConnected: Int64?

        public var casesUncompleted: Int64?

        public var casesUncompletedAfterAttempt: String?

        public var casesUncompletedAfterAttempted: Int64?

        public var completionRate: Double?

        public var contactFlowId: String?

        public var maxAttemptCount: Int64?

        public var minAttemptInterval: Int64?

        public var name: String?

        public var planedEndTime: Int64?

        public var planedStartTime: Int64?

        public var queueId: String?

        public var queueName: String?

        public var simulation: Bool?

        public var simulationParameters: String?

        public var state: String?

        public var strategyParameters: String?

        public var strategyType: String?

        public var totalCases: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.actualEndTime != nil {
                map["ActualEndTime"] = self.actualEndTime!
            }
            if self.actualStartTime != nil {
                map["ActualStartTime"] = self.actualStartTime!
            }
            if self.campaignId != nil {
                map["CampaignId"] = self.campaignId!
            }
            if self.casesAborted != nil {
                map["CasesAborted"] = self.casesAborted!
            }
            if self.casesConnected != nil {
                map["CasesConnected"] = self.casesConnected!
            }
            if self.casesUncompleted != nil {
                map["CasesUncompleted"] = self.casesUncompleted!
            }
            if self.casesUncompletedAfterAttempt != nil {
                map["CasesUncompletedAfterAttempt"] = self.casesUncompletedAfterAttempt!
            }
            if self.casesUncompletedAfterAttempted != nil {
                map["CasesUncompletedAfterAttempted"] = self.casesUncompletedAfterAttempted!
            }
            if self.completionRate != nil {
                map["CompletionRate"] = self.completionRate!
            }
            if self.contactFlowId != nil {
                map["ContactFlowId"] = self.contactFlowId!
            }
            if self.maxAttemptCount != nil {
                map["MaxAttemptCount"] = self.maxAttemptCount!
            }
            if self.minAttemptInterval != nil {
                map["MinAttemptInterval"] = self.minAttemptInterval!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.planedEndTime != nil {
                map["PlanedEndTime"] = self.planedEndTime!
            }
            if self.planedStartTime != nil {
                map["PlanedStartTime"] = self.planedStartTime!
            }
            if self.queueId != nil {
                map["QueueId"] = self.queueId!
            }
            if self.queueName != nil {
                map["QueueName"] = self.queueName!
            }
            if self.simulation != nil {
                map["Simulation"] = self.simulation!
            }
            if self.simulationParameters != nil {
                map["SimulationParameters"] = self.simulationParameters!
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            if self.strategyParameters != nil {
                map["StrategyParameters"] = self.strategyParameters!
            }
            if self.strategyType != nil {
                map["StrategyType"] = self.strategyType!
            }
            if self.totalCases != nil {
                map["TotalCases"] = self.totalCases!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ActualEndTime") {
                self.actualEndTime = dict["ActualEndTime"] as! Int64
            }
            if dict.keys.contains("ActualStartTime") {
                self.actualStartTime = dict["ActualStartTime"] as! Int64
            }
            if dict.keys.contains("CampaignId") {
                self.campaignId = dict["CampaignId"] as! String
            }
            if dict.keys.contains("CasesAborted") {
                self.casesAborted = dict["CasesAborted"] as! Int64
            }
            if dict.keys.contains("CasesConnected") {
                self.casesConnected = dict["CasesConnected"] as! Int64
            }
            if dict.keys.contains("CasesUncompleted") {
                self.casesUncompleted = dict["CasesUncompleted"] as! Int64
            }
            if dict.keys.contains("CasesUncompletedAfterAttempt") {
                self.casesUncompletedAfterAttempt = dict["CasesUncompletedAfterAttempt"] as! String
            }
            if dict.keys.contains("CasesUncompletedAfterAttempted") {
                self.casesUncompletedAfterAttempted = dict["CasesUncompletedAfterAttempted"] as! Int64
            }
            if dict.keys.contains("CompletionRate") {
                self.completionRate = dict["CompletionRate"] as! Double
            }
            if dict.keys.contains("ContactFlowId") {
                self.contactFlowId = dict["ContactFlowId"] as! String
            }
            if dict.keys.contains("MaxAttemptCount") {
                self.maxAttemptCount = dict["MaxAttemptCount"] as! Int64
            }
            if dict.keys.contains("MinAttemptInterval") {
                self.minAttemptInterval = dict["MinAttemptInterval"] as! Int64
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("PlanedEndTime") {
                self.planedEndTime = dict["PlanedEndTime"] as! Int64
            }
            if dict.keys.contains("PlanedStartTime") {
                self.planedStartTime = dict["PlanedStartTime"] as! Int64
            }
            if dict.keys.contains("QueueId") {
                self.queueId = dict["QueueId"] as! String
            }
            if dict.keys.contains("QueueName") {
                self.queueName = dict["QueueName"] as! String
            }
            if dict.keys.contains("Simulation") {
                self.simulation = dict["Simulation"] as! Bool
            }
            if dict.keys.contains("SimulationParameters") {
                self.simulationParameters = dict["SimulationParameters"] as! String
            }
            if dict.keys.contains("State") {
                self.state = dict["State"] as! String
            }
            if dict.keys.contains("StrategyParameters") {
                self.strategyParameters = dict["StrategyParameters"] as! String
            }
            if dict.keys.contains("StrategyType") {
                self.strategyType = dict["StrategyType"] as! String
            }
            if dict.keys.contains("TotalCases") {
                self.totalCases = dict["TotalCases"] as! Int64
            }
        }
    }
    public var code: String?

    public var data: GetCampaignResponseBody.Data?

    public var httpStatusCode: Int64?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = GetCampaignResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int64
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetCampaignResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetCampaignResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetCampaignResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetCaseFileUploadUrlRequest : Tea.TeaModel {
    public var fileName: String?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.fileName != nil {
            map["FileName"] = self.fileName!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FileName") {
            self.fileName = dict["FileName"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
    }
}

public class GetCaseFileUploadUrlResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var caseFileKey: String?

        public var url: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.caseFileKey != nil {
                map["CaseFileKey"] = self.caseFileKey!
            }
            if self.url != nil {
                map["Url"] = self.url!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CaseFileKey") {
                self.caseFileKey = dict["CaseFileKey"] as! String
            }
            if dict.keys.contains("Url") {
                self.url = dict["Url"] as! String
            }
        }
    }
    public var code: String?

    public var data: GetCaseFileUploadUrlResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = GetCaseFileUploadUrlResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetCaseFileUploadUrlResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetCaseFileUploadUrlResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetCaseFileUploadUrlResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetChatMediaUrlRequest : Tea.TeaModel {
    public var instanceId: String?

    public var mediaId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.mediaId != nil {
            map["MediaId"] = self.mediaId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("MediaId") {
            self.mediaId = dict["MediaId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetChatMediaUrlResponseBody : Tea.TeaModel {
    public var code: String?

    public var data: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var params: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.params != nil {
            map["Params"] = self.params!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Params") {
            self.params = dict["Params"] as! [String]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetChatMediaUrlResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetChatMediaUrlResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetChatMediaUrlResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetContactFlowRequest : Tea.TeaModel {
    public var contactFlowId: String?

    public var draftId: String?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.contactFlowId != nil {
            map["ContactFlowId"] = self.contactFlowId!
        }
        if self.draftId != nil {
            map["DraftId"] = self.draftId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ContactFlowId") {
            self.contactFlowId = dict["ContactFlowId"] as! String
        }
        if dict.keys.contains("DraftId") {
            self.draftId = dict["DraftId"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
    }
}

public class GetContactFlowResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var contactFlowId: String?

        public var createdTime: String?

        public var definition: String?

        public var description_: String?

        public var draftId: String?

        public var editor: String?

        public var instanceId: String?

        public var name: String?

        public var published: Bool?

        public var type: String?

        public var updatedTime: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.contactFlowId != nil {
                map["ContactFlowId"] = self.contactFlowId!
            }
            if self.createdTime != nil {
                map["CreatedTime"] = self.createdTime!
            }
            if self.definition != nil {
                map["Definition"] = self.definition!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.draftId != nil {
                map["DraftId"] = self.draftId!
            }
            if self.editor != nil {
                map["Editor"] = self.editor!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.published != nil {
                map["Published"] = self.published!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.updatedTime != nil {
                map["UpdatedTime"] = self.updatedTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ContactFlowId") {
                self.contactFlowId = dict["ContactFlowId"] as! String
            }
            if dict.keys.contains("CreatedTime") {
                self.createdTime = dict["CreatedTime"] as! String
            }
            if dict.keys.contains("Definition") {
                self.definition = dict["Definition"] as! String
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("DraftId") {
                self.draftId = dict["DraftId"] as! String
            }
            if dict.keys.contains("Editor") {
                self.editor = dict["Editor"] as! String
            }
            if dict.keys.contains("InstanceId") {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Published") {
                self.published = dict["Published"] as! Bool
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
            if dict.keys.contains("UpdatedTime") {
                self.updatedTime = dict["UpdatedTime"] as! String
            }
        }
    }
    public var code: String?

    public var data: GetContactFlowResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = GetContactFlowResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetContactFlowResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetContactFlowResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetContactFlowResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetConversationDetailRequest : Tea.TeaModel {
    public var contactId: String?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.contactId != nil {
            map["ContactId"] = self.contactId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ContactId") {
            self.contactId = dict["ContactId"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
    }
}

public class GetConversationDetailResponseBody : Tea.TeaModel {
    public class Phrases : Tea.TeaModel {
        public var begin: Int32?

        public var end: Int32?

        public var identity: String?

        public var role: String?

        public var words: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.begin != nil {
                map["Begin"] = self.begin!
            }
            if self.end != nil {
                map["End"] = self.end!
            }
            if self.identity != nil {
                map["Identity"] = self.identity!
            }
            if self.role != nil {
                map["Role"] = self.role!
            }
            if self.words != nil {
                map["Words"] = self.words!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Begin") {
                self.begin = dict["Begin"] as! Int32
            }
            if dict.keys.contains("End") {
                self.end = dict["End"] as! Int32
            }
            if dict.keys.contains("Identity") {
                self.identity = dict["Identity"] as! String
            }
            if dict.keys.contains("Role") {
                self.role = dict["Role"] as! String
            }
            if dict.keys.contains("Words") {
                self.words = dict["Words"] as! String
            }
        }
    }
    public var code: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var phrases: [GetConversationDetailResponseBody.Phrases]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.phrases != nil {
            var tmp : [Any] = []
            for k in self.phrases! {
                tmp.append(k.toMap())
            }
            map["Phrases"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Phrases") {
            var tmp : [GetConversationDetailResponseBody.Phrases] = []
            for v in dict["Phrases"] as! [Any] {
                var model = GetConversationDetailResponseBody.Phrases()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.phrases = tmp
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetConversationDetailResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetConversationDetailResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetConversationDetailResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetDataChannelCredentialsRequest : Tea.TeaModel {
    public var deviceId: String?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.deviceId != nil {
            map["DeviceId"] = self.deviceId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DeviceId") {
            self.deviceId = dict["DeviceId"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
    }
}

public class GetDataChannelCredentialsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var clientId: String?

        public var deviceId: String?

        public var endpoint: String?

        public var expiredTime: Int64?

        public var password: String?

        public var topic: String?

        public var userName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.clientId != nil {
                map["ClientId"] = self.clientId!
            }
            if self.deviceId != nil {
                map["DeviceId"] = self.deviceId!
            }
            if self.endpoint != nil {
                map["Endpoint"] = self.endpoint!
            }
            if self.expiredTime != nil {
                map["ExpiredTime"] = self.expiredTime!
            }
            if self.password != nil {
                map["Password"] = self.password!
            }
            if self.topic != nil {
                map["Topic"] = self.topic!
            }
            if self.userName != nil {
                map["UserName"] = self.userName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ClientId") {
                self.clientId = dict["ClientId"] as! String
            }
            if dict.keys.contains("DeviceId") {
                self.deviceId = dict["DeviceId"] as! String
            }
            if dict.keys.contains("Endpoint") {
                self.endpoint = dict["Endpoint"] as! String
            }
            if dict.keys.contains("ExpiredTime") {
                self.expiredTime = dict["ExpiredTime"] as! Int64
            }
            if dict.keys.contains("Password") {
                self.password = dict["Password"] as! String
            }
            if dict.keys.contains("Topic") {
                self.topic = dict["Topic"] as! String
            }
            if dict.keys.contains("UserName") {
                self.userName = dict["UserName"] as! String
            }
        }
    }
    public var code: String?

    public var data: GetDataChannelCredentialsResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var params: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.params != nil {
            map["Params"] = self.params!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = GetDataChannelCredentialsResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Params") {
            self.params = dict["Params"] as! [String]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetDataChannelCredentialsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetDataChannelCredentialsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetDataChannelCredentialsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetDoNotCallFileUploadParametersRequest : Tea.TeaModel {
    public var fileName: String?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.fileName != nil {
            map["FileName"] = self.fileName!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FileName") {
            self.fileName = dict["FileName"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
    }
}

public class GetDoNotCallFileUploadParametersResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var accessKeyId: String?

        public var expireTime: Int32?

        public var filePath: String?

        public var host: String?

        public var policy: String?

        public var signature: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accessKeyId != nil {
                map["AccessKeyId"] = self.accessKeyId!
            }
            if self.expireTime != nil {
                map["ExpireTime"] = self.expireTime!
            }
            if self.filePath != nil {
                map["FilePath"] = self.filePath!
            }
            if self.host != nil {
                map["Host"] = self.host!
            }
            if self.policy != nil {
                map["Policy"] = self.policy!
            }
            if self.signature != nil {
                map["Signature"] = self.signature!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AccessKeyId") {
                self.accessKeyId = dict["AccessKeyId"] as! String
            }
            if dict.keys.contains("ExpireTime") {
                self.expireTime = dict["ExpireTime"] as! Int32
            }
            if dict.keys.contains("FilePath") {
                self.filePath = dict["FilePath"] as! String
            }
            if dict.keys.contains("Host") {
                self.host = dict["Host"] as! String
            }
            if dict.keys.contains("Policy") {
                self.policy = dict["Policy"] as! String
            }
            if dict.keys.contains("Signature") {
                self.signature = dict["Signature"] as! String
            }
        }
    }
    public var code: String?

    public var data: GetDoNotCallFileUploadParametersResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = GetDoNotCallFileUploadParametersResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetDoNotCallFileUploadParametersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetDoNotCallFileUploadParametersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetDoNotCallFileUploadParametersResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetDocumentUploadParametersRequest : Tea.TeaModel {
    public var fileName: String?

    public var instanceId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.fileName != nil {
            map["FileName"] = self.fileName!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FileName") {
            self.fileName = dict["FileName"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetDocumentUploadParametersResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var accessKeyId: String?

        public var expireTime: Int32?

        public var filePath: String?

        public var host: String?

        public var policy: String?

        public var signature: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accessKeyId != nil {
                map["AccessKeyId"] = self.accessKeyId!
            }
            if self.expireTime != nil {
                map["ExpireTime"] = self.expireTime!
            }
            if self.filePath != nil {
                map["FilePath"] = self.filePath!
            }
            if self.host != nil {
                map["Host"] = self.host!
            }
            if self.policy != nil {
                map["Policy"] = self.policy!
            }
            if self.signature != nil {
                map["Signature"] = self.signature!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AccessKeyId") {
                self.accessKeyId = dict["AccessKeyId"] as! String
            }
            if dict.keys.contains("ExpireTime") {
                self.expireTime = dict["ExpireTime"] as! Int32
            }
            if dict.keys.contains("FilePath") {
                self.filePath = dict["FilePath"] as! String
            }
            if dict.keys.contains("Host") {
                self.host = dict["Host"] as! String
            }
            if dict.keys.contains("Policy") {
                self.policy = dict["Policy"] as! String
            }
            if dict.keys.contains("Signature") {
                self.signature = dict["Signature"] as! String
            }
        }
    }
    public var code: String?

    public var data: GetDocumentUploadParametersResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var params: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.params != nil {
            map["Params"] = self.params!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = GetDocumentUploadParametersResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Params") {
            self.params = dict["Params"] as! [String]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetDocumentUploadParametersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetDocumentUploadParametersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetDocumentUploadParametersResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetEarlyMediaRecordingRequest : Tea.TeaModel {
    public var contactId: String?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.contactId != nil {
            map["ContactId"] = self.contactId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ContactId") {
            self.contactId = dict["ContactId"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
    }
}

public class GetEarlyMediaRecordingResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var fileName: String?

        public var fileUrl: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.fileName != nil {
                map["FileName"] = self.fileName!
            }
            if self.fileUrl != nil {
                map["FileUrl"] = self.fileUrl!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("FileName") {
                self.fileName = dict["FileName"] as! String
            }
            if dict.keys.contains("FileUrl") {
                self.fileUrl = dict["FileUrl"] as! String
            }
        }
    }
    public var code: String?

    public var data: GetEarlyMediaRecordingResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = GetEarlyMediaRecordingResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetEarlyMediaRecordingResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetEarlyMediaRecordingResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetEarlyMediaRecordingResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetHistoricalCallerReportRequest : Tea.TeaModel {
    public var callingNumber: String?

    public var instanceId: String?

    public var startTime: Int64?

    public var stopTime: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.callingNumber != nil {
            map["CallingNumber"] = self.callingNumber!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.stopTime != nil {
            map["StopTime"] = self.stopTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CallingNumber") {
            self.callingNumber = dict["CallingNumber"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! Int64
        }
        if dict.keys.contains("StopTime") {
            self.stopTime = dict["StopTime"] as! Int64
        }
    }
}

public class GetHistoricalCallerReportResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var lastCallingTime: Int64?

        public var totalCalls: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.lastCallingTime != nil {
                map["LastCallingTime"] = self.lastCallingTime!
            }
            if self.totalCalls != nil {
                map["TotalCalls"] = self.totalCalls!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("LastCallingTime") {
                self.lastCallingTime = dict["LastCallingTime"] as! Int64
            }
            if dict.keys.contains("TotalCalls") {
                self.totalCalls = dict["TotalCalls"] as! Int64
            }
        }
    }
    public var code: String?

    public var data: GetHistoricalCallerReportResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = GetHistoricalCallerReportResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetHistoricalCallerReportResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetHistoricalCallerReportResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetHistoricalCallerReportResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetHistoricalCampaignReportRequest : Tea.TeaModel {
    public var campaignId: String?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.campaignId != nil {
            map["CampaignId"] = self.campaignId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CampaignId") {
            self.campaignId = dict["CampaignId"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
    }
}

public class GetHistoricalCampaignReportResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var abandonRate: Double?

        public var abandonedRate: Double?

        public var answerRate: Double?

        public var callsAbandoned: Int64?

        public var callsConnected: Int64?

        public var callsDialed: Int64?

        public var connectedRate: Double?

        public var occupancyRate: Double?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.abandonRate != nil {
                map["AbandonRate"] = self.abandonRate!
            }
            if self.abandonedRate != nil {
                map["AbandonedRate"] = self.abandonedRate!
            }
            if self.answerRate != nil {
                map["AnswerRate"] = self.answerRate!
            }
            if self.callsAbandoned != nil {
                map["CallsAbandoned"] = self.callsAbandoned!
            }
            if self.callsConnected != nil {
                map["CallsConnected"] = self.callsConnected!
            }
            if self.callsDialed != nil {
                map["CallsDialed"] = self.callsDialed!
            }
            if self.connectedRate != nil {
                map["ConnectedRate"] = self.connectedRate!
            }
            if self.occupancyRate != nil {
                map["OccupancyRate"] = self.occupancyRate!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AbandonRate") {
                self.abandonRate = dict["AbandonRate"] as! Double
            }
            if dict.keys.contains("AbandonedRate") {
                self.abandonedRate = dict["AbandonedRate"] as! Double
            }
            if dict.keys.contains("AnswerRate") {
                self.answerRate = dict["AnswerRate"] as! Double
            }
            if dict.keys.contains("CallsAbandoned") {
                self.callsAbandoned = dict["CallsAbandoned"] as! Int64
            }
            if dict.keys.contains("CallsConnected") {
                self.callsConnected = dict["CallsConnected"] as! Int64
            }
            if dict.keys.contains("CallsDialed") {
                self.callsDialed = dict["CallsDialed"] as! Int64
            }
            if dict.keys.contains("ConnectedRate") {
                self.connectedRate = dict["ConnectedRate"] as! Double
            }
            if dict.keys.contains("OccupancyRate") {
                self.occupancyRate = dict["OccupancyRate"] as! Double
            }
        }
    }
    public var code: String?

    public var data: GetHistoricalCampaignReportResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = GetHistoricalCampaignReportResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetHistoricalCampaignReportResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetHistoricalCampaignReportResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetHistoricalCampaignReportResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetHistoricalInstanceReportRequest : Tea.TeaModel {
    public var endTime: Int64?

    public var instanceId: String?

    public var mediaType: String?

    public var startTime: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.mediaType != nil {
            map["MediaType"] = self.mediaType!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("MediaType") {
            self.mediaType = dict["MediaType"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! Int64
        }
    }
}

public class GetHistoricalInstanceReportResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Inbound : Tea.TeaModel {
            public class AccessChannelTypeDetailList : Tea.TeaModel {
                public var accessChannelType: String?

                public var callsOffered: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.accessChannelType != nil {
                        map["AccessChannelType"] = self.accessChannelType!
                    }
                    if self.callsOffered != nil {
                        map["CallsOffered"] = self.callsOffered!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AccessChannelType") {
                        self.accessChannelType = dict["AccessChannelType"] as! String
                    }
                    if dict.keys.contains("CallsOffered") {
                        self.callsOffered = dict["CallsOffered"] as! Int64
                    }
                }
            }
            public var abandonRate: Double?

            public var accessChannelTypeDetailList: [GetHistoricalInstanceReportResponseBody.Data.Inbound.AccessChannelTypeDetailList]?

            public var averageAbandonTime: Double?

            public var averageAbandonedInIVRTime: Double?

            public var averageAbandonedInQueueTime: Double?

            public var averageAbandonedInRingTime: Double?

            public var averageFirstResponseTime: Double?

            public var averageHoldTime: Double?

            public var averageResponseTime: Double?

            public var averageRingTime: Double?

            public var averageTalkTime: Double?

            public var averageWaitTime: Double?

            public var averageWorkTime: Double?

            public var callsAbandoned: Int64?

            public var callsAbandonedInIVR: Int64?

            public var callsAbandonedInQueue: Int64?

            public var callsAbandonedInRing: Int64?

            public var callsAbandonedInVoiceNavigator: Int64?

            public var callsAttendedTransferred: Int64?

            public var callsBlindTransferred: Int64?

            public var callsCausedIVRException: Int64?

            public var callsForwardToOutsideNumber: Int64?

            public var callsHandled: Int64?

            public var callsHold: Int64?

            public var callsIVRException: Int64?

            public var callsOffered: Int64?

            public var callsQueued: Int64?

            public var callsQueuingFailed: Int64?

            public var callsQueuingOverflow: Int64?

            public var callsQueuingTimeout: Int64?

            public var callsRinged: Int64?

            public var callsToVoicemail: Int64?

            public var callsVoicemail: Int64?

            public var handleRate: Double?

            public var maxAbandonTime: Int64?

            public var maxAbandonedInIVRTime: Int64?

            public var maxAbandonedInQueueTime: Int64?

            public var maxAbandonedInRingTime: Int64?

            public var maxHoldTime: Int64?

            public var maxRingTime: Int64?

            public var maxTalkTime: Int64?

            public var maxWaitTime: Int64?

            public var maxWorkTime: Int64?

            public var satisfactionIndex: Double?

            public var satisfactionRate: Double?

            public var satisfactionSurveysOffered: Int64?

            public var satisfactionSurveysResponded: Int64?

            public var serviceLevel15: Double?

            public var serviceLevel20: Double?

            public var serviceLevel30: Double?

            public var totalAbandonTime: Int64?

            public var totalAbandonedInIVRTime: Int64?

            public var totalAbandonedInQueueTime: Int64?

            public var totalAbandonedInRingTime: Int64?

            public var totalHoldTime: Int64?

            public var totalMessagesSent: Int64?

            public var totalMessagesSentByAgent: Int64?

            public var totalMessagesSentByCustomer: Int64?

            public var totalRingTime: Int64?

            public var totalTalkTime: Int64?

            public var totalWaitTime: Int64?

            public var totalWorkTime: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.abandonRate != nil {
                    map["AbandonRate"] = self.abandonRate!
                }
                if self.accessChannelTypeDetailList != nil {
                    var tmp : [Any] = []
                    for k in self.accessChannelTypeDetailList! {
                        tmp.append(k.toMap())
                    }
                    map["AccessChannelTypeDetailList"] = tmp
                }
                if self.averageAbandonTime != nil {
                    map["AverageAbandonTime"] = self.averageAbandonTime!
                }
                if self.averageAbandonedInIVRTime != nil {
                    map["AverageAbandonedInIVRTime"] = self.averageAbandonedInIVRTime!
                }
                if self.averageAbandonedInQueueTime != nil {
                    map["AverageAbandonedInQueueTime"] = self.averageAbandonedInQueueTime!
                }
                if self.averageAbandonedInRingTime != nil {
                    map["AverageAbandonedInRingTime"] = self.averageAbandonedInRingTime!
                }
                if self.averageFirstResponseTime != nil {
                    map["AverageFirstResponseTime"] = self.averageFirstResponseTime!
                }
                if self.averageHoldTime != nil {
                    map["AverageHoldTime"] = self.averageHoldTime!
                }
                if self.averageResponseTime != nil {
                    map["AverageResponseTime"] = self.averageResponseTime!
                }
                if self.averageRingTime != nil {
                    map["AverageRingTime"] = self.averageRingTime!
                }
                if self.averageTalkTime != nil {
                    map["AverageTalkTime"] = self.averageTalkTime!
                }
                if self.averageWaitTime != nil {
                    map["AverageWaitTime"] = self.averageWaitTime!
                }
                if self.averageWorkTime != nil {
                    map["AverageWorkTime"] = self.averageWorkTime!
                }
                if self.callsAbandoned != nil {
                    map["CallsAbandoned"] = self.callsAbandoned!
                }
                if self.callsAbandonedInIVR != nil {
                    map["CallsAbandonedInIVR"] = self.callsAbandonedInIVR!
                }
                if self.callsAbandonedInQueue != nil {
                    map["CallsAbandonedInQueue"] = self.callsAbandonedInQueue!
                }
                if self.callsAbandonedInRing != nil {
                    map["CallsAbandonedInRing"] = self.callsAbandonedInRing!
                }
                if self.callsAbandonedInVoiceNavigator != nil {
                    map["CallsAbandonedInVoiceNavigator"] = self.callsAbandonedInVoiceNavigator!
                }
                if self.callsAttendedTransferred != nil {
                    map["CallsAttendedTransferred"] = self.callsAttendedTransferred!
                }
                if self.callsBlindTransferred != nil {
                    map["CallsBlindTransferred"] = self.callsBlindTransferred!
                }
                if self.callsCausedIVRException != nil {
                    map["CallsCausedIVRException"] = self.callsCausedIVRException!
                }
                if self.callsForwardToOutsideNumber != nil {
                    map["CallsForwardToOutsideNumber"] = self.callsForwardToOutsideNumber!
                }
                if self.callsHandled != nil {
                    map["CallsHandled"] = self.callsHandled!
                }
                if self.callsHold != nil {
                    map["CallsHold"] = self.callsHold!
                }
                if self.callsIVRException != nil {
                    map["CallsIVRException"] = self.callsIVRException!
                }
                if self.callsOffered != nil {
                    map["CallsOffered"] = self.callsOffered!
                }
                if self.callsQueued != nil {
                    map["CallsQueued"] = self.callsQueued!
                }
                if self.callsQueuingFailed != nil {
                    map["CallsQueuingFailed"] = self.callsQueuingFailed!
                }
                if self.callsQueuingOverflow != nil {
                    map["CallsQueuingOverflow"] = self.callsQueuingOverflow!
                }
                if self.callsQueuingTimeout != nil {
                    map["CallsQueuingTimeout"] = self.callsQueuingTimeout!
                }
                if self.callsRinged != nil {
                    map["CallsRinged"] = self.callsRinged!
                }
                if self.callsToVoicemail != nil {
                    map["CallsToVoicemail"] = self.callsToVoicemail!
                }
                if self.callsVoicemail != nil {
                    map["CallsVoicemail"] = self.callsVoicemail!
                }
                if self.handleRate != nil {
                    map["HandleRate"] = self.handleRate!
                }
                if self.maxAbandonTime != nil {
                    map["MaxAbandonTime"] = self.maxAbandonTime!
                }
                if self.maxAbandonedInIVRTime != nil {
                    map["MaxAbandonedInIVRTime"] = self.maxAbandonedInIVRTime!
                }
                if self.maxAbandonedInQueueTime != nil {
                    map["MaxAbandonedInQueueTime"] = self.maxAbandonedInQueueTime!
                }
                if self.maxAbandonedInRingTime != nil {
                    map["MaxAbandonedInRingTime"] = self.maxAbandonedInRingTime!
                }
                if self.maxHoldTime != nil {
                    map["MaxHoldTime"] = self.maxHoldTime!
                }
                if self.maxRingTime != nil {
                    map["MaxRingTime"] = self.maxRingTime!
                }
                if self.maxTalkTime != nil {
                    map["MaxTalkTime"] = self.maxTalkTime!
                }
                if self.maxWaitTime != nil {
                    map["MaxWaitTime"] = self.maxWaitTime!
                }
                if self.maxWorkTime != nil {
                    map["MaxWorkTime"] = self.maxWorkTime!
                }
                if self.satisfactionIndex != nil {
                    map["SatisfactionIndex"] = self.satisfactionIndex!
                }
                if self.satisfactionRate != nil {
                    map["SatisfactionRate"] = self.satisfactionRate!
                }
                if self.satisfactionSurveysOffered != nil {
                    map["SatisfactionSurveysOffered"] = self.satisfactionSurveysOffered!
                }
                if self.satisfactionSurveysResponded != nil {
                    map["SatisfactionSurveysResponded"] = self.satisfactionSurveysResponded!
                }
                if self.serviceLevel15 != nil {
                    map["ServiceLevel15"] = self.serviceLevel15!
                }
                if self.serviceLevel20 != nil {
                    map["ServiceLevel20"] = self.serviceLevel20!
                }
                if self.serviceLevel30 != nil {
                    map["ServiceLevel30"] = self.serviceLevel30!
                }
                if self.totalAbandonTime != nil {
                    map["TotalAbandonTime"] = self.totalAbandonTime!
                }
                if self.totalAbandonedInIVRTime != nil {
                    map["TotalAbandonedInIVRTime"] = self.totalAbandonedInIVRTime!
                }
                if self.totalAbandonedInQueueTime != nil {
                    map["TotalAbandonedInQueueTime"] = self.totalAbandonedInQueueTime!
                }
                if self.totalAbandonedInRingTime != nil {
                    map["TotalAbandonedInRingTime"] = self.totalAbandonedInRingTime!
                }
                if self.totalHoldTime != nil {
                    map["TotalHoldTime"] = self.totalHoldTime!
                }
                if self.totalMessagesSent != nil {
                    map["TotalMessagesSent"] = self.totalMessagesSent!
                }
                if self.totalMessagesSentByAgent != nil {
                    map["TotalMessagesSentByAgent"] = self.totalMessagesSentByAgent!
                }
                if self.totalMessagesSentByCustomer != nil {
                    map["TotalMessagesSentByCustomer"] = self.totalMessagesSentByCustomer!
                }
                if self.totalRingTime != nil {
                    map["TotalRingTime"] = self.totalRingTime!
                }
                if self.totalTalkTime != nil {
                    map["TotalTalkTime"] = self.totalTalkTime!
                }
                if self.totalWaitTime != nil {
                    map["TotalWaitTime"] = self.totalWaitTime!
                }
                if self.totalWorkTime != nil {
                    map["TotalWorkTime"] = self.totalWorkTime!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AbandonRate") {
                    self.abandonRate = dict["AbandonRate"] as! Double
                }
                if dict.keys.contains("AccessChannelTypeDetailList") {
                    var tmp : [GetHistoricalInstanceReportResponseBody.Data.Inbound.AccessChannelTypeDetailList] = []
                    for v in dict["AccessChannelTypeDetailList"] as! [Any] {
                        var model = GetHistoricalInstanceReportResponseBody.Data.Inbound.AccessChannelTypeDetailList()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.accessChannelTypeDetailList = tmp
                }
                if dict.keys.contains("AverageAbandonTime") {
                    self.averageAbandonTime = dict["AverageAbandonTime"] as! Double
                }
                if dict.keys.contains("AverageAbandonedInIVRTime") {
                    self.averageAbandonedInIVRTime = dict["AverageAbandonedInIVRTime"] as! Double
                }
                if dict.keys.contains("AverageAbandonedInQueueTime") {
                    self.averageAbandonedInQueueTime = dict["AverageAbandonedInQueueTime"] as! Double
                }
                if dict.keys.contains("AverageAbandonedInRingTime") {
                    self.averageAbandonedInRingTime = dict["AverageAbandonedInRingTime"] as! Double
                }
                if dict.keys.contains("AverageFirstResponseTime") {
                    self.averageFirstResponseTime = dict["AverageFirstResponseTime"] as! Double
                }
                if dict.keys.contains("AverageHoldTime") {
                    self.averageHoldTime = dict["AverageHoldTime"] as! Double
                }
                if dict.keys.contains("AverageResponseTime") {
                    self.averageResponseTime = dict["AverageResponseTime"] as! Double
                }
                if dict.keys.contains("AverageRingTime") {
                    self.averageRingTime = dict["AverageRingTime"] as! Double
                }
                if dict.keys.contains("AverageTalkTime") {
                    self.averageTalkTime = dict["AverageTalkTime"] as! Double
                }
                if dict.keys.contains("AverageWaitTime") {
                    self.averageWaitTime = dict["AverageWaitTime"] as! Double
                }
                if dict.keys.contains("AverageWorkTime") {
                    self.averageWorkTime = dict["AverageWorkTime"] as! Double
                }
                if dict.keys.contains("CallsAbandoned") {
                    self.callsAbandoned = dict["CallsAbandoned"] as! Int64
                }
                if dict.keys.contains("CallsAbandonedInIVR") {
                    self.callsAbandonedInIVR = dict["CallsAbandonedInIVR"] as! Int64
                }
                if dict.keys.contains("CallsAbandonedInQueue") {
                    self.callsAbandonedInQueue = dict["CallsAbandonedInQueue"] as! Int64
                }
                if dict.keys.contains("CallsAbandonedInRing") {
                    self.callsAbandonedInRing = dict["CallsAbandonedInRing"] as! Int64
                }
                if dict.keys.contains("CallsAbandonedInVoiceNavigator") {
                    self.callsAbandonedInVoiceNavigator = dict["CallsAbandonedInVoiceNavigator"] as! Int64
                }
                if dict.keys.contains("CallsAttendedTransferred") {
                    self.callsAttendedTransferred = dict["CallsAttendedTransferred"] as! Int64
                }
                if dict.keys.contains("CallsBlindTransferred") {
                    self.callsBlindTransferred = dict["CallsBlindTransferred"] as! Int64
                }
                if dict.keys.contains("CallsCausedIVRException") {
                    self.callsCausedIVRException = dict["CallsCausedIVRException"] as! Int64
                }
                if dict.keys.contains("CallsForwardToOutsideNumber") {
                    self.callsForwardToOutsideNumber = dict["CallsForwardToOutsideNumber"] as! Int64
                }
                if dict.keys.contains("CallsHandled") {
                    self.callsHandled = dict["CallsHandled"] as! Int64
                }
                if dict.keys.contains("CallsHold") {
                    self.callsHold = dict["CallsHold"] as! Int64
                }
                if dict.keys.contains("CallsIVRException") {
                    self.callsIVRException = dict["CallsIVRException"] as! Int64
                }
                if dict.keys.contains("CallsOffered") {
                    self.callsOffered = dict["CallsOffered"] as! Int64
                }
                if dict.keys.contains("CallsQueued") {
                    self.callsQueued = dict["CallsQueued"] as! Int64
                }
                if dict.keys.contains("CallsQueuingFailed") {
                    self.callsQueuingFailed = dict["CallsQueuingFailed"] as! Int64
                }
                if dict.keys.contains("CallsQueuingOverflow") {
                    self.callsQueuingOverflow = dict["CallsQueuingOverflow"] as! Int64
                }
                if dict.keys.contains("CallsQueuingTimeout") {
                    self.callsQueuingTimeout = dict["CallsQueuingTimeout"] as! Int64
                }
                if dict.keys.contains("CallsRinged") {
                    self.callsRinged = dict["CallsRinged"] as! Int64
                }
                if dict.keys.contains("CallsToVoicemail") {
                    self.callsToVoicemail = dict["CallsToVoicemail"] as! Int64
                }
                if dict.keys.contains("CallsVoicemail") {
                    self.callsVoicemail = dict["CallsVoicemail"] as! Int64
                }
                if dict.keys.contains("HandleRate") {
                    self.handleRate = dict["HandleRate"] as! Double
                }
                if dict.keys.contains("MaxAbandonTime") {
                    self.maxAbandonTime = dict["MaxAbandonTime"] as! Int64
                }
                if dict.keys.contains("MaxAbandonedInIVRTime") {
                    self.maxAbandonedInIVRTime = dict["MaxAbandonedInIVRTime"] as! Int64
                }
                if dict.keys.contains("MaxAbandonedInQueueTime") {
                    self.maxAbandonedInQueueTime = dict["MaxAbandonedInQueueTime"] as! Int64
                }
                if dict.keys.contains("MaxAbandonedInRingTime") {
                    self.maxAbandonedInRingTime = dict["MaxAbandonedInRingTime"] as! Int64
                }
                if dict.keys.contains("MaxHoldTime") {
                    self.maxHoldTime = dict["MaxHoldTime"] as! Int64
                }
                if dict.keys.contains("MaxRingTime") {
                    self.maxRingTime = dict["MaxRingTime"] as! Int64
                }
                if dict.keys.contains("MaxTalkTime") {
                    self.maxTalkTime = dict["MaxTalkTime"] as! Int64
                }
                if dict.keys.contains("MaxWaitTime") {
                    self.maxWaitTime = dict["MaxWaitTime"] as! Int64
                }
                if dict.keys.contains("MaxWorkTime") {
                    self.maxWorkTime = dict["MaxWorkTime"] as! Int64
                }
                if dict.keys.contains("SatisfactionIndex") {
                    self.satisfactionIndex = dict["SatisfactionIndex"] as! Double
                }
                if dict.keys.contains("SatisfactionRate") {
                    self.satisfactionRate = dict["SatisfactionRate"] as! Double
                }
                if dict.keys.contains("SatisfactionSurveysOffered") {
                    self.satisfactionSurveysOffered = dict["SatisfactionSurveysOffered"] as! Int64
                }
                if dict.keys.contains("SatisfactionSurveysResponded") {
                    self.satisfactionSurveysResponded = dict["SatisfactionSurveysResponded"] as! Int64
                }
                if dict.keys.contains("ServiceLevel15") {
                    self.serviceLevel15 = dict["ServiceLevel15"] as! Double
                }
                if dict.keys.contains("ServiceLevel20") {
                    self.serviceLevel20 = dict["ServiceLevel20"] as! Double
                }
                if dict.keys.contains("ServiceLevel30") {
                    self.serviceLevel30 = dict["ServiceLevel30"] as! Double
                }
                if dict.keys.contains("TotalAbandonTime") {
                    self.totalAbandonTime = dict["TotalAbandonTime"] as! Int64
                }
                if dict.keys.contains("TotalAbandonedInIVRTime") {
                    self.totalAbandonedInIVRTime = dict["TotalAbandonedInIVRTime"] as! Int64
                }
                if dict.keys.contains("TotalAbandonedInQueueTime") {
                    self.totalAbandonedInQueueTime = dict["TotalAbandonedInQueueTime"] as! Int64
                }
                if dict.keys.contains("TotalAbandonedInRingTime") {
                    self.totalAbandonedInRingTime = dict["TotalAbandonedInRingTime"] as! Int64
                }
                if dict.keys.contains("TotalHoldTime") {
                    self.totalHoldTime = dict["TotalHoldTime"] as! Int64
                }
                if dict.keys.contains("TotalMessagesSent") {
                    self.totalMessagesSent = dict["TotalMessagesSent"] as! Int64
                }
                if dict.keys.contains("TotalMessagesSentByAgent") {
                    self.totalMessagesSentByAgent = dict["TotalMessagesSentByAgent"] as! Int64
                }
                if dict.keys.contains("TotalMessagesSentByCustomer") {
                    self.totalMessagesSentByCustomer = dict["TotalMessagesSentByCustomer"] as! Int64
                }
                if dict.keys.contains("TotalRingTime") {
                    self.totalRingTime = dict["TotalRingTime"] as! Int64
                }
                if dict.keys.contains("TotalTalkTime") {
                    self.totalTalkTime = dict["TotalTalkTime"] as! Int64
                }
                if dict.keys.contains("TotalWaitTime") {
                    self.totalWaitTime = dict["TotalWaitTime"] as! Int64
                }
                if dict.keys.contains("TotalWorkTime") {
                    self.totalWorkTime = dict["TotalWorkTime"] as! Int64
                }
            }
        }
        public class Internal_ : Tea.TeaModel {
            public var callsAnswered: Int64?

            public var callsDialed: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.callsAnswered != nil {
                    map["CallsAnswered"] = self.callsAnswered!
                }
                if self.callsDialed != nil {
                    map["CallsDialed"] = self.callsDialed!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CallsAnswered") {
                    self.callsAnswered = dict["CallsAnswered"] as! Int64
                }
                if dict.keys.contains("CallsDialed") {
                    self.callsDialed = dict["CallsDialed"] as! Int64
                }
            }
        }
        public class Outbound : Tea.TeaModel {
            public var answerRate: Double?

            public var averageDialingTime: Double?

            public var averageHoldTime: Double?

            public var averageRingTime: Double?

            public var averageTalkTime: Double?

            public var averageWorkTime: Double?

            public var callsAnswered: Int64?

            public var callsAttendedTransferred: Int64?

            public var callsBlindTransferred: Int64?

            public var callsDialed: Int64?

            public var callsHold: Int32?

            public var callsRinged: Int64?

            public var maxDialingTime: Int64?

            public var maxHoldTime: Int64?

            public var maxRingTime: Int64?

            public var maxTalkTime: Int64?

            public var maxWorkTime: Int64?

            public var satisfactionIndex: Double?

            public var satisfactionRate: Double?

            public var satisfactionSurveysOffered: Int64?

            public var satisfactionSurveysResponded: Int64?

            public var totalDialingTime: Int64?

            public var totalHoldTime: Int64?

            public var totalRingTime: Int64?

            public var totalTalkTime: Int64?

            public var totalWorkTime: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.answerRate != nil {
                    map["AnswerRate"] = self.answerRate!
                }
                if self.averageDialingTime != nil {
                    map["AverageDialingTime"] = self.averageDialingTime!
                }
                if self.averageHoldTime != nil {
                    map["AverageHoldTime"] = self.averageHoldTime!
                }
                if self.averageRingTime != nil {
                    map["AverageRingTime"] = self.averageRingTime!
                }
                if self.averageTalkTime != nil {
                    map["AverageTalkTime"] = self.averageTalkTime!
                }
                if self.averageWorkTime != nil {
                    map["AverageWorkTime"] = self.averageWorkTime!
                }
                if self.callsAnswered != nil {
                    map["CallsAnswered"] = self.callsAnswered!
                }
                if self.callsAttendedTransferred != nil {
                    map["CallsAttendedTransferred"] = self.callsAttendedTransferred!
                }
                if self.callsBlindTransferred != nil {
                    map["CallsBlindTransferred"] = self.callsBlindTransferred!
                }
                if self.callsDialed != nil {
                    map["CallsDialed"] = self.callsDialed!
                }
                if self.callsHold != nil {
                    map["CallsHold"] = self.callsHold!
                }
                if self.callsRinged != nil {
                    map["CallsRinged"] = self.callsRinged!
                }
                if self.maxDialingTime != nil {
                    map["MaxDialingTime"] = self.maxDialingTime!
                }
                if self.maxHoldTime != nil {
                    map["MaxHoldTime"] = self.maxHoldTime!
                }
                if self.maxRingTime != nil {
                    map["MaxRingTime"] = self.maxRingTime!
                }
                if self.maxTalkTime != nil {
                    map["MaxTalkTime"] = self.maxTalkTime!
                }
                if self.maxWorkTime != nil {
                    map["MaxWorkTime"] = self.maxWorkTime!
                }
                if self.satisfactionIndex != nil {
                    map["SatisfactionIndex"] = self.satisfactionIndex!
                }
                if self.satisfactionRate != nil {
                    map["SatisfactionRate"] = self.satisfactionRate!
                }
                if self.satisfactionSurveysOffered != nil {
                    map["SatisfactionSurveysOffered"] = self.satisfactionSurveysOffered!
                }
                if self.satisfactionSurveysResponded != nil {
                    map["SatisfactionSurveysResponded"] = self.satisfactionSurveysResponded!
                }
                if self.totalDialingTime != nil {
                    map["TotalDialingTime"] = self.totalDialingTime!
                }
                if self.totalHoldTime != nil {
                    map["TotalHoldTime"] = self.totalHoldTime!
                }
                if self.totalRingTime != nil {
                    map["TotalRingTime"] = self.totalRingTime!
                }
                if self.totalTalkTime != nil {
                    map["TotalTalkTime"] = self.totalTalkTime!
                }
                if self.totalWorkTime != nil {
                    map["TotalWorkTime"] = self.totalWorkTime!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AnswerRate") {
                    self.answerRate = dict["AnswerRate"] as! Double
                }
                if dict.keys.contains("AverageDialingTime") {
                    self.averageDialingTime = dict["AverageDialingTime"] as! Double
                }
                if dict.keys.contains("AverageHoldTime") {
                    self.averageHoldTime = dict["AverageHoldTime"] as! Double
                }
                if dict.keys.contains("AverageRingTime") {
                    self.averageRingTime = dict["AverageRingTime"] as! Double
                }
                if dict.keys.contains("AverageTalkTime") {
                    self.averageTalkTime = dict["AverageTalkTime"] as! Double
                }
                if dict.keys.contains("AverageWorkTime") {
                    self.averageWorkTime = dict["AverageWorkTime"] as! Double
                }
                if dict.keys.contains("CallsAnswered") {
                    self.callsAnswered = dict["CallsAnswered"] as! Int64
                }
                if dict.keys.contains("CallsAttendedTransferred") {
                    self.callsAttendedTransferred = dict["CallsAttendedTransferred"] as! Int64
                }
                if dict.keys.contains("CallsBlindTransferred") {
                    self.callsBlindTransferred = dict["CallsBlindTransferred"] as! Int64
                }
                if dict.keys.contains("CallsDialed") {
                    self.callsDialed = dict["CallsDialed"] as! Int64
                }
                if dict.keys.contains("CallsHold") {
                    self.callsHold = dict["CallsHold"] as! Int32
                }
                if dict.keys.contains("CallsRinged") {
                    self.callsRinged = dict["CallsRinged"] as! Int64
                }
                if dict.keys.contains("MaxDialingTime") {
                    self.maxDialingTime = dict["MaxDialingTime"] as! Int64
                }
                if dict.keys.contains("MaxHoldTime") {
                    self.maxHoldTime = dict["MaxHoldTime"] as! Int64
                }
                if dict.keys.contains("MaxRingTime") {
                    self.maxRingTime = dict["MaxRingTime"] as! Int64
                }
                if dict.keys.contains("MaxTalkTime") {
                    self.maxTalkTime = dict["MaxTalkTime"] as! Int64
                }
                if dict.keys.contains("MaxWorkTime") {
                    self.maxWorkTime = dict["MaxWorkTime"] as! Int64
                }
                if dict.keys.contains("SatisfactionIndex") {
                    self.satisfactionIndex = dict["SatisfactionIndex"] as! Double
                }
                if dict.keys.contains("SatisfactionRate") {
                    self.satisfactionRate = dict["SatisfactionRate"] as! Double
                }
                if dict.keys.contains("SatisfactionSurveysOffered") {
                    self.satisfactionSurveysOffered = dict["SatisfactionSurveysOffered"] as! Int64
                }
                if dict.keys.contains("SatisfactionSurveysResponded") {
                    self.satisfactionSurveysResponded = dict["SatisfactionSurveysResponded"] as! Int64
                }
                if dict.keys.contains("TotalDialingTime") {
                    self.totalDialingTime = dict["TotalDialingTime"] as! Int64
                }
                if dict.keys.contains("TotalHoldTime") {
                    self.totalHoldTime = dict["TotalHoldTime"] as! Int64
                }
                if dict.keys.contains("TotalRingTime") {
                    self.totalRingTime = dict["TotalRingTime"] as! Int64
                }
                if dict.keys.contains("TotalTalkTime") {
                    self.totalTalkTime = dict["TotalTalkTime"] as! Int64
                }
                if dict.keys.contains("TotalWorkTime") {
                    self.totalWorkTime = dict["TotalWorkTime"] as! Int64
                }
            }
        }
        public class Overall : Tea.TeaModel {
            public var averageBreakTime: Double?

            public var averageHoldTime: Double?

            public var averageReadyTime: Double?

            public var averageTalkTime: Double?

            public var averageWorkTime: Double?

            public var maxBreakTime: Int64?

            public var maxHoldTime: Int64?

            public var maxLoggedInAgents: Int64?

            public var maxReadyTime: Int64?

            public var maxTalkTime: Int64?

            public var maxWorkTime: Int64?

            public var occupancyRate: Double?

            public var satisfactionIndex: Double?

            public var satisfactionRate: Double?

            public var satisfactionSurveysOffered: Int64?

            public var satisfactionSurveysResponded: Int64?

            public var totalBreakTime: Int64?

            public var totalCalls: Int64?

            public var totalHoldTime: Int64?

            public var totalLoggedInTime: Int64?

            public var totalReadyTime: Int64?

            public var totalTalkTime: Int64?

            public var totalWorkTime: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.averageBreakTime != nil {
                    map["AverageBreakTime"] = self.averageBreakTime!
                }
                if self.averageHoldTime != nil {
                    map["AverageHoldTime"] = self.averageHoldTime!
                }
                if self.averageReadyTime != nil {
                    map["AverageReadyTime"] = self.averageReadyTime!
                }
                if self.averageTalkTime != nil {
                    map["AverageTalkTime"] = self.averageTalkTime!
                }
                if self.averageWorkTime != nil {
                    map["AverageWorkTime"] = self.averageWorkTime!
                }
                if self.maxBreakTime != nil {
                    map["MaxBreakTime"] = self.maxBreakTime!
                }
                if self.maxHoldTime != nil {
                    map["MaxHoldTime"] = self.maxHoldTime!
                }
                if self.maxLoggedInAgents != nil {
                    map["MaxLoggedInAgents"] = self.maxLoggedInAgents!
                }
                if self.maxReadyTime != nil {
                    map["MaxReadyTime"] = self.maxReadyTime!
                }
                if self.maxTalkTime != nil {
                    map["MaxTalkTime"] = self.maxTalkTime!
                }
                if self.maxWorkTime != nil {
                    map["MaxWorkTime"] = self.maxWorkTime!
                }
                if self.occupancyRate != nil {
                    map["OccupancyRate"] = self.occupancyRate!
                }
                if self.satisfactionIndex != nil {
                    map["SatisfactionIndex"] = self.satisfactionIndex!
                }
                if self.satisfactionRate != nil {
                    map["SatisfactionRate"] = self.satisfactionRate!
                }
                if self.satisfactionSurveysOffered != nil {
                    map["SatisfactionSurveysOffered"] = self.satisfactionSurveysOffered!
                }
                if self.satisfactionSurveysResponded != nil {
                    map["SatisfactionSurveysResponded"] = self.satisfactionSurveysResponded!
                }
                if self.totalBreakTime != nil {
                    map["TotalBreakTime"] = self.totalBreakTime!
                }
                if self.totalCalls != nil {
                    map["TotalCalls"] = self.totalCalls!
                }
                if self.totalHoldTime != nil {
                    map["TotalHoldTime"] = self.totalHoldTime!
                }
                if self.totalLoggedInTime != nil {
                    map["TotalLoggedInTime"] = self.totalLoggedInTime!
                }
                if self.totalReadyTime != nil {
                    map["TotalReadyTime"] = self.totalReadyTime!
                }
                if self.totalTalkTime != nil {
                    map["TotalTalkTime"] = self.totalTalkTime!
                }
                if self.totalWorkTime != nil {
                    map["TotalWorkTime"] = self.totalWorkTime!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AverageBreakTime") {
                    self.averageBreakTime = dict["AverageBreakTime"] as! Double
                }
                if dict.keys.contains("AverageHoldTime") {
                    self.averageHoldTime = dict["AverageHoldTime"] as! Double
                }
                if dict.keys.contains("AverageReadyTime") {
                    self.averageReadyTime = dict["AverageReadyTime"] as! Double
                }
                if dict.keys.contains("AverageTalkTime") {
                    self.averageTalkTime = dict["AverageTalkTime"] as! Double
                }
                if dict.keys.contains("AverageWorkTime") {
                    self.averageWorkTime = dict["AverageWorkTime"] as! Double
                }
                if dict.keys.contains("MaxBreakTime") {
                    self.maxBreakTime = dict["MaxBreakTime"] as! Int64
                }
                if dict.keys.contains("MaxHoldTime") {
                    self.maxHoldTime = dict["MaxHoldTime"] as! Int64
                }
                if dict.keys.contains("MaxLoggedInAgents") {
                    self.maxLoggedInAgents = dict["MaxLoggedInAgents"] as! Int64
                }
                if dict.keys.contains("MaxReadyTime") {
                    self.maxReadyTime = dict["MaxReadyTime"] as! Int64
                }
                if dict.keys.contains("MaxTalkTime") {
                    self.maxTalkTime = dict["MaxTalkTime"] as! Int64
                }
                if dict.keys.contains("MaxWorkTime") {
                    self.maxWorkTime = dict["MaxWorkTime"] as! Int64
                }
                if dict.keys.contains("OccupancyRate") {
                    self.occupancyRate = dict["OccupancyRate"] as! Double
                }
                if dict.keys.contains("SatisfactionIndex") {
                    self.satisfactionIndex = dict["SatisfactionIndex"] as! Double
                }
                if dict.keys.contains("SatisfactionRate") {
                    self.satisfactionRate = dict["SatisfactionRate"] as! Double
                }
                if dict.keys.contains("SatisfactionSurveysOffered") {
                    self.satisfactionSurveysOffered = dict["SatisfactionSurveysOffered"] as! Int64
                }
                if dict.keys.contains("SatisfactionSurveysResponded") {
                    self.satisfactionSurveysResponded = dict["SatisfactionSurveysResponded"] as! Int64
                }
                if dict.keys.contains("TotalBreakTime") {
                    self.totalBreakTime = dict["TotalBreakTime"] as! Int64
                }
                if dict.keys.contains("TotalCalls") {
                    self.totalCalls = dict["TotalCalls"] as! Int64
                }
                if dict.keys.contains("TotalHoldTime") {
                    self.totalHoldTime = dict["TotalHoldTime"] as! Int64
                }
                if dict.keys.contains("TotalLoggedInTime") {
                    self.totalLoggedInTime = dict["TotalLoggedInTime"] as! Int64
                }
                if dict.keys.contains("TotalReadyTime") {
                    self.totalReadyTime = dict["TotalReadyTime"] as! Int64
                }
                if dict.keys.contains("TotalTalkTime") {
                    self.totalTalkTime = dict["TotalTalkTime"] as! Int64
                }
                if dict.keys.contains("TotalWorkTime") {
                    self.totalWorkTime = dict["TotalWorkTime"] as! Int64
                }
            }
        }
        public var inbound: GetHistoricalInstanceReportResponseBody.Data.Inbound?

        public var internal_: GetHistoricalInstanceReportResponseBody.Data.Internal_?

        public var outbound: GetHistoricalInstanceReportResponseBody.Data.Outbound?

        public var overall: GetHistoricalInstanceReportResponseBody.Data.Overall?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.inbound?.validate()
            try self.internal_?.validate()
            try self.outbound?.validate()
            try self.overall?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.inbound != nil {
                map["Inbound"] = self.inbound?.toMap()
            }
            if self.internal_ != nil {
                map["Internal"] = self.internal_?.toMap()
            }
            if self.outbound != nil {
                map["Outbound"] = self.outbound?.toMap()
            }
            if self.overall != nil {
                map["Overall"] = self.overall?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Inbound") {
                var model = GetHistoricalInstanceReportResponseBody.Data.Inbound()
                model.fromMap(dict["Inbound"] as! [String: Any])
                self.inbound = model
            }
            if dict.keys.contains("Internal") {
                var model = GetHistoricalInstanceReportResponseBody.Data.Internal_()
                model.fromMap(dict["Internal"] as! [String: Any])
                self.internal_ = model
            }
            if dict.keys.contains("Outbound") {
                var model = GetHistoricalInstanceReportResponseBody.Data.Outbound()
                model.fromMap(dict["Outbound"] as! [String: Any])
                self.outbound = model
            }
            if dict.keys.contains("Overall") {
                var model = GetHistoricalInstanceReportResponseBody.Data.Overall()
                model.fromMap(dict["Overall"] as! [String: Any])
                self.overall = model
            }
        }
    }
    public var code: String?

    public var data: GetHistoricalInstanceReportResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = GetHistoricalInstanceReportResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetHistoricalInstanceReportResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetHistoricalInstanceReportResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetHistoricalInstanceReportResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetInstanceRequest : Tea.TeaModel {
    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
    }
}

public class GetInstanceResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class AdminList : Tea.TeaModel {
            public var displayName: String?

            public var email: String?

            public var extension_: String?

            public var instanceId: String?

            public var loginName: String?

            public var mobile: String?

            public var roleId: String?

            public var roleName: String?

            public var userId: String?

            public var workMode: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.displayName != nil {
                    map["DisplayName"] = self.displayName!
                }
                if self.email != nil {
                    map["Email"] = self.email!
                }
                if self.extension_ != nil {
                    map["Extension"] = self.extension_!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.loginName != nil {
                    map["LoginName"] = self.loginName!
                }
                if self.mobile != nil {
                    map["Mobile"] = self.mobile!
                }
                if self.roleId != nil {
                    map["RoleId"] = self.roleId!
                }
                if self.roleName != nil {
                    map["RoleName"] = self.roleName!
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                if self.workMode != nil {
                    map["WorkMode"] = self.workMode!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DisplayName") {
                    self.displayName = dict["DisplayName"] as! String
                }
                if dict.keys.contains("Email") {
                    self.email = dict["Email"] as! String
                }
                if dict.keys.contains("Extension") {
                    self.extension_ = dict["Extension"] as! String
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("LoginName") {
                    self.loginName = dict["LoginName"] as! String
                }
                if dict.keys.contains("Mobile") {
                    self.mobile = dict["Mobile"] as! String
                }
                if dict.keys.contains("RoleId") {
                    self.roleId = dict["RoleId"] as! String
                }
                if dict.keys.contains("RoleName") {
                    self.roleName = dict["RoleName"] as! String
                }
                if dict.keys.contains("UserId") {
                    self.userId = dict["UserId"] as! String
                }
                if dict.keys.contains("WorkMode") {
                    self.workMode = dict["WorkMode"] as! String
                }
            }
        }
        public class NumberList : Tea.TeaModel {
            public class SkillGroups : Tea.TeaModel {
                public var description_: String?

                public var displayName: String?

                public var instanceId: String?

                public var name: String?

                public var phoneNumberCount: Int32?

                public var skillGroupId: String?

                public var userCount: Int32?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.displayName != nil {
                        map["DisplayName"] = self.displayName!
                    }
                    if self.instanceId != nil {
                        map["InstanceId"] = self.instanceId!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.phoneNumberCount != nil {
                        map["PhoneNumberCount"] = self.phoneNumberCount!
                    }
                    if self.skillGroupId != nil {
                        map["SkillGroupId"] = self.skillGroupId!
                    }
                    if self.userCount != nil {
                        map["UserCount"] = self.userCount!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("DisplayName") {
                        self.displayName = dict["DisplayName"] as! String
                    }
                    if dict.keys.contains("InstanceId") {
                        self.instanceId = dict["InstanceId"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("PhoneNumberCount") {
                        self.phoneNumberCount = dict["PhoneNumberCount"] as! Int32
                    }
                    if dict.keys.contains("SkillGroupId") {
                        self.skillGroupId = dict["SkillGroupId"] as! String
                    }
                    if dict.keys.contains("UserCount") {
                        self.userCount = dict["UserCount"] as! Int32
                    }
                }
            }
            public var active: Bool?

            public var city: String?

            public var contactFlowId: String?

            public var instanceId: String?

            public var number: String?

            public var province: String?

            public var skillGroups: [GetInstanceResponseBody.Data.NumberList.SkillGroups]?

            public var usage: String?

            public var userId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.active != nil {
                    map["Active"] = self.active!
                }
                if self.city != nil {
                    map["City"] = self.city!
                }
                if self.contactFlowId != nil {
                    map["ContactFlowId"] = self.contactFlowId!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.number != nil {
                    map["Number"] = self.number!
                }
                if self.province != nil {
                    map["Province"] = self.province!
                }
                if self.skillGroups != nil {
                    var tmp : [Any] = []
                    for k in self.skillGroups! {
                        tmp.append(k.toMap())
                    }
                    map["SkillGroups"] = tmp
                }
                if self.usage != nil {
                    map["Usage"] = self.usage!
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Active") {
                    self.active = dict["Active"] as! Bool
                }
                if dict.keys.contains("City") {
                    self.city = dict["City"] as! String
                }
                if dict.keys.contains("ContactFlowId") {
                    self.contactFlowId = dict["ContactFlowId"] as! String
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("Number") {
                    self.number = dict["Number"] as! String
                }
                if dict.keys.contains("Province") {
                    self.province = dict["Province"] as! String
                }
                if dict.keys.contains("SkillGroups") {
                    var tmp : [GetInstanceResponseBody.Data.NumberList.SkillGroups] = []
                    for v in dict["SkillGroups"] as! [Any] {
                        var model = GetInstanceResponseBody.Data.NumberList.SkillGroups()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.skillGroups = tmp
                }
                if dict.keys.contains("Usage") {
                    self.usage = dict["Usage"] as! String
                }
                if dict.keys.contains("UserId") {
                    self.userId = dict["UserId"] as! String
                }
            }
        }
        public var adminList: [GetInstanceResponseBody.Data.AdminList]?

        public var aliyunUid: String?

        public var consoleUrl: String?

        public var description_: String?

        public var domainName: String?

        public var id: String?

        public var name: String?

        public var numberList: [GetInstanceResponseBody.Data.NumberList]?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.adminList != nil {
                var tmp : [Any] = []
                for k in self.adminList! {
                    tmp.append(k.toMap())
                }
                map["AdminList"] = tmp
            }
            if self.aliyunUid != nil {
                map["AliyunUid"] = self.aliyunUid!
            }
            if self.consoleUrl != nil {
                map["ConsoleUrl"] = self.consoleUrl!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.domainName != nil {
                map["DomainName"] = self.domainName!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.numberList != nil {
                var tmp : [Any] = []
                for k in self.numberList! {
                    tmp.append(k.toMap())
                }
                map["NumberList"] = tmp
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AdminList") {
                var tmp : [GetInstanceResponseBody.Data.AdminList] = []
                for v in dict["AdminList"] as! [Any] {
                    var model = GetInstanceResponseBody.Data.AdminList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.adminList = tmp
            }
            if dict.keys.contains("AliyunUid") {
                self.aliyunUid = dict["AliyunUid"] as! String
            }
            if dict.keys.contains("ConsoleUrl") {
                self.consoleUrl = dict["ConsoleUrl"] as! String
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("DomainName") {
                self.domainName = dict["DomainName"] as! String
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("NumberList") {
                var tmp : [GetInstanceResponseBody.Data.NumberList] = []
                for v in dict["NumberList"] as! [Any] {
                    var model = GetInstanceResponseBody.Data.NumberList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.numberList = tmp
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
        }
    }
    public var code: String?

    public var data: GetInstanceResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = GetInstanceResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetInstanceTrendingReportRequest : Tea.TeaModel {
    public var endTime: Int64?

    public var instanceId: String?

    public var mediaType: String?

    public var startTime: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.mediaType != nil {
            map["MediaType"] = self.mediaType!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("MediaType") {
            self.mediaType = dict["MediaType"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! Int64
        }
    }
}

public class GetInstanceTrendingReportResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Inbound : Tea.TeaModel {
            public var callsAbandonedInIVR: Int64?

            public var callsAbandonedInQueue: Int64?

            public var callsAbandonedInRing: Int64?

            public var callsHandled: Int64?

            public var callsQueued: Int64?

            public var statsTime: Int64?

            public var totalCalls: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.callsAbandonedInIVR != nil {
                    map["CallsAbandonedInIVR"] = self.callsAbandonedInIVR!
                }
                if self.callsAbandonedInQueue != nil {
                    map["CallsAbandonedInQueue"] = self.callsAbandonedInQueue!
                }
                if self.callsAbandonedInRing != nil {
                    map["CallsAbandonedInRing"] = self.callsAbandonedInRing!
                }
                if self.callsHandled != nil {
                    map["CallsHandled"] = self.callsHandled!
                }
                if self.callsQueued != nil {
                    map["CallsQueued"] = self.callsQueued!
                }
                if self.statsTime != nil {
                    map["StatsTime"] = self.statsTime!
                }
                if self.totalCalls != nil {
                    map["TotalCalls"] = self.totalCalls!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CallsAbandonedInIVR") {
                    self.callsAbandonedInIVR = dict["CallsAbandonedInIVR"] as! Int64
                }
                if dict.keys.contains("CallsAbandonedInQueue") {
                    self.callsAbandonedInQueue = dict["CallsAbandonedInQueue"] as! Int64
                }
                if dict.keys.contains("CallsAbandonedInRing") {
                    self.callsAbandonedInRing = dict["CallsAbandonedInRing"] as! Int64
                }
                if dict.keys.contains("CallsHandled") {
                    self.callsHandled = dict["CallsHandled"] as! Int64
                }
                if dict.keys.contains("CallsQueued") {
                    self.callsQueued = dict["CallsQueued"] as! Int64
                }
                if dict.keys.contains("StatsTime") {
                    self.statsTime = dict["StatsTime"] as! Int64
                }
                if dict.keys.contains("TotalCalls") {
                    self.totalCalls = dict["TotalCalls"] as! Int64
                }
            }
        }
        public class Outbound : Tea.TeaModel {
            public var callsAnswered: Int64?

            public var statsTime: Int64?

            public var totalCalls: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.callsAnswered != nil {
                    map["CallsAnswered"] = self.callsAnswered!
                }
                if self.statsTime != nil {
                    map["StatsTime"] = self.statsTime!
                }
                if self.totalCalls != nil {
                    map["TotalCalls"] = self.totalCalls!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CallsAnswered") {
                    self.callsAnswered = dict["CallsAnswered"] as! Int64
                }
                if dict.keys.contains("StatsTime") {
                    self.statsTime = dict["StatsTime"] as! Int64
                }
                if dict.keys.contains("TotalCalls") {
                    self.totalCalls = dict["TotalCalls"] as! Int64
                }
            }
        }
        public class Overall : Tea.TeaModel {
            public var maxLoggedInAgents: Int64?

            public var statsTime: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.maxLoggedInAgents != nil {
                    map["MaxLoggedInAgents"] = self.maxLoggedInAgents!
                }
                if self.statsTime != nil {
                    map["StatsTime"] = self.statsTime!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("MaxLoggedInAgents") {
                    self.maxLoggedInAgents = dict["MaxLoggedInAgents"] as! Int64
                }
                if dict.keys.contains("StatsTime") {
                    self.statsTime = dict["StatsTime"] as! Int64
                }
            }
        }
        public var inbound: [GetInstanceTrendingReportResponseBody.Data.Inbound]?

        public var outbound: [GetInstanceTrendingReportResponseBody.Data.Outbound]?

        public var overall: [GetInstanceTrendingReportResponseBody.Data.Overall]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.inbound != nil {
                var tmp : [Any] = []
                for k in self.inbound! {
                    tmp.append(k.toMap())
                }
                map["Inbound"] = tmp
            }
            if self.outbound != nil {
                var tmp : [Any] = []
                for k in self.outbound! {
                    tmp.append(k.toMap())
                }
                map["Outbound"] = tmp
            }
            if self.overall != nil {
                var tmp : [Any] = []
                for k in self.overall! {
                    tmp.append(k.toMap())
                }
                map["Overall"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Inbound") {
                var tmp : [GetInstanceTrendingReportResponseBody.Data.Inbound] = []
                for v in dict["Inbound"] as! [Any] {
                    var model = GetInstanceTrendingReportResponseBody.Data.Inbound()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.inbound = tmp
            }
            if dict.keys.contains("Outbound") {
                var tmp : [GetInstanceTrendingReportResponseBody.Data.Outbound] = []
                for v in dict["Outbound"] as! [Any] {
                    var model = GetInstanceTrendingReportResponseBody.Data.Outbound()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.outbound = tmp
            }
            if dict.keys.contains("Overall") {
                var tmp : [GetInstanceTrendingReportResponseBody.Data.Overall] = []
                for v in dict["Overall"] as! [Any] {
                    var model = GetInstanceTrendingReportResponseBody.Data.Overall()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.overall = tmp
            }
        }
    }
    public var code: String?

    public var data: GetInstanceTrendingReportResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = GetInstanceTrendingReportResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetInstanceTrendingReportResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetInstanceTrendingReportResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetInstanceTrendingReportResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetLoginDetailsRequest : Tea.TeaModel {
    public var chatDeviceId: String?

    public var instanceId: String?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.chatDeviceId != nil {
            map["ChatDeviceId"] = self.chatDeviceId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ChatDeviceId") {
            self.chatDeviceId = dict["ChatDeviceId"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("UserId") {
            self.userId = dict["UserId"] as! String
        }
    }
}

public class GetLoginDetailsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var agentServerUrl: String?

        public var avatarUrl: String?

        public var chatAppId: String?

        public var chatAppKey: String?

        public var chatDeviceId: String?

        public var chatLoginToken: String?

        public var chatServerUrl: String?

        public var chatUserId: String?

        public var deviceExt: String?

        public var deviceId: String?

        public var deviceState: String?

        public var displayName: String?

        public var extension_: String?

        public var nickname: String?

        public var signature: String?

        public var signature2: String?

        public var sipServerUrl: String?

        public var userId: String?

        public var userKey: String?

        public var userKey2: String?

        public var workMode: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.agentServerUrl != nil {
                map["AgentServerUrl"] = self.agentServerUrl!
            }
            if self.avatarUrl != nil {
                map["AvatarUrl"] = self.avatarUrl!
            }
            if self.chatAppId != nil {
                map["ChatAppId"] = self.chatAppId!
            }
            if self.chatAppKey != nil {
                map["ChatAppKey"] = self.chatAppKey!
            }
            if self.chatDeviceId != nil {
                map["ChatDeviceId"] = self.chatDeviceId!
            }
            if self.chatLoginToken != nil {
                map["ChatLoginToken"] = self.chatLoginToken!
            }
            if self.chatServerUrl != nil {
                map["ChatServerUrl"] = self.chatServerUrl!
            }
            if self.chatUserId != nil {
                map["ChatUserId"] = self.chatUserId!
            }
            if self.deviceExt != nil {
                map["DeviceExt"] = self.deviceExt!
            }
            if self.deviceId != nil {
                map["DeviceId"] = self.deviceId!
            }
            if self.deviceState != nil {
                map["DeviceState"] = self.deviceState!
            }
            if self.displayName != nil {
                map["DisplayName"] = self.displayName!
            }
            if self.extension_ != nil {
                map["Extension"] = self.extension_!
            }
            if self.nickname != nil {
                map["Nickname"] = self.nickname!
            }
            if self.signature != nil {
                map["Signature"] = self.signature!
            }
            if self.signature2 != nil {
                map["Signature2"] = self.signature2!
            }
            if self.sipServerUrl != nil {
                map["SipServerUrl"] = self.sipServerUrl!
            }
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            if self.userKey != nil {
                map["UserKey"] = self.userKey!
            }
            if self.userKey2 != nil {
                map["UserKey2"] = self.userKey2!
            }
            if self.workMode != nil {
                map["WorkMode"] = self.workMode!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AgentServerUrl") {
                self.agentServerUrl = dict["AgentServerUrl"] as! String
            }
            if dict.keys.contains("AvatarUrl") {
                self.avatarUrl = dict["AvatarUrl"] as! String
            }
            if dict.keys.contains("ChatAppId") {
                self.chatAppId = dict["ChatAppId"] as! String
            }
            if dict.keys.contains("ChatAppKey") {
                self.chatAppKey = dict["ChatAppKey"] as! String
            }
            if dict.keys.contains("ChatDeviceId") {
                self.chatDeviceId = dict["ChatDeviceId"] as! String
            }
            if dict.keys.contains("ChatLoginToken") {
                self.chatLoginToken = dict["ChatLoginToken"] as! String
            }
            if dict.keys.contains("ChatServerUrl") {
                self.chatServerUrl = dict["ChatServerUrl"] as! String
            }
            if dict.keys.contains("ChatUserId") {
                self.chatUserId = dict["ChatUserId"] as! String
            }
            if dict.keys.contains("DeviceExt") {
                self.deviceExt = dict["DeviceExt"] as! String
            }
            if dict.keys.contains("DeviceId") {
                self.deviceId = dict["DeviceId"] as! String
            }
            if dict.keys.contains("DeviceState") {
                self.deviceState = dict["DeviceState"] as! String
            }
            if dict.keys.contains("DisplayName") {
                self.displayName = dict["DisplayName"] as! String
            }
            if dict.keys.contains("Extension") {
                self.extension_ = dict["Extension"] as! String
            }
            if dict.keys.contains("Nickname") {
                self.nickname = dict["Nickname"] as! String
            }
            if dict.keys.contains("Signature") {
                self.signature = dict["Signature"] as! String
            }
            if dict.keys.contains("Signature2") {
                self.signature2 = dict["Signature2"] as! String
            }
            if dict.keys.contains("SipServerUrl") {
                self.sipServerUrl = dict["SipServerUrl"] as! String
            }
            if dict.keys.contains("UserId") {
                self.userId = dict["UserId"] as! String
            }
            if dict.keys.contains("UserKey") {
                self.userKey = dict["UserKey"] as! String
            }
            if dict.keys.contains("UserKey2") {
                self.userKey2 = dict["UserKey2"] as! String
            }
            if dict.keys.contains("WorkMode") {
                self.workMode = dict["WorkMode"] as! String
            }
        }
    }
    public var code: String?

    public var data: GetLoginDetailsResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var params: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.params != nil {
            map["Params"] = self.params!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = GetLoginDetailsResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Params") {
            self.params = dict["Params"] as! [String]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetLoginDetailsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetLoginDetailsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetLoginDetailsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetMonoRecordingRequest : Tea.TeaModel {
    public var contactId: String?

    public var expireSeconds: Int64?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.contactId != nil {
            map["ContactId"] = self.contactId!
        }
        if self.expireSeconds != nil {
            map["ExpireSeconds"] = self.expireSeconds!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ContactId") {
            self.contactId = dict["ContactId"] as! String
        }
        if dict.keys.contains("ExpireSeconds") {
            self.expireSeconds = dict["ExpireSeconds"] as! Int64
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
    }
}

public class GetMonoRecordingResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var duration: Int64?

        public var fileName: String?

        public var fileUrl: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.duration != nil {
                map["Duration"] = self.duration!
            }
            if self.fileName != nil {
                map["FileName"] = self.fileName!
            }
            if self.fileUrl != nil {
                map["FileUrl"] = self.fileUrl!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Duration") {
                self.duration = dict["Duration"] as! Int64
            }
            if dict.keys.contains("FileName") {
                self.fileName = dict["FileName"] as! String
            }
            if dict.keys.contains("FileUrl") {
                self.fileUrl = dict["FileUrl"] as! String
            }
        }
    }
    public var code: String?

    public var data: GetMonoRecordingResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = GetMonoRecordingResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetMonoRecordingResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetMonoRecordingResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetMonoRecordingResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetMultiChannelRecordingRequest : Tea.TeaModel {
    public var contactId: String?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.contactId != nil {
            map["ContactId"] = self.contactId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ContactId") {
            self.contactId = dict["ContactId"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
    }
}

public class GetMultiChannelRecordingResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var fileName: String?

        public var fileUrl: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.fileName != nil {
                map["FileName"] = self.fileName!
            }
            if self.fileUrl != nil {
                map["FileUrl"] = self.fileUrl!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("FileName") {
                self.fileName = dict["FileName"] as! String
            }
            if dict.keys.contains("FileUrl") {
                self.fileUrl = dict["FileUrl"] as! String
            }
        }
    }
    public var code: String?

    public var data: GetMultiChannelRecordingResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = GetMultiChannelRecordingResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetMultiChannelRecordingResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetMultiChannelRecordingResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetMultiChannelRecordingResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetNumberLocationRequest : Tea.TeaModel {
    public var instanceId: String?

    public var number: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.number != nil {
            map["Number"] = self.number!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Number") {
            self.number = dict["Number"] as! String
        }
    }
}

public class GetNumberLocationResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var city: String?

        public var number: String?

        public var province: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.city != nil {
                map["City"] = self.city!
            }
            if self.number != nil {
                map["Number"] = self.number!
            }
            if self.province != nil {
                map["Province"] = self.province!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("City") {
                self.city = dict["City"] as! String
            }
            if dict.keys.contains("Number") {
                self.number = dict["Number"] as! String
            }
            if dict.keys.contains("Province") {
                self.province = dict["Province"] as! String
            }
        }
    }
    public var code: String?

    public var data: GetNumberLocationResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = GetNumberLocationResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetNumberLocationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetNumberLocationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetNumberLocationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetRealtimeCampaignStatsRequest : Tea.TeaModel {
    public var instanceId: String?

    public var queueId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.queueId != nil {
            map["QueueId"] = self.queueId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("QueueId") {
            self.queueId = dict["QueueId"] as! String
        }
    }
}

public class GetRealtimeCampaignStatsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var breakingAgents: Int64?

        public var caps: Int64?

        public var loggedInAgents: Int64?

        public var outboundScenarioBreakingAgents: Int64?

        public var outboundScenarioReadyAgents: Int64?

        public var outboundScenarioTalkingAgents: Int64?

        public var outboundScenarioWorkingAgents: Int64?

        public var readyAgents: Int64?

        public var talkingAgents: Int64?

        public var totalAgents: Int64?

        public var workingAgents: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.breakingAgents != nil {
                map["BreakingAgents"] = self.breakingAgents!
            }
            if self.caps != nil {
                map["Caps"] = self.caps!
            }
            if self.loggedInAgents != nil {
                map["LoggedInAgents"] = self.loggedInAgents!
            }
            if self.outboundScenarioBreakingAgents != nil {
                map["OutboundScenarioBreakingAgents"] = self.outboundScenarioBreakingAgents!
            }
            if self.outboundScenarioReadyAgents != nil {
                map["OutboundScenarioReadyAgents"] = self.outboundScenarioReadyAgents!
            }
            if self.outboundScenarioTalkingAgents != nil {
                map["OutboundScenarioTalkingAgents"] = self.outboundScenarioTalkingAgents!
            }
            if self.outboundScenarioWorkingAgents != nil {
                map["OutboundScenarioWorkingAgents"] = self.outboundScenarioWorkingAgents!
            }
            if self.readyAgents != nil {
                map["ReadyAgents"] = self.readyAgents!
            }
            if self.talkingAgents != nil {
                map["TalkingAgents"] = self.talkingAgents!
            }
            if self.totalAgents != nil {
                map["TotalAgents"] = self.totalAgents!
            }
            if self.workingAgents != nil {
                map["WorkingAgents"] = self.workingAgents!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BreakingAgents") {
                self.breakingAgents = dict["BreakingAgents"] as! Int64
            }
            if dict.keys.contains("Caps") {
                self.caps = dict["Caps"] as! Int64
            }
            if dict.keys.contains("LoggedInAgents") {
                self.loggedInAgents = dict["LoggedInAgents"] as! Int64
            }
            if dict.keys.contains("OutboundScenarioBreakingAgents") {
                self.outboundScenarioBreakingAgents = dict["OutboundScenarioBreakingAgents"] as! Int64
            }
            if dict.keys.contains("OutboundScenarioReadyAgents") {
                self.outboundScenarioReadyAgents = dict["OutboundScenarioReadyAgents"] as! Int64
            }
            if dict.keys.contains("OutboundScenarioTalkingAgents") {
                self.outboundScenarioTalkingAgents = dict["OutboundScenarioTalkingAgents"] as! Int64
            }
            if dict.keys.contains("OutboundScenarioWorkingAgents") {
                self.outboundScenarioWorkingAgents = dict["OutboundScenarioWorkingAgents"] as! Int64
            }
            if dict.keys.contains("ReadyAgents") {
                self.readyAgents = dict["ReadyAgents"] as! Int64
            }
            if dict.keys.contains("TalkingAgents") {
                self.talkingAgents = dict["TalkingAgents"] as! Int64
            }
            if dict.keys.contains("TotalAgents") {
                self.totalAgents = dict["TotalAgents"] as! Int64
            }
            if dict.keys.contains("WorkingAgents") {
                self.workingAgents = dict["WorkingAgents"] as! Int64
            }
        }
    }
    public var code: String?

    public var data: GetRealtimeCampaignStatsResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = GetRealtimeCampaignStatsResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetRealtimeCampaignStatsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetRealtimeCampaignStatsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetRealtimeCampaignStatsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetRealtimeInstanceStatesRequest : Tea.TeaModel {
    public var instanceId: String?

    public var mediaType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.mediaType != nil {
            map["MediaType"] = self.mediaType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("MediaType") {
            self.mediaType = dict["MediaType"] as! String
        }
    }
}

public class GetRealtimeInstanceStatesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class BreakCodeDetailList : Tea.TeaModel {
            public var breakCode: String?

            public var count: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.breakCode != nil {
                    map["BreakCode"] = self.breakCode!
                }
                if self.count != nil {
                    map["Count"] = self.count!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BreakCode") {
                    self.breakCode = dict["BreakCode"] as! String
                }
                if dict.keys.contains("Count") {
                    self.count = dict["Count"] as! Int64
                }
            }
        }
        public var breakCodeDetailList: [GetRealtimeInstanceStatesResponseBody.Data.BreakCodeDetailList]?

        public var breakingAgents: Int64?

        public var instanceId: String?

        public var interactiveCalls: Int64?

        public var loggedInAgents: Int64?

        public var longestWaitingTime: Int64?

        public var readyAgents: Int64?

        public var talkingAgents: Int64?

        public var totalAgents: Int64?

        public var waitingCalls: Int64?

        public var workingAgents: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.breakCodeDetailList != nil {
                var tmp : [Any] = []
                for k in self.breakCodeDetailList! {
                    tmp.append(k.toMap())
                }
                map["BreakCodeDetailList"] = tmp
            }
            if self.breakingAgents != nil {
                map["BreakingAgents"] = self.breakingAgents!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.interactiveCalls != nil {
                map["InteractiveCalls"] = self.interactiveCalls!
            }
            if self.loggedInAgents != nil {
                map["LoggedInAgents"] = self.loggedInAgents!
            }
            if self.longestWaitingTime != nil {
                map["LongestWaitingTime"] = self.longestWaitingTime!
            }
            if self.readyAgents != nil {
                map["ReadyAgents"] = self.readyAgents!
            }
            if self.talkingAgents != nil {
                map["TalkingAgents"] = self.talkingAgents!
            }
            if self.totalAgents != nil {
                map["TotalAgents"] = self.totalAgents!
            }
            if self.waitingCalls != nil {
                map["WaitingCalls"] = self.waitingCalls!
            }
            if self.workingAgents != nil {
                map["WorkingAgents"] = self.workingAgents!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BreakCodeDetailList") {
                var tmp : [GetRealtimeInstanceStatesResponseBody.Data.BreakCodeDetailList] = []
                for v in dict["BreakCodeDetailList"] as! [Any] {
                    var model = GetRealtimeInstanceStatesResponseBody.Data.BreakCodeDetailList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.breakCodeDetailList = tmp
            }
            if dict.keys.contains("BreakingAgents") {
                self.breakingAgents = dict["BreakingAgents"] as! Int64
            }
            if dict.keys.contains("InstanceId") {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("InteractiveCalls") {
                self.interactiveCalls = dict["InteractiveCalls"] as! Int64
            }
            if dict.keys.contains("LoggedInAgents") {
                self.loggedInAgents = dict["LoggedInAgents"] as! Int64
            }
            if dict.keys.contains("LongestWaitingTime") {
                self.longestWaitingTime = dict["LongestWaitingTime"] as! Int64
            }
            if dict.keys.contains("ReadyAgents") {
                self.readyAgents = dict["ReadyAgents"] as! Int64
            }
            if dict.keys.contains("TalkingAgents") {
                self.talkingAgents = dict["TalkingAgents"] as! Int64
            }
            if dict.keys.contains("TotalAgents") {
                self.totalAgents = dict["TotalAgents"] as! Int64
            }
            if dict.keys.contains("WaitingCalls") {
                self.waitingCalls = dict["WaitingCalls"] as! Int64
            }
            if dict.keys.contains("WorkingAgents") {
                self.workingAgents = dict["WorkingAgents"] as! Int64
            }
        }
    }
    public var code: String?

    public var data: GetRealtimeInstanceStatesResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = GetRealtimeInstanceStatesResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetRealtimeInstanceStatesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetRealtimeInstanceStatesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetRealtimeInstanceStatesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetSchemaRequest : Tea.TeaModel {
    public var instanceId: String?

    public var requestId: String?

    public var schemaId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.schemaId != nil {
            map["SchemaId"] = self.schemaId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SchemaId") {
            self.schemaId = dict["SchemaId"] as! String
        }
    }
}

public class GetSchemaResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var createdTime: String?

        public var deleted: Bool?

        public var description_: String?

        public var id: String?

        public var instanceId: String?

        public var properties: [String: DataPropertiesValue]?

        public var updatedTime: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createdTime != nil {
                map["CreatedTime"] = self.createdTime!
            }
            if self.deleted != nil {
                map["Deleted"] = self.deleted!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.properties != nil {
                var tmp : [String: Any] = [:]
                for (k, v) in self.properties! {
                    tmp[k] = v.toMap()
                }
                map["Properties"] = tmp
            }
            if self.updatedTime != nil {
                map["UpdatedTime"] = self.updatedTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreatedTime") {
                self.createdTime = dict["CreatedTime"] as! String
            }
            if dict.keys.contains("Deleted") {
                self.deleted = dict["Deleted"] as! Bool
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! String
            }
            if dict.keys.contains("InstanceId") {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("Properties") {
                var tmp : [String: DataPropertiesValue] = [:]
                for (k, v) in dict["Properties"] as! [String: Any] {
                    if v != nil {
                        var model = DataPropertiesValue()
                        model.fromMap(v as! [String: Any])
                        tmp[k] = model
                    }
                }
                self.properties = tmp
            }
            if dict.keys.contains("UpdatedTime") {
                self.updatedTime = dict["UpdatedTime"] as! String
            }
        }
    }
    public var code: String?

    public var data: GetSchemaResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var params: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.params != nil {
            map["Params"] = self.params!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = GetSchemaResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Params") {
            self.params = dict["Params"] as! [String]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetSchemaResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetSchemaResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetSchemaResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetSkillGroupRequest : Tea.TeaModel {
    public var instanceId: String?

    public var skillGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.skillGroupId != nil {
            map["SkillGroupId"] = self.skillGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("SkillGroupId") {
            self.skillGroupId = dict["SkillGroupId"] as! String
        }
    }
}

public class GetSkillGroupResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var description_: String?

        public var displayName: String?

        public var instanceId: String?

        public var mediaType: String?

        public var name: String?

        public var skillGroupId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.displayName != nil {
                map["DisplayName"] = self.displayName!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.mediaType != nil {
                map["MediaType"] = self.mediaType!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.skillGroupId != nil {
                map["SkillGroupId"] = self.skillGroupId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("DisplayName") {
                self.displayName = dict["DisplayName"] as! String
            }
            if dict.keys.contains("InstanceId") {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("MediaType") {
                self.mediaType = dict["MediaType"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("SkillGroupId") {
                self.skillGroupId = dict["SkillGroupId"] as! String
            }
        }
    }
    public var code: String?

    public var data: GetSkillGroupResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = GetSkillGroupResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetSkillGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetSkillGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetSkillGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetTicketRequest : Tea.TeaModel {
    public var instanceId: String?

    public var ticketId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.ticketId != nil {
            map["TicketId"] = self.ticketId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("TicketId") {
            self.ticketId = dict["TicketId"] as! String
        }
    }
}

public class GetTicketResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var assignee: String?

        public var assigneeName: String?

        public var categoryId: String?

        public var categoryName: String?

        public var closeCode: String?

        public var comment: String?

        public var context: String?

        public var createdTime: Int64?

        public var creator: String?

        public var creatorName: String?

        public var currentTaskId: String?

        public var currentTaskName: String?

        public var currentTaskStartTime: Int64?

        public var customerId: String?

        public var endTime: Int64?

        public var instanceId: String?

        public var jobId: String?

        public var source: String?

        public var startTime: Int64?

        public var state: String?

        public var templateId: String?

        public var templateVersion: String?

        public var ticketId: String?

        public var title: String?

        public var updatedTime: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.assignee != nil {
                map["Assignee"] = self.assignee!
            }
            if self.assigneeName != nil {
                map["AssigneeName"] = self.assigneeName!
            }
            if self.categoryId != nil {
                map["CategoryId"] = self.categoryId!
            }
            if self.categoryName != nil {
                map["CategoryName"] = self.categoryName!
            }
            if self.closeCode != nil {
                map["CloseCode"] = self.closeCode!
            }
            if self.comment != nil {
                map["Comment"] = self.comment!
            }
            if self.context != nil {
                map["Context"] = self.context!
            }
            if self.createdTime != nil {
                map["CreatedTime"] = self.createdTime!
            }
            if self.creator != nil {
                map["Creator"] = self.creator!
            }
            if self.creatorName != nil {
                map["CreatorName"] = self.creatorName!
            }
            if self.currentTaskId != nil {
                map["CurrentTaskId"] = self.currentTaskId!
            }
            if self.currentTaskName != nil {
                map["CurrentTaskName"] = self.currentTaskName!
            }
            if self.currentTaskStartTime != nil {
                map["CurrentTaskStartTime"] = self.currentTaskStartTime!
            }
            if self.customerId != nil {
                map["CustomerId"] = self.customerId!
            }
            if self.endTime != nil {
                map["EndTime"] = self.endTime!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            if self.source != nil {
                map["Source"] = self.source!
            }
            if self.startTime != nil {
                map["StartTime"] = self.startTime!
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            if self.templateId != nil {
                map["TemplateId"] = self.templateId!
            }
            if self.templateVersion != nil {
                map["TemplateVersion"] = self.templateVersion!
            }
            if self.ticketId != nil {
                map["TicketId"] = self.ticketId!
            }
            if self.title != nil {
                map["Title"] = self.title!
            }
            if self.updatedTime != nil {
                map["UpdatedTime"] = self.updatedTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Assignee") {
                self.assignee = dict["Assignee"] as! String
            }
            if dict.keys.contains("AssigneeName") {
                self.assigneeName = dict["AssigneeName"] as! String
            }
            if dict.keys.contains("CategoryId") {
                self.categoryId = dict["CategoryId"] as! String
            }
            if dict.keys.contains("CategoryName") {
                self.categoryName = dict["CategoryName"] as! String
            }
            if dict.keys.contains("CloseCode") {
                self.closeCode = dict["CloseCode"] as! String
            }
            if dict.keys.contains("Comment") {
                self.comment = dict["Comment"] as! String
            }
            if dict.keys.contains("Context") {
                self.context = dict["Context"] as! String
            }
            if dict.keys.contains("CreatedTime") {
                self.createdTime = dict["CreatedTime"] as! Int64
            }
            if dict.keys.contains("Creator") {
                self.creator = dict["Creator"] as! String
            }
            if dict.keys.contains("CreatorName") {
                self.creatorName = dict["CreatorName"] as! String
            }
            if dict.keys.contains("CurrentTaskId") {
                self.currentTaskId = dict["CurrentTaskId"] as! String
            }
            if dict.keys.contains("CurrentTaskName") {
                self.currentTaskName = dict["CurrentTaskName"] as! String
            }
            if dict.keys.contains("CurrentTaskStartTime") {
                self.currentTaskStartTime = dict["CurrentTaskStartTime"] as! Int64
            }
            if dict.keys.contains("CustomerId") {
                self.customerId = dict["CustomerId"] as! String
            }
            if dict.keys.contains("EndTime") {
                self.endTime = dict["EndTime"] as! Int64
            }
            if dict.keys.contains("InstanceId") {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("JobId") {
                self.jobId = dict["JobId"] as! String
            }
            if dict.keys.contains("Source") {
                self.source = dict["Source"] as! String
            }
            if dict.keys.contains("StartTime") {
                self.startTime = dict["StartTime"] as! Int64
            }
            if dict.keys.contains("State") {
                self.state = dict["State"] as! String
            }
            if dict.keys.contains("TemplateId") {
                self.templateId = dict["TemplateId"] as! String
            }
            if dict.keys.contains("TemplateVersion") {
                self.templateVersion = dict["TemplateVersion"] as! String
            }
            if dict.keys.contains("TicketId") {
                self.ticketId = dict["TicketId"] as! String
            }
            if dict.keys.contains("Title") {
                self.title = dict["Title"] as! String
            }
            if dict.keys.contains("UpdatedTime") {
                self.updatedTime = dict["UpdatedTime"] as! Int64
            }
        }
    }
    public var code: String?

    public var data: GetTicketResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var params: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.params != nil {
            map["Params"] = self.params!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = GetTicketResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Params") {
            self.params = dict["Params"] as! [String]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetTicketResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetTicketResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetTicketResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetTicketSummaryReportRequest : Tea.TeaModel {
    public var assignee: String?

    public var assigneeType: String?

    public var categoryId: String?

    public var creator: String?

    public var endTime: Int64?

    public var instanceId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var participant: String?

    public var startTime: Int64?

    public var state: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.assignee != nil {
            map["Assignee"] = self.assignee!
        }
        if self.assigneeType != nil {
            map["AssigneeType"] = self.assigneeType!
        }
        if self.categoryId != nil {
            map["CategoryId"] = self.categoryId!
        }
        if self.creator != nil {
            map["Creator"] = self.creator!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.participant != nil {
            map["Participant"] = self.participant!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.state != nil {
            map["State"] = self.state!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Assignee") {
            self.assignee = dict["Assignee"] as! String
        }
        if dict.keys.contains("AssigneeType") {
            self.assigneeType = dict["AssigneeType"] as! String
        }
        if dict.keys.contains("CategoryId") {
            self.categoryId = dict["CategoryId"] as! String
        }
        if dict.keys.contains("Creator") {
            self.creator = dict["Creator"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("Participant") {
            self.participant = dict["Participant"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! Int64
        }
        if dict.keys.contains("State") {
            self.state = dict["State"] as! String
        }
    }
}

public class GetTicketSummaryReportResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var ticketsAssigned: String?

        public var ticketsCreated: String?

        public var ticketsParticipated: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ticketsAssigned != nil {
                map["TicketsAssigned"] = self.ticketsAssigned!
            }
            if self.ticketsCreated != nil {
                map["TicketsCreated"] = self.ticketsCreated!
            }
            if self.ticketsParticipated != nil {
                map["TicketsParticipated"] = self.ticketsParticipated!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("TicketsAssigned") {
                self.ticketsAssigned = dict["TicketsAssigned"] as! String
            }
            if dict.keys.contains("TicketsCreated") {
                self.ticketsCreated = dict["TicketsCreated"] as! String
            }
            if dict.keys.contains("TicketsParticipated") {
                self.ticketsParticipated = dict["TicketsParticipated"] as! String
            }
        }
    }
    public var code: String?

    public var data: GetTicketSummaryReportResponseBody.Data?

    public var httpStatusCode: Int64?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = GetTicketSummaryReportResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int64
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetTicketSummaryReportResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetTicketSummaryReportResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetTicketSummaryReportResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetTicketTemplateRequest : Tea.TeaModel {
    public var instanceId: String?

    public var templateId: String?

    public var templateVersion: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.templateId != nil {
            map["TemplateId"] = self.templateId!
        }
        if self.templateVersion != nil {
            map["TemplateVersion"] = self.templateVersion!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("TemplateId") {
            self.templateId = dict["TemplateId"] as! String
        }
        if dict.keys.contains("TemplateVersion") {
            self.templateVersion = dict["TemplateVersion"] as! String
        }
    }
}

public class GetTicketTemplateResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class TicketFields : Tea.TeaModel {
            public var array: Bool?

            public var attributes: String?

            public var createdTime: Int64?

            public var creator: String?

            public var dataType: String?

            public var description_: String?

            public var disabled: Bool?

            public var displayName: String?

            public var displayOrder: Int32?

            public var editorType: String?

            public var maxLength: Int32?

            public var maximum: Double?

            public var minLength: Int32?

            public var minimum: Double?

            public var name: String?

            public var pattern: String?

            public var patternErrorMessage: String?

            public var readOnly: Bool?

            public var required_: Bool?

            public var system: Bool?

            public var updatedTime: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.array != nil {
                    map["Array"] = self.array!
                }
                if self.attributes != nil {
                    map["Attributes"] = self.attributes!
                }
                if self.createdTime != nil {
                    map["CreatedTime"] = self.createdTime!
                }
                if self.creator != nil {
                    map["Creator"] = self.creator!
                }
                if self.dataType != nil {
                    map["DataType"] = self.dataType!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.disabled != nil {
                    map["Disabled"] = self.disabled!
                }
                if self.displayName != nil {
                    map["DisplayName"] = self.displayName!
                }
                if self.displayOrder != nil {
                    map["DisplayOrder"] = self.displayOrder!
                }
                if self.editorType != nil {
                    map["EditorType"] = self.editorType!
                }
                if self.maxLength != nil {
                    map["MaxLength"] = self.maxLength!
                }
                if self.maximum != nil {
                    map["Maximum"] = self.maximum!
                }
                if self.minLength != nil {
                    map["MinLength"] = self.minLength!
                }
                if self.minimum != nil {
                    map["Minimum"] = self.minimum!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.pattern != nil {
                    map["Pattern"] = self.pattern!
                }
                if self.patternErrorMessage != nil {
                    map["PatternErrorMessage"] = self.patternErrorMessage!
                }
                if self.readOnly != nil {
                    map["ReadOnly"] = self.readOnly!
                }
                if self.required_ != nil {
                    map["Required"] = self.required_!
                }
                if self.system != nil {
                    map["System"] = self.system!
                }
                if self.updatedTime != nil {
                    map["UpdatedTime"] = self.updatedTime!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Array") {
                    self.array = dict["Array"] as! Bool
                }
                if dict.keys.contains("Attributes") {
                    self.attributes = dict["Attributes"] as! String
                }
                if dict.keys.contains("CreatedTime") {
                    self.createdTime = dict["CreatedTime"] as! Int64
                }
                if dict.keys.contains("Creator") {
                    self.creator = dict["Creator"] as! String
                }
                if dict.keys.contains("DataType") {
                    self.dataType = dict["DataType"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("Disabled") {
                    self.disabled = dict["Disabled"] as! Bool
                }
                if dict.keys.contains("DisplayName") {
                    self.displayName = dict["DisplayName"] as! String
                }
                if dict.keys.contains("DisplayOrder") {
                    self.displayOrder = dict["DisplayOrder"] as! Int32
                }
                if dict.keys.contains("EditorType") {
                    self.editorType = dict["EditorType"] as! String
                }
                if dict.keys.contains("MaxLength") {
                    self.maxLength = dict["MaxLength"] as! Int32
                }
                if dict.keys.contains("Maximum") {
                    self.maximum = dict["Maximum"] as! Double
                }
                if dict.keys.contains("MinLength") {
                    self.minLength = dict["MinLength"] as! Int32
                }
                if dict.keys.contains("Minimum") {
                    self.minimum = dict["Minimum"] as! Double
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Pattern") {
                    self.pattern = dict["Pattern"] as! String
                }
                if dict.keys.contains("PatternErrorMessage") {
                    self.patternErrorMessage = dict["PatternErrorMessage"] as! String
                }
                if dict.keys.contains("ReadOnly") {
                    self.readOnly = dict["ReadOnly"] as! Bool
                }
                if dict.keys.contains("Required") {
                    self.required_ = dict["Required"] as! Bool
                }
                if dict.keys.contains("System") {
                    self.system = dict["System"] as! Bool
                }
                if dict.keys.contains("UpdatedTime") {
                    self.updatedTime = dict["UpdatedTime"] as! Int64
                }
            }
        }
        public var categoryId: String?

        public var editor: String?

        public var instanceId: String?

        public var name: String?

        public var processDefinition: String?

        public var state: String?

        public var templateId: String?

        public var ticketFields: [GetTicketTemplateResponseBody.Data.TicketFields]?

        public var updatedTime: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.categoryId != nil {
                map["CategoryId"] = self.categoryId!
            }
            if self.editor != nil {
                map["Editor"] = self.editor!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.processDefinition != nil {
                map["ProcessDefinition"] = self.processDefinition!
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            if self.templateId != nil {
                map["TemplateId"] = self.templateId!
            }
            if self.ticketFields != nil {
                var tmp : [Any] = []
                for k in self.ticketFields! {
                    tmp.append(k.toMap())
                }
                map["TicketFields"] = tmp
            }
            if self.updatedTime != nil {
                map["UpdatedTime"] = self.updatedTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CategoryId") {
                self.categoryId = dict["CategoryId"] as! String
            }
            if dict.keys.contains("Editor") {
                self.editor = dict["Editor"] as! String
            }
            if dict.keys.contains("InstanceId") {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("ProcessDefinition") {
                self.processDefinition = dict["ProcessDefinition"] as! String
            }
            if dict.keys.contains("State") {
                self.state = dict["State"] as! String
            }
            if dict.keys.contains("TemplateId") {
                self.templateId = dict["TemplateId"] as! String
            }
            if dict.keys.contains("TicketFields") {
                var tmp : [GetTicketTemplateResponseBody.Data.TicketFields] = []
                for v in dict["TicketFields"] as! [Any] {
                    var model = GetTicketTemplateResponseBody.Data.TicketFields()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.ticketFields = tmp
            }
            if dict.keys.contains("UpdatedTime") {
                self.updatedTime = dict["UpdatedTime"] as! Int64
            }
        }
    }
    public var code: String?

    public var data: GetTicketTemplateResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var params: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.params != nil {
            map["Params"] = self.params!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = GetTicketTemplateResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Params") {
            self.params = dict["Params"] as! [String]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetTicketTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetTicketTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetTicketTemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetTurnCredentialsRequest : Tea.TeaModel {
    public var instanceId: String?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("UserId") {
            self.userId = dict["UserId"] as! String
        }
    }
}

public class GetTurnCredentialsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var password: String?

        public var userName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.password != nil {
                map["Password"] = self.password!
            }
            if self.userName != nil {
                map["UserName"] = self.userName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Password") {
                self.password = dict["Password"] as! String
            }
            if dict.keys.contains("UserName") {
                self.userName = dict["UserName"] as! String
            }
        }
    }
    public var code: String?

    public var data: GetTurnCredentialsResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var params: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.params != nil {
            map["Params"] = self.params!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = GetTurnCredentialsResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Params") {
            self.params = dict["Params"] as! [String]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetTurnCredentialsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetTurnCredentialsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetTurnCredentialsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetTurnServerListRequest : Tea.TeaModel {
    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
    }
}

public class GetTurnServerListResponseBody : Tea.TeaModel {
    public var code: String?

    public var data: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var params: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.params != nil {
            map["Params"] = self.params!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Params") {
            self.params = dict["Params"] as! [String]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetTurnServerListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetTurnServerListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetTurnServerListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetUploadAudioDataParamsRequest : Tea.TeaModel {
    public var contactId: String?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.contactId != nil {
            map["ContactId"] = self.contactId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ContactId") {
            self.contactId = dict["ContactId"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
    }
}

public class GetUploadAudioDataParamsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var paramsStr: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.paramsStr != nil {
                map["ParamsStr"] = self.paramsStr!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ParamsStr") {
                self.paramsStr = dict["ParamsStr"] as! String
            }
        }
    }
    public var code: String?

    public var data: GetUploadAudioDataParamsResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = GetUploadAudioDataParamsResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetUploadAudioDataParamsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetUploadAudioDataParamsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetUploadAudioDataParamsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetUserRequest : Tea.TeaModel {
    public var extension_: String?

    public var instanceId: String?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.extension_ != nil {
            map["Extension"] = self.extension_!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Extension") {
            self.extension_ = dict["Extension"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("UserId") {
            self.userId = dict["UserId"] as! String
        }
    }
}

public class GetUserResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var avatarUrl: String?

        public var deviceExt: String?

        public var deviceId: String?

        public var deviceState: String?

        public var displayId: String?

        public var displayName: String?

        public var email: String?

        public var extension_: String?

        public var instanceId: String?

        public var loginName: String?

        public var mobile: String?

        public var nickname: String?

        public var roleId: String?

        public var roleName: String?

        public var userId: String?

        public var workMode: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.avatarUrl != nil {
                map["AvatarUrl"] = self.avatarUrl!
            }
            if self.deviceExt != nil {
                map["DeviceExt"] = self.deviceExt!
            }
            if self.deviceId != nil {
                map["DeviceId"] = self.deviceId!
            }
            if self.deviceState != nil {
                map["DeviceState"] = self.deviceState!
            }
            if self.displayId != nil {
                map["DisplayId"] = self.displayId!
            }
            if self.displayName != nil {
                map["DisplayName"] = self.displayName!
            }
            if self.email != nil {
                map["Email"] = self.email!
            }
            if self.extension_ != nil {
                map["Extension"] = self.extension_!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.loginName != nil {
                map["LoginName"] = self.loginName!
            }
            if self.mobile != nil {
                map["Mobile"] = self.mobile!
            }
            if self.nickname != nil {
                map["Nickname"] = self.nickname!
            }
            if self.roleId != nil {
                map["RoleId"] = self.roleId!
            }
            if self.roleName != nil {
                map["RoleName"] = self.roleName!
            }
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            if self.workMode != nil {
                map["WorkMode"] = self.workMode!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AvatarUrl") {
                self.avatarUrl = dict["AvatarUrl"] as! String
            }
            if dict.keys.contains("DeviceExt") {
                self.deviceExt = dict["DeviceExt"] as! String
            }
            if dict.keys.contains("DeviceId") {
                self.deviceId = dict["DeviceId"] as! String
            }
            if dict.keys.contains("DeviceState") {
                self.deviceState = dict["DeviceState"] as! String
            }
            if dict.keys.contains("DisplayId") {
                self.displayId = dict["DisplayId"] as! String
            }
            if dict.keys.contains("DisplayName") {
                self.displayName = dict["DisplayName"] as! String
            }
            if dict.keys.contains("Email") {
                self.email = dict["Email"] as! String
            }
            if dict.keys.contains("Extension") {
                self.extension_ = dict["Extension"] as! String
            }
            if dict.keys.contains("InstanceId") {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("LoginName") {
                self.loginName = dict["LoginName"] as! String
            }
            if dict.keys.contains("Mobile") {
                self.mobile = dict["Mobile"] as! String
            }
            if dict.keys.contains("Nickname") {
                self.nickname = dict["Nickname"] as! String
            }
            if dict.keys.contains("RoleId") {
                self.roleId = dict["RoleId"] as! String
            }
            if dict.keys.contains("RoleName") {
                self.roleName = dict["RoleName"] as! String
            }
            if dict.keys.contains("UserId") {
                self.userId = dict["UserId"] as! String
            }
            if dict.keys.contains("WorkMode") {
                self.workMode = dict["WorkMode"] as! String
            }
        }
    }
    public var code: String?

    public var data: GetUserResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var params: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.params != nil {
            map["Params"] = self.params!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = GetUserResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Params") {
            self.params = dict["Params"] as! [String]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetUserResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetUserResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetUserResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetVideoRequest : Tea.TeaModel {
    public var contactId: String?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.contactId != nil {
            map["ContactId"] = self.contactId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ContactId") {
            self.contactId = dict["ContactId"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
    }
}

public class GetVideoResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var fileName: String?

        public var fileUrl: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.fileName != nil {
                map["FileName"] = self.fileName!
            }
            if self.fileUrl != nil {
                map["FileUrl"] = self.fileUrl!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("FileName") {
                self.fileName = dict["FileName"] as! String
            }
            if dict.keys.contains("FileUrl") {
                self.fileUrl = dict["FileUrl"] as! String
            }
        }
    }
    public var code: String?

    public var data: GetVideoResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = GetVideoResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetVideoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetVideoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetVideoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetVisitorLoginDetailsRequest : Tea.TeaModel {
    public var chatDeviceId: String?

    public var instanceId: String?

    public var token: String?

    public var visitorId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.chatDeviceId != nil {
            map["ChatDeviceId"] = self.chatDeviceId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.token != nil {
            map["Token"] = self.token!
        }
        if self.visitorId != nil {
            map["VisitorId"] = self.visitorId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ChatDeviceId") {
            self.chatDeviceId = dict["ChatDeviceId"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Token") {
            self.token = dict["Token"] as! String
        }
        if dict.keys.contains("VisitorId") {
            self.visitorId = dict["VisitorId"] as! String
        }
    }
}

public class GetVisitorLoginDetailsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var chatAppId: String?

        public var chatAppKey: String?

        public var chatDeviceId: String?

        public var chatLoginToken: String?

        public var chatServerUrl: String?

        public var chatUserId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.chatAppId != nil {
                map["ChatAppId"] = self.chatAppId!
            }
            if self.chatAppKey != nil {
                map["ChatAppKey"] = self.chatAppKey!
            }
            if self.chatDeviceId != nil {
                map["ChatDeviceId"] = self.chatDeviceId!
            }
            if self.chatLoginToken != nil {
                map["ChatLoginToken"] = self.chatLoginToken!
            }
            if self.chatServerUrl != nil {
                map["ChatServerUrl"] = self.chatServerUrl!
            }
            if self.chatUserId != nil {
                map["ChatUserId"] = self.chatUserId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ChatAppId") {
                self.chatAppId = dict["ChatAppId"] as! String
            }
            if dict.keys.contains("ChatAppKey") {
                self.chatAppKey = dict["ChatAppKey"] as! String
            }
            if dict.keys.contains("ChatDeviceId") {
                self.chatDeviceId = dict["ChatDeviceId"] as! String
            }
            if dict.keys.contains("ChatLoginToken") {
                self.chatLoginToken = dict["ChatLoginToken"] as! String
            }
            if dict.keys.contains("ChatServerUrl") {
                self.chatServerUrl = dict["ChatServerUrl"] as! String
            }
            if dict.keys.contains("ChatUserId") {
                self.chatUserId = dict["ChatUserId"] as! String
            }
        }
    }
    public var code: String?

    public var data: GetVisitorLoginDetailsResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var params: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.params != nil {
            map["Params"] = self.params!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = GetVisitorLoginDetailsResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Params") {
            self.params = dict["Params"] as! [String]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetVisitorLoginDetailsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetVisitorLoginDetailsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetVisitorLoginDetailsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetVoicemailRecordingRequest : Tea.TeaModel {
    public var contactId: String?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.contactId != nil {
            map["ContactId"] = self.contactId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ContactId") {
            self.contactId = dict["ContactId"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
    }
}

public class GetVoicemailRecordingResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var fileName: String?

        public var fileUrl: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.fileName != nil {
                map["FileName"] = self.fileName!
            }
            if self.fileUrl != nil {
                map["FileUrl"] = self.fileUrl!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("FileName") {
                self.fileName = dict["FileName"] as! String
            }
            if dict.keys.contains("FileUrl") {
                self.fileUrl = dict["FileUrl"] as! String
            }
        }
    }
    public var code: String?

    public var data: GetVoicemailRecordingResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = GetVoicemailRecordingResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetVoicemailRecordingResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetVoicemailRecordingResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetVoicemailRecordingResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class HoldCallRequest : Tea.TeaModel {
    public var channelId: String?

    public var deviceId: String?

    public var instanceId: String?

    public var jobId: String?

    public var music: String?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.channelId != nil {
            map["ChannelId"] = self.channelId!
        }
        if self.deviceId != nil {
            map["DeviceId"] = self.deviceId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.music != nil {
            map["Music"] = self.music!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ChannelId") {
            self.channelId = dict["ChannelId"] as! String
        }
        if dict.keys.contains("DeviceId") {
            self.deviceId = dict["DeviceId"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("Music") {
            self.music = dict["Music"] as! String
        }
        if dict.keys.contains("UserId") {
            self.userId = dict["UserId"] as! String
        }
    }
}

public class HoldCallResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class CallContext : Tea.TeaModel {
            public class ChannelContexts : Tea.TeaModel {
                public var callType: String?

                public var channelId: String?

                public var channelState: String?

                public var destination: String?

                public var jobId: String?

                public var originator: String?

                public var releaseInitiator: String?

                public var releaseReason: String?

                public var skillGroupId: String?

                public var timestamp: Int64?

                public var userExtension: String?

                public var userId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.callType != nil {
                        map["CallType"] = self.callType!
                    }
                    if self.channelId != nil {
                        map["ChannelId"] = self.channelId!
                    }
                    if self.channelState != nil {
                        map["ChannelState"] = self.channelState!
                    }
                    if self.destination != nil {
                        map["Destination"] = self.destination!
                    }
                    if self.jobId != nil {
                        map["JobId"] = self.jobId!
                    }
                    if self.originator != nil {
                        map["Originator"] = self.originator!
                    }
                    if self.releaseInitiator != nil {
                        map["ReleaseInitiator"] = self.releaseInitiator!
                    }
                    if self.releaseReason != nil {
                        map["ReleaseReason"] = self.releaseReason!
                    }
                    if self.skillGroupId != nil {
                        map["SkillGroupId"] = self.skillGroupId!
                    }
                    if self.timestamp != nil {
                        map["Timestamp"] = self.timestamp!
                    }
                    if self.userExtension != nil {
                        map["UserExtension"] = self.userExtension!
                    }
                    if self.userId != nil {
                        map["UserId"] = self.userId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("CallType") {
                        self.callType = dict["CallType"] as! String
                    }
                    if dict.keys.contains("ChannelId") {
                        self.channelId = dict["ChannelId"] as! String
                    }
                    if dict.keys.contains("ChannelState") {
                        self.channelState = dict["ChannelState"] as! String
                    }
                    if dict.keys.contains("Destination") {
                        self.destination = dict["Destination"] as! String
                    }
                    if dict.keys.contains("JobId") {
                        self.jobId = dict["JobId"] as! String
                    }
                    if dict.keys.contains("Originator") {
                        self.originator = dict["Originator"] as! String
                    }
                    if dict.keys.contains("ReleaseInitiator") {
                        self.releaseInitiator = dict["ReleaseInitiator"] as! String
                    }
                    if dict.keys.contains("ReleaseReason") {
                        self.releaseReason = dict["ReleaseReason"] as! String
                    }
                    if dict.keys.contains("SkillGroupId") {
                        self.skillGroupId = dict["SkillGroupId"] as! String
                    }
                    if dict.keys.contains("Timestamp") {
                        self.timestamp = dict["Timestamp"] as! Int64
                    }
                    if dict.keys.contains("UserExtension") {
                        self.userExtension = dict["UserExtension"] as! String
                    }
                    if dict.keys.contains("UserId") {
                        self.userId = dict["UserId"] as! String
                    }
                }
            }
            public var callType: String?

            public var channelContexts: [HoldCallResponseBody.Data.CallContext.ChannelContexts]?

            public var instanceId: String?

            public var jobId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.callType != nil {
                    map["CallType"] = self.callType!
                }
                if self.channelContexts != nil {
                    var tmp : [Any] = []
                    for k in self.channelContexts! {
                        tmp.append(k.toMap())
                    }
                    map["ChannelContexts"] = tmp
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.jobId != nil {
                    map["JobId"] = self.jobId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CallType") {
                    self.callType = dict["CallType"] as! String
                }
                if dict.keys.contains("ChannelContexts") {
                    var tmp : [HoldCallResponseBody.Data.CallContext.ChannelContexts] = []
                    for v in dict["ChannelContexts"] as! [Any] {
                        var model = HoldCallResponseBody.Data.CallContext.ChannelContexts()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.channelContexts = tmp
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("JobId") {
                    self.jobId = dict["JobId"] as! String
                }
            }
        }
        public class UserContext : Tea.TeaModel {
            public var breakCode: String?

            public var deviceId: String?

            public var extension_: String?

            public var heartbeat: Int64?

            public var instanceId: String?

            public var jobId: String?

            public var mobile: String?

            public var outboundScenario: Bool?

            public var reserved: Int64?

            public var signedSkillGroupIdList: [String]?

            public var userId: String?

            public var userState: String?

            public var workMode: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.breakCode != nil {
                    map["BreakCode"] = self.breakCode!
                }
                if self.deviceId != nil {
                    map["DeviceId"] = self.deviceId!
                }
                if self.extension_ != nil {
                    map["Extension"] = self.extension_!
                }
                if self.heartbeat != nil {
                    map["Heartbeat"] = self.heartbeat!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.jobId != nil {
                    map["JobId"] = self.jobId!
                }
                if self.mobile != nil {
                    map["Mobile"] = self.mobile!
                }
                if self.outboundScenario != nil {
                    map["OutboundScenario"] = self.outboundScenario!
                }
                if self.reserved != nil {
                    map["Reserved"] = self.reserved!
                }
                if self.signedSkillGroupIdList != nil {
                    map["SignedSkillGroupIdList"] = self.signedSkillGroupIdList!
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                if self.userState != nil {
                    map["UserState"] = self.userState!
                }
                if self.workMode != nil {
                    map["WorkMode"] = self.workMode!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BreakCode") {
                    self.breakCode = dict["BreakCode"] as! String
                }
                if dict.keys.contains("DeviceId") {
                    self.deviceId = dict["DeviceId"] as! String
                }
                if dict.keys.contains("Extension") {
                    self.extension_ = dict["Extension"] as! String
                }
                if dict.keys.contains("Heartbeat") {
                    self.heartbeat = dict["Heartbeat"] as! Int64
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("JobId") {
                    self.jobId = dict["JobId"] as! String
                }
                if dict.keys.contains("Mobile") {
                    self.mobile = dict["Mobile"] as! String
                }
                if dict.keys.contains("OutboundScenario") {
                    self.outboundScenario = dict["OutboundScenario"] as! Bool
                }
                if dict.keys.contains("Reserved") {
                    self.reserved = dict["Reserved"] as! Int64
                }
                if dict.keys.contains("SignedSkillGroupIdList") {
                    self.signedSkillGroupIdList = dict["SignedSkillGroupIdList"] as! [String]
                }
                if dict.keys.contains("UserId") {
                    self.userId = dict["UserId"] as! String
                }
                if dict.keys.contains("UserState") {
                    self.userState = dict["UserState"] as! String
                }
                if dict.keys.contains("WorkMode") {
                    self.workMode = dict["WorkMode"] as! String
                }
            }
        }
        public var callContext: HoldCallResponseBody.Data.CallContext?

        public var userContext: HoldCallResponseBody.Data.UserContext?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.callContext?.validate()
            try self.userContext?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.callContext != nil {
                map["CallContext"] = self.callContext?.toMap()
            }
            if self.userContext != nil {
                map["UserContext"] = self.userContext?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CallContext") {
                var model = HoldCallResponseBody.Data.CallContext()
                model.fromMap(dict["CallContext"] as! [String: Any])
                self.callContext = model
            }
            if dict.keys.contains("UserContext") {
                var model = HoldCallResponseBody.Data.UserContext()
                model.fromMap(dict["UserContext"] as! [String: Any])
                self.userContext = model
            }
        }
    }
    public var code: String?

    public var data: HoldCallResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var params: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.params != nil {
            map["Params"] = self.params!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = HoldCallResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Params") {
            self.params = dict["Params"] as! [String]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class HoldCallResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: HoldCallResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = HoldCallResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ImportAdminsRequest : Tea.TeaModel {
    public var instanceId: String?

    public var ramIdList: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.ramIdList != nil {
            map["RamIdList"] = self.ramIdList!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("RamIdList") {
            self.ramIdList = dict["RamIdList"] as! String
        }
    }
}

public class ImportAdminsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var extension_: String?

        public var instanceId: String?

        public var ramId: String?

        public var roleId: String?

        public var userId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.extension_ != nil {
                map["Extension"] = self.extension_!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.ramId != nil {
                map["RamId"] = self.ramId!
            }
            if self.roleId != nil {
                map["RoleId"] = self.roleId!
            }
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Extension") {
                self.extension_ = dict["Extension"] as! String
            }
            if dict.keys.contains("InstanceId") {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("RamId") {
                self.ramId = dict["RamId"] as! String
            }
            if dict.keys.contains("RoleId") {
                self.roleId = dict["RoleId"] as! String
            }
            if dict.keys.contains("UserId") {
                self.userId = dict["UserId"] as! String
            }
        }
    }
    public var code: String?

    public var data: [ImportAdminsResponseBody.Data]?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var tmp : [ImportAdminsResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = ImportAdminsResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ImportAdminsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ImportAdminsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ImportAdminsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ImportCorpNumbersRequest : Tea.TeaModel {
    public var city: String?

    public var corpName: String?

    public var numberList: String?

    public var provider: String?

    public var province: String?

    public var tagList: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.city != nil {
            map["City"] = self.city!
        }
        if self.corpName != nil {
            map["CorpName"] = self.corpName!
        }
        if self.numberList != nil {
            map["NumberList"] = self.numberList!
        }
        if self.provider != nil {
            map["Provider"] = self.provider!
        }
        if self.province != nil {
            map["Province"] = self.province!
        }
        if self.tagList != nil {
            map["TagList"] = self.tagList!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("City") {
            self.city = dict["City"] as! String
        }
        if dict.keys.contains("CorpName") {
            self.corpName = dict["CorpName"] as! String
        }
        if dict.keys.contains("NumberList") {
            self.numberList = dict["NumberList"] as! String
        }
        if dict.keys.contains("Provider") {
            self.provider = dict["Provider"] as! String
        }
        if dict.keys.contains("Province") {
            self.province = dict["Province"] as! String
        }
        if dict.keys.contains("TagList") {
            self.tagList = dict["TagList"] as! String
        }
    }
}

public class ImportCorpNumbersResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ImportCorpNumbersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ImportCorpNumbersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ImportCorpNumbersResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ImportCustomCallTaggingRequest : Tea.TeaModel {
    public var filePath: String?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.filePath != nil {
            map["FilePath"] = self.filePath!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FilePath") {
            self.filePath = dict["FilePath"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
    }
}

public class ImportCustomCallTaggingResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var item: String?

        public var reason: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.item != nil {
                map["Item"] = self.item!
            }
            if self.reason != nil {
                map["Reason"] = self.reason!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Item") {
                self.item = dict["Item"] as! String
            }
            if dict.keys.contains("Reason") {
                self.reason = dict["Reason"] as! String
            }
        }
    }
    public var code: String?

    public var data: [ImportCustomCallTaggingResponseBody.Data]?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var tmp : [ImportCustomCallTaggingResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = ImportCustomCallTaggingResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ImportCustomCallTaggingResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ImportCustomCallTaggingResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ImportCustomCallTaggingResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ImportDoNotCallNumbersRequest : Tea.TeaModel {
    public var filePath: String?

    public var instanceId: String?

    public var numberList: String?

    public var remark: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.filePath != nil {
            map["FilePath"] = self.filePath!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.numberList != nil {
            map["NumberList"] = self.numberList!
        }
        if self.remark != nil {
            map["Remark"] = self.remark!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FilePath") {
            self.filePath = dict["FilePath"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("NumberList") {
            self.numberList = dict["NumberList"] as! String
        }
        if dict.keys.contains("Remark") {
            self.remark = dict["Remark"] as! String
        }
    }
}

public class ImportDoNotCallNumbersResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var params: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.params != nil {
            map["Params"] = self.params!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Params") {
            self.params = dict["Params"] as! [String]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ImportDoNotCallNumbersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ImportDoNotCallNumbersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ImportDoNotCallNumbersResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ImportDocumentsRequest : Tea.TeaModel {
    public var instanceId: String?

    public var ossFileKey: String?

    public var requestId: String?

    public var schemaId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.ossFileKey != nil {
            map["OssFileKey"] = self.ossFileKey!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.schemaId != nil {
            map["SchemaId"] = self.schemaId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("OssFileKey") {
            self.ossFileKey = dict["OssFileKey"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SchemaId") {
            self.schemaId = dict["SchemaId"] as! String
        }
    }
}

public class ImportDocumentsResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var params: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.params != nil {
            map["Params"] = self.params!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Params") {
            self.params = dict["Params"] as! [String]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ImportDocumentsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ImportDocumentsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ImportDocumentsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class InitiateAttendedTransferRequest : Tea.TeaModel {
    public var callPriority: Int32?

    public var deviceId: String?

    public var instanceId: String?

    public var jobId: String?

    public var queuingOverflowThreshold: Int64?

    public var queuingTimeoutSeconds: Int64?

    public var routingType: String?

    public var strategyName: String?

    public var strategyParams: String?

    public var tags: String?

    public var timeoutSeconds: Int32?

    public var transferee: String?

    public var transfereeType: String?

    public var transferor: String?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.callPriority != nil {
            map["CallPriority"] = self.callPriority!
        }
        if self.deviceId != nil {
            map["DeviceId"] = self.deviceId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.queuingOverflowThreshold != nil {
            map["QueuingOverflowThreshold"] = self.queuingOverflowThreshold!
        }
        if self.queuingTimeoutSeconds != nil {
            map["QueuingTimeoutSeconds"] = self.queuingTimeoutSeconds!
        }
        if self.routingType != nil {
            map["RoutingType"] = self.routingType!
        }
        if self.strategyName != nil {
            map["StrategyName"] = self.strategyName!
        }
        if self.strategyParams != nil {
            map["StrategyParams"] = self.strategyParams!
        }
        if self.tags != nil {
            map["Tags"] = self.tags!
        }
        if self.timeoutSeconds != nil {
            map["TimeoutSeconds"] = self.timeoutSeconds!
        }
        if self.transferee != nil {
            map["Transferee"] = self.transferee!
        }
        if self.transfereeType != nil {
            map["TransfereeType"] = self.transfereeType!
        }
        if self.transferor != nil {
            map["Transferor"] = self.transferor!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CallPriority") {
            self.callPriority = dict["CallPriority"] as! Int32
        }
        if dict.keys.contains("DeviceId") {
            self.deviceId = dict["DeviceId"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("QueuingOverflowThreshold") {
            self.queuingOverflowThreshold = dict["QueuingOverflowThreshold"] as! Int64
        }
        if dict.keys.contains("QueuingTimeoutSeconds") {
            self.queuingTimeoutSeconds = dict["QueuingTimeoutSeconds"] as! Int64
        }
        if dict.keys.contains("RoutingType") {
            self.routingType = dict["RoutingType"] as! String
        }
        if dict.keys.contains("StrategyName") {
            self.strategyName = dict["StrategyName"] as! String
        }
        if dict.keys.contains("StrategyParams") {
            self.strategyParams = dict["StrategyParams"] as! String
        }
        if dict.keys.contains("Tags") {
            self.tags = dict["Tags"] as! String
        }
        if dict.keys.contains("TimeoutSeconds") {
            self.timeoutSeconds = dict["TimeoutSeconds"] as! Int32
        }
        if dict.keys.contains("Transferee") {
            self.transferee = dict["Transferee"] as! String
        }
        if dict.keys.contains("TransfereeType") {
            self.transfereeType = dict["TransfereeType"] as! String
        }
        if dict.keys.contains("Transferor") {
            self.transferor = dict["Transferor"] as! String
        }
        if dict.keys.contains("UserId") {
            self.userId = dict["UserId"] as! String
        }
    }
}

public class InitiateAttendedTransferResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class CallContext : Tea.TeaModel {
            public class ChannelContexts : Tea.TeaModel {
                public var callType: String?

                public var channelFlags: String?

                public var channelId: String?

                public var channelState: String?

                public var destination: String?

                public var index: Int32?

                public var jobId: String?

                public var originator: String?

                public var releaseInitiator: String?

                public var releaseReason: String?

                public var skillGroupId: String?

                public var timestamp: Int64?

                public var userExtension: String?

                public var userId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.callType != nil {
                        map["CallType"] = self.callType!
                    }
                    if self.channelFlags != nil {
                        map["ChannelFlags"] = self.channelFlags!
                    }
                    if self.channelId != nil {
                        map["ChannelId"] = self.channelId!
                    }
                    if self.channelState != nil {
                        map["ChannelState"] = self.channelState!
                    }
                    if self.destination != nil {
                        map["Destination"] = self.destination!
                    }
                    if self.index != nil {
                        map["Index"] = self.index!
                    }
                    if self.jobId != nil {
                        map["JobId"] = self.jobId!
                    }
                    if self.originator != nil {
                        map["Originator"] = self.originator!
                    }
                    if self.releaseInitiator != nil {
                        map["ReleaseInitiator"] = self.releaseInitiator!
                    }
                    if self.releaseReason != nil {
                        map["ReleaseReason"] = self.releaseReason!
                    }
                    if self.skillGroupId != nil {
                        map["SkillGroupId"] = self.skillGroupId!
                    }
                    if self.timestamp != nil {
                        map["Timestamp"] = self.timestamp!
                    }
                    if self.userExtension != nil {
                        map["UserExtension"] = self.userExtension!
                    }
                    if self.userId != nil {
                        map["UserId"] = self.userId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("CallType") {
                        self.callType = dict["CallType"] as! String
                    }
                    if dict.keys.contains("ChannelFlags") {
                        self.channelFlags = dict["ChannelFlags"] as! String
                    }
                    if dict.keys.contains("ChannelId") {
                        self.channelId = dict["ChannelId"] as! String
                    }
                    if dict.keys.contains("ChannelState") {
                        self.channelState = dict["ChannelState"] as! String
                    }
                    if dict.keys.contains("Destination") {
                        self.destination = dict["Destination"] as! String
                    }
                    if dict.keys.contains("Index") {
                        self.index = dict["Index"] as! Int32
                    }
                    if dict.keys.contains("JobId") {
                        self.jobId = dict["JobId"] as! String
                    }
                    if dict.keys.contains("Originator") {
                        self.originator = dict["Originator"] as! String
                    }
                    if dict.keys.contains("ReleaseInitiator") {
                        self.releaseInitiator = dict["ReleaseInitiator"] as! String
                    }
                    if dict.keys.contains("ReleaseReason") {
                        self.releaseReason = dict["ReleaseReason"] as! String
                    }
                    if dict.keys.contains("SkillGroupId") {
                        self.skillGroupId = dict["SkillGroupId"] as! String
                    }
                    if dict.keys.contains("Timestamp") {
                        self.timestamp = dict["Timestamp"] as! Int64
                    }
                    if dict.keys.contains("UserExtension") {
                        self.userExtension = dict["UserExtension"] as! String
                    }
                    if dict.keys.contains("UserId") {
                        self.userId = dict["UserId"] as! String
                    }
                }
            }
            public var callType: String?

            public var channelContexts: [InitiateAttendedTransferResponseBody.Data.CallContext.ChannelContexts]?

            public var instanceId: String?

            public var jobId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.callType != nil {
                    map["CallType"] = self.callType!
                }
                if self.channelContexts != nil {
                    var tmp : [Any] = []
                    for k in self.channelContexts! {
                        tmp.append(k.toMap())
                    }
                    map["ChannelContexts"] = tmp
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.jobId != nil {
                    map["JobId"] = self.jobId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CallType") {
                    self.callType = dict["CallType"] as! String
                }
                if dict.keys.contains("ChannelContexts") {
                    var tmp : [InitiateAttendedTransferResponseBody.Data.CallContext.ChannelContexts] = []
                    for v in dict["ChannelContexts"] as! [Any] {
                        var model = InitiateAttendedTransferResponseBody.Data.CallContext.ChannelContexts()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.channelContexts = tmp
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("JobId") {
                    self.jobId = dict["JobId"] as! String
                }
            }
        }
        public class UserContext : Tea.TeaModel {
            public var breakCode: String?

            public var deviceId: String?

            public var extension_: String?

            public var heartbeat: Int64?

            public var instanceId: String?

            public var jobId: String?

            public var mobile: String?

            public var outboundScenario: Bool?

            public var reserved: Int64?

            public var signedSkillGroupIdList: [String]?

            public var userId: String?

            public var userState: String?

            public var workMode: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.breakCode != nil {
                    map["BreakCode"] = self.breakCode!
                }
                if self.deviceId != nil {
                    map["DeviceId"] = self.deviceId!
                }
                if self.extension_ != nil {
                    map["Extension"] = self.extension_!
                }
                if self.heartbeat != nil {
                    map["Heartbeat"] = self.heartbeat!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.jobId != nil {
                    map["JobId"] = self.jobId!
                }
                if self.mobile != nil {
                    map["Mobile"] = self.mobile!
                }
                if self.outboundScenario != nil {
                    map["OutboundScenario"] = self.outboundScenario!
                }
                if self.reserved != nil {
                    map["Reserved"] = self.reserved!
                }
                if self.signedSkillGroupIdList != nil {
                    map["SignedSkillGroupIdList"] = self.signedSkillGroupIdList!
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                if self.userState != nil {
                    map["UserState"] = self.userState!
                }
                if self.workMode != nil {
                    map["WorkMode"] = self.workMode!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BreakCode") {
                    self.breakCode = dict["BreakCode"] as! String
                }
                if dict.keys.contains("DeviceId") {
                    self.deviceId = dict["DeviceId"] as! String
                }
                if dict.keys.contains("Extension") {
                    self.extension_ = dict["Extension"] as! String
                }
                if dict.keys.contains("Heartbeat") {
                    self.heartbeat = dict["Heartbeat"] as! Int64
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("JobId") {
                    self.jobId = dict["JobId"] as! String
                }
                if dict.keys.contains("Mobile") {
                    self.mobile = dict["Mobile"] as! String
                }
                if dict.keys.contains("OutboundScenario") {
                    self.outboundScenario = dict["OutboundScenario"] as! Bool
                }
                if dict.keys.contains("Reserved") {
                    self.reserved = dict["Reserved"] as! Int64
                }
                if dict.keys.contains("SignedSkillGroupIdList") {
                    self.signedSkillGroupIdList = dict["SignedSkillGroupIdList"] as! [String]
                }
                if dict.keys.contains("UserId") {
                    self.userId = dict["UserId"] as! String
                }
                if dict.keys.contains("UserState") {
                    self.userState = dict["UserState"] as! String
                }
                if dict.keys.contains("WorkMode") {
                    self.workMode = dict["WorkMode"] as! String
                }
            }
        }
        public var callContext: InitiateAttendedTransferResponseBody.Data.CallContext?

        public var contextId: Int64?

        public var userContext: InitiateAttendedTransferResponseBody.Data.UserContext?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.callContext?.validate()
            try self.userContext?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.callContext != nil {
                map["CallContext"] = self.callContext?.toMap()
            }
            if self.contextId != nil {
                map["ContextId"] = self.contextId!
            }
            if self.userContext != nil {
                map["UserContext"] = self.userContext?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CallContext") {
                var model = InitiateAttendedTransferResponseBody.Data.CallContext()
                model.fromMap(dict["CallContext"] as! [String: Any])
                self.callContext = model
            }
            if dict.keys.contains("ContextId") {
                self.contextId = dict["ContextId"] as! Int64
            }
            if dict.keys.contains("UserContext") {
                var model = InitiateAttendedTransferResponseBody.Data.UserContext()
                model.fromMap(dict["UserContext"] as! [String: Any])
                self.userContext = model
            }
        }
    }
    public var code: String?

    public var data: InitiateAttendedTransferResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var params: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.params != nil {
            map["Params"] = self.params!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = InitiateAttendedTransferResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Params") {
            self.params = dict["Params"] as! [String]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class InitiateAttendedTransferResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: InitiateAttendedTransferResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = InitiateAttendedTransferResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class InterceptCallRequest : Tea.TeaModel {
    public var deviceId: String?

    public var instanceId: String?

    public var interceptedUserId: String?

    public var jobId: String?

    public var timeoutSeconds: Int32?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.deviceId != nil {
            map["DeviceId"] = self.deviceId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.interceptedUserId != nil {
            map["InterceptedUserId"] = self.interceptedUserId!
        }
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.timeoutSeconds != nil {
            map["TimeoutSeconds"] = self.timeoutSeconds!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DeviceId") {
            self.deviceId = dict["DeviceId"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("InterceptedUserId") {
            self.interceptedUserId = dict["InterceptedUserId"] as! String
        }
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("TimeoutSeconds") {
            self.timeoutSeconds = dict["TimeoutSeconds"] as! Int32
        }
        if dict.keys.contains("UserId") {
            self.userId = dict["UserId"] as! String
        }
    }
}

public class InterceptCallResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class CallContext : Tea.TeaModel {
            public class ChannelContexts : Tea.TeaModel {
                public var callType: String?

                public var channelFlags: String?

                public var channelId: String?

                public var channelState: String?

                public var destination: String?

                public var index: Int32?

                public var jobId: String?

                public var originator: String?

                public var releaseInitiator: String?

                public var releaseReason: String?

                public var skillGroupId: String?

                public var timestamp: Int64?

                public var userExtension: String?

                public var userId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.callType != nil {
                        map["CallType"] = self.callType!
                    }
                    if self.channelFlags != nil {
                        map["ChannelFlags"] = self.channelFlags!
                    }
                    if self.channelId != nil {
                        map["ChannelId"] = self.channelId!
                    }
                    if self.channelState != nil {
                        map["ChannelState"] = self.channelState!
                    }
                    if self.destination != nil {
                        map["Destination"] = self.destination!
                    }
                    if self.index != nil {
                        map["Index"] = self.index!
                    }
                    if self.jobId != nil {
                        map["JobId"] = self.jobId!
                    }
                    if self.originator != nil {
                        map["Originator"] = self.originator!
                    }
                    if self.releaseInitiator != nil {
                        map["ReleaseInitiator"] = self.releaseInitiator!
                    }
                    if self.releaseReason != nil {
                        map["ReleaseReason"] = self.releaseReason!
                    }
                    if self.skillGroupId != nil {
                        map["SkillGroupId"] = self.skillGroupId!
                    }
                    if self.timestamp != nil {
                        map["Timestamp"] = self.timestamp!
                    }
                    if self.userExtension != nil {
                        map["UserExtension"] = self.userExtension!
                    }
                    if self.userId != nil {
                        map["UserId"] = self.userId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("CallType") {
                        self.callType = dict["CallType"] as! String
                    }
                    if dict.keys.contains("ChannelFlags") {
                        self.channelFlags = dict["ChannelFlags"] as! String
                    }
                    if dict.keys.contains("ChannelId") {
                        self.channelId = dict["ChannelId"] as! String
                    }
                    if dict.keys.contains("ChannelState") {
                        self.channelState = dict["ChannelState"] as! String
                    }
                    if dict.keys.contains("Destination") {
                        self.destination = dict["Destination"] as! String
                    }
                    if dict.keys.contains("Index") {
                        self.index = dict["Index"] as! Int32
                    }
                    if dict.keys.contains("JobId") {
                        self.jobId = dict["JobId"] as! String
                    }
                    if dict.keys.contains("Originator") {
                        self.originator = dict["Originator"] as! String
                    }
                    if dict.keys.contains("ReleaseInitiator") {
                        self.releaseInitiator = dict["ReleaseInitiator"] as! String
                    }
                    if dict.keys.contains("ReleaseReason") {
                        self.releaseReason = dict["ReleaseReason"] as! String
                    }
                    if dict.keys.contains("SkillGroupId") {
                        self.skillGroupId = dict["SkillGroupId"] as! String
                    }
                    if dict.keys.contains("Timestamp") {
                        self.timestamp = dict["Timestamp"] as! Int64
                    }
                    if dict.keys.contains("UserExtension") {
                        self.userExtension = dict["UserExtension"] as! String
                    }
                    if dict.keys.contains("UserId") {
                        self.userId = dict["UserId"] as! String
                    }
                }
            }
            public var callType: String?

            public var channelContexts: [InterceptCallResponseBody.Data.CallContext.ChannelContexts]?

            public var instanceId: String?

            public var jobId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.callType != nil {
                    map["CallType"] = self.callType!
                }
                if self.channelContexts != nil {
                    var tmp : [Any] = []
                    for k in self.channelContexts! {
                        tmp.append(k.toMap())
                    }
                    map["ChannelContexts"] = tmp
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.jobId != nil {
                    map["JobId"] = self.jobId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CallType") {
                    self.callType = dict["CallType"] as! String
                }
                if dict.keys.contains("ChannelContexts") {
                    var tmp : [InterceptCallResponseBody.Data.CallContext.ChannelContexts] = []
                    for v in dict["ChannelContexts"] as! [Any] {
                        var model = InterceptCallResponseBody.Data.CallContext.ChannelContexts()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.channelContexts = tmp
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("JobId") {
                    self.jobId = dict["JobId"] as! String
                }
            }
        }
        public class UserContext : Tea.TeaModel {
            public var breakCode: String?

            public var deviceId: String?

            public var extension_: String?

            public var heartbeat: Int64?

            public var instanceId: String?

            public var jobId: String?

            public var mobile: String?

            public var outboundScenario: Bool?

            public var reserved: Int64?

            public var signedSkillGroupIdList: [String]?

            public var userId: String?

            public var userState: String?

            public var workMode: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.breakCode != nil {
                    map["BreakCode"] = self.breakCode!
                }
                if self.deviceId != nil {
                    map["DeviceId"] = self.deviceId!
                }
                if self.extension_ != nil {
                    map["Extension"] = self.extension_!
                }
                if self.heartbeat != nil {
                    map["Heartbeat"] = self.heartbeat!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.jobId != nil {
                    map["JobId"] = self.jobId!
                }
                if self.mobile != nil {
                    map["Mobile"] = self.mobile!
                }
                if self.outboundScenario != nil {
                    map["OutboundScenario"] = self.outboundScenario!
                }
                if self.reserved != nil {
                    map["Reserved"] = self.reserved!
                }
                if self.signedSkillGroupIdList != nil {
                    map["SignedSkillGroupIdList"] = self.signedSkillGroupIdList!
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                if self.userState != nil {
                    map["UserState"] = self.userState!
                }
                if self.workMode != nil {
                    map["WorkMode"] = self.workMode!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BreakCode") {
                    self.breakCode = dict["BreakCode"] as! String
                }
                if dict.keys.contains("DeviceId") {
                    self.deviceId = dict["DeviceId"] as! String
                }
                if dict.keys.contains("Extension") {
                    self.extension_ = dict["Extension"] as! String
                }
                if dict.keys.contains("Heartbeat") {
                    self.heartbeat = dict["Heartbeat"] as! Int64
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("JobId") {
                    self.jobId = dict["JobId"] as! String
                }
                if dict.keys.contains("Mobile") {
                    self.mobile = dict["Mobile"] as! String
                }
                if dict.keys.contains("OutboundScenario") {
                    self.outboundScenario = dict["OutboundScenario"] as! Bool
                }
                if dict.keys.contains("Reserved") {
                    self.reserved = dict["Reserved"] as! Int64
                }
                if dict.keys.contains("SignedSkillGroupIdList") {
                    self.signedSkillGroupIdList = dict["SignedSkillGroupIdList"] as! [String]
                }
                if dict.keys.contains("UserId") {
                    self.userId = dict["UserId"] as! String
                }
                if dict.keys.contains("UserState") {
                    self.userState = dict["UserState"] as! String
                }
                if dict.keys.contains("WorkMode") {
                    self.workMode = dict["WorkMode"] as! String
                }
            }
        }
        public var callContext: InterceptCallResponseBody.Data.CallContext?

        public var userContext: InterceptCallResponseBody.Data.UserContext?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.callContext?.validate()
            try self.userContext?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.callContext != nil {
                map["CallContext"] = self.callContext?.toMap()
            }
            if self.userContext != nil {
                map["UserContext"] = self.userContext?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CallContext") {
                var model = InterceptCallResponseBody.Data.CallContext()
                model.fromMap(dict["CallContext"] as! [String: Any])
                self.callContext = model
            }
            if dict.keys.contains("UserContext") {
                var model = InterceptCallResponseBody.Data.UserContext()
                model.fromMap(dict["UserContext"] as! [String: Any])
                self.userContext = model
            }
        }
    }
    public var code: String?

    public var data: InterceptCallResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var params: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.params != nil {
            map["Params"] = self.params!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = InterceptCallResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Params") {
            self.params = dict["Params"] as! [String]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class InterceptCallResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: InterceptCallResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = InterceptCallResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class LaunchAuthenticationRequest : Tea.TeaModel {
    public var contactFlowId: String?

    public var contactFlowVariables: String?

    public var deviceId: String?

    public var instanceId: String?

    public var jobId: String?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.contactFlowId != nil {
            map["ContactFlowId"] = self.contactFlowId!
        }
        if self.contactFlowVariables != nil {
            map["ContactFlowVariables"] = self.contactFlowVariables!
        }
        if self.deviceId != nil {
            map["DeviceId"] = self.deviceId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ContactFlowId") {
            self.contactFlowId = dict["ContactFlowId"] as! String
        }
        if dict.keys.contains("ContactFlowVariables") {
            self.contactFlowVariables = dict["ContactFlowVariables"] as! String
        }
        if dict.keys.contains("DeviceId") {
            self.deviceId = dict["DeviceId"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("UserId") {
            self.userId = dict["UserId"] as! String
        }
    }
}

public class LaunchAuthenticationResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class CallContext : Tea.TeaModel {
            public class ChannelContexts : Tea.TeaModel {
                public var callType: String?

                public var channelFlags: String?

                public var channelId: String?

                public var channelState: String?

                public var destination: String?

                public var index: Int32?

                public var jobId: String?

                public var originator: String?

                public var releaseInitiator: String?

                public var releaseReason: String?

                public var skillGroupId: String?

                public var timestamp: Int64?

                public var userExtension: String?

                public var userId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.callType != nil {
                        map["CallType"] = self.callType!
                    }
                    if self.channelFlags != nil {
                        map["ChannelFlags"] = self.channelFlags!
                    }
                    if self.channelId != nil {
                        map["ChannelId"] = self.channelId!
                    }
                    if self.channelState != nil {
                        map["ChannelState"] = self.channelState!
                    }
                    if self.destination != nil {
                        map["Destination"] = self.destination!
                    }
                    if self.index != nil {
                        map["Index"] = self.index!
                    }
                    if self.jobId != nil {
                        map["JobId"] = self.jobId!
                    }
                    if self.originator != nil {
                        map["Originator"] = self.originator!
                    }
                    if self.releaseInitiator != nil {
                        map["ReleaseInitiator"] = self.releaseInitiator!
                    }
                    if self.releaseReason != nil {
                        map["ReleaseReason"] = self.releaseReason!
                    }
                    if self.skillGroupId != nil {
                        map["SkillGroupId"] = self.skillGroupId!
                    }
                    if self.timestamp != nil {
                        map["Timestamp"] = self.timestamp!
                    }
                    if self.userExtension != nil {
                        map["UserExtension"] = self.userExtension!
                    }
                    if self.userId != nil {
                        map["UserId"] = self.userId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("CallType") {
                        self.callType = dict["CallType"] as! String
                    }
                    if dict.keys.contains("ChannelFlags") {
                        self.channelFlags = dict["ChannelFlags"] as! String
                    }
                    if dict.keys.contains("ChannelId") {
                        self.channelId = dict["ChannelId"] as! String
                    }
                    if dict.keys.contains("ChannelState") {
                        self.channelState = dict["ChannelState"] as! String
                    }
                    if dict.keys.contains("Destination") {
                        self.destination = dict["Destination"] as! String
                    }
                    if dict.keys.contains("Index") {
                        self.index = dict["Index"] as! Int32
                    }
                    if dict.keys.contains("JobId") {
                        self.jobId = dict["JobId"] as! String
                    }
                    if dict.keys.contains("Originator") {
                        self.originator = dict["Originator"] as! String
                    }
                    if dict.keys.contains("ReleaseInitiator") {
                        self.releaseInitiator = dict["ReleaseInitiator"] as! String
                    }
                    if dict.keys.contains("ReleaseReason") {
                        self.releaseReason = dict["ReleaseReason"] as! String
                    }
                    if dict.keys.contains("SkillGroupId") {
                        self.skillGroupId = dict["SkillGroupId"] as! String
                    }
                    if dict.keys.contains("Timestamp") {
                        self.timestamp = dict["Timestamp"] as! Int64
                    }
                    if dict.keys.contains("UserExtension") {
                        self.userExtension = dict["UserExtension"] as! String
                    }
                    if dict.keys.contains("UserId") {
                        self.userId = dict["UserId"] as! String
                    }
                }
            }
            public var callType: String?

            public var channelContexts: [LaunchAuthenticationResponseBody.Data.CallContext.ChannelContexts]?

            public var instanceId: String?

            public var jobId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.callType != nil {
                    map["CallType"] = self.callType!
                }
                if self.channelContexts != nil {
                    var tmp : [Any] = []
                    for k in self.channelContexts! {
                        tmp.append(k.toMap())
                    }
                    map["ChannelContexts"] = tmp
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.jobId != nil {
                    map["JobId"] = self.jobId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CallType") {
                    self.callType = dict["CallType"] as! String
                }
                if dict.keys.contains("ChannelContexts") {
                    var tmp : [LaunchAuthenticationResponseBody.Data.CallContext.ChannelContexts] = []
                    for v in dict["ChannelContexts"] as! [Any] {
                        var model = LaunchAuthenticationResponseBody.Data.CallContext.ChannelContexts()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.channelContexts = tmp
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("JobId") {
                    self.jobId = dict["JobId"] as! String
                }
            }
        }
        public class UserContext : Tea.TeaModel {
            public var breakCode: String?

            public var deviceId: String?

            public var extension_: String?

            public var heartbeat: Int64?

            public var instanceId: String?

            public var jobId: String?

            public var mobile: String?

            public var outboundScenario: Bool?

            public var reserved: Int64?

            public var signedSkillGroupIdList: [String]?

            public var userId: String?

            public var userState: String?

            public var workMode: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.breakCode != nil {
                    map["BreakCode"] = self.breakCode!
                }
                if self.deviceId != nil {
                    map["DeviceId"] = self.deviceId!
                }
                if self.extension_ != nil {
                    map["Extension"] = self.extension_!
                }
                if self.heartbeat != nil {
                    map["Heartbeat"] = self.heartbeat!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.jobId != nil {
                    map["JobId"] = self.jobId!
                }
                if self.mobile != nil {
                    map["Mobile"] = self.mobile!
                }
                if self.outboundScenario != nil {
                    map["OutboundScenario"] = self.outboundScenario!
                }
                if self.reserved != nil {
                    map["Reserved"] = self.reserved!
                }
                if self.signedSkillGroupIdList != nil {
                    map["SignedSkillGroupIdList"] = self.signedSkillGroupIdList!
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                if self.userState != nil {
                    map["UserState"] = self.userState!
                }
                if self.workMode != nil {
                    map["WorkMode"] = self.workMode!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BreakCode") {
                    self.breakCode = dict["BreakCode"] as! String
                }
                if dict.keys.contains("DeviceId") {
                    self.deviceId = dict["DeviceId"] as! String
                }
                if dict.keys.contains("Extension") {
                    self.extension_ = dict["Extension"] as! String
                }
                if dict.keys.contains("Heartbeat") {
                    self.heartbeat = dict["Heartbeat"] as! Int64
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("JobId") {
                    self.jobId = dict["JobId"] as! String
                }
                if dict.keys.contains("Mobile") {
                    self.mobile = dict["Mobile"] as! String
                }
                if dict.keys.contains("OutboundScenario") {
                    self.outboundScenario = dict["OutboundScenario"] as! Bool
                }
                if dict.keys.contains("Reserved") {
                    self.reserved = dict["Reserved"] as! Int64
                }
                if dict.keys.contains("SignedSkillGroupIdList") {
                    self.signedSkillGroupIdList = dict["SignedSkillGroupIdList"] as! [String]
                }
                if dict.keys.contains("UserId") {
                    self.userId = dict["UserId"] as! String
                }
                if dict.keys.contains("UserState") {
                    self.userState = dict["UserState"] as! String
                }
                if dict.keys.contains("WorkMode") {
                    self.workMode = dict["WorkMode"] as! String
                }
            }
        }
        public var callContext: LaunchAuthenticationResponseBody.Data.CallContext?

        public var userContext: LaunchAuthenticationResponseBody.Data.UserContext?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.callContext?.validate()
            try self.userContext?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.callContext != nil {
                map["CallContext"] = self.callContext?.toMap()
            }
            if self.userContext != nil {
                map["UserContext"] = self.userContext?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CallContext") {
                var model = LaunchAuthenticationResponseBody.Data.CallContext()
                model.fromMap(dict["CallContext"] as! [String: Any])
                self.callContext = model
            }
            if dict.keys.contains("UserContext") {
                var model = LaunchAuthenticationResponseBody.Data.UserContext()
                model.fromMap(dict["UserContext"] as! [String: Any])
                self.userContext = model
            }
        }
    }
    public var code: String?

    public var data: LaunchAuthenticationResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var params: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.params != nil {
            map["Params"] = self.params!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = LaunchAuthenticationResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Params") {
            self.params = dict["Params"] as! [String]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class LaunchAuthenticationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: LaunchAuthenticationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = LaunchAuthenticationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class LaunchSurveyRequest : Tea.TeaModel {
    public var contactFlowId: String?

    public var contactFlowVariables: String?

    public var deviceId: String?

    public var instanceId: String?

    public var jobId: String?

    public var smsMetadataId: String?

    public var surveyChannel: String?

    public var surveyTemplateId: String?

    public var surveyTemplateVariables: String?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.contactFlowId != nil {
            map["ContactFlowId"] = self.contactFlowId!
        }
        if self.contactFlowVariables != nil {
            map["ContactFlowVariables"] = self.contactFlowVariables!
        }
        if self.deviceId != nil {
            map["DeviceId"] = self.deviceId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.smsMetadataId != nil {
            map["SmsMetadataId"] = self.smsMetadataId!
        }
        if self.surveyChannel != nil {
            map["SurveyChannel"] = self.surveyChannel!
        }
        if self.surveyTemplateId != nil {
            map["SurveyTemplateId"] = self.surveyTemplateId!
        }
        if self.surveyTemplateVariables != nil {
            map["SurveyTemplateVariables"] = self.surveyTemplateVariables!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ContactFlowId") {
            self.contactFlowId = dict["ContactFlowId"] as! String
        }
        if dict.keys.contains("ContactFlowVariables") {
            self.contactFlowVariables = dict["ContactFlowVariables"] as! String
        }
        if dict.keys.contains("DeviceId") {
            self.deviceId = dict["DeviceId"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("SmsMetadataId") {
            self.smsMetadataId = dict["SmsMetadataId"] as! String
        }
        if dict.keys.contains("SurveyChannel") {
            self.surveyChannel = dict["SurveyChannel"] as! String
        }
        if dict.keys.contains("SurveyTemplateId") {
            self.surveyTemplateId = dict["SurveyTemplateId"] as! String
        }
        if dict.keys.contains("SurveyTemplateVariables") {
            self.surveyTemplateVariables = dict["SurveyTemplateVariables"] as! String
        }
        if dict.keys.contains("UserId") {
            self.userId = dict["UserId"] as! String
        }
    }
}

public class LaunchSurveyResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class CallContext : Tea.TeaModel {
            public class ChannelContexts : Tea.TeaModel {
                public var callType: String?

                public var channelFlags: String?

                public var channelId: String?

                public var channelState: String?

                public var destination: String?

                public var index: Int32?

                public var jobId: String?

                public var originator: String?

                public var releaseInitiator: String?

                public var releaseReason: String?

                public var skillGroupId: String?

                public var timestamp: Int64?

                public var userExtension: String?

                public var userId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.callType != nil {
                        map["CallType"] = self.callType!
                    }
                    if self.channelFlags != nil {
                        map["ChannelFlags"] = self.channelFlags!
                    }
                    if self.channelId != nil {
                        map["ChannelId"] = self.channelId!
                    }
                    if self.channelState != nil {
                        map["ChannelState"] = self.channelState!
                    }
                    if self.destination != nil {
                        map["Destination"] = self.destination!
                    }
                    if self.index != nil {
                        map["Index"] = self.index!
                    }
                    if self.jobId != nil {
                        map["JobId"] = self.jobId!
                    }
                    if self.originator != nil {
                        map["Originator"] = self.originator!
                    }
                    if self.releaseInitiator != nil {
                        map["ReleaseInitiator"] = self.releaseInitiator!
                    }
                    if self.releaseReason != nil {
                        map["ReleaseReason"] = self.releaseReason!
                    }
                    if self.skillGroupId != nil {
                        map["SkillGroupId"] = self.skillGroupId!
                    }
                    if self.timestamp != nil {
                        map["Timestamp"] = self.timestamp!
                    }
                    if self.userExtension != nil {
                        map["UserExtension"] = self.userExtension!
                    }
                    if self.userId != nil {
                        map["UserId"] = self.userId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("CallType") {
                        self.callType = dict["CallType"] as! String
                    }
                    if dict.keys.contains("ChannelFlags") {
                        self.channelFlags = dict["ChannelFlags"] as! String
                    }
                    if dict.keys.contains("ChannelId") {
                        self.channelId = dict["ChannelId"] as! String
                    }
                    if dict.keys.contains("ChannelState") {
                        self.channelState = dict["ChannelState"] as! String
                    }
                    if dict.keys.contains("Destination") {
                        self.destination = dict["Destination"] as! String
                    }
                    if dict.keys.contains("Index") {
                        self.index = dict["Index"] as! Int32
                    }
                    if dict.keys.contains("JobId") {
                        self.jobId = dict["JobId"] as! String
                    }
                    if dict.keys.contains("Originator") {
                        self.originator = dict["Originator"] as! String
                    }
                    if dict.keys.contains("ReleaseInitiator") {
                        self.releaseInitiator = dict["ReleaseInitiator"] as! String
                    }
                    if dict.keys.contains("ReleaseReason") {
                        self.releaseReason = dict["ReleaseReason"] as! String
                    }
                    if dict.keys.contains("SkillGroupId") {
                        self.skillGroupId = dict["SkillGroupId"] as! String
                    }
                    if dict.keys.contains("Timestamp") {
                        self.timestamp = dict["Timestamp"] as! Int64
                    }
                    if dict.keys.contains("UserExtension") {
                        self.userExtension = dict["UserExtension"] as! String
                    }
                    if dict.keys.contains("UserId") {
                        self.userId = dict["UserId"] as! String
                    }
                }
            }
            public var callType: String?

            public var channelContexts: [LaunchSurveyResponseBody.Data.CallContext.ChannelContexts]?

            public var instanceId: String?

            public var jobId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.callType != nil {
                    map["CallType"] = self.callType!
                }
                if self.channelContexts != nil {
                    var tmp : [Any] = []
                    for k in self.channelContexts! {
                        tmp.append(k.toMap())
                    }
                    map["ChannelContexts"] = tmp
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.jobId != nil {
                    map["JobId"] = self.jobId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CallType") {
                    self.callType = dict["CallType"] as! String
                }
                if dict.keys.contains("ChannelContexts") {
                    var tmp : [LaunchSurveyResponseBody.Data.CallContext.ChannelContexts] = []
                    for v in dict["ChannelContexts"] as! [Any] {
                        var model = LaunchSurveyResponseBody.Data.CallContext.ChannelContexts()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.channelContexts = tmp
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("JobId") {
                    self.jobId = dict["JobId"] as! String
                }
            }
        }
        public class UserContext : Tea.TeaModel {
            public var breakCode: String?

            public var deviceId: String?

            public var extension_: String?

            public var heartbeat: Int64?

            public var instanceId: String?

            public var jobId: String?

            public var mobile: String?

            public var outboundScenario: Bool?

            public var reserved: Int64?

            public var signedSkillGroupIdList: [String]?

            public var userId: String?

            public var userState: String?

            public var workMode: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.breakCode != nil {
                    map["BreakCode"] = self.breakCode!
                }
                if self.deviceId != nil {
                    map["DeviceId"] = self.deviceId!
                }
                if self.extension_ != nil {
                    map["Extension"] = self.extension_!
                }
                if self.heartbeat != nil {
                    map["Heartbeat"] = self.heartbeat!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.jobId != nil {
                    map["JobId"] = self.jobId!
                }
                if self.mobile != nil {
                    map["Mobile"] = self.mobile!
                }
                if self.outboundScenario != nil {
                    map["OutboundScenario"] = self.outboundScenario!
                }
                if self.reserved != nil {
                    map["Reserved"] = self.reserved!
                }
                if self.signedSkillGroupIdList != nil {
                    map["SignedSkillGroupIdList"] = self.signedSkillGroupIdList!
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                if self.userState != nil {
                    map["UserState"] = self.userState!
                }
                if self.workMode != nil {
                    map["WorkMode"] = self.workMode!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BreakCode") {
                    self.breakCode = dict["BreakCode"] as! String
                }
                if dict.keys.contains("DeviceId") {
                    self.deviceId = dict["DeviceId"] as! String
                }
                if dict.keys.contains("Extension") {
                    self.extension_ = dict["Extension"] as! String
                }
                if dict.keys.contains("Heartbeat") {
                    self.heartbeat = dict["Heartbeat"] as! Int64
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("JobId") {
                    self.jobId = dict["JobId"] as! String
                }
                if dict.keys.contains("Mobile") {
                    self.mobile = dict["Mobile"] as! String
                }
                if dict.keys.contains("OutboundScenario") {
                    self.outboundScenario = dict["OutboundScenario"] as! Bool
                }
                if dict.keys.contains("Reserved") {
                    self.reserved = dict["Reserved"] as! Int64
                }
                if dict.keys.contains("SignedSkillGroupIdList") {
                    self.signedSkillGroupIdList = dict["SignedSkillGroupIdList"] as! [String]
                }
                if dict.keys.contains("UserId") {
                    self.userId = dict["UserId"] as! String
                }
                if dict.keys.contains("UserState") {
                    self.userState = dict["UserState"] as! String
                }
                if dict.keys.contains("WorkMode") {
                    self.workMode = dict["WorkMode"] as! String
                }
            }
        }
        public var callContext: LaunchSurveyResponseBody.Data.CallContext?

        public var contextId: Int64?

        public var userContext: LaunchSurveyResponseBody.Data.UserContext?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.callContext?.validate()
            try self.userContext?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.callContext != nil {
                map["CallContext"] = self.callContext?.toMap()
            }
            if self.contextId != nil {
                map["ContextId"] = self.contextId!
            }
            if self.userContext != nil {
                map["UserContext"] = self.userContext?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CallContext") {
                var model = LaunchSurveyResponseBody.Data.CallContext()
                model.fromMap(dict["CallContext"] as! [String: Any])
                self.callContext = model
            }
            if dict.keys.contains("ContextId") {
                self.contextId = dict["ContextId"] as! Int64
            }
            if dict.keys.contains("UserContext") {
                var model = LaunchSurveyResponseBody.Data.UserContext()
                model.fromMap(dict["UserContext"] as! [String: Any])
                self.userContext = model
            }
        }
    }
    public var code: String?

    public var data: LaunchSurveyResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var params: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.params != nil {
            map["Params"] = self.params!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = LaunchSurveyResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Params") {
            self.params = dict["Params"] as! [String]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class LaunchSurveyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: LaunchSurveyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = LaunchSurveyResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListAgentStateLogsRequest : Tea.TeaModel {
    public var agentId: String?

    public var endTime: Int64?

    public var instanceId: String?

    public var startTime: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.agentId != nil {
            map["AgentId"] = self.agentId!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AgentId") {
            self.agentId = dict["AgentId"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! Int64
        }
    }
}

public class ListAgentStateLogsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var breakCode: String?

        public var duration: Int64?

        public var outboundScenario: Bool?

        public var startTime: Int64?

        public var state: String?

        public var stateCode: String?

        public var workMode: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.breakCode != nil {
                map["BreakCode"] = self.breakCode!
            }
            if self.duration != nil {
                map["Duration"] = self.duration!
            }
            if self.outboundScenario != nil {
                map["OutboundScenario"] = self.outboundScenario!
            }
            if self.startTime != nil {
                map["StartTime"] = self.startTime!
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            if self.stateCode != nil {
                map["StateCode"] = self.stateCode!
            }
            if self.workMode != nil {
                map["WorkMode"] = self.workMode!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BreakCode") {
                self.breakCode = dict["BreakCode"] as! String
            }
            if dict.keys.contains("Duration") {
                self.duration = dict["Duration"] as! Int64
            }
            if dict.keys.contains("OutboundScenario") {
                self.outboundScenario = dict["OutboundScenario"] as! Bool
            }
            if dict.keys.contains("StartTime") {
                self.startTime = dict["StartTime"] as! Int64
            }
            if dict.keys.contains("State") {
                self.state = dict["State"] as! String
            }
            if dict.keys.contains("StateCode") {
                self.stateCode = dict["StateCode"] as! String
            }
            if dict.keys.contains("WorkMode") {
                self.workMode = dict["WorkMode"] as! String
            }
        }
    }
    public var code: String?

    public var data: [ListAgentStateLogsResponseBody.Data]?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var tmp : [ListAgentStateLogsResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = ListAgentStateLogsResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListAgentStateLogsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListAgentStateLogsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListAgentStateLogsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListAgentStatesRequest : Tea.TeaModel {
    public var agentIds: String?

    public var excludeOfflineUsers: Bool?

    public var instanceId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var skillGroupId: String?

    public var state: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.agentIds != nil {
            map["AgentIds"] = self.agentIds!
        }
        if self.excludeOfflineUsers != nil {
            map["ExcludeOfflineUsers"] = self.excludeOfflineUsers!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.skillGroupId != nil {
            map["SkillGroupId"] = self.skillGroupId!
        }
        if self.state != nil {
            map["State"] = self.state!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AgentIds") {
            self.agentIds = dict["AgentIds"] as! String
        }
        if dict.keys.contains("ExcludeOfflineUsers") {
            self.excludeOfflineUsers = dict["ExcludeOfflineUsers"] as! Bool
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SkillGroupId") {
            self.skillGroupId = dict["SkillGroupId"] as! String
        }
        if dict.keys.contains("State") {
            self.state = dict["State"] as! String
        }
    }
}

public class ListAgentStatesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class List : Tea.TeaModel {
            public var agentId: String?

            public var agentName: String?

            public var breakCode: String?

            public var dn: String?

            public var instanceId: String?

            public var loginName: String?

            public var outboundScenario: Bool?

            public var state: String?

            public var stateDuration: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.agentId != nil {
                    map["AgentId"] = self.agentId!
                }
                if self.agentName != nil {
                    map["AgentName"] = self.agentName!
                }
                if self.breakCode != nil {
                    map["BreakCode"] = self.breakCode!
                }
                if self.dn != nil {
                    map["Dn"] = self.dn!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.loginName != nil {
                    map["LoginName"] = self.loginName!
                }
                if self.outboundScenario != nil {
                    map["OutboundScenario"] = self.outboundScenario!
                }
                if self.state != nil {
                    map["State"] = self.state!
                }
                if self.stateDuration != nil {
                    map["StateDuration"] = self.stateDuration!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AgentId") {
                    self.agentId = dict["AgentId"] as! String
                }
                if dict.keys.contains("AgentName") {
                    self.agentName = dict["AgentName"] as! String
                }
                if dict.keys.contains("BreakCode") {
                    self.breakCode = dict["BreakCode"] as! String
                }
                if dict.keys.contains("Dn") {
                    self.dn = dict["Dn"] as! String
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("LoginName") {
                    self.loginName = dict["LoginName"] as! String
                }
                if dict.keys.contains("OutboundScenario") {
                    self.outboundScenario = dict["OutboundScenario"] as! Bool
                }
                if dict.keys.contains("State") {
                    self.state = dict["State"] as! String
                }
                if dict.keys.contains("StateDuration") {
                    self.stateDuration = dict["StateDuration"] as! String
                }
            }
        }
        public var list: [ListAgentStatesResponseBody.Data.List]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.list != nil {
                var tmp : [Any] = []
                for k in self.list! {
                    tmp.append(k.toMap())
                }
                map["List"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("List") {
                var tmp : [ListAgentStatesResponseBody.Data.List] = []
                for v in dict["List"] as! [Any] {
                    var model = ListAgentStatesResponseBody.Data.List()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.list = tmp
            }
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var code: String?

    public var data: ListAgentStatesResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = ListAgentStatesResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListAgentStatesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListAgentStatesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListAgentStatesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListAgentSummaryReportsSinceMidnightRequest : Tea.TeaModel {
    public var agentIds: String?

    public var instanceId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var skillGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.agentIds != nil {
            map["AgentIds"] = self.agentIds!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.skillGroupId != nil {
            map["SkillGroupId"] = self.skillGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AgentIds") {
            self.agentIds = dict["AgentIds"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SkillGroupId") {
            self.skillGroupId = dict["SkillGroupId"] as! String
        }
    }
}

public class ListAgentSummaryReportsSinceMidnightResponseBody : Tea.TeaModel {
    public class PagedAgentSummaryReport : Tea.TeaModel {
        public class List : Tea.TeaModel {
            public class Inbound : Tea.TeaModel {
                public var averageRingTime: Int64?

                public var averageTalkTime: Int64?

                public var averageWorkTime: Int64?

                public var callsHandled: Int64?

                public var callsOffered: Int64?

                public var handleRate: Double?

                public var maxRingTime: Int64?

                public var maxTalkTime: Int64?

                public var maxWorkTime: Int64?

                public var satisfactionIndex: Double?

                public var satisfactionSurveysOffered: Int64?

                public var satisfactionSurveysResponded: Int64?

                public var serviceLevel20: Double?

                public var totalRingTime: Int64?

                public var totalTalkTime: Int64?

                public var totalWorkTime: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.averageRingTime != nil {
                        map["AverageRingTime"] = self.averageRingTime!
                    }
                    if self.averageTalkTime != nil {
                        map["AverageTalkTime"] = self.averageTalkTime!
                    }
                    if self.averageWorkTime != nil {
                        map["AverageWorkTime"] = self.averageWorkTime!
                    }
                    if self.callsHandled != nil {
                        map["CallsHandled"] = self.callsHandled!
                    }
                    if self.callsOffered != nil {
                        map["CallsOffered"] = self.callsOffered!
                    }
                    if self.handleRate != nil {
                        map["HandleRate"] = self.handleRate!
                    }
                    if self.maxRingTime != nil {
                        map["MaxRingTime"] = self.maxRingTime!
                    }
                    if self.maxTalkTime != nil {
                        map["MaxTalkTime"] = self.maxTalkTime!
                    }
                    if self.maxWorkTime != nil {
                        map["MaxWorkTime"] = self.maxWorkTime!
                    }
                    if self.satisfactionIndex != nil {
                        map["SatisfactionIndex"] = self.satisfactionIndex!
                    }
                    if self.satisfactionSurveysOffered != nil {
                        map["SatisfactionSurveysOffered"] = self.satisfactionSurveysOffered!
                    }
                    if self.satisfactionSurveysResponded != nil {
                        map["SatisfactionSurveysResponded"] = self.satisfactionSurveysResponded!
                    }
                    if self.serviceLevel20 != nil {
                        map["ServiceLevel20"] = self.serviceLevel20!
                    }
                    if self.totalRingTime != nil {
                        map["TotalRingTime"] = self.totalRingTime!
                    }
                    if self.totalTalkTime != nil {
                        map["TotalTalkTime"] = self.totalTalkTime!
                    }
                    if self.totalWorkTime != nil {
                        map["TotalWorkTime"] = self.totalWorkTime!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AverageRingTime") {
                        self.averageRingTime = dict["AverageRingTime"] as! Int64
                    }
                    if dict.keys.contains("AverageTalkTime") {
                        self.averageTalkTime = dict["AverageTalkTime"] as! Int64
                    }
                    if dict.keys.contains("AverageWorkTime") {
                        self.averageWorkTime = dict["AverageWorkTime"] as! Int64
                    }
                    if dict.keys.contains("CallsHandled") {
                        self.callsHandled = dict["CallsHandled"] as! Int64
                    }
                    if dict.keys.contains("CallsOffered") {
                        self.callsOffered = dict["CallsOffered"] as! Int64
                    }
                    if dict.keys.contains("HandleRate") {
                        self.handleRate = dict["HandleRate"] as! Double
                    }
                    if dict.keys.contains("MaxRingTime") {
                        self.maxRingTime = dict["MaxRingTime"] as! Int64
                    }
                    if dict.keys.contains("MaxTalkTime") {
                        self.maxTalkTime = dict["MaxTalkTime"] as! Int64
                    }
                    if dict.keys.contains("MaxWorkTime") {
                        self.maxWorkTime = dict["MaxWorkTime"] as! Int64
                    }
                    if dict.keys.contains("SatisfactionIndex") {
                        self.satisfactionIndex = dict["SatisfactionIndex"] as! Double
                    }
                    if dict.keys.contains("SatisfactionSurveysOffered") {
                        self.satisfactionSurveysOffered = dict["SatisfactionSurveysOffered"] as! Int64
                    }
                    if dict.keys.contains("SatisfactionSurveysResponded") {
                        self.satisfactionSurveysResponded = dict["SatisfactionSurveysResponded"] as! Int64
                    }
                    if dict.keys.contains("ServiceLevel20") {
                        self.serviceLevel20 = dict["ServiceLevel20"] as! Double
                    }
                    if dict.keys.contains("TotalRingTime") {
                        self.totalRingTime = dict["TotalRingTime"] as! Int64
                    }
                    if dict.keys.contains("TotalTalkTime") {
                        self.totalTalkTime = dict["TotalTalkTime"] as! Int64
                    }
                    if dict.keys.contains("TotalWorkTime") {
                        self.totalWorkTime = dict["TotalWorkTime"] as! Int64
                    }
                }
            }
            public class Outbound : Tea.TeaModel {
                public var answerRate: Double?

                public var averageDialingTime: Int64?

                public var averageTalkTime: Int64?

                public var averageWorkTime: Int64?

                public var callsAnswered: Int64?

                public var callsDialed: Int64?

                public var maxDialingTime: Int64?

                public var maxTalkTime: Int64?

                public var maxWorkTime: String?

                public var satisfactionIndex: Double?

                public var satisfactionSurveysOffered: Int64?

                public var satisfactionSurveysResponded: Int64?

                public var totalDialingTime: Int64?

                public var totalTalkTime: Int64?

                public var totalWorkTime: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.answerRate != nil {
                        map["AnswerRate"] = self.answerRate!
                    }
                    if self.averageDialingTime != nil {
                        map["AverageDialingTime"] = self.averageDialingTime!
                    }
                    if self.averageTalkTime != nil {
                        map["AverageTalkTime"] = self.averageTalkTime!
                    }
                    if self.averageWorkTime != nil {
                        map["AverageWorkTime"] = self.averageWorkTime!
                    }
                    if self.callsAnswered != nil {
                        map["CallsAnswered"] = self.callsAnswered!
                    }
                    if self.callsDialed != nil {
                        map["CallsDialed"] = self.callsDialed!
                    }
                    if self.maxDialingTime != nil {
                        map["MaxDialingTime"] = self.maxDialingTime!
                    }
                    if self.maxTalkTime != nil {
                        map["MaxTalkTime"] = self.maxTalkTime!
                    }
                    if self.maxWorkTime != nil {
                        map["MaxWorkTime"] = self.maxWorkTime!
                    }
                    if self.satisfactionIndex != nil {
                        map["SatisfactionIndex"] = self.satisfactionIndex!
                    }
                    if self.satisfactionSurveysOffered != nil {
                        map["SatisfactionSurveysOffered"] = self.satisfactionSurveysOffered!
                    }
                    if self.satisfactionSurveysResponded != nil {
                        map["SatisfactionSurveysResponded"] = self.satisfactionSurveysResponded!
                    }
                    if self.totalDialingTime != nil {
                        map["TotalDialingTime"] = self.totalDialingTime!
                    }
                    if self.totalTalkTime != nil {
                        map["TotalTalkTime"] = self.totalTalkTime!
                    }
                    if self.totalWorkTime != nil {
                        map["TotalWorkTime"] = self.totalWorkTime!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AnswerRate") {
                        self.answerRate = dict["AnswerRate"] as! Double
                    }
                    if dict.keys.contains("AverageDialingTime") {
                        self.averageDialingTime = dict["AverageDialingTime"] as! Int64
                    }
                    if dict.keys.contains("AverageTalkTime") {
                        self.averageTalkTime = dict["AverageTalkTime"] as! Int64
                    }
                    if dict.keys.contains("AverageWorkTime") {
                        self.averageWorkTime = dict["AverageWorkTime"] as! Int64
                    }
                    if dict.keys.contains("CallsAnswered") {
                        self.callsAnswered = dict["CallsAnswered"] as! Int64
                    }
                    if dict.keys.contains("CallsDialed") {
                        self.callsDialed = dict["CallsDialed"] as! Int64
                    }
                    if dict.keys.contains("MaxDialingTime") {
                        self.maxDialingTime = dict["MaxDialingTime"] as! Int64
                    }
                    if dict.keys.contains("MaxTalkTime") {
                        self.maxTalkTime = dict["MaxTalkTime"] as! Int64
                    }
                    if dict.keys.contains("MaxWorkTime") {
                        self.maxWorkTime = dict["MaxWorkTime"] as! String
                    }
                    if dict.keys.contains("SatisfactionIndex") {
                        self.satisfactionIndex = dict["SatisfactionIndex"] as! Double
                    }
                    if dict.keys.contains("SatisfactionSurveysOffered") {
                        self.satisfactionSurveysOffered = dict["SatisfactionSurveysOffered"] as! Int64
                    }
                    if dict.keys.contains("SatisfactionSurveysResponded") {
                        self.satisfactionSurveysResponded = dict["SatisfactionSurveysResponded"] as! Int64
                    }
                    if dict.keys.contains("TotalDialingTime") {
                        self.totalDialingTime = dict["TotalDialingTime"] as! Int64
                    }
                    if dict.keys.contains("TotalTalkTime") {
                        self.totalTalkTime = dict["TotalTalkTime"] as! Int64
                    }
                    if dict.keys.contains("TotalWorkTime") {
                        self.totalWorkTime = dict["TotalWorkTime"] as! Int64
                    }
                }
            }
            public class Overall : Tea.TeaModel {
                public var averageReadyTime: Int64?

                public var averageTalkTime: Int64?

                public var averageWorkTime: Int64?

                public var maxReadyTime: Int64?

                public var maxTalkTime: Int64?

                public var maxWorkTime: Int64?

                public var occupancyRate: Double?

                public var oneTransferCalls: Int64?

                public var satisfactionIndex: Double?

                public var satisfactionSurveysOffered: Int64?

                public var satisfactionSurveysResponded: Int64?

                public var totalBreakTime: Int64?

                public var totalCalls: Int64?

                public var totalLoggedInTime: Int64?

                public var totalReadyTime: Int64?

                public var totalTalkTime: Int64?

                public var totalWorkTime: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.averageReadyTime != nil {
                        map["AverageReadyTime"] = self.averageReadyTime!
                    }
                    if self.averageTalkTime != nil {
                        map["AverageTalkTime"] = self.averageTalkTime!
                    }
                    if self.averageWorkTime != nil {
                        map["AverageWorkTime"] = self.averageWorkTime!
                    }
                    if self.maxReadyTime != nil {
                        map["MaxReadyTime"] = self.maxReadyTime!
                    }
                    if self.maxTalkTime != nil {
                        map["MaxTalkTime"] = self.maxTalkTime!
                    }
                    if self.maxWorkTime != nil {
                        map["MaxWorkTime"] = self.maxWorkTime!
                    }
                    if self.occupancyRate != nil {
                        map["OccupancyRate"] = self.occupancyRate!
                    }
                    if self.oneTransferCalls != nil {
                        map["OneTransferCalls"] = self.oneTransferCalls!
                    }
                    if self.satisfactionIndex != nil {
                        map["SatisfactionIndex"] = self.satisfactionIndex!
                    }
                    if self.satisfactionSurveysOffered != nil {
                        map["SatisfactionSurveysOffered"] = self.satisfactionSurveysOffered!
                    }
                    if self.satisfactionSurveysResponded != nil {
                        map["SatisfactionSurveysResponded"] = self.satisfactionSurveysResponded!
                    }
                    if self.totalBreakTime != nil {
                        map["TotalBreakTime"] = self.totalBreakTime!
                    }
                    if self.totalCalls != nil {
                        map["TotalCalls"] = self.totalCalls!
                    }
                    if self.totalLoggedInTime != nil {
                        map["TotalLoggedInTime"] = self.totalLoggedInTime!
                    }
                    if self.totalReadyTime != nil {
                        map["TotalReadyTime"] = self.totalReadyTime!
                    }
                    if self.totalTalkTime != nil {
                        map["TotalTalkTime"] = self.totalTalkTime!
                    }
                    if self.totalWorkTime != nil {
                        map["TotalWorkTime"] = self.totalWorkTime!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AverageReadyTime") {
                        self.averageReadyTime = dict["AverageReadyTime"] as! Int64
                    }
                    if dict.keys.contains("AverageTalkTime") {
                        self.averageTalkTime = dict["AverageTalkTime"] as! Int64
                    }
                    if dict.keys.contains("AverageWorkTime") {
                        self.averageWorkTime = dict["AverageWorkTime"] as! Int64
                    }
                    if dict.keys.contains("MaxReadyTime") {
                        self.maxReadyTime = dict["MaxReadyTime"] as! Int64
                    }
                    if dict.keys.contains("MaxTalkTime") {
                        self.maxTalkTime = dict["MaxTalkTime"] as! Int64
                    }
                    if dict.keys.contains("MaxWorkTime") {
                        self.maxWorkTime = dict["MaxWorkTime"] as! Int64
                    }
                    if dict.keys.contains("OccupancyRate") {
                        self.occupancyRate = dict["OccupancyRate"] as! Double
                    }
                    if dict.keys.contains("OneTransferCalls") {
                        self.oneTransferCalls = dict["OneTransferCalls"] as! Int64
                    }
                    if dict.keys.contains("SatisfactionIndex") {
                        self.satisfactionIndex = dict["SatisfactionIndex"] as! Double
                    }
                    if dict.keys.contains("SatisfactionSurveysOffered") {
                        self.satisfactionSurveysOffered = dict["SatisfactionSurveysOffered"] as! Int64
                    }
                    if dict.keys.contains("SatisfactionSurveysResponded") {
                        self.satisfactionSurveysResponded = dict["SatisfactionSurveysResponded"] as! Int64
                    }
                    if dict.keys.contains("TotalBreakTime") {
                        self.totalBreakTime = dict["TotalBreakTime"] as! Int64
                    }
                    if dict.keys.contains("TotalCalls") {
                        self.totalCalls = dict["TotalCalls"] as! Int64
                    }
                    if dict.keys.contains("TotalLoggedInTime") {
                        self.totalLoggedInTime = dict["TotalLoggedInTime"] as! Int64
                    }
                    if dict.keys.contains("TotalReadyTime") {
                        self.totalReadyTime = dict["TotalReadyTime"] as! Int64
                    }
                    if dict.keys.contains("TotalTalkTime") {
                        self.totalTalkTime = dict["TotalTalkTime"] as! Int64
                    }
                    if dict.keys.contains("TotalWorkTime") {
                        self.totalWorkTime = dict["TotalWorkTime"] as! Int64
                    }
                }
            }
            public var agentId: String?

            public var agentName: String?

            public var inbound: ListAgentSummaryReportsSinceMidnightResponseBody.PagedAgentSummaryReport.List.Inbound?

            public var instanceId: String?

            public var loginName: String?

            public var outbound: ListAgentSummaryReportsSinceMidnightResponseBody.PagedAgentSummaryReport.List.Outbound?

            public var overall: ListAgentSummaryReportsSinceMidnightResponseBody.PagedAgentSummaryReport.List.Overall?

            public var skillGroupIds: String?

            public var skillGroupNames: String?

            public var timestamp: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.inbound?.validate()
                try self.outbound?.validate()
                try self.overall?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.agentId != nil {
                    map["AgentId"] = self.agentId!
                }
                if self.agentName != nil {
                    map["AgentName"] = self.agentName!
                }
                if self.inbound != nil {
                    map["Inbound"] = self.inbound?.toMap()
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.loginName != nil {
                    map["LoginName"] = self.loginName!
                }
                if self.outbound != nil {
                    map["Outbound"] = self.outbound?.toMap()
                }
                if self.overall != nil {
                    map["Overall"] = self.overall?.toMap()
                }
                if self.skillGroupIds != nil {
                    map["SkillGroupIds"] = self.skillGroupIds!
                }
                if self.skillGroupNames != nil {
                    map["SkillGroupNames"] = self.skillGroupNames!
                }
                if self.timestamp != nil {
                    map["Timestamp"] = self.timestamp!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AgentId") {
                    self.agentId = dict["AgentId"] as! String
                }
                if dict.keys.contains("AgentName") {
                    self.agentName = dict["AgentName"] as! String
                }
                if dict.keys.contains("Inbound") {
                    var model = ListAgentSummaryReportsSinceMidnightResponseBody.PagedAgentSummaryReport.List.Inbound()
                    model.fromMap(dict["Inbound"] as! [String: Any])
                    self.inbound = model
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("LoginName") {
                    self.loginName = dict["LoginName"] as! String
                }
                if dict.keys.contains("Outbound") {
                    var model = ListAgentSummaryReportsSinceMidnightResponseBody.PagedAgentSummaryReport.List.Outbound()
                    model.fromMap(dict["Outbound"] as! [String: Any])
                    self.outbound = model
                }
                if dict.keys.contains("Overall") {
                    var model = ListAgentSummaryReportsSinceMidnightResponseBody.PagedAgentSummaryReport.List.Overall()
                    model.fromMap(dict["Overall"] as! [String: Any])
                    self.overall = model
                }
                if dict.keys.contains("SkillGroupIds") {
                    self.skillGroupIds = dict["SkillGroupIds"] as! String
                }
                if dict.keys.contains("SkillGroupNames") {
                    self.skillGroupNames = dict["SkillGroupNames"] as! String
                }
                if dict.keys.contains("Timestamp") {
                    self.timestamp = dict["Timestamp"] as! String
                }
            }
        }
        public var list: [ListAgentSummaryReportsSinceMidnightResponseBody.PagedAgentSummaryReport.List]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.list != nil {
                var tmp : [Any] = []
                for k in self.list! {
                    tmp.append(k.toMap())
                }
                map["List"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("List") {
                var tmp : [ListAgentSummaryReportsSinceMidnightResponseBody.PagedAgentSummaryReport.List] = []
                for v in dict["List"] as! [Any] {
                    var model = ListAgentSummaryReportsSinceMidnightResponseBody.PagedAgentSummaryReport.List()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.list = tmp
            }
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var code: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var pagedAgentSummaryReport: ListAgentSummaryReportsSinceMidnightResponseBody.PagedAgentSummaryReport?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pagedAgentSummaryReport?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.pagedAgentSummaryReport != nil {
            map["PagedAgentSummaryReport"] = self.pagedAgentSummaryReport?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("PagedAgentSummaryReport") {
            var model = ListAgentSummaryReportsSinceMidnightResponseBody.PagedAgentSummaryReport()
            model.fromMap(dict["PagedAgentSummaryReport"] as! [String: Any])
            self.pagedAgentSummaryReport = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListAgentSummaryReportsSinceMidnightResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListAgentSummaryReportsSinceMidnightResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListAgentSummaryReportsSinceMidnightResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListAttemptsRequest : Tea.TeaModel {
    public var agentId: String?

    public var attemptId: String?

    public var callee: String?

    public var caller: String?

    public var campaignId: String?

    public var caseId: String?

    public var contactId: String?

    public var criteria: String?

    public var endTime: Int64?

    public var instanceId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var queueId: String?

    public var startTime: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.agentId != nil {
            map["AgentId"] = self.agentId!
        }
        if self.attemptId != nil {
            map["AttemptId"] = self.attemptId!
        }
        if self.callee != nil {
            map["Callee"] = self.callee!
        }
        if self.caller != nil {
            map["Caller"] = self.caller!
        }
        if self.campaignId != nil {
            map["CampaignId"] = self.campaignId!
        }
        if self.caseId != nil {
            map["CaseId"] = self.caseId!
        }
        if self.contactId != nil {
            map["ContactId"] = self.contactId!
        }
        if self.criteria != nil {
            map["Criteria"] = self.criteria!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.queueId != nil {
            map["QueueId"] = self.queueId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AgentId") {
            self.agentId = dict["AgentId"] as! String
        }
        if dict.keys.contains("AttemptId") {
            self.attemptId = dict["AttemptId"] as! String
        }
        if dict.keys.contains("Callee") {
            self.callee = dict["Callee"] as! String
        }
        if dict.keys.contains("Caller") {
            self.caller = dict["Caller"] as! String
        }
        if dict.keys.contains("CampaignId") {
            self.campaignId = dict["CampaignId"] as! String
        }
        if dict.keys.contains("CaseId") {
            self.caseId = dict["CaseId"] as! String
        }
        if dict.keys.contains("ContactId") {
            self.contactId = dict["ContactId"] as! String
        }
        if dict.keys.contains("Criteria") {
            self.criteria = dict["Criteria"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("QueueId") {
            self.queueId = dict["QueueId"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! Int64
        }
    }
}

public class ListAttemptsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class List : Tea.TeaModel {
            public var agentEstablishedTime: Int64?

            public var agentId: String?

            public var agentRingDuration: Int64?

            public var assignAgentTime: Int64?

            public var attemptId: String?

            public var callee: String?

            public var caller: String?

            public var campaignId: String?

            public var caseId: String?

            public var contactId: String?

            public var customerEstablishedTime: Int64?

            public var customerReleasedTime: Int64?

            public var dialDuration: Int64?

            public var dialTime: Int64?

            public var enqueueTime: Int64?

            public var enterIvrTime: Int64?

            public var instanceId: String?

            public var ivrDuration: Int64?

            public var queueDuration: Int64?

            public var queueId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.agentEstablishedTime != nil {
                    map["AgentEstablishedTime"] = self.agentEstablishedTime!
                }
                if self.agentId != nil {
                    map["AgentId"] = self.agentId!
                }
                if self.agentRingDuration != nil {
                    map["AgentRingDuration"] = self.agentRingDuration!
                }
                if self.assignAgentTime != nil {
                    map["AssignAgentTime"] = self.assignAgentTime!
                }
                if self.attemptId != nil {
                    map["AttemptId"] = self.attemptId!
                }
                if self.callee != nil {
                    map["Callee"] = self.callee!
                }
                if self.caller != nil {
                    map["Caller"] = self.caller!
                }
                if self.campaignId != nil {
                    map["CampaignId"] = self.campaignId!
                }
                if self.caseId != nil {
                    map["CaseId"] = self.caseId!
                }
                if self.contactId != nil {
                    map["ContactId"] = self.contactId!
                }
                if self.customerEstablishedTime != nil {
                    map["CustomerEstablishedTime"] = self.customerEstablishedTime!
                }
                if self.customerReleasedTime != nil {
                    map["CustomerReleasedTime"] = self.customerReleasedTime!
                }
                if self.dialDuration != nil {
                    map["DialDuration"] = self.dialDuration!
                }
                if self.dialTime != nil {
                    map["DialTime"] = self.dialTime!
                }
                if self.enqueueTime != nil {
                    map["EnqueueTime"] = self.enqueueTime!
                }
                if self.enterIvrTime != nil {
                    map["EnterIvrTime"] = self.enterIvrTime!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.ivrDuration != nil {
                    map["IvrDuration"] = self.ivrDuration!
                }
                if self.queueDuration != nil {
                    map["QueueDuration"] = self.queueDuration!
                }
                if self.queueId != nil {
                    map["QueueId"] = self.queueId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AgentEstablishedTime") {
                    self.agentEstablishedTime = dict["AgentEstablishedTime"] as! Int64
                }
                if dict.keys.contains("AgentId") {
                    self.agentId = dict["AgentId"] as! String
                }
                if dict.keys.contains("AgentRingDuration") {
                    self.agentRingDuration = dict["AgentRingDuration"] as! Int64
                }
                if dict.keys.contains("AssignAgentTime") {
                    self.assignAgentTime = dict["AssignAgentTime"] as! Int64
                }
                if dict.keys.contains("AttemptId") {
                    self.attemptId = dict["AttemptId"] as! String
                }
                if dict.keys.contains("Callee") {
                    self.callee = dict["Callee"] as! String
                }
                if dict.keys.contains("Caller") {
                    self.caller = dict["Caller"] as! String
                }
                if dict.keys.contains("CampaignId") {
                    self.campaignId = dict["CampaignId"] as! String
                }
                if dict.keys.contains("CaseId") {
                    self.caseId = dict["CaseId"] as! String
                }
                if dict.keys.contains("ContactId") {
                    self.contactId = dict["ContactId"] as! String
                }
                if dict.keys.contains("CustomerEstablishedTime") {
                    self.customerEstablishedTime = dict["CustomerEstablishedTime"] as! Int64
                }
                if dict.keys.contains("CustomerReleasedTime") {
                    self.customerReleasedTime = dict["CustomerReleasedTime"] as! Int64
                }
                if dict.keys.contains("DialDuration") {
                    self.dialDuration = dict["DialDuration"] as! Int64
                }
                if dict.keys.contains("DialTime") {
                    self.dialTime = dict["DialTime"] as! Int64
                }
                if dict.keys.contains("EnqueueTime") {
                    self.enqueueTime = dict["EnqueueTime"] as! Int64
                }
                if dict.keys.contains("EnterIvrTime") {
                    self.enterIvrTime = dict["EnterIvrTime"] as! Int64
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("IvrDuration") {
                    self.ivrDuration = dict["IvrDuration"] as! Int64
                }
                if dict.keys.contains("QueueDuration") {
                    self.queueDuration = dict["QueueDuration"] as! Int64
                }
                if dict.keys.contains("QueueId") {
                    self.queueId = dict["QueueId"] as! String
                }
            }
        }
        public var list: [ListAttemptsResponseBody.Data.List]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.list != nil {
                var tmp : [Any] = []
                for k in self.list! {
                    tmp.append(k.toMap())
                }
                map["List"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("List") {
                var tmp : [ListAttemptsResponseBody.Data.List] = []
                for v in dict["List"] as! [Any] {
                    var model = ListAttemptsResponseBody.Data.List()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.list = tmp
            }
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var code: String?

    public var data: ListAttemptsResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = ListAttemptsResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListAttemptsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListAttemptsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListAttemptsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListAudioFilesRequest : Tea.TeaModel {
    public var instanceId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var status: String?

    public var usage: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.usage != nil {
            map["Usage"] = self.usage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("Usage") {
            self.usage = dict["Usage"] as! String
        }
    }
}

public class ListAudioFilesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class List : Tea.TeaModel {
            public var audioFileName: String?

            public var audioResourceId: String?

            public var auditResult: String?

            public var createdTime: String?

            public var instanceId: String?

            public var name: String?

            public var ossFileKey: String?

            public var status: String?

            public var updatedTime: String?

            public var usage: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.audioFileName != nil {
                    map["AudioFileName"] = self.audioFileName!
                }
                if self.audioResourceId != nil {
                    map["AudioResourceId"] = self.audioResourceId!
                }
                if self.auditResult != nil {
                    map["AuditResult"] = self.auditResult!
                }
                if self.createdTime != nil {
                    map["CreatedTime"] = self.createdTime!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.ossFileKey != nil {
                    map["OssFileKey"] = self.ossFileKey!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.updatedTime != nil {
                    map["UpdatedTime"] = self.updatedTime!
                }
                if self.usage != nil {
                    map["Usage"] = self.usage!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AudioFileName") {
                    self.audioFileName = dict["AudioFileName"] as! String
                }
                if dict.keys.contains("AudioResourceId") {
                    self.audioResourceId = dict["AudioResourceId"] as! String
                }
                if dict.keys.contains("AuditResult") {
                    self.auditResult = dict["AuditResult"] as! String
                }
                if dict.keys.contains("CreatedTime") {
                    self.createdTime = dict["CreatedTime"] as! String
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("OssFileKey") {
                    self.ossFileKey = dict["OssFileKey"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("UpdatedTime") {
                    self.updatedTime = dict["UpdatedTime"] as! String
                }
                if dict.keys.contains("Usage") {
                    self.usage = dict["Usage"] as! String
                }
            }
        }
        public var list: [ListAudioFilesResponseBody.Data.List]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.list != nil {
                var tmp : [Any] = []
                for k in self.list! {
                    tmp.append(k.toMap())
                }
                map["List"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("List") {
                var tmp : [ListAudioFilesResponseBody.Data.List] = []
                for v in dict["List"] as! [Any] {
                    var model = ListAudioFilesResponseBody.Data.List()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.list = tmp
            }
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var code: String?

    public var data: ListAudioFilesResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = ListAudioFilesResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListAudioFilesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListAudioFilesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListAudioFilesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListBlacklistCallTaggingsRequest : Tea.TeaModel {
    public var instanceId: String?

    public var numberList: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.numberList != nil {
            map["NumberList"] = self.numberList!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("NumberList") {
            self.numberList = dict["NumberList"] as! String
        }
    }
}

public class ListBlacklistCallTaggingsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var blacklisted: Bool?

        public var jobId: String?

        public var number: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.blacklisted != nil {
                map["Blacklisted"] = self.blacklisted!
            }
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            if self.number != nil {
                map["Number"] = self.number!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Blacklisted") {
                self.blacklisted = dict["Blacklisted"] as! Bool
            }
            if dict.keys.contains("JobId") {
                self.jobId = dict["JobId"] as! String
            }
            if dict.keys.contains("Number") {
                self.number = dict["Number"] as! String
            }
        }
    }
    public var code: String?

    public var data: [ListBlacklistCallTaggingsResponseBody.Data]?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var tmp : [ListBlacklistCallTaggingsResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = ListBlacklistCallTaggingsResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListBlacklistCallTaggingsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListBlacklistCallTaggingsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListBlacklistCallTaggingsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListBriefSkillGroupsRequest : Tea.TeaModel {
    public var instanceId: String?

    public var mediaType: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var searchPattern: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.mediaType != nil {
            map["MediaType"] = self.mediaType!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.searchPattern != nil {
            map["SearchPattern"] = self.searchPattern!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("MediaType") {
            self.mediaType = dict["MediaType"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SearchPattern") {
            self.searchPattern = dict["SearchPattern"] as! String
        }
    }
}

public class ListBriefSkillGroupsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class List : Tea.TeaModel {
            public var description_: String?

            public var displayName: String?

            public var instanceId: String?

            public var mediaType: String?

            public var phoneNumberCount: Int32?

            public var skillGroupId: String?

            public var skillGroupName: String?

            public var userCount: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.displayName != nil {
                    map["DisplayName"] = self.displayName!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.mediaType != nil {
                    map["MediaType"] = self.mediaType!
                }
                if self.phoneNumberCount != nil {
                    map["PhoneNumberCount"] = self.phoneNumberCount!
                }
                if self.skillGroupId != nil {
                    map["SkillGroupId"] = self.skillGroupId!
                }
                if self.skillGroupName != nil {
                    map["SkillGroupName"] = self.skillGroupName!
                }
                if self.userCount != nil {
                    map["UserCount"] = self.userCount!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("DisplayName") {
                    self.displayName = dict["DisplayName"] as! String
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("MediaType") {
                    self.mediaType = dict["MediaType"] as! String
                }
                if dict.keys.contains("PhoneNumberCount") {
                    self.phoneNumberCount = dict["PhoneNumberCount"] as! Int32
                }
                if dict.keys.contains("SkillGroupId") {
                    self.skillGroupId = dict["SkillGroupId"] as! String
                }
                if dict.keys.contains("SkillGroupName") {
                    self.skillGroupName = dict["SkillGroupName"] as! String
                }
                if dict.keys.contains("UserCount") {
                    self.userCount = dict["UserCount"] as! Int32
                }
            }
        }
        public var list: [ListBriefSkillGroupsResponseBody.Data.List]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.list != nil {
                var tmp : [Any] = []
                for k in self.list! {
                    tmp.append(k.toMap())
                }
                map["List"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("List") {
                var tmp : [ListBriefSkillGroupsResponseBody.Data.List] = []
                for v in dict["List"] as! [Any] {
                    var model = ListBriefSkillGroupsResponseBody.Data.List()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.list = tmp
            }
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var code: String?

    public var data: ListBriefSkillGroupsResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = ListBriefSkillGroupsResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListBriefSkillGroupsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListBriefSkillGroupsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListBriefSkillGroupsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListCallDetailRecordsRequest : Tea.TeaModel {
    public var agentId: String?

    public var calledNumber: String?

    public var callingNumber: String?

    public var contactDisposition: String?

    public var contactDispositionList: String?

    public var contactId: String?

    public var contactType: String?

    public var contactTypeList: String?

    public var criteria: String?

    public var earlyMediaStateList: String?

    public var endTime: Int64?

    public var instanceId: String?

    public var orderByField: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var satisfactionDescriptionList: String?

    public var satisfactionList: String?

    public var satisfactionSurveyChannel: String?

    public var skillGroupId: String?

    public var sortOrder: String?

    public var startTime: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.agentId != nil {
            map["AgentId"] = self.agentId!
        }
        if self.calledNumber != nil {
            map["CalledNumber"] = self.calledNumber!
        }
        if self.callingNumber != nil {
            map["CallingNumber"] = self.callingNumber!
        }
        if self.contactDisposition != nil {
            map["ContactDisposition"] = self.contactDisposition!
        }
        if self.contactDispositionList != nil {
            map["ContactDispositionList"] = self.contactDispositionList!
        }
        if self.contactId != nil {
            map["ContactId"] = self.contactId!
        }
        if self.contactType != nil {
            map["ContactType"] = self.contactType!
        }
        if self.contactTypeList != nil {
            map["ContactTypeList"] = self.contactTypeList!
        }
        if self.criteria != nil {
            map["Criteria"] = self.criteria!
        }
        if self.earlyMediaStateList != nil {
            map["EarlyMediaStateList"] = self.earlyMediaStateList!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.orderByField != nil {
            map["OrderByField"] = self.orderByField!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.satisfactionDescriptionList != nil {
            map["SatisfactionDescriptionList"] = self.satisfactionDescriptionList!
        }
        if self.satisfactionList != nil {
            map["SatisfactionList"] = self.satisfactionList!
        }
        if self.satisfactionSurveyChannel != nil {
            map["SatisfactionSurveyChannel"] = self.satisfactionSurveyChannel!
        }
        if self.skillGroupId != nil {
            map["SkillGroupId"] = self.skillGroupId!
        }
        if self.sortOrder != nil {
            map["SortOrder"] = self.sortOrder!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AgentId") {
            self.agentId = dict["AgentId"] as! String
        }
        if dict.keys.contains("CalledNumber") {
            self.calledNumber = dict["CalledNumber"] as! String
        }
        if dict.keys.contains("CallingNumber") {
            self.callingNumber = dict["CallingNumber"] as! String
        }
        if dict.keys.contains("ContactDisposition") {
            self.contactDisposition = dict["ContactDisposition"] as! String
        }
        if dict.keys.contains("ContactDispositionList") {
            self.contactDispositionList = dict["ContactDispositionList"] as! String
        }
        if dict.keys.contains("ContactId") {
            self.contactId = dict["ContactId"] as! String
        }
        if dict.keys.contains("ContactType") {
            self.contactType = dict["ContactType"] as! String
        }
        if dict.keys.contains("ContactTypeList") {
            self.contactTypeList = dict["ContactTypeList"] as! String
        }
        if dict.keys.contains("Criteria") {
            self.criteria = dict["Criteria"] as! String
        }
        if dict.keys.contains("EarlyMediaStateList") {
            self.earlyMediaStateList = dict["EarlyMediaStateList"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("OrderByField") {
            self.orderByField = dict["OrderByField"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SatisfactionDescriptionList") {
            self.satisfactionDescriptionList = dict["SatisfactionDescriptionList"] as! String
        }
        if dict.keys.contains("SatisfactionList") {
            self.satisfactionList = dict["SatisfactionList"] as! String
        }
        if dict.keys.contains("SatisfactionSurveyChannel") {
            self.satisfactionSurveyChannel = dict["SatisfactionSurveyChannel"] as! String
        }
        if dict.keys.contains("SkillGroupId") {
            self.skillGroupId = dict["SkillGroupId"] as! String
        }
        if dict.keys.contains("SortOrder") {
            self.sortOrder = dict["SortOrder"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! Int64
        }
    }
}

public class ListCallDetailRecordsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class List : Tea.TeaModel {
            public var additionalBroker: String?

            public var agentIds: String?

            public var agentNames: String?

            public var broker: String?

            public var callDuration: String?

            public var callIds: String?

            public var calledNumber: String?

            public var calleeLocation: String?

            public var callerLocation: String?

            public var callingNumber: String?

            public var contactDisposition: String?

            public var contactId: String?

            public var contactType: String?

            public var dialingTime: Int64?

            public var earlyMediaState: String?

            public var establishedTime: Int64?

            public var heldTime: Int64?

            public var instanceId: String?

            public var ivrTime: Int64?

            public var queueTime: Int64?

            public var recordingDuration: Int64?

            public var recordingReady: Bool?

            public var releaseInitiator: String?

            public var releaseReason: String?

            public var releaseTime: Int64?

            public var ringTime: Int64?

            public var satisfactionDescription: String?

            public var satisfactionIndex: Int32?

            public var satisfactionSurveyChannel: String?

            public var satisfactionSurveyOffered: Bool?

            public var skillGroupIds: String?

            public var skillGroupNames: String?

            public var startTime: Int64?

            public var talkTime: Int64?

            public var waitTime: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.additionalBroker != nil {
                    map["AdditionalBroker"] = self.additionalBroker!
                }
                if self.agentIds != nil {
                    map["AgentIds"] = self.agentIds!
                }
                if self.agentNames != nil {
                    map["AgentNames"] = self.agentNames!
                }
                if self.broker != nil {
                    map["Broker"] = self.broker!
                }
                if self.callDuration != nil {
                    map["CallDuration"] = self.callDuration!
                }
                if self.callIds != nil {
                    map["CallIds"] = self.callIds!
                }
                if self.calledNumber != nil {
                    map["CalledNumber"] = self.calledNumber!
                }
                if self.calleeLocation != nil {
                    map["CalleeLocation"] = self.calleeLocation!
                }
                if self.callerLocation != nil {
                    map["CallerLocation"] = self.callerLocation!
                }
                if self.callingNumber != nil {
                    map["CallingNumber"] = self.callingNumber!
                }
                if self.contactDisposition != nil {
                    map["ContactDisposition"] = self.contactDisposition!
                }
                if self.contactId != nil {
                    map["ContactId"] = self.contactId!
                }
                if self.contactType != nil {
                    map["ContactType"] = self.contactType!
                }
                if self.dialingTime != nil {
                    map["DialingTime"] = self.dialingTime!
                }
                if self.earlyMediaState != nil {
                    map["EarlyMediaState"] = self.earlyMediaState!
                }
                if self.establishedTime != nil {
                    map["EstablishedTime"] = self.establishedTime!
                }
                if self.heldTime != nil {
                    map["HeldTime"] = self.heldTime!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.ivrTime != nil {
                    map["IvrTime"] = self.ivrTime!
                }
                if self.queueTime != nil {
                    map["QueueTime"] = self.queueTime!
                }
                if self.recordingDuration != nil {
                    map["RecordingDuration"] = self.recordingDuration!
                }
                if self.recordingReady != nil {
                    map["RecordingReady"] = self.recordingReady!
                }
                if self.releaseInitiator != nil {
                    map["ReleaseInitiator"] = self.releaseInitiator!
                }
                if self.releaseReason != nil {
                    map["ReleaseReason"] = self.releaseReason!
                }
                if self.releaseTime != nil {
                    map["ReleaseTime"] = self.releaseTime!
                }
                if self.ringTime != nil {
                    map["RingTime"] = self.ringTime!
                }
                if self.satisfactionDescription != nil {
                    map["SatisfactionDescription"] = self.satisfactionDescription!
                }
                if self.satisfactionIndex != nil {
                    map["SatisfactionIndex"] = self.satisfactionIndex!
                }
                if self.satisfactionSurveyChannel != nil {
                    map["SatisfactionSurveyChannel"] = self.satisfactionSurveyChannel!
                }
                if self.satisfactionSurveyOffered != nil {
                    map["SatisfactionSurveyOffered"] = self.satisfactionSurveyOffered!
                }
                if self.skillGroupIds != nil {
                    map["SkillGroupIds"] = self.skillGroupIds!
                }
                if self.skillGroupNames != nil {
                    map["SkillGroupNames"] = self.skillGroupNames!
                }
                if self.startTime != nil {
                    map["StartTime"] = self.startTime!
                }
                if self.talkTime != nil {
                    map["TalkTime"] = self.talkTime!
                }
                if self.waitTime != nil {
                    map["WaitTime"] = self.waitTime!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AdditionalBroker") {
                    self.additionalBroker = dict["AdditionalBroker"] as! String
                }
                if dict.keys.contains("AgentIds") {
                    self.agentIds = dict["AgentIds"] as! String
                }
                if dict.keys.contains("AgentNames") {
                    self.agentNames = dict["AgentNames"] as! String
                }
                if dict.keys.contains("Broker") {
                    self.broker = dict["Broker"] as! String
                }
                if dict.keys.contains("CallDuration") {
                    self.callDuration = dict["CallDuration"] as! String
                }
                if dict.keys.contains("CallIds") {
                    self.callIds = dict["CallIds"] as! String
                }
                if dict.keys.contains("CalledNumber") {
                    self.calledNumber = dict["CalledNumber"] as! String
                }
                if dict.keys.contains("CalleeLocation") {
                    self.calleeLocation = dict["CalleeLocation"] as! String
                }
                if dict.keys.contains("CallerLocation") {
                    self.callerLocation = dict["CallerLocation"] as! String
                }
                if dict.keys.contains("CallingNumber") {
                    self.callingNumber = dict["CallingNumber"] as! String
                }
                if dict.keys.contains("ContactDisposition") {
                    self.contactDisposition = dict["ContactDisposition"] as! String
                }
                if dict.keys.contains("ContactId") {
                    self.contactId = dict["ContactId"] as! String
                }
                if dict.keys.contains("ContactType") {
                    self.contactType = dict["ContactType"] as! String
                }
                if dict.keys.contains("DialingTime") {
                    self.dialingTime = dict["DialingTime"] as! Int64
                }
                if dict.keys.contains("EarlyMediaState") {
                    self.earlyMediaState = dict["EarlyMediaState"] as! String
                }
                if dict.keys.contains("EstablishedTime") {
                    self.establishedTime = dict["EstablishedTime"] as! Int64
                }
                if dict.keys.contains("HeldTime") {
                    self.heldTime = dict["HeldTime"] as! Int64
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("IvrTime") {
                    self.ivrTime = dict["IvrTime"] as! Int64
                }
                if dict.keys.contains("QueueTime") {
                    self.queueTime = dict["QueueTime"] as! Int64
                }
                if dict.keys.contains("RecordingDuration") {
                    self.recordingDuration = dict["RecordingDuration"] as! Int64
                }
                if dict.keys.contains("RecordingReady") {
                    self.recordingReady = dict["RecordingReady"] as! Bool
                }
                if dict.keys.contains("ReleaseInitiator") {
                    self.releaseInitiator = dict["ReleaseInitiator"] as! String
                }
                if dict.keys.contains("ReleaseReason") {
                    self.releaseReason = dict["ReleaseReason"] as! String
                }
                if dict.keys.contains("ReleaseTime") {
                    self.releaseTime = dict["ReleaseTime"] as! Int64
                }
                if dict.keys.contains("RingTime") {
                    self.ringTime = dict["RingTime"] as! Int64
                }
                if dict.keys.contains("SatisfactionDescription") {
                    self.satisfactionDescription = dict["SatisfactionDescription"] as! String
                }
                if dict.keys.contains("SatisfactionIndex") {
                    self.satisfactionIndex = dict["SatisfactionIndex"] as! Int32
                }
                if dict.keys.contains("SatisfactionSurveyChannel") {
                    self.satisfactionSurveyChannel = dict["SatisfactionSurveyChannel"] as! String
                }
                if dict.keys.contains("SatisfactionSurveyOffered") {
                    self.satisfactionSurveyOffered = dict["SatisfactionSurveyOffered"] as! Bool
                }
                if dict.keys.contains("SkillGroupIds") {
                    self.skillGroupIds = dict["SkillGroupIds"] as! String
                }
                if dict.keys.contains("SkillGroupNames") {
                    self.skillGroupNames = dict["SkillGroupNames"] as! String
                }
                if dict.keys.contains("StartTime") {
                    self.startTime = dict["StartTime"] as! Int64
                }
                if dict.keys.contains("TalkTime") {
                    self.talkTime = dict["TalkTime"] as! Int64
                }
                if dict.keys.contains("WaitTime") {
                    self.waitTime = dict["WaitTime"] as! Int64
                }
            }
        }
        public var list: [ListCallDetailRecordsResponseBody.Data.List]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.list != nil {
                var tmp : [Any] = []
                for k in self.list! {
                    tmp.append(k.toMap())
                }
                map["List"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("List") {
                var tmp : [ListCallDetailRecordsResponseBody.Data.List] = []
                for v in dict["List"] as! [Any] {
                    var model = ListCallDetailRecordsResponseBody.Data.List()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.list = tmp
            }
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var code: String?

    public var data: ListCallDetailRecordsResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = ListCallDetailRecordsResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListCallDetailRecordsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListCallDetailRecordsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListCallDetailRecordsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListCallDetailRecordsV2Request : Tea.TeaModel {
    public var accessChannelTypeList: String?

    public var agentId: String?

    public var broker: String?

    public var calledNumber: String?

    public var callingNumber: String?

    public var contactDispositionList: String?

    public var contactIdList: String?

    public var contactTypeList: String?

    public var earlyMediaStateList: String?

    public var endTime: Int64?

    public var firstAgentId: String?

    public var instanceId: String?

    public var mediaType: String?

    public var number: String?

    public var orderByField: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var releaseInitiatorList: String?

    public var releaseReasonList: String?

    public var satisfactionDescriptionList: String?

    public var satisfactionRateList: String?

    public var satisfactionSurveyChannel: String?

    public var searchPattern: String?

    public var skillGroupIdList: String?

    public var sortOrder: String?

    public var startTime: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessChannelTypeList != nil {
            map["AccessChannelTypeList"] = self.accessChannelTypeList!
        }
        if self.agentId != nil {
            map["AgentId"] = self.agentId!
        }
        if self.broker != nil {
            map["Broker"] = self.broker!
        }
        if self.calledNumber != nil {
            map["CalledNumber"] = self.calledNumber!
        }
        if self.callingNumber != nil {
            map["CallingNumber"] = self.callingNumber!
        }
        if self.contactDispositionList != nil {
            map["ContactDispositionList"] = self.contactDispositionList!
        }
        if self.contactIdList != nil {
            map["ContactIdList"] = self.contactIdList!
        }
        if self.contactTypeList != nil {
            map["ContactTypeList"] = self.contactTypeList!
        }
        if self.earlyMediaStateList != nil {
            map["EarlyMediaStateList"] = self.earlyMediaStateList!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.firstAgentId != nil {
            map["FirstAgentId"] = self.firstAgentId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.mediaType != nil {
            map["MediaType"] = self.mediaType!
        }
        if self.number != nil {
            map["Number"] = self.number!
        }
        if self.orderByField != nil {
            map["OrderByField"] = self.orderByField!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.releaseInitiatorList != nil {
            map["ReleaseInitiatorList"] = self.releaseInitiatorList!
        }
        if self.releaseReasonList != nil {
            map["ReleaseReasonList"] = self.releaseReasonList!
        }
        if self.satisfactionDescriptionList != nil {
            map["SatisfactionDescriptionList"] = self.satisfactionDescriptionList!
        }
        if self.satisfactionRateList != nil {
            map["SatisfactionRateList"] = self.satisfactionRateList!
        }
        if self.satisfactionSurveyChannel != nil {
            map["SatisfactionSurveyChannel"] = self.satisfactionSurveyChannel!
        }
        if self.searchPattern != nil {
            map["SearchPattern"] = self.searchPattern!
        }
        if self.skillGroupIdList != nil {
            map["SkillGroupIdList"] = self.skillGroupIdList!
        }
        if self.sortOrder != nil {
            map["SortOrder"] = self.sortOrder!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AccessChannelTypeList") {
            self.accessChannelTypeList = dict["AccessChannelTypeList"] as! String
        }
        if dict.keys.contains("AgentId") {
            self.agentId = dict["AgentId"] as! String
        }
        if dict.keys.contains("Broker") {
            self.broker = dict["Broker"] as! String
        }
        if dict.keys.contains("CalledNumber") {
            self.calledNumber = dict["CalledNumber"] as! String
        }
        if dict.keys.contains("CallingNumber") {
            self.callingNumber = dict["CallingNumber"] as! String
        }
        if dict.keys.contains("ContactDispositionList") {
            self.contactDispositionList = dict["ContactDispositionList"] as! String
        }
        if dict.keys.contains("ContactIdList") {
            self.contactIdList = dict["ContactIdList"] as! String
        }
        if dict.keys.contains("ContactTypeList") {
            self.contactTypeList = dict["ContactTypeList"] as! String
        }
        if dict.keys.contains("EarlyMediaStateList") {
            self.earlyMediaStateList = dict["EarlyMediaStateList"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("FirstAgentId") {
            self.firstAgentId = dict["FirstAgentId"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("MediaType") {
            self.mediaType = dict["MediaType"] as! String
        }
        if dict.keys.contains("Number") {
            self.number = dict["Number"] as! String
        }
        if dict.keys.contains("OrderByField") {
            self.orderByField = dict["OrderByField"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("ReleaseInitiatorList") {
            self.releaseInitiatorList = dict["ReleaseInitiatorList"] as! String
        }
        if dict.keys.contains("ReleaseReasonList") {
            self.releaseReasonList = dict["ReleaseReasonList"] as! String
        }
        if dict.keys.contains("SatisfactionDescriptionList") {
            self.satisfactionDescriptionList = dict["SatisfactionDescriptionList"] as! String
        }
        if dict.keys.contains("SatisfactionRateList") {
            self.satisfactionRateList = dict["SatisfactionRateList"] as! String
        }
        if dict.keys.contains("SatisfactionSurveyChannel") {
            self.satisfactionSurveyChannel = dict["SatisfactionSurveyChannel"] as! String
        }
        if dict.keys.contains("SearchPattern") {
            self.searchPattern = dict["SearchPattern"] as! String
        }
        if dict.keys.contains("SkillGroupIdList") {
            self.skillGroupIdList = dict["SkillGroupIdList"] as! String
        }
        if dict.keys.contains("SortOrder") {
            self.sortOrder = dict["SortOrder"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! Int64
        }
    }
}

public class ListCallDetailRecordsV2ResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class List : Tea.TeaModel {
            public var accessChannelName: String?

            public var accessChannelType: String?

            public var accessChannelUserId: String?

            public var accessChannelUserName: String?

            public var additionalBroker: String?

            public var agentIds: String?

            public var agentNames: String?

            public var broker: String?

            public var callDuration: String?

            public var callIds: String?

            public var calledNumber: String?

            public var calleeLocation: String?

            public var callerLocation: String?

            public var callingNumber: String?

            public var clientAppName: String?

            public var clientIpAddress: String?

            public var clientLocation: String?

            public var clientUserAgent: String?

            public var contactDisposition: String?

            public var contactId: String?

            public var contactType: String?

            public var dialingTime: Int64?

            public var earlyMediaState: String?

            public var earlyMediaText: String?

            public var establishedTime: Int64?

            public var firstResponseTime: Int64?

            public var heldTime: Int64?

            public var instanceId: String?

            public var ivrTime: Int64?

            public var mediaType: String?

            public var messagesSent: Int64?

            public var messagesSentByAgent: Int64?

            public var messagesSentByCustomer: Int64?

            public var offSiteAgentIds: String?

            public var offsiteAgentDestinationNumbers: String?

            public var offsiteAgentOriginatorNumbers: String?

            public var queueTime: Int64?

            public var recordingDuration: Int64?

            public var recordingReady: Bool?

            public var releaseInitiator: String?

            public var releaseReason: String?

            public var releaseTime: Int64?

            public var ringTime: Int64?

            public var satisfactionDescription: String?

            public var satisfactionIndex: Int32?

            public var satisfactionSurveyChannel: String?

            public var satisfactionSurveyOffered: Bool?

            public var skillGroupIds: String?

            public var skillGroupNames: String?

            public var startTime: Int64?

            public var talkTime: Int64?

            public var transferCount: Int64?

            public var waitTime: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.accessChannelName != nil {
                    map["AccessChannelName"] = self.accessChannelName!
                }
                if self.accessChannelType != nil {
                    map["AccessChannelType"] = self.accessChannelType!
                }
                if self.accessChannelUserId != nil {
                    map["AccessChannelUserId"] = self.accessChannelUserId!
                }
                if self.accessChannelUserName != nil {
                    map["AccessChannelUserName"] = self.accessChannelUserName!
                }
                if self.additionalBroker != nil {
                    map["AdditionalBroker"] = self.additionalBroker!
                }
                if self.agentIds != nil {
                    map["AgentIds"] = self.agentIds!
                }
                if self.agentNames != nil {
                    map["AgentNames"] = self.agentNames!
                }
                if self.broker != nil {
                    map["Broker"] = self.broker!
                }
                if self.callDuration != nil {
                    map["CallDuration"] = self.callDuration!
                }
                if self.callIds != nil {
                    map["CallIds"] = self.callIds!
                }
                if self.calledNumber != nil {
                    map["CalledNumber"] = self.calledNumber!
                }
                if self.calleeLocation != nil {
                    map["CalleeLocation"] = self.calleeLocation!
                }
                if self.callerLocation != nil {
                    map["CallerLocation"] = self.callerLocation!
                }
                if self.callingNumber != nil {
                    map["CallingNumber"] = self.callingNumber!
                }
                if self.clientAppName != nil {
                    map["ClientAppName"] = self.clientAppName!
                }
                if self.clientIpAddress != nil {
                    map["ClientIpAddress"] = self.clientIpAddress!
                }
                if self.clientLocation != nil {
                    map["ClientLocation"] = self.clientLocation!
                }
                if self.clientUserAgent != nil {
                    map["ClientUserAgent"] = self.clientUserAgent!
                }
                if self.contactDisposition != nil {
                    map["ContactDisposition"] = self.contactDisposition!
                }
                if self.contactId != nil {
                    map["ContactId"] = self.contactId!
                }
                if self.contactType != nil {
                    map["ContactType"] = self.contactType!
                }
                if self.dialingTime != nil {
                    map["DialingTime"] = self.dialingTime!
                }
                if self.earlyMediaState != nil {
                    map["EarlyMediaState"] = self.earlyMediaState!
                }
                if self.earlyMediaText != nil {
                    map["EarlyMediaText"] = self.earlyMediaText!
                }
                if self.establishedTime != nil {
                    map["EstablishedTime"] = self.establishedTime!
                }
                if self.firstResponseTime != nil {
                    map["FirstResponseTime"] = self.firstResponseTime!
                }
                if self.heldTime != nil {
                    map["HeldTime"] = self.heldTime!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.ivrTime != nil {
                    map["IvrTime"] = self.ivrTime!
                }
                if self.mediaType != nil {
                    map["MediaType"] = self.mediaType!
                }
                if self.messagesSent != nil {
                    map["MessagesSent"] = self.messagesSent!
                }
                if self.messagesSentByAgent != nil {
                    map["MessagesSentByAgent"] = self.messagesSentByAgent!
                }
                if self.messagesSentByCustomer != nil {
                    map["MessagesSentByCustomer"] = self.messagesSentByCustomer!
                }
                if self.offSiteAgentIds != nil {
                    map["OffSiteAgentIds"] = self.offSiteAgentIds!
                }
                if self.offsiteAgentDestinationNumbers != nil {
                    map["OffsiteAgentDestinationNumbers"] = self.offsiteAgentDestinationNumbers!
                }
                if self.offsiteAgentOriginatorNumbers != nil {
                    map["OffsiteAgentOriginatorNumbers"] = self.offsiteAgentOriginatorNumbers!
                }
                if self.queueTime != nil {
                    map["QueueTime"] = self.queueTime!
                }
                if self.recordingDuration != nil {
                    map["RecordingDuration"] = self.recordingDuration!
                }
                if self.recordingReady != nil {
                    map["RecordingReady"] = self.recordingReady!
                }
                if self.releaseInitiator != nil {
                    map["ReleaseInitiator"] = self.releaseInitiator!
                }
                if self.releaseReason != nil {
                    map["ReleaseReason"] = self.releaseReason!
                }
                if self.releaseTime != nil {
                    map["ReleaseTime"] = self.releaseTime!
                }
                if self.ringTime != nil {
                    map["RingTime"] = self.ringTime!
                }
                if self.satisfactionDescription != nil {
                    map["SatisfactionDescription"] = self.satisfactionDescription!
                }
                if self.satisfactionIndex != nil {
                    map["SatisfactionIndex"] = self.satisfactionIndex!
                }
                if self.satisfactionSurveyChannel != nil {
                    map["SatisfactionSurveyChannel"] = self.satisfactionSurveyChannel!
                }
                if self.satisfactionSurveyOffered != nil {
                    map["SatisfactionSurveyOffered"] = self.satisfactionSurveyOffered!
                }
                if self.skillGroupIds != nil {
                    map["SkillGroupIds"] = self.skillGroupIds!
                }
                if self.skillGroupNames != nil {
                    map["SkillGroupNames"] = self.skillGroupNames!
                }
                if self.startTime != nil {
                    map["StartTime"] = self.startTime!
                }
                if self.talkTime != nil {
                    map["TalkTime"] = self.talkTime!
                }
                if self.transferCount != nil {
                    map["TransferCount"] = self.transferCount!
                }
                if self.waitTime != nil {
                    map["WaitTime"] = self.waitTime!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AccessChannelName") {
                    self.accessChannelName = dict["AccessChannelName"] as! String
                }
                if dict.keys.contains("AccessChannelType") {
                    self.accessChannelType = dict["AccessChannelType"] as! String
                }
                if dict.keys.contains("AccessChannelUserId") {
                    self.accessChannelUserId = dict["AccessChannelUserId"] as! String
                }
                if dict.keys.contains("AccessChannelUserName") {
                    self.accessChannelUserName = dict["AccessChannelUserName"] as! String
                }
                if dict.keys.contains("AdditionalBroker") {
                    self.additionalBroker = dict["AdditionalBroker"] as! String
                }
                if dict.keys.contains("AgentIds") {
                    self.agentIds = dict["AgentIds"] as! String
                }
                if dict.keys.contains("AgentNames") {
                    self.agentNames = dict["AgentNames"] as! String
                }
                if dict.keys.contains("Broker") {
                    self.broker = dict["Broker"] as! String
                }
                if dict.keys.contains("CallDuration") {
                    self.callDuration = dict["CallDuration"] as! String
                }
                if dict.keys.contains("CallIds") {
                    self.callIds = dict["CallIds"] as! String
                }
                if dict.keys.contains("CalledNumber") {
                    self.calledNumber = dict["CalledNumber"] as! String
                }
                if dict.keys.contains("CalleeLocation") {
                    self.calleeLocation = dict["CalleeLocation"] as! String
                }
                if dict.keys.contains("CallerLocation") {
                    self.callerLocation = dict["CallerLocation"] as! String
                }
                if dict.keys.contains("CallingNumber") {
                    self.callingNumber = dict["CallingNumber"] as! String
                }
                if dict.keys.contains("ClientAppName") {
                    self.clientAppName = dict["ClientAppName"] as! String
                }
                if dict.keys.contains("ClientIpAddress") {
                    self.clientIpAddress = dict["ClientIpAddress"] as! String
                }
                if dict.keys.contains("ClientLocation") {
                    self.clientLocation = dict["ClientLocation"] as! String
                }
                if dict.keys.contains("ClientUserAgent") {
                    self.clientUserAgent = dict["ClientUserAgent"] as! String
                }
                if dict.keys.contains("ContactDisposition") {
                    self.contactDisposition = dict["ContactDisposition"] as! String
                }
                if dict.keys.contains("ContactId") {
                    self.contactId = dict["ContactId"] as! String
                }
                if dict.keys.contains("ContactType") {
                    self.contactType = dict["ContactType"] as! String
                }
                if dict.keys.contains("DialingTime") {
                    self.dialingTime = dict["DialingTime"] as! Int64
                }
                if dict.keys.contains("EarlyMediaState") {
                    self.earlyMediaState = dict["EarlyMediaState"] as! String
                }
                if dict.keys.contains("EarlyMediaText") {
                    self.earlyMediaText = dict["EarlyMediaText"] as! String
                }
                if dict.keys.contains("EstablishedTime") {
                    self.establishedTime = dict["EstablishedTime"] as! Int64
                }
                if dict.keys.contains("FirstResponseTime") {
                    self.firstResponseTime = dict["FirstResponseTime"] as! Int64
                }
                if dict.keys.contains("HeldTime") {
                    self.heldTime = dict["HeldTime"] as! Int64
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("IvrTime") {
                    self.ivrTime = dict["IvrTime"] as! Int64
                }
                if dict.keys.contains("MediaType") {
                    self.mediaType = dict["MediaType"] as! String
                }
                if dict.keys.contains("MessagesSent") {
                    self.messagesSent = dict["MessagesSent"] as! Int64
                }
                if dict.keys.contains("MessagesSentByAgent") {
                    self.messagesSentByAgent = dict["MessagesSentByAgent"] as! Int64
                }
                if dict.keys.contains("MessagesSentByCustomer") {
                    self.messagesSentByCustomer = dict["MessagesSentByCustomer"] as! Int64
                }
                if dict.keys.contains("OffSiteAgentIds") {
                    self.offSiteAgentIds = dict["OffSiteAgentIds"] as! String
                }
                if dict.keys.contains("OffsiteAgentDestinationNumbers") {
                    self.offsiteAgentDestinationNumbers = dict["OffsiteAgentDestinationNumbers"] as! String
                }
                if dict.keys.contains("OffsiteAgentOriginatorNumbers") {
                    self.offsiteAgentOriginatorNumbers = dict["OffsiteAgentOriginatorNumbers"] as! String
                }
                if dict.keys.contains("QueueTime") {
                    self.queueTime = dict["QueueTime"] as! Int64
                }
                if dict.keys.contains("RecordingDuration") {
                    self.recordingDuration = dict["RecordingDuration"] as! Int64
                }
                if dict.keys.contains("RecordingReady") {
                    self.recordingReady = dict["RecordingReady"] as! Bool
                }
                if dict.keys.contains("ReleaseInitiator") {
                    self.releaseInitiator = dict["ReleaseInitiator"] as! String
                }
                if dict.keys.contains("ReleaseReason") {
                    self.releaseReason = dict["ReleaseReason"] as! String
                }
                if dict.keys.contains("ReleaseTime") {
                    self.releaseTime = dict["ReleaseTime"] as! Int64
                }
                if dict.keys.contains("RingTime") {
                    self.ringTime = dict["RingTime"] as! Int64
                }
                if dict.keys.contains("SatisfactionDescription") {
                    self.satisfactionDescription = dict["SatisfactionDescription"] as! String
                }
                if dict.keys.contains("SatisfactionIndex") {
                    self.satisfactionIndex = dict["SatisfactionIndex"] as! Int32
                }
                if dict.keys.contains("SatisfactionSurveyChannel") {
                    self.satisfactionSurveyChannel = dict["SatisfactionSurveyChannel"] as! String
                }
                if dict.keys.contains("SatisfactionSurveyOffered") {
                    self.satisfactionSurveyOffered = dict["SatisfactionSurveyOffered"] as! Bool
                }
                if dict.keys.contains("SkillGroupIds") {
                    self.skillGroupIds = dict["SkillGroupIds"] as! String
                }
                if dict.keys.contains("SkillGroupNames") {
                    self.skillGroupNames = dict["SkillGroupNames"] as! String
                }
                if dict.keys.contains("StartTime") {
                    self.startTime = dict["StartTime"] as! Int64
                }
                if dict.keys.contains("TalkTime") {
                    self.talkTime = dict["TalkTime"] as! Int64
                }
                if dict.keys.contains("TransferCount") {
                    self.transferCount = dict["TransferCount"] as! Int64
                }
                if dict.keys.contains("WaitTime") {
                    self.waitTime = dict["WaitTime"] as! Int64
                }
            }
        }
        public var list: [ListCallDetailRecordsV2ResponseBody.Data.List]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.list != nil {
                var tmp : [Any] = []
                for k in self.list! {
                    tmp.append(k.toMap())
                }
                map["List"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("List") {
                var tmp : [ListCallDetailRecordsV2ResponseBody.Data.List] = []
                for v in dict["List"] as! [Any] {
                    var model = ListCallDetailRecordsV2ResponseBody.Data.List()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.list = tmp
            }
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var code: String?

    public var data: ListCallDetailRecordsV2ResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = ListCallDetailRecordsV2ResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListCallDetailRecordsV2Response : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListCallDetailRecordsV2ResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListCallDetailRecordsV2ResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListCallSummariesRequest : Tea.TeaModel {
    public var contactIdList: [String]?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.contactIdList != nil {
            map["ContactIdList"] = self.contactIdList!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ContactIdList") {
            self.contactIdList = dict["ContactIdList"] as! [String]
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
    }
}

public class ListCallSummariesShrinkRequest : Tea.TeaModel {
    public var contactIdListShrink: String?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.contactIdListShrink != nil {
            map["ContactIdList"] = self.contactIdListShrink!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ContactIdList") {
            self.contactIdListShrink = dict["ContactIdList"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
    }
}

public class ListCallSummariesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var contactId: String?

        public var context: String?

        public var createdTime: Int64?

        public var creator: String?

        public var editor: String?

        public var ticketId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.contactId != nil {
                map["ContactId"] = self.contactId!
            }
            if self.context != nil {
                map["Context"] = self.context!
            }
            if self.createdTime != nil {
                map["CreatedTime"] = self.createdTime!
            }
            if self.creator != nil {
                map["Creator"] = self.creator!
            }
            if self.editor != nil {
                map["Editor"] = self.editor!
            }
            if self.ticketId != nil {
                map["TicketId"] = self.ticketId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ContactId") {
                self.contactId = dict["ContactId"] as! String
            }
            if dict.keys.contains("Context") {
                self.context = dict["Context"] as! String
            }
            if dict.keys.contains("CreatedTime") {
                self.createdTime = dict["CreatedTime"] as! Int64
            }
            if dict.keys.contains("Creator") {
                self.creator = dict["Creator"] as! String
            }
            if dict.keys.contains("Editor") {
                self.editor = dict["Editor"] as! String
            }
            if dict.keys.contains("TicketId") {
                self.ticketId = dict["TicketId"] as! String
            }
        }
    }
    public var code: String?

    public var data: [ListCallSummariesResponseBody.Data]?

    public var httpStatusCode: Int32?

    public var message: String?

    public var params: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.params != nil {
            map["Params"] = self.params!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var tmp : [ListCallSummariesResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = ListCallSummariesResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Params") {
            self.params = dict["Params"] as! [String]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListCallSummariesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListCallSummariesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListCallSummariesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListCallTagsRequest : Tea.TeaModel {
    public var instanceId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
    }
}

public class ListCallTagsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class List : Tea.TeaModel {
            public var instanceId: String?

            public var tagName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.tagName != nil {
                    map["TagName"] = self.tagName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("TagName") {
                    self.tagName = dict["TagName"] as! String
                }
            }
        }
        public var list: [ListCallTagsResponseBody.Data.List]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.list != nil {
                var tmp : [Any] = []
                for k in self.list! {
                    tmp.append(k.toMap())
                }
                map["List"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("List") {
                var tmp : [ListCallTagsResponseBody.Data.List] = []
                for v in dict["List"] as! [Any] {
                    var model = ListCallTagsResponseBody.Data.List()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.list = tmp
            }
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var code: String?

    public var data: ListCallTagsResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = ListCallTagsResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListCallTagsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListCallTagsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListCallTagsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListCampaignTrendingReportRequest : Tea.TeaModel {
    public var campaignId: String?

    public var endTime: Int64?

    public var instanceId: String?

    public var startTime: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.campaignId != nil {
            map["CampaignId"] = self.campaignId!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CampaignId") {
            self.campaignId = dict["CampaignId"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! Int64
        }
    }
}

public class ListCampaignTrendingReportResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var breakAgents: Int64?

        public var breakingAgents: Int64?

        public var concurrency: Int64?

        public var datetime: Int64?

        public var loggedInAgents: Int64?

        public var outboundScenarioBreakingAgents: Int64?

        public var outboundScenarioReadyAgents: Int64?

        public var outboundScenarioTalkingAgents: Int64?

        public var outboundScenarioWorkingAgents: Int64?

        public var readyAgents: Int64?

        public var statsTime: Int64?

        public var talkAgents: Int64?

        public var talkingAgents: Int64?

        public var workAgents: Int64?

        public var workingAgents: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.breakAgents != nil {
                map["BreakAgents"] = self.breakAgents!
            }
            if self.breakingAgents != nil {
                map["BreakingAgents"] = self.breakingAgents!
            }
            if self.concurrency != nil {
                map["Concurrency"] = self.concurrency!
            }
            if self.datetime != nil {
                map["Datetime"] = self.datetime!
            }
            if self.loggedInAgents != nil {
                map["LoggedInAgents"] = self.loggedInAgents!
            }
            if self.outboundScenarioBreakingAgents != nil {
                map["OutboundScenarioBreakingAgents"] = self.outboundScenarioBreakingAgents!
            }
            if self.outboundScenarioReadyAgents != nil {
                map["OutboundScenarioReadyAgents"] = self.outboundScenarioReadyAgents!
            }
            if self.outboundScenarioTalkingAgents != nil {
                map["OutboundScenarioTalkingAgents"] = self.outboundScenarioTalkingAgents!
            }
            if self.outboundScenarioWorkingAgents != nil {
                map["OutboundScenarioWorkingAgents"] = self.outboundScenarioWorkingAgents!
            }
            if self.readyAgents != nil {
                map["ReadyAgents"] = self.readyAgents!
            }
            if self.statsTime != nil {
                map["StatsTime"] = self.statsTime!
            }
            if self.talkAgents != nil {
                map["TalkAgents"] = self.talkAgents!
            }
            if self.talkingAgents != nil {
                map["TalkingAgents"] = self.talkingAgents!
            }
            if self.workAgents != nil {
                map["WorkAgents"] = self.workAgents!
            }
            if self.workingAgents != nil {
                map["WorkingAgents"] = self.workingAgents!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BreakAgents") {
                self.breakAgents = dict["BreakAgents"] as! Int64
            }
            if dict.keys.contains("BreakingAgents") {
                self.breakingAgents = dict["BreakingAgents"] as! Int64
            }
            if dict.keys.contains("Concurrency") {
                self.concurrency = dict["Concurrency"] as! Int64
            }
            if dict.keys.contains("Datetime") {
                self.datetime = dict["Datetime"] as! Int64
            }
            if dict.keys.contains("LoggedInAgents") {
                self.loggedInAgents = dict["LoggedInAgents"] as! Int64
            }
            if dict.keys.contains("OutboundScenarioBreakingAgents") {
                self.outboundScenarioBreakingAgents = dict["OutboundScenarioBreakingAgents"] as! Int64
            }
            if dict.keys.contains("OutboundScenarioReadyAgents") {
                self.outboundScenarioReadyAgents = dict["OutboundScenarioReadyAgents"] as! Int64
            }
            if dict.keys.contains("OutboundScenarioTalkingAgents") {
                self.outboundScenarioTalkingAgents = dict["OutboundScenarioTalkingAgents"] as! Int64
            }
            if dict.keys.contains("OutboundScenarioWorkingAgents") {
                self.outboundScenarioWorkingAgents = dict["OutboundScenarioWorkingAgents"] as! Int64
            }
            if dict.keys.contains("ReadyAgents") {
                self.readyAgents = dict["ReadyAgents"] as! Int64
            }
            if dict.keys.contains("StatsTime") {
                self.statsTime = dict["StatsTime"] as! Int64
            }
            if dict.keys.contains("TalkAgents") {
                self.talkAgents = dict["TalkAgents"] as! Int64
            }
            if dict.keys.contains("TalkingAgents") {
                self.talkingAgents = dict["TalkingAgents"] as! Int64
            }
            if dict.keys.contains("WorkAgents") {
                self.workAgents = dict["WorkAgents"] as! Int64
            }
            if dict.keys.contains("WorkingAgents") {
                self.workingAgents = dict["WorkingAgents"] as! Int64
            }
        }
    }
    public var code: String?

    public var data: [ListCampaignTrendingReportResponseBody.Data]?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var tmp : [ListCampaignTrendingReportResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = ListCampaignTrendingReportResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListCampaignTrendingReportResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListCampaignTrendingReportResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListCampaignTrendingReportResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListCampaignsRequest : Tea.TeaModel {
    public var actualStartTimeFrom: String?

    public var actualStartTimeTo: String?

    public var instanceId: String?

    public var name: String?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var planedStartTimeFrom: String?

    public var planedStartTimeTo: String?

    public var queueId: String?

    public var state: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.actualStartTimeFrom != nil {
            map["ActualStartTimeFrom"] = self.actualStartTimeFrom!
        }
        if self.actualStartTimeTo != nil {
            map["ActualStartTimeTo"] = self.actualStartTimeTo!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.planedStartTimeFrom != nil {
            map["PlanedStartTimeFrom"] = self.planedStartTimeFrom!
        }
        if self.planedStartTimeTo != nil {
            map["PlanedStartTimeTo"] = self.planedStartTimeTo!
        }
        if self.queueId != nil {
            map["QueueId"] = self.queueId!
        }
        if self.state != nil {
            map["State"] = self.state!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ActualStartTimeFrom") {
            self.actualStartTimeFrom = dict["ActualStartTimeFrom"] as! String
        }
        if dict.keys.contains("ActualStartTimeTo") {
            self.actualStartTimeTo = dict["ActualStartTimeTo"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("PlanedStartTimeFrom") {
            self.planedStartTimeFrom = dict["PlanedStartTimeFrom"] as! String
        }
        if dict.keys.contains("PlanedStartTimeTo") {
            self.planedStartTimeTo = dict["PlanedStartTimeTo"] as! String
        }
        if dict.keys.contains("QueueId") {
            self.queueId = dict["QueueId"] as! String
        }
        if dict.keys.contains("State") {
            self.state = dict["State"] as! String
        }
    }
}

public class ListCampaignsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class List : Tea.TeaModel {
            public var actualEndTime: Int64?

            public var actualStartTime: Int64?

            public var campaignId: String?

            public var casesAborted: Int64?

            public var casesConnected: Int64?

            public var casesUncompleted: Int64?

            public var completionRate: Double?

            public var contactFlowId: String?

            public var maxAttemptCount: Int64?

            public var minAttemptInterval: Int64?

            public var name: String?

            public var planedEndTime: Int64?

            public var planedStartTime: Int64?

            public var queueId: String?

            public var queueName: String?

            public var simulation: Bool?

            public var state: String?

            public var strategyParameters: String?

            public var strategyType: String?

            public var totalCases: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.actualEndTime != nil {
                    map["ActualEndTime"] = self.actualEndTime!
                }
                if self.actualStartTime != nil {
                    map["ActualStartTime"] = self.actualStartTime!
                }
                if self.campaignId != nil {
                    map["CampaignId"] = self.campaignId!
                }
                if self.casesAborted != nil {
                    map["CasesAborted"] = self.casesAborted!
                }
                if self.casesConnected != nil {
                    map["CasesConnected"] = self.casesConnected!
                }
                if self.casesUncompleted != nil {
                    map["CasesUncompleted"] = self.casesUncompleted!
                }
                if self.completionRate != nil {
                    map["CompletionRate"] = self.completionRate!
                }
                if self.contactFlowId != nil {
                    map["ContactFlowId"] = self.contactFlowId!
                }
                if self.maxAttemptCount != nil {
                    map["MaxAttemptCount"] = self.maxAttemptCount!
                }
                if self.minAttemptInterval != nil {
                    map["MinAttemptInterval"] = self.minAttemptInterval!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.planedEndTime != nil {
                    map["PlanedEndTime"] = self.planedEndTime!
                }
                if self.planedStartTime != nil {
                    map["PlanedStartTime"] = self.planedStartTime!
                }
                if self.queueId != nil {
                    map["QueueId"] = self.queueId!
                }
                if self.queueName != nil {
                    map["QueueName"] = self.queueName!
                }
                if self.simulation != nil {
                    map["Simulation"] = self.simulation!
                }
                if self.state != nil {
                    map["State"] = self.state!
                }
                if self.strategyParameters != nil {
                    map["StrategyParameters"] = self.strategyParameters!
                }
                if self.strategyType != nil {
                    map["StrategyType"] = self.strategyType!
                }
                if self.totalCases != nil {
                    map["TotalCases"] = self.totalCases!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ActualEndTime") {
                    self.actualEndTime = dict["ActualEndTime"] as! Int64
                }
                if dict.keys.contains("ActualStartTime") {
                    self.actualStartTime = dict["ActualStartTime"] as! Int64
                }
                if dict.keys.contains("CampaignId") {
                    self.campaignId = dict["CampaignId"] as! String
                }
                if dict.keys.contains("CasesAborted") {
                    self.casesAborted = dict["CasesAborted"] as! Int64
                }
                if dict.keys.contains("CasesConnected") {
                    self.casesConnected = dict["CasesConnected"] as! Int64
                }
                if dict.keys.contains("CasesUncompleted") {
                    self.casesUncompleted = dict["CasesUncompleted"] as! Int64
                }
                if dict.keys.contains("CompletionRate") {
                    self.completionRate = dict["CompletionRate"] as! Double
                }
                if dict.keys.contains("ContactFlowId") {
                    self.contactFlowId = dict["ContactFlowId"] as! String
                }
                if dict.keys.contains("MaxAttemptCount") {
                    self.maxAttemptCount = dict["MaxAttemptCount"] as! Int64
                }
                if dict.keys.contains("MinAttemptInterval") {
                    self.minAttemptInterval = dict["MinAttemptInterval"] as! Int64
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("PlanedEndTime") {
                    self.planedEndTime = dict["PlanedEndTime"] as! Int64
                }
                if dict.keys.contains("PlanedStartTime") {
                    self.planedStartTime = dict["PlanedStartTime"] as! Int64
                }
                if dict.keys.contains("QueueId") {
                    self.queueId = dict["QueueId"] as! String
                }
                if dict.keys.contains("QueueName") {
                    self.queueName = dict["QueueName"] as! String
                }
                if dict.keys.contains("Simulation") {
                    self.simulation = dict["Simulation"] as! Bool
                }
                if dict.keys.contains("State") {
                    self.state = dict["State"] as! String
                }
                if dict.keys.contains("StrategyParameters") {
                    self.strategyParameters = dict["StrategyParameters"] as! String
                }
                if dict.keys.contains("StrategyType") {
                    self.strategyType = dict["StrategyType"] as! String
                }
                if dict.keys.contains("TotalCases") {
                    self.totalCases = dict["TotalCases"] as! Int64
                }
            }
        }
        public var list: [ListCampaignsResponseBody.Data.List]?

        public var pageNumber: Int64?

        public var pageSize: Int64?

        public var totalCount: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.list != nil {
                var tmp : [Any] = []
                for k in self.list! {
                    tmp.append(k.toMap())
                }
                map["List"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("List") {
                var tmp : [ListCampaignsResponseBody.Data.List] = []
                for v in dict["List"] as! [Any] {
                    var model = ListCampaignsResponseBody.Data.List()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.list = tmp
            }
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int64
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int64
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int64
            }
        }
    }
    public var code: String?

    public var data: ListCampaignsResponseBody.Data?

    public var httpStatusCode: Int64?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = ListCampaignsResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int64
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListCampaignsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListCampaignsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListCampaignsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListCasesRequest : Tea.TeaModel {
    public var campaignId: String?

    public var instanceId: String?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var phoneNumber: String?

    public var state: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.campaignId != nil {
            map["CampaignId"] = self.campaignId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.phoneNumber != nil {
            map["PhoneNumber"] = self.phoneNumber!
        }
        if self.state != nil {
            map["State"] = self.state!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CampaignId") {
            self.campaignId = dict["CampaignId"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("PhoneNumber") {
            self.phoneNumber = dict["PhoneNumber"] as! String
        }
        if dict.keys.contains("State") {
            self.state = dict["State"] as! String
        }
    }
}

public class ListCasesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class List : Tea.TeaModel {
            public var abandonPhase: String?

            public var abandonType: String?

            public var attemptCount: Int64?

            public var caseId: String?

            public var customVariables: String?

            public var failureReason: String?

            public var phoneNumber: String?

            public var state: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.abandonPhase != nil {
                    map["AbandonPhase"] = self.abandonPhase!
                }
                if self.abandonType != nil {
                    map["AbandonType"] = self.abandonType!
                }
                if self.attemptCount != nil {
                    map["AttemptCount"] = self.attemptCount!
                }
                if self.caseId != nil {
                    map["CaseId"] = self.caseId!
                }
                if self.customVariables != nil {
                    map["CustomVariables"] = self.customVariables!
                }
                if self.failureReason != nil {
                    map["FailureReason"] = self.failureReason!
                }
                if self.phoneNumber != nil {
                    map["PhoneNumber"] = self.phoneNumber!
                }
                if self.state != nil {
                    map["State"] = self.state!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AbandonPhase") {
                    self.abandonPhase = dict["AbandonPhase"] as! String
                }
                if dict.keys.contains("AbandonType") {
                    self.abandonType = dict["AbandonType"] as! String
                }
                if dict.keys.contains("AttemptCount") {
                    self.attemptCount = dict["AttemptCount"] as! Int64
                }
                if dict.keys.contains("CaseId") {
                    self.caseId = dict["CaseId"] as! String
                }
                if dict.keys.contains("CustomVariables") {
                    self.customVariables = dict["CustomVariables"] as! String
                }
                if dict.keys.contains("FailureReason") {
                    self.failureReason = dict["FailureReason"] as! String
                }
                if dict.keys.contains("PhoneNumber") {
                    self.phoneNumber = dict["PhoneNumber"] as! String
                }
                if dict.keys.contains("State") {
                    self.state = dict["State"] as! String
                }
            }
        }
        public var list: [ListCasesResponseBody.Data.List]?

        public var pageNumber: Int64?

        public var pageSize: Int64?

        public var totalCount: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.list != nil {
                var tmp : [Any] = []
                for k in self.list! {
                    tmp.append(k.toMap())
                }
                map["List"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("List") {
                var tmp : [ListCasesResponseBody.Data.List] = []
                for v in dict["List"] as! [Any] {
                    var model = ListCasesResponseBody.Data.List()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.list = tmp
            }
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int64
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int64
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int64
            }
        }
    }
    public var code: String?

    public var data: ListCasesResponseBody.Data?

    public var httpStatusCode: Int64?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = ListCasesResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int64
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListCasesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListCasesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListCasesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListCategoriesRequest : Tea.TeaModel {
    public var categoryId: String?

    public var instanceId: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.categoryId != nil {
            map["CategoryId"] = self.categoryId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CategoryId") {
            self.categoryId = dict["CategoryId"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
    }
}

public class ListCategoriesResponseBody : Tea.TeaModel {
    public var code: String?

    public var data: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var params: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.params != nil {
            map["Params"] = self.params!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Params") {
            self.params = dict["Params"] as! [String]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListCategoriesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListCategoriesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListCategoriesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListCommonTicketFieldsRequest : Tea.TeaModel {
    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
    }
}

public class ListCommonTicketFieldsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var createdTime: String?

        public var id: String?

        public var instanceId: String?

        public var properties: [String: DataPropertiesValue]?

        public var updatedTime: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createdTime != nil {
                map["CreatedTime"] = self.createdTime!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.properties != nil {
                var tmp : [String: Any] = [:]
                for (k, v) in self.properties! {
                    tmp[k] = v.toMap()
                }
                map["Properties"] = tmp
            }
            if self.updatedTime != nil {
                map["UpdatedTime"] = self.updatedTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CreatedTime") {
                self.createdTime = dict["CreatedTime"] as! String
            }
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! String
            }
            if dict.keys.contains("InstanceId") {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("Properties") {
                var tmp : [String: DataPropertiesValue] = [:]
                for (k, v) in dict["Properties"] as! [String: Any] {
                    if v != nil {
                        var model = DataPropertiesValue()
                        model.fromMap(v as! [String: Any])
                        tmp[k] = model
                    }
                }
                self.properties = tmp
            }
            if dict.keys.contains("UpdatedTime") {
                self.updatedTime = dict["UpdatedTime"] as! String
            }
        }
    }
    public var code: String?

    public var data: ListCommonTicketFieldsResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var params: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.params != nil {
            map["Params"] = self.params!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = ListCommonTicketFieldsResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Params") {
            self.params = dict["Params"] as! [String]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListCommonTicketFieldsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListCommonTicketFieldsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListCommonTicketFieldsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListConfigItemsRequest : Tea.TeaModel {
    public var instanceId: String?

    public var objectId: String?

    public var objectType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.objectId != nil {
            map["ObjectId"] = self.objectId!
        }
        if self.objectType != nil {
            map["ObjectType"] = self.objectType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("ObjectId") {
            self.objectId = dict["ObjectId"] as! String
        }
        if dict.keys.contains("ObjectType") {
            self.objectType = dict["ObjectType"] as! String
        }
    }
}

public class ListConfigItemsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var instanceId: String?

        public var name: String?

        public var objectId: String?

        public var objectType: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.objectId != nil {
                map["ObjectId"] = self.objectId!
            }
            if self.objectType != nil {
                map["ObjectType"] = self.objectType!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("InstanceId") {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("ObjectId") {
                self.objectId = dict["ObjectId"] as! String
            }
            if dict.keys.contains("ObjectType") {
                self.objectType = dict["ObjectType"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var code: String?

    public var data: [ListConfigItemsResponseBody.Data]?

    public var httpStatusCode: Int32?

    public var message: String?

    public var params: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.params != nil {
            map["Params"] = self.params!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var tmp : [ListConfigItemsResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = ListConfigItemsResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Params") {
            self.params = dict["Params"] as! [String]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListConfigItemsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListConfigItemsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListConfigItemsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListContactFlowsRequest : Tea.TeaModel {
    public var instanceId: String?

    public var orderByField: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var sortOrder: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.orderByField != nil {
            map["OrderByField"] = self.orderByField!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.sortOrder != nil {
            map["SortOrder"] = self.sortOrder!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("OrderByField") {
            self.orderByField = dict["OrderByField"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SortOrder") {
            self.sortOrder = dict["SortOrder"] as! String
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
    }
}

public class ListContactFlowsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class List : Tea.TeaModel {
            public var contactFlowId: String?

            public var createdTime: String?

            public var definition: String?

            public var description_: String?

            public var draftId: String?

            public var editor: String?

            public var instanceId: String?

            public var name: String?

            public var numberList: [String]?

            public var published: Bool?

            public var type: String?

            public var updatedTime: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.contactFlowId != nil {
                    map["ContactFlowId"] = self.contactFlowId!
                }
                if self.createdTime != nil {
                    map["CreatedTime"] = self.createdTime!
                }
                if self.definition != nil {
                    map["Definition"] = self.definition!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.draftId != nil {
                    map["DraftId"] = self.draftId!
                }
                if self.editor != nil {
                    map["Editor"] = self.editor!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.numberList != nil {
                    map["NumberList"] = self.numberList!
                }
                if self.published != nil {
                    map["Published"] = self.published!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.updatedTime != nil {
                    map["UpdatedTime"] = self.updatedTime!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ContactFlowId") {
                    self.contactFlowId = dict["ContactFlowId"] as! String
                }
                if dict.keys.contains("CreatedTime") {
                    self.createdTime = dict["CreatedTime"] as! String
                }
                if dict.keys.contains("Definition") {
                    self.definition = dict["Definition"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("DraftId") {
                    self.draftId = dict["DraftId"] as! String
                }
                if dict.keys.contains("Editor") {
                    self.editor = dict["Editor"] as! String
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("NumberList") {
                    self.numberList = dict["NumberList"] as! [String]
                }
                if dict.keys.contains("Published") {
                    self.published = dict["Published"] as! Bool
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("UpdatedTime") {
                    self.updatedTime = dict["UpdatedTime"] as! String
                }
            }
        }
        public var list: [ListContactFlowsResponseBody.Data.List]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.list != nil {
                var tmp : [Any] = []
                for k in self.list! {
                    tmp.append(k.toMap())
                }
                map["List"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("List") {
                var tmp : [ListContactFlowsResponseBody.Data.List] = []
                for v in dict["List"] as! [Any] {
                    var model = ListContactFlowsResponseBody.Data.List()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.list = tmp
            }
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var code: String?

    public var data: ListContactFlowsResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = ListContactFlowsResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListContactFlowsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListContactFlowsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListContactFlowsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListCustomCallTaggingRequest : Tea.TeaModel {
    public var callTagNameList: String?

    public var instanceId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var searchPattern: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.callTagNameList != nil {
            map["CallTagNameList"] = self.callTagNameList!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.searchPattern != nil {
            map["SearchPattern"] = self.searchPattern!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CallTagNameList") {
            self.callTagNameList = dict["CallTagNameList"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SearchPattern") {
            self.searchPattern = dict["SearchPattern"] as! String
        }
    }
}

public class ListCustomCallTaggingResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class List : Tea.TeaModel {
            public class CallTagList : Tea.TeaModel {
                public var instanceId: String?

                public var tagName: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.instanceId != nil {
                        map["InstanceId"] = self.instanceId!
                    }
                    if self.tagName != nil {
                        map["TagName"] = self.tagName!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("InstanceId") {
                        self.instanceId = dict["InstanceId"] as! String
                    }
                    if dict.keys.contains("TagName") {
                        self.tagName = dict["TagName"] as! String
                    }
                }
            }
            public var callTagList: [ListCustomCallTaggingResponseBody.Data.List.CallTagList]?

            public var creator: String?

            public var description_: String?

            public var instanceId: String?

            public var number: String?

            public var updateTime: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.callTagList != nil {
                    var tmp : [Any] = []
                    for k in self.callTagList! {
                        tmp.append(k.toMap())
                    }
                    map["CallTagList"] = tmp
                }
                if self.creator != nil {
                    map["Creator"] = self.creator!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.number != nil {
                    map["Number"] = self.number!
                }
                if self.updateTime != nil {
                    map["UpdateTime"] = self.updateTime!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CallTagList") {
                    var tmp : [ListCustomCallTaggingResponseBody.Data.List.CallTagList] = []
                    for v in dict["CallTagList"] as! [Any] {
                        var model = ListCustomCallTaggingResponseBody.Data.List.CallTagList()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.callTagList = tmp
                }
                if dict.keys.contains("Creator") {
                    self.creator = dict["Creator"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("Number") {
                    self.number = dict["Number"] as! String
                }
                if dict.keys.contains("UpdateTime") {
                    self.updateTime = dict["UpdateTime"] as! String
                }
            }
        }
        public var list: [ListCustomCallTaggingResponseBody.Data.List]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.list != nil {
                var tmp : [Any] = []
                for k in self.list! {
                    tmp.append(k.toMap())
                }
                map["List"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("List") {
                var tmp : [ListCustomCallTaggingResponseBody.Data.List] = []
                for v in dict["List"] as! [Any] {
                    var model = ListCustomCallTaggingResponseBody.Data.List()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.list = tmp
            }
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var code: String?

    public var data: ListCustomCallTaggingResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = ListCustomCallTaggingResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListCustomCallTaggingResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListCustomCallTaggingResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListCustomCallTaggingResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListDevicesRequest : Tea.TeaModel {
    public var instanceId: String?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("UserId") {
            self.userId = dict["UserId"] as! String
        }
    }
}

public class ListDevicesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var callId: String?

        public var contact: String?

        public var deviceId: String?

        public var deviceType: String?

        public var expires: Int64?

        public var extension_: String?

        public var instanceId: String?

        public var userId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.callId != nil {
                map["CallId"] = self.callId!
            }
            if self.contact != nil {
                map["Contact"] = self.contact!
            }
            if self.deviceId != nil {
                map["DeviceId"] = self.deviceId!
            }
            if self.deviceType != nil {
                map["DeviceType"] = self.deviceType!
            }
            if self.expires != nil {
                map["Expires"] = self.expires!
            }
            if self.extension_ != nil {
                map["Extension"] = self.extension_!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CallId") {
                self.callId = dict["CallId"] as! String
            }
            if dict.keys.contains("Contact") {
                self.contact = dict["Contact"] as! String
            }
            if dict.keys.contains("DeviceId") {
                self.deviceId = dict["DeviceId"] as! String
            }
            if dict.keys.contains("DeviceType") {
                self.deviceType = dict["DeviceType"] as! String
            }
            if dict.keys.contains("Expires") {
                self.expires = dict["Expires"] as! Int64
            }
            if dict.keys.contains("Extension") {
                self.extension_ = dict["Extension"] as! String
            }
            if dict.keys.contains("InstanceId") {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("UserId") {
                self.userId = dict["UserId"] as! String
            }
        }
    }
    public var code: String?

    public var data: [ListDevicesResponseBody.Data]?

    public var httpStatusCode: Int32?

    public var message: String?

    public var params: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.params != nil {
            map["Params"] = self.params!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var tmp : [ListDevicesResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = ListDevicesResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Params") {
            self.params = dict["Params"] as! [String]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListDevicesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListDevicesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListDevicesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListDoNotCallNumbersRequest : Tea.TeaModel {
    public var instanceId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var scope: String?

    public var searchPattern: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.scope != nil {
            map["Scope"] = self.scope!
        }
        if self.searchPattern != nil {
            map["SearchPattern"] = self.searchPattern!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("Scope") {
            self.scope = dict["Scope"] as! String
        }
        if dict.keys.contains("SearchPattern") {
            self.searchPattern = dict["SearchPattern"] as! String
        }
    }
}

public class ListDoNotCallNumbersResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class List : Tea.TeaModel {
            public var createTime: Int64?

            public var createdTime: Int64?

            public var creator: String?

            public var number: String?

            public var remark: String?

            public var scope: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.createdTime != nil {
                    map["CreatedTime"] = self.createdTime!
                }
                if self.creator != nil {
                    map["Creator"] = self.creator!
                }
                if self.number != nil {
                    map["Number"] = self.number!
                }
                if self.remark != nil {
                    map["Remark"] = self.remark!
                }
                if self.scope != nil {
                    map["Scope"] = self.scope!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! Int64
                }
                if dict.keys.contains("CreatedTime") {
                    self.createdTime = dict["CreatedTime"] as! Int64
                }
                if dict.keys.contains("Creator") {
                    self.creator = dict["Creator"] as! String
                }
                if dict.keys.contains("Number") {
                    self.number = dict["Number"] as! String
                }
                if dict.keys.contains("Remark") {
                    self.remark = dict["Remark"] as! String
                }
                if dict.keys.contains("Scope") {
                    self.scope = dict["Scope"] as! String
                }
            }
        }
        public var list: [ListDoNotCallNumbersResponseBody.Data.List]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.list != nil {
                var tmp : [Any] = []
                for k in self.list! {
                    tmp.append(k.toMap())
                }
                map["List"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("List") {
                var tmp : [ListDoNotCallNumbersResponseBody.Data.List] = []
                for v in dict["List"] as! [Any] {
                    var model = ListDoNotCallNumbersResponseBody.Data.List()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.list = tmp
            }
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var code: String?

    public var data: ListDoNotCallNumbersResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var params: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.params != nil {
            map["Params"] = self.params!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = ListDoNotCallNumbersResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Params") {
            self.params = dict["Params"] as! [String]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListDoNotCallNumbersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListDoNotCallNumbersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListDoNotCallNumbersResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListDocumentsRequest : Tea.TeaModel {
    public class Sorts : Tea.TeaModel {
        public var order: String?

        public var propertyName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.order != nil {
                map["Order"] = self.order!
            }
            if self.propertyName != nil {
                map["PropertyName"] = self.propertyName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Order") {
                self.order = dict["Order"] as! String
            }
            if dict.keys.contains("PropertyName") {
                self.propertyName = dict["PropertyName"] as! String
            }
        }
    }
    public var instanceId: String?

    public var nextPageToken: String?

    public var pageSize: Int32?

    public var requestId: String?

    public var schemaId: String?

    public var searchPattern: String?

    public var sorts: [ListDocumentsRequest.Sorts]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.nextPageToken != nil {
            map["NextPageToken"] = self.nextPageToken!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.schemaId != nil {
            map["SchemaId"] = self.schemaId!
        }
        if self.searchPattern != nil {
            map["SearchPattern"] = self.searchPattern!
        }
        if self.sorts != nil {
            var tmp : [Any] = []
            for k in self.sorts! {
                tmp.append(k.toMap())
            }
            map["Sorts"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("NextPageToken") {
            self.nextPageToken = dict["NextPageToken"] as! String
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SchemaId") {
            self.schemaId = dict["SchemaId"] as! String
        }
        if dict.keys.contains("SearchPattern") {
            self.searchPattern = dict["SearchPattern"] as! String
        }
        if dict.keys.contains("Sorts") {
            var tmp : [ListDocumentsRequest.Sorts] = []
            for v in dict["Sorts"] as! [Any] {
                var model = ListDocumentsRequest.Sorts()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.sorts = tmp
        }
    }
}

public class ListDocumentsShrinkRequest : Tea.TeaModel {
    public var instanceId: String?

    public var nextPageToken: String?

    public var pageSize: Int32?

    public var requestId: String?

    public var schemaId: String?

    public var searchPattern: String?

    public var sortsShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.nextPageToken != nil {
            map["NextPageToken"] = self.nextPageToken!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.schemaId != nil {
            map["SchemaId"] = self.schemaId!
        }
        if self.searchPattern != nil {
            map["SearchPattern"] = self.searchPattern!
        }
        if self.sortsShrink != nil {
            map["Sorts"] = self.sortsShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("NextPageToken") {
            self.nextPageToken = dict["NextPageToken"] as! String
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SchemaId") {
            self.schemaId = dict["SchemaId"] as! String
        }
        if dict.keys.contains("SearchPattern") {
            self.searchPattern = dict["SearchPattern"] as! String
        }
        if dict.keys.contains("Sorts") {
            self.sortsShrink = dict["Sorts"] as! String
        }
    }
}

public class ListDocumentsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Schema : Tea.TeaModel {
            public var createdTime: String?

            public var deleted: Bool?

            public var description_: String?

            public var id: String?

            public var instanceId: String?

            public var properties: [String: DataSchemaPropertiesValue]?

            public var updatedTime: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.createdTime != nil {
                    map["CreatedTime"] = self.createdTime!
                }
                if self.deleted != nil {
                    map["Deleted"] = self.deleted!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.properties != nil {
                    var tmp : [String: Any] = [:]
                    for (k, v) in self.properties! {
                        tmp[k] = v.toMap()
                    }
                    map["Properties"] = tmp
                }
                if self.updatedTime != nil {
                    map["UpdatedTime"] = self.updatedTime!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CreatedTime") {
                    self.createdTime = dict["CreatedTime"] as! String
                }
                if dict.keys.contains("Deleted") {
                    self.deleted = dict["Deleted"] as! Bool
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! String
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("Properties") {
                    var tmp : [String: DataSchemaPropertiesValue] = [:]
                    for (k, v) in dict["Properties"] as! [String: Any] {
                        if v != nil {
                            var model = DataSchemaPropertiesValue()
                            model.fromMap(v as! [String: Any])
                            tmp[k] = model
                        }
                    }
                    self.properties = tmp
                }
                if dict.keys.contains("UpdatedTime") {
                    self.updatedTime = dict["UpdatedTime"] as! String
                }
            }
        }
        public var documents: [[String: Any]]?

        public var nextPageToken: String?

        public var schema: ListDocumentsResponseBody.Data.Schema?

        public var totalCount: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.schema?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.documents != nil {
                map["Documents"] = self.documents!
            }
            if self.nextPageToken != nil {
                map["NextPageToken"] = self.nextPageToken!
            }
            if self.schema != nil {
                map["Schema"] = self.schema?.toMap()
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Documents") {
                self.documents = dict["Documents"] as! [[String: Any]]
            }
            if dict.keys.contains("NextPageToken") {
                self.nextPageToken = dict["NextPageToken"] as! String
            }
            if dict.keys.contains("Schema") {
                var model = ListDocumentsResponseBody.Data.Schema()
                model.fromMap(dict["Schema"] as! [String: Any])
                self.schema = model
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int64
            }
        }
    }
    public var code: String?

    public var data: ListDocumentsResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var params: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.params != nil {
            map["Params"] = self.params!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = ListDocumentsResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Params") {
            self.params = dict["Params"] as! [String]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListDocumentsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListDocumentsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListDocumentsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListFlashSmsApplicationsRequest : Tea.TeaModel {
    public var instanceId: String?

    public var name: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var providerId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.providerId != nil {
            map["ProviderId"] = self.providerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("ProviderId") {
            self.providerId = dict["ProviderId"] as! String
        }
    }
}

public class ListFlashSmsApplicationsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class List : Tea.TeaModel {
            public var applicationId: String?

            public var instanceId: String?

            public var name: String?

            public var providerId: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.applicationId != nil {
                    map["ApplicationId"] = self.applicationId!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.providerId != nil {
                    map["ProviderId"] = self.providerId!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ApplicationId") {
                    self.applicationId = dict["ApplicationId"] as! String
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("ProviderId") {
                    self.providerId = dict["ProviderId"] as! String
                }
                if dict.keys.contains("Value") {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public var list: [ListFlashSmsApplicationsResponseBody.Data.List]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.list != nil {
                var tmp : [Any] = []
                for k in self.list! {
                    tmp.append(k.toMap())
                }
                map["List"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("List") {
                var tmp : [ListFlashSmsApplicationsResponseBody.Data.List] = []
                for v in dict["List"] as! [Any] {
                    var model = ListFlashSmsApplicationsResponseBody.Data.List()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.list = tmp
            }
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var code: String?

    public var data: ListFlashSmsApplicationsResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var params: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.params != nil {
            map["Params"] = self.params!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = ListFlashSmsApplicationsResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Params") {
            self.params = dict["Params"] as! [String]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListFlashSmsApplicationsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListFlashSmsApplicationsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListFlashSmsApplicationsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListFlashSmsTemplatesRequest : Tea.TeaModel {
    public var applicationId: String?

    public var instanceId: String?

    public var providerId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.applicationId != nil {
            map["ApplicationId"] = self.applicationId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.providerId != nil {
            map["ProviderId"] = self.providerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ApplicationId") {
            self.applicationId = dict["ApplicationId"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("ProviderId") {
            self.providerId = dict["ProviderId"] as! String
        }
    }
}

public class ListFlashSmsTemplatesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var templateId: String?

        public var templateName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.templateId != nil {
                map["TemplateId"] = self.templateId!
            }
            if self.templateName != nil {
                map["TemplateName"] = self.templateName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("TemplateId") {
                self.templateId = dict["TemplateId"] as! String
            }
            if dict.keys.contains("TemplateName") {
                self.templateName = dict["TemplateName"] as! String
            }
        }
    }
    public var code: String?

    public var data: [ListFlashSmsTemplatesResponseBody.Data]?

    public var httpStatusCode: Int32?

    public var message: String?

    public var params: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.params != nil {
            map["Params"] = self.params!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var tmp : [ListFlashSmsTemplatesResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = ListFlashSmsTemplatesResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Params") {
            self.params = dict["Params"] as! [String]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListFlashSmsTemplatesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListFlashSmsTemplatesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListFlashSmsTemplatesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListGroupChatMessagesRequest : Tea.TeaModel {
    public var instanceId: String?

    public var jobId: String?

    public var nextPageToken: String?

    public var pageSize: Int32?

    public var sortOrder: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.nextPageToken != nil {
            map["NextPageToken"] = self.nextPageToken!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.sortOrder != nil {
            map["SortOrder"] = self.sortOrder!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("NextPageToken") {
            self.nextPageToken = dict["NextPageToken"] as! String
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SortOrder") {
            self.sortOrder = dict["SortOrder"] as! String
        }
    }
}

public class ListGroupChatMessagesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Messages : Tea.TeaModel {
            public var content: String?

            public var jobId: String?

            public var recalled: Bool?

            public var senderAvatarUrl: String?

            public var senderId: String?

            public var senderName: String?

            public var senderType: String?

            public var timestamp: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.content != nil {
                    map["Content"] = self.content!
                }
                if self.jobId != nil {
                    map["JobId"] = self.jobId!
                }
                if self.recalled != nil {
                    map["Recalled"] = self.recalled!
                }
                if self.senderAvatarUrl != nil {
                    map["SenderAvatarUrl"] = self.senderAvatarUrl!
                }
                if self.senderId != nil {
                    map["SenderId"] = self.senderId!
                }
                if self.senderName != nil {
                    map["SenderName"] = self.senderName!
                }
                if self.senderType != nil {
                    map["SenderType"] = self.senderType!
                }
                if self.timestamp != nil {
                    map["Timestamp"] = self.timestamp!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Content") {
                    self.content = dict["Content"] as! String
                }
                if dict.keys.contains("JobId") {
                    self.jobId = dict["JobId"] as! String
                }
                if dict.keys.contains("Recalled") {
                    self.recalled = dict["Recalled"] as! Bool
                }
                if dict.keys.contains("SenderAvatarUrl") {
                    self.senderAvatarUrl = dict["SenderAvatarUrl"] as! String
                }
                if dict.keys.contains("SenderId") {
                    self.senderId = dict["SenderId"] as! String
                }
                if dict.keys.contains("SenderName") {
                    self.senderName = dict["SenderName"] as! String
                }
                if dict.keys.contains("SenderType") {
                    self.senderType = dict["SenderType"] as! String
                }
                if dict.keys.contains("Timestamp") {
                    self.timestamp = dict["Timestamp"] as! Int64
                }
            }
        }
        public var messages: [ListGroupChatMessagesResponseBody.Data.Messages]?

        public var nextPageToken: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.messages != nil {
                var tmp : [Any] = []
                for k in self.messages! {
                    tmp.append(k.toMap())
                }
                map["Messages"] = tmp
            }
            if self.nextPageToken != nil {
                map["NextPageToken"] = self.nextPageToken!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Messages") {
                var tmp : [ListGroupChatMessagesResponseBody.Data.Messages] = []
                for v in dict["Messages"] as! [Any] {
                    var model = ListGroupChatMessagesResponseBody.Data.Messages()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.messages = tmp
            }
            if dict.keys.contains("NextPageToken") {
                self.nextPageToken = dict["NextPageToken"] as! String
            }
        }
    }
    public var code: String?

    public var data: ListGroupChatMessagesResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = ListGroupChatMessagesResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListGroupChatMessagesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListGroupChatMessagesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListGroupChatMessagesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListHistoricalAgentReportRequest : Tea.TeaModel {
    public var agentIdList: String?

    public var instanceId: String?

    public var mediaType: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var skillGroupId: String?

    public var startTime: Int64?

    public var stopTime: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.agentIdList != nil {
            map["AgentIdList"] = self.agentIdList!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.mediaType != nil {
            map["MediaType"] = self.mediaType!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.skillGroupId != nil {
            map["SkillGroupId"] = self.skillGroupId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.stopTime != nil {
            map["StopTime"] = self.stopTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AgentIdList") {
            self.agentIdList = dict["AgentIdList"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("MediaType") {
            self.mediaType = dict["MediaType"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SkillGroupId") {
            self.skillGroupId = dict["SkillGroupId"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! Int64
        }
        if dict.keys.contains("StopTime") {
            self.stopTime = dict["StopTime"] as! Int64
        }
    }
}

public class ListHistoricalAgentReportResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class List : Tea.TeaModel {
            public class Back2Back : Tea.TeaModel {
                public var agentHandleRate: String?

                public var answerRate: String?

                public var averageCustomerRingTime: String?

                public var averageRingTime: String?

                public var averageTalkTime: String?

                public var callsAgentHandled: String?

                public var callsAnswered: String?

                public var callsCustomerAnswered: String?

                public var callsDialed: String?

                public var customerAnswerRate: String?

                public var maxCustomerRingTime: String?

                public var maxRingTime: String?

                public var maxTalkTime: String?

                public var totalCustomerRingTime: String?

                public var totalRingTime: String?

                public var totalTalkTime: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.agentHandleRate != nil {
                        map["AgentHandleRate"] = self.agentHandleRate!
                    }
                    if self.answerRate != nil {
                        map["AnswerRate"] = self.answerRate!
                    }
                    if self.averageCustomerRingTime != nil {
                        map["AverageCustomerRingTime"] = self.averageCustomerRingTime!
                    }
                    if self.averageRingTime != nil {
                        map["AverageRingTime"] = self.averageRingTime!
                    }
                    if self.averageTalkTime != nil {
                        map["AverageTalkTime"] = self.averageTalkTime!
                    }
                    if self.callsAgentHandled != nil {
                        map["CallsAgentHandled"] = self.callsAgentHandled!
                    }
                    if self.callsAnswered != nil {
                        map["CallsAnswered"] = self.callsAnswered!
                    }
                    if self.callsCustomerAnswered != nil {
                        map["CallsCustomerAnswered"] = self.callsCustomerAnswered!
                    }
                    if self.callsDialed != nil {
                        map["CallsDialed"] = self.callsDialed!
                    }
                    if self.customerAnswerRate != nil {
                        map["CustomerAnswerRate"] = self.customerAnswerRate!
                    }
                    if self.maxCustomerRingTime != nil {
                        map["MaxCustomerRingTime"] = self.maxCustomerRingTime!
                    }
                    if self.maxRingTime != nil {
                        map["MaxRingTime"] = self.maxRingTime!
                    }
                    if self.maxTalkTime != nil {
                        map["MaxTalkTime"] = self.maxTalkTime!
                    }
                    if self.totalCustomerRingTime != nil {
                        map["TotalCustomerRingTime"] = self.totalCustomerRingTime!
                    }
                    if self.totalRingTime != nil {
                        map["TotalRingTime"] = self.totalRingTime!
                    }
                    if self.totalTalkTime != nil {
                        map["TotalTalkTime"] = self.totalTalkTime!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AgentHandleRate") {
                        self.agentHandleRate = dict["AgentHandleRate"] as! String
                    }
                    if dict.keys.contains("AnswerRate") {
                        self.answerRate = dict["AnswerRate"] as! String
                    }
                    if dict.keys.contains("AverageCustomerRingTime") {
                        self.averageCustomerRingTime = dict["AverageCustomerRingTime"] as! String
                    }
                    if dict.keys.contains("AverageRingTime") {
                        self.averageRingTime = dict["AverageRingTime"] as! String
                    }
                    if dict.keys.contains("AverageTalkTime") {
                        self.averageTalkTime = dict["AverageTalkTime"] as! String
                    }
                    if dict.keys.contains("CallsAgentHandled") {
                        self.callsAgentHandled = dict["CallsAgentHandled"] as! String
                    }
                    if dict.keys.contains("CallsAnswered") {
                        self.callsAnswered = dict["CallsAnswered"] as! String
                    }
                    if dict.keys.contains("CallsCustomerAnswered") {
                        self.callsCustomerAnswered = dict["CallsCustomerAnswered"] as! String
                    }
                    if dict.keys.contains("CallsDialed") {
                        self.callsDialed = dict["CallsDialed"] as! String
                    }
                    if dict.keys.contains("CustomerAnswerRate") {
                        self.customerAnswerRate = dict["CustomerAnswerRate"] as! String
                    }
                    if dict.keys.contains("MaxCustomerRingTime") {
                        self.maxCustomerRingTime = dict["MaxCustomerRingTime"] as! String
                    }
                    if dict.keys.contains("MaxRingTime") {
                        self.maxRingTime = dict["MaxRingTime"] as! String
                    }
                    if dict.keys.contains("MaxTalkTime") {
                        self.maxTalkTime = dict["MaxTalkTime"] as! String
                    }
                    if dict.keys.contains("TotalCustomerRingTime") {
                        self.totalCustomerRingTime = dict["TotalCustomerRingTime"] as! String
                    }
                    if dict.keys.contains("TotalRingTime") {
                        self.totalRingTime = dict["TotalRingTime"] as! String
                    }
                    if dict.keys.contains("TotalTalkTime") {
                        self.totalTalkTime = dict["TotalTalkTime"] as! String
                    }
                }
            }
            public class Inbound : Tea.TeaModel {
                public class AccessChannelTypeDetails : Tea.TeaModel {
                    public var accessChannelType: String?

                    public var callsOffered: Int64?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.accessChannelType != nil {
                            map["AccessChannelType"] = self.accessChannelType!
                        }
                        if self.callsOffered != nil {
                            map["CallsOffered"] = self.callsOffered!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("AccessChannelType") {
                            self.accessChannelType = dict["AccessChannelType"] as! String
                        }
                        if dict.keys.contains("CallsOffered") {
                            self.callsOffered = dict["CallsOffered"] as! Int64
                        }
                    }
                }
                public var accessChannelTypeDetails: [ListHistoricalAgentReportResponseBody.Data.List.Inbound.AccessChannelTypeDetails]?

                public var averageFirstResponseTime: Double?

                public var averageHoldTime: Double?

                public var averageResponseTime: Double?

                public var averageRingTime: Double?

                public var averageTalkTime: Double?

                public var averageWorkTime: Double?

                public var callsAttendedTransferIn: Int64?

                public var callsAttendedTransferOut: Int64?

                public var callsBlindTransferIn: Int64?

                public var callsBlindTransferOut: Int64?

                public var callsHandled: Int64?

                public var callsHold: Int64?

                public var callsOffered: Int64?

                public var callsRinged: Int64?

                public var handleRate: Double?

                public var maxHoldTime: Int64?

                public var maxRingTime: Int64?

                public var maxTalkTime: Int64?

                public var maxWorkTime: Int64?

                public var satisfactionIndex: Double?

                public var satisfactionRate: Double?

                public var satisfactionSurveysOffered: Int64?

                public var satisfactionSurveysResponded: Int64?

                public var serviceLevel15: Double?

                public var totalHoldTime: Int64?

                public var totalMessagesSent: Int64?

                public var totalMessagesSentByAgent: Int64?

                public var totalMessagesSentByCustomer: String?

                public var totalRingTime: Int64?

                public var totalTalkTime: Int64?

                public var totalWorkTime: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.accessChannelTypeDetails != nil {
                        var tmp : [Any] = []
                        for k in self.accessChannelTypeDetails! {
                            tmp.append(k.toMap())
                        }
                        map["AccessChannelTypeDetails"] = tmp
                    }
                    if self.averageFirstResponseTime != nil {
                        map["AverageFirstResponseTime"] = self.averageFirstResponseTime!
                    }
                    if self.averageHoldTime != nil {
                        map["AverageHoldTime"] = self.averageHoldTime!
                    }
                    if self.averageResponseTime != nil {
                        map["AverageResponseTime"] = self.averageResponseTime!
                    }
                    if self.averageRingTime != nil {
                        map["AverageRingTime"] = self.averageRingTime!
                    }
                    if self.averageTalkTime != nil {
                        map["AverageTalkTime"] = self.averageTalkTime!
                    }
                    if self.averageWorkTime != nil {
                        map["AverageWorkTime"] = self.averageWorkTime!
                    }
                    if self.callsAttendedTransferIn != nil {
                        map["CallsAttendedTransferIn"] = self.callsAttendedTransferIn!
                    }
                    if self.callsAttendedTransferOut != nil {
                        map["CallsAttendedTransferOut"] = self.callsAttendedTransferOut!
                    }
                    if self.callsBlindTransferIn != nil {
                        map["CallsBlindTransferIn"] = self.callsBlindTransferIn!
                    }
                    if self.callsBlindTransferOut != nil {
                        map["CallsBlindTransferOut"] = self.callsBlindTransferOut!
                    }
                    if self.callsHandled != nil {
                        map["CallsHandled"] = self.callsHandled!
                    }
                    if self.callsHold != nil {
                        map["CallsHold"] = self.callsHold!
                    }
                    if self.callsOffered != nil {
                        map["CallsOffered"] = self.callsOffered!
                    }
                    if self.callsRinged != nil {
                        map["CallsRinged"] = self.callsRinged!
                    }
                    if self.handleRate != nil {
                        map["HandleRate"] = self.handleRate!
                    }
                    if self.maxHoldTime != nil {
                        map["MaxHoldTime"] = self.maxHoldTime!
                    }
                    if self.maxRingTime != nil {
                        map["MaxRingTime"] = self.maxRingTime!
                    }
                    if self.maxTalkTime != nil {
                        map["MaxTalkTime"] = self.maxTalkTime!
                    }
                    if self.maxWorkTime != nil {
                        map["MaxWorkTime"] = self.maxWorkTime!
                    }
                    if self.satisfactionIndex != nil {
                        map["SatisfactionIndex"] = self.satisfactionIndex!
                    }
                    if self.satisfactionRate != nil {
                        map["SatisfactionRate"] = self.satisfactionRate!
                    }
                    if self.satisfactionSurveysOffered != nil {
                        map["SatisfactionSurveysOffered"] = self.satisfactionSurveysOffered!
                    }
                    if self.satisfactionSurveysResponded != nil {
                        map["SatisfactionSurveysResponded"] = self.satisfactionSurveysResponded!
                    }
                    if self.serviceLevel15 != nil {
                        map["ServiceLevel15"] = self.serviceLevel15!
                    }
                    if self.totalHoldTime != nil {
                        map["TotalHoldTime"] = self.totalHoldTime!
                    }
                    if self.totalMessagesSent != nil {
                        map["TotalMessagesSent"] = self.totalMessagesSent!
                    }
                    if self.totalMessagesSentByAgent != nil {
                        map["TotalMessagesSentByAgent"] = self.totalMessagesSentByAgent!
                    }
                    if self.totalMessagesSentByCustomer != nil {
                        map["TotalMessagesSentByCustomer"] = self.totalMessagesSentByCustomer!
                    }
                    if self.totalRingTime != nil {
                        map["TotalRingTime"] = self.totalRingTime!
                    }
                    if self.totalTalkTime != nil {
                        map["TotalTalkTime"] = self.totalTalkTime!
                    }
                    if self.totalWorkTime != nil {
                        map["TotalWorkTime"] = self.totalWorkTime!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AccessChannelTypeDetails") {
                        var tmp : [ListHistoricalAgentReportResponseBody.Data.List.Inbound.AccessChannelTypeDetails] = []
                        for v in dict["AccessChannelTypeDetails"] as! [Any] {
                            var model = ListHistoricalAgentReportResponseBody.Data.List.Inbound.AccessChannelTypeDetails()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.accessChannelTypeDetails = tmp
                    }
                    if dict.keys.contains("AverageFirstResponseTime") {
                        self.averageFirstResponseTime = dict["AverageFirstResponseTime"] as! Double
                    }
                    if dict.keys.contains("AverageHoldTime") {
                        self.averageHoldTime = dict["AverageHoldTime"] as! Double
                    }
                    if dict.keys.contains("AverageResponseTime") {
                        self.averageResponseTime = dict["AverageResponseTime"] as! Double
                    }
                    if dict.keys.contains("AverageRingTime") {
                        self.averageRingTime = dict["AverageRingTime"] as! Double
                    }
                    if dict.keys.contains("AverageTalkTime") {
                        self.averageTalkTime = dict["AverageTalkTime"] as! Double
                    }
                    if dict.keys.contains("AverageWorkTime") {
                        self.averageWorkTime = dict["AverageWorkTime"] as! Double
                    }
                    if dict.keys.contains("CallsAttendedTransferIn") {
                        self.callsAttendedTransferIn = dict["CallsAttendedTransferIn"] as! Int64
                    }
                    if dict.keys.contains("CallsAttendedTransferOut") {
                        self.callsAttendedTransferOut = dict["CallsAttendedTransferOut"] as! Int64
                    }
                    if dict.keys.contains("CallsBlindTransferIn") {
                        self.callsBlindTransferIn = dict["CallsBlindTransferIn"] as! Int64
                    }
                    if dict.keys.contains("CallsBlindTransferOut") {
                        self.callsBlindTransferOut = dict["CallsBlindTransferOut"] as! Int64
                    }
                    if dict.keys.contains("CallsHandled") {
                        self.callsHandled = dict["CallsHandled"] as! Int64
                    }
                    if dict.keys.contains("CallsHold") {
                        self.callsHold = dict["CallsHold"] as! Int64
                    }
                    if dict.keys.contains("CallsOffered") {
                        self.callsOffered = dict["CallsOffered"] as! Int64
                    }
                    if dict.keys.contains("CallsRinged") {
                        self.callsRinged = dict["CallsRinged"] as! Int64
                    }
                    if dict.keys.contains("HandleRate") {
                        self.handleRate = dict["HandleRate"] as! Double
                    }
                    if dict.keys.contains("MaxHoldTime") {
                        self.maxHoldTime = dict["MaxHoldTime"] as! Int64
                    }
                    if dict.keys.contains("MaxRingTime") {
                        self.maxRingTime = dict["MaxRingTime"] as! Int64
                    }
                    if dict.keys.contains("MaxTalkTime") {
                        self.maxTalkTime = dict["MaxTalkTime"] as! Int64
                    }
                    if dict.keys.contains("MaxWorkTime") {
                        self.maxWorkTime = dict["MaxWorkTime"] as! Int64
                    }
                    if dict.keys.contains("SatisfactionIndex") {
                        self.satisfactionIndex = dict["SatisfactionIndex"] as! Double
                    }
                    if dict.keys.contains("SatisfactionRate") {
                        self.satisfactionRate = dict["SatisfactionRate"] as! Double
                    }
                    if dict.keys.contains("SatisfactionSurveysOffered") {
                        self.satisfactionSurveysOffered = dict["SatisfactionSurveysOffered"] as! Int64
                    }
                    if dict.keys.contains("SatisfactionSurveysResponded") {
                        self.satisfactionSurveysResponded = dict["SatisfactionSurveysResponded"] as! Int64
                    }
                    if dict.keys.contains("ServiceLevel15") {
                        self.serviceLevel15 = dict["ServiceLevel15"] as! Double
                    }
                    if dict.keys.contains("TotalHoldTime") {
                        self.totalHoldTime = dict["TotalHoldTime"] as! Int64
                    }
                    if dict.keys.contains("TotalMessagesSent") {
                        self.totalMessagesSent = dict["TotalMessagesSent"] as! Int64
                    }
                    if dict.keys.contains("TotalMessagesSentByAgent") {
                        self.totalMessagesSentByAgent = dict["TotalMessagesSentByAgent"] as! Int64
                    }
                    if dict.keys.contains("TotalMessagesSentByCustomer") {
                        self.totalMessagesSentByCustomer = dict["TotalMessagesSentByCustomer"] as! String
                    }
                    if dict.keys.contains("TotalRingTime") {
                        self.totalRingTime = dict["TotalRingTime"] as! Int64
                    }
                    if dict.keys.contains("TotalTalkTime") {
                        self.totalTalkTime = dict["TotalTalkTime"] as! Int64
                    }
                    if dict.keys.contains("TotalWorkTime") {
                        self.totalWorkTime = dict["TotalWorkTime"] as! Int64
                    }
                }
            }
            public class Internal_ : Tea.TeaModel {
                public var averageTalkTime: Double?

                public var callsAnswered: Int64?

                public var callsDialed: Int64?

                public var callsHandled: Int64?

                public var callsOffered: Int64?

                public var callsTalked: Int64?

                public var maxTalkTime: Int64?

                public var totalTalkTime: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.averageTalkTime != nil {
                        map["AverageTalkTime"] = self.averageTalkTime!
                    }
                    if self.callsAnswered != nil {
                        map["CallsAnswered"] = self.callsAnswered!
                    }
                    if self.callsDialed != nil {
                        map["CallsDialed"] = self.callsDialed!
                    }
                    if self.callsHandled != nil {
                        map["CallsHandled"] = self.callsHandled!
                    }
                    if self.callsOffered != nil {
                        map["CallsOffered"] = self.callsOffered!
                    }
                    if self.callsTalked != nil {
                        map["CallsTalked"] = self.callsTalked!
                    }
                    if self.maxTalkTime != nil {
                        map["MaxTalkTime"] = self.maxTalkTime!
                    }
                    if self.totalTalkTime != nil {
                        map["TotalTalkTime"] = self.totalTalkTime!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AverageTalkTime") {
                        self.averageTalkTime = dict["AverageTalkTime"] as! Double
                    }
                    if dict.keys.contains("CallsAnswered") {
                        self.callsAnswered = dict["CallsAnswered"] as! Int64
                    }
                    if dict.keys.contains("CallsDialed") {
                        self.callsDialed = dict["CallsDialed"] as! Int64
                    }
                    if dict.keys.contains("CallsHandled") {
                        self.callsHandled = dict["CallsHandled"] as! Int64
                    }
                    if dict.keys.contains("CallsOffered") {
                        self.callsOffered = dict["CallsOffered"] as! Int64
                    }
                    if dict.keys.contains("CallsTalked") {
                        self.callsTalked = dict["CallsTalked"] as! Int64
                    }
                    if dict.keys.contains("MaxTalkTime") {
                        self.maxTalkTime = dict["MaxTalkTime"] as! Int64
                    }
                    if dict.keys.contains("TotalTalkTime") {
                        self.totalTalkTime = dict["TotalTalkTime"] as! Int64
                    }
                }
            }
            public class Outbound : Tea.TeaModel {
                public var answerRate: Double?

                public var averageDialingTime: Double?

                public var averageHoldTime: Double?

                public var averageRingTime: Double?

                public var averageTalkTime: Double?

                public var averageWorkTime: Double?

                public var callsAnswered: Int64?

                public var callsAttendedTransferIn: Int64?

                public var callsAttendedTransferOut: Int64?

                public var callsBlindTransferIn: Int64?

                public var callsBlindTransferOut: Int64?

                public var callsDialed: Int64?

                public var callsHold: Int64?

                public var callsRinged: Int64?

                public var maxDialingTime: Int64?

                public var maxHoldTime: Int64?

                public var maxRingTime: Int64?

                public var maxTalkTime: Int64?

                public var maxWorkTime: Int64?

                public var satisfactionIndex: Double?

                public var satisfactionRate: Double?

                public var satisfactionSurveysOffered: Int64?

                public var satisfactionSurveysResponded: Int64?

                public var totalDialingTime: Int64?

                public var totalHoldTime: Int64?

                public var totalRingTime: Int64?

                public var totalTalkTime: Int64?

                public var totalWorkTime: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.answerRate != nil {
                        map["AnswerRate"] = self.answerRate!
                    }
                    if self.averageDialingTime != nil {
                        map["AverageDialingTime"] = self.averageDialingTime!
                    }
                    if self.averageHoldTime != nil {
                        map["AverageHoldTime"] = self.averageHoldTime!
                    }
                    if self.averageRingTime != nil {
                        map["AverageRingTime"] = self.averageRingTime!
                    }
                    if self.averageTalkTime != nil {
                        map["AverageTalkTime"] = self.averageTalkTime!
                    }
                    if self.averageWorkTime != nil {
                        map["AverageWorkTime"] = self.averageWorkTime!
                    }
                    if self.callsAnswered != nil {
                        map["CallsAnswered"] = self.callsAnswered!
                    }
                    if self.callsAttendedTransferIn != nil {
                        map["CallsAttendedTransferIn"] = self.callsAttendedTransferIn!
                    }
                    if self.callsAttendedTransferOut != nil {
                        map["CallsAttendedTransferOut"] = self.callsAttendedTransferOut!
                    }
                    if self.callsBlindTransferIn != nil {
                        map["CallsBlindTransferIn"] = self.callsBlindTransferIn!
                    }
                    if self.callsBlindTransferOut != nil {
                        map["CallsBlindTransferOut"] = self.callsBlindTransferOut!
                    }
                    if self.callsDialed != nil {
                        map["CallsDialed"] = self.callsDialed!
                    }
                    if self.callsHold != nil {
                        map["CallsHold"] = self.callsHold!
                    }
                    if self.callsRinged != nil {
                        map["CallsRinged"] = self.callsRinged!
                    }
                    if self.maxDialingTime != nil {
                        map["MaxDialingTime"] = self.maxDialingTime!
                    }
                    if self.maxHoldTime != nil {
                        map["MaxHoldTime"] = self.maxHoldTime!
                    }
                    if self.maxRingTime != nil {
                        map["MaxRingTime"] = self.maxRingTime!
                    }
                    if self.maxTalkTime != nil {
                        map["MaxTalkTime"] = self.maxTalkTime!
                    }
                    if self.maxWorkTime != nil {
                        map["MaxWorkTime"] = self.maxWorkTime!
                    }
                    if self.satisfactionIndex != nil {
                        map["SatisfactionIndex"] = self.satisfactionIndex!
                    }
                    if self.satisfactionRate != nil {
                        map["SatisfactionRate"] = self.satisfactionRate!
                    }
                    if self.satisfactionSurveysOffered != nil {
                        map["SatisfactionSurveysOffered"] = self.satisfactionSurveysOffered!
                    }
                    if self.satisfactionSurveysResponded != nil {
                        map["SatisfactionSurveysResponded"] = self.satisfactionSurveysResponded!
                    }
                    if self.totalDialingTime != nil {
                        map["TotalDialingTime"] = self.totalDialingTime!
                    }
                    if self.totalHoldTime != nil {
                        map["TotalHoldTime"] = self.totalHoldTime!
                    }
                    if self.totalRingTime != nil {
                        map["TotalRingTime"] = self.totalRingTime!
                    }
                    if self.totalTalkTime != nil {
                        map["TotalTalkTime"] = self.totalTalkTime!
                    }
                    if self.totalWorkTime != nil {
                        map["TotalWorkTime"] = self.totalWorkTime!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AnswerRate") {
                        self.answerRate = dict["AnswerRate"] as! Double
                    }
                    if dict.keys.contains("AverageDialingTime") {
                        self.averageDialingTime = dict["AverageDialingTime"] as! Double
                    }
                    if dict.keys.contains("AverageHoldTime") {
                        self.averageHoldTime = dict["AverageHoldTime"] as! Double
                    }
                    if dict.keys.contains("AverageRingTime") {
                        self.averageRingTime = dict["AverageRingTime"] as! Double
                    }
                    if dict.keys.contains("AverageTalkTime") {
                        self.averageTalkTime = dict["AverageTalkTime"] as! Double
                    }
                    if dict.keys.contains("AverageWorkTime") {
                        self.averageWorkTime = dict["AverageWorkTime"] as! Double
                    }
                    if dict.keys.contains("CallsAnswered") {
                        self.callsAnswered = dict["CallsAnswered"] as! Int64
                    }
                    if dict.keys.contains("CallsAttendedTransferIn") {
                        self.callsAttendedTransferIn = dict["CallsAttendedTransferIn"] as! Int64
                    }
                    if dict.keys.contains("CallsAttendedTransferOut") {
                        self.callsAttendedTransferOut = dict["CallsAttendedTransferOut"] as! Int64
                    }
                    if dict.keys.contains("CallsBlindTransferIn") {
                        self.callsBlindTransferIn = dict["CallsBlindTransferIn"] as! Int64
                    }
                    if dict.keys.contains("CallsBlindTransferOut") {
                        self.callsBlindTransferOut = dict["CallsBlindTransferOut"] as! Int64
                    }
                    if dict.keys.contains("CallsDialed") {
                        self.callsDialed = dict["CallsDialed"] as! Int64
                    }
                    if dict.keys.contains("CallsHold") {
                        self.callsHold = dict["CallsHold"] as! Int64
                    }
                    if dict.keys.contains("CallsRinged") {
                        self.callsRinged = dict["CallsRinged"] as! Int64
                    }
                    if dict.keys.contains("MaxDialingTime") {
                        self.maxDialingTime = dict["MaxDialingTime"] as! Int64
                    }
                    if dict.keys.contains("MaxHoldTime") {
                        self.maxHoldTime = dict["MaxHoldTime"] as! Int64
                    }
                    if dict.keys.contains("MaxRingTime") {
                        self.maxRingTime = dict["MaxRingTime"] as! Int64
                    }
                    if dict.keys.contains("MaxTalkTime") {
                        self.maxTalkTime = dict["MaxTalkTime"] as! Int64
                    }
                    if dict.keys.contains("MaxWorkTime") {
                        self.maxWorkTime = dict["MaxWorkTime"] as! Int64
                    }
                    if dict.keys.contains("SatisfactionIndex") {
                        self.satisfactionIndex = dict["SatisfactionIndex"] as! Double
                    }
                    if dict.keys.contains("SatisfactionRate") {
                        self.satisfactionRate = dict["SatisfactionRate"] as! Double
                    }
                    if dict.keys.contains("SatisfactionSurveysOffered") {
                        self.satisfactionSurveysOffered = dict["SatisfactionSurveysOffered"] as! Int64
                    }
                    if dict.keys.contains("SatisfactionSurveysResponded") {
                        self.satisfactionSurveysResponded = dict["SatisfactionSurveysResponded"] as! Int64
                    }
                    if dict.keys.contains("TotalDialingTime") {
                        self.totalDialingTime = dict["TotalDialingTime"] as! Int64
                    }
                    if dict.keys.contains("TotalHoldTime") {
                        self.totalHoldTime = dict["TotalHoldTime"] as! Int64
                    }
                    if dict.keys.contains("TotalRingTime") {
                        self.totalRingTime = dict["TotalRingTime"] as! Int64
                    }
                    if dict.keys.contains("TotalTalkTime") {
                        self.totalTalkTime = dict["TotalTalkTime"] as! Int64
                    }
                    if dict.keys.contains("TotalWorkTime") {
                        self.totalWorkTime = dict["TotalWorkTime"] as! Int64
                    }
                }
            }
            public class Overall : Tea.TeaModel {
                public class BreakCodeDetailList : Tea.TeaModel {
                    public var breakCode: String?

                    public var count: Int64?

                    public var duration: Int64?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.breakCode != nil {
                            map["BreakCode"] = self.breakCode!
                        }
                        if self.count != nil {
                            map["Count"] = self.count!
                        }
                        if self.duration != nil {
                            map["Duration"] = self.duration!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("BreakCode") {
                            self.breakCode = dict["BreakCode"] as! String
                        }
                        if dict.keys.contains("Count") {
                            self.count = dict["Count"] as! Int64
                        }
                        if dict.keys.contains("Duration") {
                            self.duration = dict["Duration"] as! Int64
                        }
                    }
                }
                public var averageBreakTime: Double?

                public var averageHoldTime: Double?

                public var averageReadyTime: Double?

                public var averageTalkTime: Double?

                public var averageWorkTime: Double?

                public var breakCodeDetailList: [ListHistoricalAgentReportResponseBody.Data.List.Overall.BreakCodeDetailList]?

                public var firstCheckInTime: Int64?

                public var lastCheckOutTime: Int64?

                public var maxBreakTime: Int64?

                public var maxHoldTime: Int64?

                public var maxReadyTime: Int64?

                public var maxTalkTime: Int64?

                public var maxWorkTime: Int64?

                public var occupancyRate: Double?

                public var satisfactionIndex: Double?

                public var satisfactionRate: Double?

                public var satisfactionSurveysOffered: Int64?

                public var satisfactionSurveysResponded: Int64?

                public var totalBreakTime: Int64?

                public var totalCalls: Int64?

                public var totalHoldTime: Int64?

                public var totalLoggedInTime: Int64?

                public var totalOffSiteLoggedInTime: Int64?

                public var totalOffSiteOnlineTime: Int64?

                public var totalOfficePhoneLoggedInTime: Int64?

                public var totalOfficePhoneOnlineTime: Int64?

                public var totalOnSiteLoggedInTime: Int64?

                public var totalOnSiteOnlineTime: Int64?

                public var totalOutboundScenarioLoggedInTime: Int64?

                public var totalOutboundScenarioReadyTime: Int64?

                public var totalOutboundScenarioTime: Int64?

                public var totalReadyTime: Int64?

                public var totalTalkTime: Int64?

                public var totalWorkTime: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.averageBreakTime != nil {
                        map["AverageBreakTime"] = self.averageBreakTime!
                    }
                    if self.averageHoldTime != nil {
                        map["AverageHoldTime"] = self.averageHoldTime!
                    }
                    if self.averageReadyTime != nil {
                        map["AverageReadyTime"] = self.averageReadyTime!
                    }
                    if self.averageTalkTime != nil {
                        map["AverageTalkTime"] = self.averageTalkTime!
                    }
                    if self.averageWorkTime != nil {
                        map["AverageWorkTime"] = self.averageWorkTime!
                    }
                    if self.breakCodeDetailList != nil {
                        var tmp : [Any] = []
                        for k in self.breakCodeDetailList! {
                            tmp.append(k.toMap())
                        }
                        map["BreakCodeDetailList"] = tmp
                    }
                    if self.firstCheckInTime != nil {
                        map["FirstCheckInTime"] = self.firstCheckInTime!
                    }
                    if self.lastCheckOutTime != nil {
                        map["LastCheckOutTime"] = self.lastCheckOutTime!
                    }
                    if self.maxBreakTime != nil {
                        map["MaxBreakTime"] = self.maxBreakTime!
                    }
                    if self.maxHoldTime != nil {
                        map["MaxHoldTime"] = self.maxHoldTime!
                    }
                    if self.maxReadyTime != nil {
                        map["MaxReadyTime"] = self.maxReadyTime!
                    }
                    if self.maxTalkTime != nil {
                        map["MaxTalkTime"] = self.maxTalkTime!
                    }
                    if self.maxWorkTime != nil {
                        map["MaxWorkTime"] = self.maxWorkTime!
                    }
                    if self.occupancyRate != nil {
                        map["OccupancyRate"] = self.occupancyRate!
                    }
                    if self.satisfactionIndex != nil {
                        map["SatisfactionIndex"] = self.satisfactionIndex!
                    }
                    if self.satisfactionRate != nil {
                        map["SatisfactionRate"] = self.satisfactionRate!
                    }
                    if self.satisfactionSurveysOffered != nil {
                        map["SatisfactionSurveysOffered"] = self.satisfactionSurveysOffered!
                    }
                    if self.satisfactionSurveysResponded != nil {
                        map["SatisfactionSurveysResponded"] = self.satisfactionSurveysResponded!
                    }
                    if self.totalBreakTime != nil {
                        map["TotalBreakTime"] = self.totalBreakTime!
                    }
                    if self.totalCalls != nil {
                        map["TotalCalls"] = self.totalCalls!
                    }
                    if self.totalHoldTime != nil {
                        map["TotalHoldTime"] = self.totalHoldTime!
                    }
                    if self.totalLoggedInTime != nil {
                        map["TotalLoggedInTime"] = self.totalLoggedInTime!
                    }
                    if self.totalOffSiteLoggedInTime != nil {
                        map["TotalOffSiteLoggedInTime"] = self.totalOffSiteLoggedInTime!
                    }
                    if self.totalOffSiteOnlineTime != nil {
                        map["TotalOffSiteOnlineTime"] = self.totalOffSiteOnlineTime!
                    }
                    if self.totalOfficePhoneLoggedInTime != nil {
                        map["TotalOfficePhoneLoggedInTime"] = self.totalOfficePhoneLoggedInTime!
                    }
                    if self.totalOfficePhoneOnlineTime != nil {
                        map["TotalOfficePhoneOnlineTime"] = self.totalOfficePhoneOnlineTime!
                    }
                    if self.totalOnSiteLoggedInTime != nil {
                        map["TotalOnSiteLoggedInTime"] = self.totalOnSiteLoggedInTime!
                    }
                    if self.totalOnSiteOnlineTime != nil {
                        map["TotalOnSiteOnlineTime"] = self.totalOnSiteOnlineTime!
                    }
                    if self.totalOutboundScenarioLoggedInTime != nil {
                        map["TotalOutboundScenarioLoggedInTime"] = self.totalOutboundScenarioLoggedInTime!
                    }
                    if self.totalOutboundScenarioReadyTime != nil {
                        map["TotalOutboundScenarioReadyTime"] = self.totalOutboundScenarioReadyTime!
                    }
                    if self.totalOutboundScenarioTime != nil {
                        map["TotalOutboundScenarioTime"] = self.totalOutboundScenarioTime!
                    }
                    if self.totalReadyTime != nil {
                        map["TotalReadyTime"] = self.totalReadyTime!
                    }
                    if self.totalTalkTime != nil {
                        map["TotalTalkTime"] = self.totalTalkTime!
                    }
                    if self.totalWorkTime != nil {
                        map["TotalWorkTime"] = self.totalWorkTime!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AverageBreakTime") {
                        self.averageBreakTime = dict["AverageBreakTime"] as! Double
                    }
                    if dict.keys.contains("AverageHoldTime") {
                        self.averageHoldTime = dict["AverageHoldTime"] as! Double
                    }
                    if dict.keys.contains("AverageReadyTime") {
                        self.averageReadyTime = dict["AverageReadyTime"] as! Double
                    }
                    if dict.keys.contains("AverageTalkTime") {
                        self.averageTalkTime = dict["AverageTalkTime"] as! Double
                    }
                    if dict.keys.contains("AverageWorkTime") {
                        self.averageWorkTime = dict["AverageWorkTime"] as! Double
                    }
                    if dict.keys.contains("BreakCodeDetailList") {
                        var tmp : [ListHistoricalAgentReportResponseBody.Data.List.Overall.BreakCodeDetailList] = []
                        for v in dict["BreakCodeDetailList"] as! [Any] {
                            var model = ListHistoricalAgentReportResponseBody.Data.List.Overall.BreakCodeDetailList()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.breakCodeDetailList = tmp
                    }
                    if dict.keys.contains("FirstCheckInTime") {
                        self.firstCheckInTime = dict["FirstCheckInTime"] as! Int64
                    }
                    if dict.keys.contains("LastCheckOutTime") {
                        self.lastCheckOutTime = dict["LastCheckOutTime"] as! Int64
                    }
                    if dict.keys.contains("MaxBreakTime") {
                        self.maxBreakTime = dict["MaxBreakTime"] as! Int64
                    }
                    if dict.keys.contains("MaxHoldTime") {
                        self.maxHoldTime = dict["MaxHoldTime"] as! Int64
                    }
                    if dict.keys.contains("MaxReadyTime") {
                        self.maxReadyTime = dict["MaxReadyTime"] as! Int64
                    }
                    if dict.keys.contains("MaxTalkTime") {
                        self.maxTalkTime = dict["MaxTalkTime"] as! Int64
                    }
                    if dict.keys.contains("MaxWorkTime") {
                        self.maxWorkTime = dict["MaxWorkTime"] as! Int64
                    }
                    if dict.keys.contains("OccupancyRate") {
                        self.occupancyRate = dict["OccupancyRate"] as! Double
                    }
                    if dict.keys.contains("SatisfactionIndex") {
                        self.satisfactionIndex = dict["SatisfactionIndex"] as! Double
                    }
                    if dict.keys.contains("SatisfactionRate") {
                        self.satisfactionRate = dict["SatisfactionRate"] as! Double
                    }
                    if dict.keys.contains("SatisfactionSurveysOffered") {
                        self.satisfactionSurveysOffered = dict["SatisfactionSurveysOffered"] as! Int64
                    }
                    if dict.keys.contains("SatisfactionSurveysResponded") {
                        self.satisfactionSurveysResponded = dict["SatisfactionSurveysResponded"] as! Int64
                    }
                    if dict.keys.contains("TotalBreakTime") {
                        self.totalBreakTime = dict["TotalBreakTime"] as! Int64
                    }
                    if dict.keys.contains("TotalCalls") {
                        self.totalCalls = dict["TotalCalls"] as! Int64
                    }
                    if dict.keys.contains("TotalHoldTime") {
                        self.totalHoldTime = dict["TotalHoldTime"] as! Int64
                    }
                    if dict.keys.contains("TotalLoggedInTime") {
                        self.totalLoggedInTime = dict["TotalLoggedInTime"] as! Int64
                    }
                    if dict.keys.contains("TotalOffSiteLoggedInTime") {
                        self.totalOffSiteLoggedInTime = dict["TotalOffSiteLoggedInTime"] as! Int64
                    }
                    if dict.keys.contains("TotalOffSiteOnlineTime") {
                        self.totalOffSiteOnlineTime = dict["TotalOffSiteOnlineTime"] as! Int64
                    }
                    if dict.keys.contains("TotalOfficePhoneLoggedInTime") {
                        self.totalOfficePhoneLoggedInTime = dict["TotalOfficePhoneLoggedInTime"] as! Int64
                    }
                    if dict.keys.contains("TotalOfficePhoneOnlineTime") {
                        self.totalOfficePhoneOnlineTime = dict["TotalOfficePhoneOnlineTime"] as! Int64
                    }
                    if dict.keys.contains("TotalOnSiteLoggedInTime") {
                        self.totalOnSiteLoggedInTime = dict["TotalOnSiteLoggedInTime"] as! Int64
                    }
                    if dict.keys.contains("TotalOnSiteOnlineTime") {
                        self.totalOnSiteOnlineTime = dict["TotalOnSiteOnlineTime"] as! Int64
                    }
                    if dict.keys.contains("TotalOutboundScenarioLoggedInTime") {
                        self.totalOutboundScenarioLoggedInTime = dict["TotalOutboundScenarioLoggedInTime"] as! Int64
                    }
                    if dict.keys.contains("TotalOutboundScenarioReadyTime") {
                        self.totalOutboundScenarioReadyTime = dict["TotalOutboundScenarioReadyTime"] as! Int64
                    }
                    if dict.keys.contains("TotalOutboundScenarioTime") {
                        self.totalOutboundScenarioTime = dict["TotalOutboundScenarioTime"] as! Int64
                    }
                    if dict.keys.contains("TotalReadyTime") {
                        self.totalReadyTime = dict["TotalReadyTime"] as! Int64
                    }
                    if dict.keys.contains("TotalTalkTime") {
                        self.totalTalkTime = dict["TotalTalkTime"] as! Int64
                    }
                    if dict.keys.contains("TotalWorkTime") {
                        self.totalWorkTime = dict["TotalWorkTime"] as! Int64
                    }
                }
            }
            public var agentId: String?

            public var agentName: String?

            public var back2Back: ListHistoricalAgentReportResponseBody.Data.List.Back2Back?

            public var displayId: String?

            public var inbound: ListHistoricalAgentReportResponseBody.Data.List.Inbound?

            public var internal_: ListHistoricalAgentReportResponseBody.Data.List.Internal_?

            public var outbound: ListHistoricalAgentReportResponseBody.Data.List.Outbound?

            public var overall: ListHistoricalAgentReportResponseBody.Data.List.Overall?

            public var skillGroupIds: String?

            public var skillGroupNames: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.back2Back?.validate()
                try self.inbound?.validate()
                try self.internal_?.validate()
                try self.outbound?.validate()
                try self.overall?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.agentId != nil {
                    map["AgentId"] = self.agentId!
                }
                if self.agentName != nil {
                    map["AgentName"] = self.agentName!
                }
                if self.back2Back != nil {
                    map["Back2Back"] = self.back2Back?.toMap()
                }
                if self.displayId != nil {
                    map["DisplayId"] = self.displayId!
                }
                if self.inbound != nil {
                    map["Inbound"] = self.inbound?.toMap()
                }
                if self.internal_ != nil {
                    map["Internal"] = self.internal_?.toMap()
                }
                if self.outbound != nil {
                    map["Outbound"] = self.outbound?.toMap()
                }
                if self.overall != nil {
                    map["Overall"] = self.overall?.toMap()
                }
                if self.skillGroupIds != nil {
                    map["SkillGroupIds"] = self.skillGroupIds!
                }
                if self.skillGroupNames != nil {
                    map["SkillGroupNames"] = self.skillGroupNames!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AgentId") {
                    self.agentId = dict["AgentId"] as! String
                }
                if dict.keys.contains("AgentName") {
                    self.agentName = dict["AgentName"] as! String
                }
                if dict.keys.contains("Back2Back") {
                    var model = ListHistoricalAgentReportResponseBody.Data.List.Back2Back()
                    model.fromMap(dict["Back2Back"] as! [String: Any])
                    self.back2Back = model
                }
                if dict.keys.contains("DisplayId") {
                    self.displayId = dict["DisplayId"] as! String
                }
                if dict.keys.contains("Inbound") {
                    var model = ListHistoricalAgentReportResponseBody.Data.List.Inbound()
                    model.fromMap(dict["Inbound"] as! [String: Any])
                    self.inbound = model
                }
                if dict.keys.contains("Internal") {
                    var model = ListHistoricalAgentReportResponseBody.Data.List.Internal_()
                    model.fromMap(dict["Internal"] as! [String: Any])
                    self.internal_ = model
                }
                if dict.keys.contains("Outbound") {
                    var model = ListHistoricalAgentReportResponseBody.Data.List.Outbound()
                    model.fromMap(dict["Outbound"] as! [String: Any])
                    self.outbound = model
                }
                if dict.keys.contains("Overall") {
                    var model = ListHistoricalAgentReportResponseBody.Data.List.Overall()
                    model.fromMap(dict["Overall"] as! [String: Any])
                    self.overall = model
                }
                if dict.keys.contains("SkillGroupIds") {
                    self.skillGroupIds = dict["SkillGroupIds"] as! String
                }
                if dict.keys.contains("SkillGroupNames") {
                    self.skillGroupNames = dict["SkillGroupNames"] as! String
                }
            }
        }
        public var list: [ListHistoricalAgentReportResponseBody.Data.List]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.list != nil {
                var tmp : [Any] = []
                for k in self.list! {
                    tmp.append(k.toMap())
                }
                map["List"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("List") {
                var tmp : [ListHistoricalAgentReportResponseBody.Data.List] = []
                for v in dict["List"] as! [Any] {
                    var model = ListHistoricalAgentReportResponseBody.Data.List()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.list = tmp
            }
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var code: String?

    public var data: ListHistoricalAgentReportResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = ListHistoricalAgentReportResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListHistoricalAgentReportResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListHistoricalAgentReportResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListHistoricalAgentReportResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListHistoricalAgentSkillGroupReportRequest : Tea.TeaModel {
    public var agentIdList: String?

    public var endTime: Int64?

    public var instanceId: String?

    public var mediaType: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var skillGroupIdList: String?

    public var startTime: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.agentIdList != nil {
            map["AgentIdList"] = self.agentIdList!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.mediaType != nil {
            map["MediaType"] = self.mediaType!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.skillGroupIdList != nil {
            map["SkillGroupIdList"] = self.skillGroupIdList!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AgentIdList") {
            self.agentIdList = dict["AgentIdList"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("MediaType") {
            self.mediaType = dict["MediaType"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SkillGroupIdList") {
            self.skillGroupIdList = dict["SkillGroupIdList"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! Int64
        }
    }
}

public class ListHistoricalAgentSkillGroupReportResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class List : Tea.TeaModel {
            public class Back2Back : Tea.TeaModel {
                public var agentAnswerRate: Double?

                public var agentHandleRate: Double?

                public var answerRate: Double?

                public var averageCustomerRingTime: Double?

                public var averageRingTime: Double?

                public var averageTalkTime: Int64?

                public var callsAgentHandled: Int64?

                public var callsAnswered: Int64?

                public var callsCustomerAnswered: Int64?

                public var callsCustomerHandled: Int64?

                public var callsDialed: Int64?

                public var customerAnswerRate: Double?

                public var customerHandleRate: Double?

                public var maxCustomerRingTime: Int64?

                public var maxRingTime: Int64?

                public var maxTalkTime: Int64?

                public var totalCustomerRingTime: Int64?

                public var totalRingTime: Int64?

                public var totalTalkTime: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.agentAnswerRate != nil {
                        map["AgentAnswerRate"] = self.agentAnswerRate!
                    }
                    if self.agentHandleRate != nil {
                        map["AgentHandleRate"] = self.agentHandleRate!
                    }
                    if self.answerRate != nil {
                        map["AnswerRate"] = self.answerRate!
                    }
                    if self.averageCustomerRingTime != nil {
                        map["AverageCustomerRingTime"] = self.averageCustomerRingTime!
                    }
                    if self.averageRingTime != nil {
                        map["AverageRingTime"] = self.averageRingTime!
                    }
                    if self.averageTalkTime != nil {
                        map["AverageTalkTime"] = self.averageTalkTime!
                    }
                    if self.callsAgentHandled != nil {
                        map["CallsAgentHandled"] = self.callsAgentHandled!
                    }
                    if self.callsAnswered != nil {
                        map["CallsAnswered"] = self.callsAnswered!
                    }
                    if self.callsCustomerAnswered != nil {
                        map["CallsCustomerAnswered"] = self.callsCustomerAnswered!
                    }
                    if self.callsCustomerHandled != nil {
                        map["CallsCustomerHandled"] = self.callsCustomerHandled!
                    }
                    if self.callsDialed != nil {
                        map["CallsDialed"] = self.callsDialed!
                    }
                    if self.customerAnswerRate != nil {
                        map["CustomerAnswerRate"] = self.customerAnswerRate!
                    }
                    if self.customerHandleRate != nil {
                        map["CustomerHandleRate"] = self.customerHandleRate!
                    }
                    if self.maxCustomerRingTime != nil {
                        map["MaxCustomerRingTime"] = self.maxCustomerRingTime!
                    }
                    if self.maxRingTime != nil {
                        map["MaxRingTime"] = self.maxRingTime!
                    }
                    if self.maxTalkTime != nil {
                        map["MaxTalkTime"] = self.maxTalkTime!
                    }
                    if self.totalCustomerRingTime != nil {
                        map["TotalCustomerRingTime"] = self.totalCustomerRingTime!
                    }
                    if self.totalRingTime != nil {
                        map["TotalRingTime"] = self.totalRingTime!
                    }
                    if self.totalTalkTime != nil {
                        map["TotalTalkTime"] = self.totalTalkTime!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AgentAnswerRate") {
                        self.agentAnswerRate = dict["AgentAnswerRate"] as! Double
                    }
                    if dict.keys.contains("AgentHandleRate") {
                        self.agentHandleRate = dict["AgentHandleRate"] as! Double
                    }
                    if dict.keys.contains("AnswerRate") {
                        self.answerRate = dict["AnswerRate"] as! Double
                    }
                    if dict.keys.contains("AverageCustomerRingTime") {
                        self.averageCustomerRingTime = dict["AverageCustomerRingTime"] as! Double
                    }
                    if dict.keys.contains("AverageRingTime") {
                        self.averageRingTime = dict["AverageRingTime"] as! Double
                    }
                    if dict.keys.contains("AverageTalkTime") {
                        self.averageTalkTime = dict["AverageTalkTime"] as! Int64
                    }
                    if dict.keys.contains("CallsAgentHandled") {
                        self.callsAgentHandled = dict["CallsAgentHandled"] as! Int64
                    }
                    if dict.keys.contains("CallsAnswered") {
                        self.callsAnswered = dict["CallsAnswered"] as! Int64
                    }
                    if dict.keys.contains("CallsCustomerAnswered") {
                        self.callsCustomerAnswered = dict["CallsCustomerAnswered"] as! Int64
                    }
                    if dict.keys.contains("CallsCustomerHandled") {
                        self.callsCustomerHandled = dict["CallsCustomerHandled"] as! Int64
                    }
                    if dict.keys.contains("CallsDialed") {
                        self.callsDialed = dict["CallsDialed"] as! Int64
                    }
                    if dict.keys.contains("CustomerAnswerRate") {
                        self.customerAnswerRate = dict["CustomerAnswerRate"] as! Double
                    }
                    if dict.keys.contains("CustomerHandleRate") {
                        self.customerHandleRate = dict["CustomerHandleRate"] as! Double
                    }
                    if dict.keys.contains("MaxCustomerRingTime") {
                        self.maxCustomerRingTime = dict["MaxCustomerRingTime"] as! Int64
                    }
                    if dict.keys.contains("MaxRingTime") {
                        self.maxRingTime = dict["MaxRingTime"] as! Int64
                    }
                    if dict.keys.contains("MaxTalkTime") {
                        self.maxTalkTime = dict["MaxTalkTime"] as! Int64
                    }
                    if dict.keys.contains("TotalCustomerRingTime") {
                        self.totalCustomerRingTime = dict["TotalCustomerRingTime"] as! Int64
                    }
                    if dict.keys.contains("TotalRingTime") {
                        self.totalRingTime = dict["TotalRingTime"] as! Int64
                    }
                    if dict.keys.contains("TotalTalkTime") {
                        self.totalTalkTime = dict["TotalTalkTime"] as! Int64
                    }
                }
            }
            public class Inbound : Tea.TeaModel {
                public var averageFirstResponseTime: Double?

                public var averageHoldTime: Double?

                public var averageResponseTime: Double?

                public var averageRingTime: Double?

                public var averageTalkTime: Double?

                public var averageWorkTime: Double?

                public var callsAttendedTransferIn: Int64?

                public var callsAttendedTransferOut: Int64?

                public var callsBlindTransferIn: Int64?

                public var callsBlindTransferOut: Int64?

                public var callsHandled: Int64?

                public var callsHold: Int64?

                public var callsOffered: Int64?

                public var callsRinged: Int64?

                public var handleRate: Double?

                public var maxHoldTime: Int64?

                public var maxRingTime: Int64?

                public var maxTalkTime: Int64?

                public var maxWorkTime: Int64?

                public var satisfactionIndex: Double?

                public var satisfactionRate: Double?

                public var satisfactionSurveysOffered: Int64?

                public var satisfactionSurveysResponded: Int64?

                public var totalHoldTime: Int64?

                public var totalMessagesSent: Int64?

                public var totalMessagesSentByAgent: Int64?

                public var totalMessagesSentByCustomer: Int64?

                public var totalRingTime: Int64?

                public var totalTalkTime: Int64?

                public var totalWorkTime: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.averageFirstResponseTime != nil {
                        map["AverageFirstResponseTime"] = self.averageFirstResponseTime!
                    }
                    if self.averageHoldTime != nil {
                        map["AverageHoldTime"] = self.averageHoldTime!
                    }
                    if self.averageResponseTime != nil {
                        map["AverageResponseTime"] = self.averageResponseTime!
                    }
                    if self.averageRingTime != nil {
                        map["AverageRingTime"] = self.averageRingTime!
                    }
                    if self.averageTalkTime != nil {
                        map["AverageTalkTime"] = self.averageTalkTime!
                    }
                    if self.averageWorkTime != nil {
                        map["AverageWorkTime"] = self.averageWorkTime!
                    }
                    if self.callsAttendedTransferIn != nil {
                        map["CallsAttendedTransferIn"] = self.callsAttendedTransferIn!
                    }
                    if self.callsAttendedTransferOut != nil {
                        map["CallsAttendedTransferOut"] = self.callsAttendedTransferOut!
                    }
                    if self.callsBlindTransferIn != nil {
                        map["CallsBlindTransferIn"] = self.callsBlindTransferIn!
                    }
                    if self.callsBlindTransferOut != nil {
                        map["CallsBlindTransferOut"] = self.callsBlindTransferOut!
                    }
                    if self.callsHandled != nil {
                        map["CallsHandled"] = self.callsHandled!
                    }
                    if self.callsHold != nil {
                        map["CallsHold"] = self.callsHold!
                    }
                    if self.callsOffered != nil {
                        map["CallsOffered"] = self.callsOffered!
                    }
                    if self.callsRinged != nil {
                        map["CallsRinged"] = self.callsRinged!
                    }
                    if self.handleRate != nil {
                        map["HandleRate"] = self.handleRate!
                    }
                    if self.maxHoldTime != nil {
                        map["MaxHoldTime"] = self.maxHoldTime!
                    }
                    if self.maxRingTime != nil {
                        map["MaxRingTime"] = self.maxRingTime!
                    }
                    if self.maxTalkTime != nil {
                        map["MaxTalkTime"] = self.maxTalkTime!
                    }
                    if self.maxWorkTime != nil {
                        map["MaxWorkTime"] = self.maxWorkTime!
                    }
                    if self.satisfactionIndex != nil {
                        map["SatisfactionIndex"] = self.satisfactionIndex!
                    }
                    if self.satisfactionRate != nil {
                        map["SatisfactionRate"] = self.satisfactionRate!
                    }
                    if self.satisfactionSurveysOffered != nil {
                        map["SatisfactionSurveysOffered"] = self.satisfactionSurveysOffered!
                    }
                    if self.satisfactionSurveysResponded != nil {
                        map["SatisfactionSurveysResponded"] = self.satisfactionSurveysResponded!
                    }
                    if self.totalHoldTime != nil {
                        map["TotalHoldTime"] = self.totalHoldTime!
                    }
                    if self.totalMessagesSent != nil {
                        map["TotalMessagesSent"] = self.totalMessagesSent!
                    }
                    if self.totalMessagesSentByAgent != nil {
                        map["TotalMessagesSentByAgent"] = self.totalMessagesSentByAgent!
                    }
                    if self.totalMessagesSentByCustomer != nil {
                        map["TotalMessagesSentByCustomer"] = self.totalMessagesSentByCustomer!
                    }
                    if self.totalRingTime != nil {
                        map["TotalRingTime"] = self.totalRingTime!
                    }
                    if self.totalTalkTime != nil {
                        map["TotalTalkTime"] = self.totalTalkTime!
                    }
                    if self.totalWorkTime != nil {
                        map["TotalWorkTime"] = self.totalWorkTime!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AverageFirstResponseTime") {
                        self.averageFirstResponseTime = dict["AverageFirstResponseTime"] as! Double
                    }
                    if dict.keys.contains("AverageHoldTime") {
                        self.averageHoldTime = dict["AverageHoldTime"] as! Double
                    }
                    if dict.keys.contains("AverageResponseTime") {
                        self.averageResponseTime = dict["AverageResponseTime"] as! Double
                    }
                    if dict.keys.contains("AverageRingTime") {
                        self.averageRingTime = dict["AverageRingTime"] as! Double
                    }
                    if dict.keys.contains("AverageTalkTime") {
                        self.averageTalkTime = dict["AverageTalkTime"] as! Double
                    }
                    if dict.keys.contains("AverageWorkTime") {
                        self.averageWorkTime = dict["AverageWorkTime"] as! Double
                    }
                    if dict.keys.contains("CallsAttendedTransferIn") {
                        self.callsAttendedTransferIn = dict["CallsAttendedTransferIn"] as! Int64
                    }
                    if dict.keys.contains("CallsAttendedTransferOut") {
                        self.callsAttendedTransferOut = dict["CallsAttendedTransferOut"] as! Int64
                    }
                    if dict.keys.contains("CallsBlindTransferIn") {
                        self.callsBlindTransferIn = dict["CallsBlindTransferIn"] as! Int64
                    }
                    if dict.keys.contains("CallsBlindTransferOut") {
                        self.callsBlindTransferOut = dict["CallsBlindTransferOut"] as! Int64
                    }
                    if dict.keys.contains("CallsHandled") {
                        self.callsHandled = dict["CallsHandled"] as! Int64
                    }
                    if dict.keys.contains("CallsHold") {
                        self.callsHold = dict["CallsHold"] as! Int64
                    }
                    if dict.keys.contains("CallsOffered") {
                        self.callsOffered = dict["CallsOffered"] as! Int64
                    }
                    if dict.keys.contains("CallsRinged") {
                        self.callsRinged = dict["CallsRinged"] as! Int64
                    }
                    if dict.keys.contains("HandleRate") {
                        self.handleRate = dict["HandleRate"] as! Double
                    }
                    if dict.keys.contains("MaxHoldTime") {
                        self.maxHoldTime = dict["MaxHoldTime"] as! Int64
                    }
                    if dict.keys.contains("MaxRingTime") {
                        self.maxRingTime = dict["MaxRingTime"] as! Int64
                    }
                    if dict.keys.contains("MaxTalkTime") {
                        self.maxTalkTime = dict["MaxTalkTime"] as! Int64
                    }
                    if dict.keys.contains("MaxWorkTime") {
                        self.maxWorkTime = dict["MaxWorkTime"] as! Int64
                    }
                    if dict.keys.contains("SatisfactionIndex") {
                        self.satisfactionIndex = dict["SatisfactionIndex"] as! Double
                    }
                    if dict.keys.contains("SatisfactionRate") {
                        self.satisfactionRate = dict["SatisfactionRate"] as! Double
                    }
                    if dict.keys.contains("SatisfactionSurveysOffered") {
                        self.satisfactionSurveysOffered = dict["SatisfactionSurveysOffered"] as! Int64
                    }
                    if dict.keys.contains("SatisfactionSurveysResponded") {
                        self.satisfactionSurveysResponded = dict["SatisfactionSurveysResponded"] as! Int64
                    }
                    if dict.keys.contains("TotalHoldTime") {
                        self.totalHoldTime = dict["TotalHoldTime"] as! Int64
                    }
                    if dict.keys.contains("TotalMessagesSent") {
                        self.totalMessagesSent = dict["TotalMessagesSent"] as! Int64
                    }
                    if dict.keys.contains("TotalMessagesSentByAgent") {
                        self.totalMessagesSentByAgent = dict["TotalMessagesSentByAgent"] as! Int64
                    }
                    if dict.keys.contains("TotalMessagesSentByCustomer") {
                        self.totalMessagesSentByCustomer = dict["TotalMessagesSentByCustomer"] as! Int64
                    }
                    if dict.keys.contains("TotalRingTime") {
                        self.totalRingTime = dict["TotalRingTime"] as! Int64
                    }
                    if dict.keys.contains("TotalTalkTime") {
                        self.totalTalkTime = dict["TotalTalkTime"] as! Int64
                    }
                    if dict.keys.contains("TotalWorkTime") {
                        self.totalWorkTime = dict["TotalWorkTime"] as! Int64
                    }
                }
            }
            public class Internal_ : Tea.TeaModel {
                public var averageTalkTime: Int64?

                public var callsAnswered: Int64?

                public var callsDialed: Int64?

                public var callsHandled: Int64?

                public var callsOffered: Int64?

                public var callsTalk: Int64?

                public var callsTalked: Int64?

                public var maxTalkTime: Int64?

                public var totalTalkTime: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.averageTalkTime != nil {
                        map["AverageTalkTime"] = self.averageTalkTime!
                    }
                    if self.callsAnswered != nil {
                        map["CallsAnswered"] = self.callsAnswered!
                    }
                    if self.callsDialed != nil {
                        map["CallsDialed"] = self.callsDialed!
                    }
                    if self.callsHandled != nil {
                        map["CallsHandled"] = self.callsHandled!
                    }
                    if self.callsOffered != nil {
                        map["CallsOffered"] = self.callsOffered!
                    }
                    if self.callsTalk != nil {
                        map["CallsTalk"] = self.callsTalk!
                    }
                    if self.callsTalked != nil {
                        map["CallsTalked"] = self.callsTalked!
                    }
                    if self.maxTalkTime != nil {
                        map["MaxTalkTime"] = self.maxTalkTime!
                    }
                    if self.totalTalkTime != nil {
                        map["TotalTalkTime"] = self.totalTalkTime!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AverageTalkTime") {
                        self.averageTalkTime = dict["AverageTalkTime"] as! Int64
                    }
                    if dict.keys.contains("CallsAnswered") {
                        self.callsAnswered = dict["CallsAnswered"] as! Int64
                    }
                    if dict.keys.contains("CallsDialed") {
                        self.callsDialed = dict["CallsDialed"] as! Int64
                    }
                    if dict.keys.contains("CallsHandled") {
                        self.callsHandled = dict["CallsHandled"] as! Int64
                    }
                    if dict.keys.contains("CallsOffered") {
                        self.callsOffered = dict["CallsOffered"] as! Int64
                    }
                    if dict.keys.contains("CallsTalk") {
                        self.callsTalk = dict["CallsTalk"] as! Int64
                    }
                    if dict.keys.contains("CallsTalked") {
                        self.callsTalked = dict["CallsTalked"] as! Int64
                    }
                    if dict.keys.contains("MaxTalkTime") {
                        self.maxTalkTime = dict["MaxTalkTime"] as! Int64
                    }
                    if dict.keys.contains("TotalTalkTime") {
                        self.totalTalkTime = dict["TotalTalkTime"] as! Int64
                    }
                }
            }
            public class Outbound : Tea.TeaModel {
                public var answerRate: Double?

                public var averageDialingTime: Double?

                public var averageHoldTime: Double?

                public var averageRingTime: Double?

                public var averageTalkTime: Double?

                public var averageWorkTime: Double?

                public var callsAnswered: Int64?

                public var callsAttendedTransferIn: Int64?

                public var callsAttendedTransferOut: Int64?

                public var callsBlindTransferIn: Int64?

                public var callsBlindTransferOut: Int64?

                public var callsDialed: Int64?

                public var callsHold: Int64?

                public var callsRinged: Int64?

                public var maxDialingTime: Int64?

                public var maxHoldTime: Int64?

                public var maxRingTime: Int64?

                public var maxTalkTime: Int64?

                public var maxWorkTime: Int64?

                public var satisfactionIndex: Double?

                public var satisfactionRate: Double?

                public var satisfactionSurveysOffered: Int64?

                public var satisfactionSurveysResponded: Int64?

                public var totalDialingTime: Int64?

                public var totalHoldTime: Int64?

                public var totalRingTime: Int64?

                public var totalTalkTime: Int64?

                public var totalWorkTime: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.answerRate != nil {
                        map["AnswerRate"] = self.answerRate!
                    }
                    if self.averageDialingTime != nil {
                        map["AverageDialingTime"] = self.averageDialingTime!
                    }
                    if self.averageHoldTime != nil {
                        map["AverageHoldTime"] = self.averageHoldTime!
                    }
                    if self.averageRingTime != nil {
                        map["AverageRingTime"] = self.averageRingTime!
                    }
                    if self.averageTalkTime != nil {
                        map["AverageTalkTime"] = self.averageTalkTime!
                    }
                    if self.averageWorkTime != nil {
                        map["AverageWorkTime"] = self.averageWorkTime!
                    }
                    if self.callsAnswered != nil {
                        map["CallsAnswered"] = self.callsAnswered!
                    }
                    if self.callsAttendedTransferIn != nil {
                        map["CallsAttendedTransferIn"] = self.callsAttendedTransferIn!
                    }
                    if self.callsAttendedTransferOut != nil {
                        map["CallsAttendedTransferOut"] = self.callsAttendedTransferOut!
                    }
                    if self.callsBlindTransferIn != nil {
                        map["CallsBlindTransferIn"] = self.callsBlindTransferIn!
                    }
                    if self.callsBlindTransferOut != nil {
                        map["CallsBlindTransferOut"] = self.callsBlindTransferOut!
                    }
                    if self.callsDialed != nil {
                        map["CallsDialed"] = self.callsDialed!
                    }
                    if self.callsHold != nil {
                        map["CallsHold"] = self.callsHold!
                    }
                    if self.callsRinged != nil {
                        map["CallsRinged"] = self.callsRinged!
                    }
                    if self.maxDialingTime != nil {
                        map["MaxDialingTime"] = self.maxDialingTime!
                    }
                    if self.maxHoldTime != nil {
                        map["MaxHoldTime"] = self.maxHoldTime!
                    }
                    if self.maxRingTime != nil {
                        map["MaxRingTime"] = self.maxRingTime!
                    }
                    if self.maxTalkTime != nil {
                        map["MaxTalkTime"] = self.maxTalkTime!
                    }
                    if self.maxWorkTime != nil {
                        map["MaxWorkTime"] = self.maxWorkTime!
                    }
                    if self.satisfactionIndex != nil {
                        map["SatisfactionIndex"] = self.satisfactionIndex!
                    }
                    if self.satisfactionRate != nil {
                        map["SatisfactionRate"] = self.satisfactionRate!
                    }
                    if self.satisfactionSurveysOffered != nil {
                        map["SatisfactionSurveysOffered"] = self.satisfactionSurveysOffered!
                    }
                    if self.satisfactionSurveysResponded != nil {
                        map["SatisfactionSurveysResponded"] = self.satisfactionSurveysResponded!
                    }
                    if self.totalDialingTime != nil {
                        map["TotalDialingTime"] = self.totalDialingTime!
                    }
                    if self.totalHoldTime != nil {
                        map["TotalHoldTime"] = self.totalHoldTime!
                    }
                    if self.totalRingTime != nil {
                        map["TotalRingTime"] = self.totalRingTime!
                    }
                    if self.totalTalkTime != nil {
                        map["TotalTalkTime"] = self.totalTalkTime!
                    }
                    if self.totalWorkTime != nil {
                        map["TotalWorkTime"] = self.totalWorkTime!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AnswerRate") {
                        self.answerRate = dict["AnswerRate"] as! Double
                    }
                    if dict.keys.contains("AverageDialingTime") {
                        self.averageDialingTime = dict["AverageDialingTime"] as! Double
                    }
                    if dict.keys.contains("AverageHoldTime") {
                        self.averageHoldTime = dict["AverageHoldTime"] as! Double
                    }
                    if dict.keys.contains("AverageRingTime") {
                        self.averageRingTime = dict["AverageRingTime"] as! Double
                    }
                    if dict.keys.contains("AverageTalkTime") {
                        self.averageTalkTime = dict["AverageTalkTime"] as! Double
                    }
                    if dict.keys.contains("AverageWorkTime") {
                        self.averageWorkTime = dict["AverageWorkTime"] as! Double
                    }
                    if dict.keys.contains("CallsAnswered") {
                        self.callsAnswered = dict["CallsAnswered"] as! Int64
                    }
                    if dict.keys.contains("CallsAttendedTransferIn") {
                        self.callsAttendedTransferIn = dict["CallsAttendedTransferIn"] as! Int64
                    }
                    if dict.keys.contains("CallsAttendedTransferOut") {
                        self.callsAttendedTransferOut = dict["CallsAttendedTransferOut"] as! Int64
                    }
                    if dict.keys.contains("CallsBlindTransferIn") {
                        self.callsBlindTransferIn = dict["CallsBlindTransferIn"] as! Int64
                    }
                    if dict.keys.contains("CallsBlindTransferOut") {
                        self.callsBlindTransferOut = dict["CallsBlindTransferOut"] as! Int64
                    }
                    if dict.keys.contains("CallsDialed") {
                        self.callsDialed = dict["CallsDialed"] as! Int64
                    }
                    if dict.keys.contains("CallsHold") {
                        self.callsHold = dict["CallsHold"] as! Int64
                    }
                    if dict.keys.contains("CallsRinged") {
                        self.callsRinged = dict["CallsRinged"] as! Int64
                    }
                    if dict.keys.contains("MaxDialingTime") {
                        self.maxDialingTime = dict["MaxDialingTime"] as! Int64
                    }
                    if dict.keys.contains("MaxHoldTime") {
                        self.maxHoldTime = dict["MaxHoldTime"] as! Int64
                    }
                    if dict.keys.contains("MaxRingTime") {
                        self.maxRingTime = dict["MaxRingTime"] as! Int64
                    }
                    if dict.keys.contains("MaxTalkTime") {
                        self.maxTalkTime = dict["MaxTalkTime"] as! Int64
                    }
                    if dict.keys.contains("MaxWorkTime") {
                        self.maxWorkTime = dict["MaxWorkTime"] as! Int64
                    }
                    if dict.keys.contains("SatisfactionIndex") {
                        self.satisfactionIndex = dict["SatisfactionIndex"] as! Double
                    }
                    if dict.keys.contains("SatisfactionRate") {
                        self.satisfactionRate = dict["SatisfactionRate"] as! Double
                    }
                    if dict.keys.contains("SatisfactionSurveysOffered") {
                        self.satisfactionSurveysOffered = dict["SatisfactionSurveysOffered"] as! Int64
                    }
                    if dict.keys.contains("SatisfactionSurveysResponded") {
                        self.satisfactionSurveysResponded = dict["SatisfactionSurveysResponded"] as! Int64
                    }
                    if dict.keys.contains("TotalDialingTime") {
                        self.totalDialingTime = dict["TotalDialingTime"] as! Int64
                    }
                    if dict.keys.contains("TotalHoldTime") {
                        self.totalHoldTime = dict["TotalHoldTime"] as! Int64
                    }
                    if dict.keys.contains("TotalRingTime") {
                        self.totalRingTime = dict["TotalRingTime"] as! Int64
                    }
                    if dict.keys.contains("TotalTalkTime") {
                        self.totalTalkTime = dict["TotalTalkTime"] as! Int64
                    }
                    if dict.keys.contains("TotalWorkTime") {
                        self.totalWorkTime = dict["TotalWorkTime"] as! Int64
                    }
                }
            }
            public class Overall : Tea.TeaModel {
                public class BreakCodeDetailList : Tea.TeaModel {
                    public var breakCode: String?

                    public var count: Int64?

                    public var duration: Int64?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.breakCode != nil {
                            map["BreakCode"] = self.breakCode!
                        }
                        if self.count != nil {
                            map["Count"] = self.count!
                        }
                        if self.duration != nil {
                            map["Duration"] = self.duration!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("BreakCode") {
                            self.breakCode = dict["BreakCode"] as! String
                        }
                        if dict.keys.contains("Count") {
                            self.count = dict["Count"] as! Int64
                        }
                        if dict.keys.contains("Duration") {
                            self.duration = dict["Duration"] as! Int64
                        }
                    }
                }
                public var averageBreakTime: Double?

                public var averageHoldTime: Double?

                public var averageReadyTime: Double?

                public var averageTalkTime: Double?

                public var averageWorkTime: Double?

                public var breakCodeDetailList: [ListHistoricalAgentSkillGroupReportResponseBody.Data.List.Overall.BreakCodeDetailList]?

                public var firstCheckInTime: Int64?

                public var lastCheckOutTime: Int64?

                public var maxBreakTime: Int64?

                public var maxHoldTime: Int64?

                public var maxReadyTime: Int64?

                public var maxTalkTime: Int64?

                public var maxWorkTime: Int64?

                public var occupancyRate: Double?

                public var satisfactionIndex: Double?

                public var satisfactionRate: Double?

                public var satisfactionSurveysOffered: Int64?

                public var satisfactionSurveysResponded: Int64?

                public var totalBreakTime: Int64?

                public var totalCalls: Int64?

                public var totalHoldTime: Int64?

                public var totalLoggedInTime: Int64?

                public var totalOffSiteLggedInTime: Int64?

                public var totalOfficePhoneLoggedInTime: Int64?

                public var totalOnSiteLoggedInTime: String?

                public var totalOutboundScenarioLoggedInTime: Int64?

                public var totalOutboundScenarioReadyTime: Int64?

                public var totalOutboundScenarioTime: Int64?

                public var totalReadyTime: Int64?

                public var totalTalkTime: Int64?

                public var totalWorkTime: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.averageBreakTime != nil {
                        map["AverageBreakTime"] = self.averageBreakTime!
                    }
                    if self.averageHoldTime != nil {
                        map["AverageHoldTime"] = self.averageHoldTime!
                    }
                    if self.averageReadyTime != nil {
                        map["AverageReadyTime"] = self.averageReadyTime!
                    }
                    if self.averageTalkTime != nil {
                        map["AverageTalkTime"] = self.averageTalkTime!
                    }
                    if self.averageWorkTime != nil {
                        map["AverageWorkTime"] = self.averageWorkTime!
                    }
                    if self.breakCodeDetailList != nil {
                        var tmp : [Any] = []
                        for k in self.breakCodeDetailList! {
                            tmp.append(k.toMap())
                        }
                        map["BreakCodeDetailList"] = tmp
                    }
                    if self.firstCheckInTime != nil {
                        map["FirstCheckInTime"] = self.firstCheckInTime!
                    }
                    if self.lastCheckOutTime != nil {
                        map["LastCheckOutTime"] = self.lastCheckOutTime!
                    }
                    if self.maxBreakTime != nil {
                        map["MaxBreakTime"] = self.maxBreakTime!
                    }
                    if self.maxHoldTime != nil {
                        map["MaxHoldTime"] = self.maxHoldTime!
                    }
                    if self.maxReadyTime != nil {
                        map["MaxReadyTime"] = self.maxReadyTime!
                    }
                    if self.maxTalkTime != nil {
                        map["MaxTalkTime"] = self.maxTalkTime!
                    }
                    if self.maxWorkTime != nil {
                        map["MaxWorkTime"] = self.maxWorkTime!
                    }
                    if self.occupancyRate != nil {
                        map["OccupancyRate"] = self.occupancyRate!
                    }
                    if self.satisfactionIndex != nil {
                        map["SatisfactionIndex"] = self.satisfactionIndex!
                    }
                    if self.satisfactionRate != nil {
                        map["SatisfactionRate"] = self.satisfactionRate!
                    }
                    if self.satisfactionSurveysOffered != nil {
                        map["SatisfactionSurveysOffered"] = self.satisfactionSurveysOffered!
                    }
                    if self.satisfactionSurveysResponded != nil {
                        map["SatisfactionSurveysResponded"] = self.satisfactionSurveysResponded!
                    }
                    if self.totalBreakTime != nil {
                        map["TotalBreakTime"] = self.totalBreakTime!
                    }
                    if self.totalCalls != nil {
                        map["TotalCalls"] = self.totalCalls!
                    }
                    if self.totalHoldTime != nil {
                        map["TotalHoldTime"] = self.totalHoldTime!
                    }
                    if self.totalLoggedInTime != nil {
                        map["TotalLoggedInTime"] = self.totalLoggedInTime!
                    }
                    if self.totalOffSiteLggedInTime != nil {
                        map["TotalOffSiteLggedInTime"] = self.totalOffSiteLggedInTime!
                    }
                    if self.totalOfficePhoneLoggedInTime != nil {
                        map["TotalOfficePhoneLoggedInTime"] = self.totalOfficePhoneLoggedInTime!
                    }
                    if self.totalOnSiteLoggedInTime != nil {
                        map["TotalOnSiteLoggedInTime"] = self.totalOnSiteLoggedInTime!
                    }
                    if self.totalOutboundScenarioLoggedInTime != nil {
                        map["TotalOutboundScenarioLoggedInTime"] = self.totalOutboundScenarioLoggedInTime!
                    }
                    if self.totalOutboundScenarioReadyTime != nil {
                        map["TotalOutboundScenarioReadyTime"] = self.totalOutboundScenarioReadyTime!
                    }
                    if self.totalOutboundScenarioTime != nil {
                        map["TotalOutboundScenarioTime"] = self.totalOutboundScenarioTime!
                    }
                    if self.totalReadyTime != nil {
                        map["TotalReadyTime"] = self.totalReadyTime!
                    }
                    if self.totalTalkTime != nil {
                        map["TotalTalkTime"] = self.totalTalkTime!
                    }
                    if self.totalWorkTime != nil {
                        map["TotalWorkTime"] = self.totalWorkTime!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AverageBreakTime") {
                        self.averageBreakTime = dict["AverageBreakTime"] as! Double
                    }
                    if dict.keys.contains("AverageHoldTime") {
                        self.averageHoldTime = dict["AverageHoldTime"] as! Double
                    }
                    if dict.keys.contains("AverageReadyTime") {
                        self.averageReadyTime = dict["AverageReadyTime"] as! Double
                    }
                    if dict.keys.contains("AverageTalkTime") {
                        self.averageTalkTime = dict["AverageTalkTime"] as! Double
                    }
                    if dict.keys.contains("AverageWorkTime") {
                        self.averageWorkTime = dict["AverageWorkTime"] as! Double
                    }
                    if dict.keys.contains("BreakCodeDetailList") {
                        var tmp : [ListHistoricalAgentSkillGroupReportResponseBody.Data.List.Overall.BreakCodeDetailList] = []
                        for v in dict["BreakCodeDetailList"] as! [Any] {
                            var model = ListHistoricalAgentSkillGroupReportResponseBody.Data.List.Overall.BreakCodeDetailList()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.breakCodeDetailList = tmp
                    }
                    if dict.keys.contains("FirstCheckInTime") {
                        self.firstCheckInTime = dict["FirstCheckInTime"] as! Int64
                    }
                    if dict.keys.contains("LastCheckOutTime") {
                        self.lastCheckOutTime = dict["LastCheckOutTime"] as! Int64
                    }
                    if dict.keys.contains("MaxBreakTime") {
                        self.maxBreakTime = dict["MaxBreakTime"] as! Int64
                    }
                    if dict.keys.contains("MaxHoldTime") {
                        self.maxHoldTime = dict["MaxHoldTime"] as! Int64
                    }
                    if dict.keys.contains("MaxReadyTime") {
                        self.maxReadyTime = dict["MaxReadyTime"] as! Int64
                    }
                    if dict.keys.contains("MaxTalkTime") {
                        self.maxTalkTime = dict["MaxTalkTime"] as! Int64
                    }
                    if dict.keys.contains("MaxWorkTime") {
                        self.maxWorkTime = dict["MaxWorkTime"] as! Int64
                    }
                    if dict.keys.contains("OccupancyRate") {
                        self.occupancyRate = dict["OccupancyRate"] as! Double
                    }
                    if dict.keys.contains("SatisfactionIndex") {
                        self.satisfactionIndex = dict["SatisfactionIndex"] as! Double
                    }
                    if dict.keys.contains("SatisfactionRate") {
                        self.satisfactionRate = dict["SatisfactionRate"] as! Double
                    }
                    if dict.keys.contains("SatisfactionSurveysOffered") {
                        self.satisfactionSurveysOffered = dict["SatisfactionSurveysOffered"] as! Int64
                    }
                    if dict.keys.contains("SatisfactionSurveysResponded") {
                        self.satisfactionSurveysResponded = dict["SatisfactionSurveysResponded"] as! Int64
                    }
                    if dict.keys.contains("TotalBreakTime") {
                        self.totalBreakTime = dict["TotalBreakTime"] as! Int64
                    }
                    if dict.keys.contains("TotalCalls") {
                        self.totalCalls = dict["TotalCalls"] as! Int64
                    }
                    if dict.keys.contains("TotalHoldTime") {
                        self.totalHoldTime = dict["TotalHoldTime"] as! Int64
                    }
                    if dict.keys.contains("TotalLoggedInTime") {
                        self.totalLoggedInTime = dict["TotalLoggedInTime"] as! Int64
                    }
                    if dict.keys.contains("TotalOffSiteLggedInTime") {
                        self.totalOffSiteLggedInTime = dict["TotalOffSiteLggedInTime"] as! Int64
                    }
                    if dict.keys.contains("TotalOfficePhoneLoggedInTime") {
                        self.totalOfficePhoneLoggedInTime = dict["TotalOfficePhoneLoggedInTime"] as! Int64
                    }
                    if dict.keys.contains("TotalOnSiteLoggedInTime") {
                        self.totalOnSiteLoggedInTime = dict["TotalOnSiteLoggedInTime"] as! String
                    }
                    if dict.keys.contains("TotalOutboundScenarioLoggedInTime") {
                        self.totalOutboundScenarioLoggedInTime = dict["TotalOutboundScenarioLoggedInTime"] as! Int64
                    }
                    if dict.keys.contains("TotalOutboundScenarioReadyTime") {
                        self.totalOutboundScenarioReadyTime = dict["TotalOutboundScenarioReadyTime"] as! Int64
                    }
                    if dict.keys.contains("TotalOutboundScenarioTime") {
                        self.totalOutboundScenarioTime = dict["TotalOutboundScenarioTime"] as! Int64
                    }
                    if dict.keys.contains("TotalReadyTime") {
                        self.totalReadyTime = dict["TotalReadyTime"] as! Int64
                    }
                    if dict.keys.contains("TotalTalkTime") {
                        self.totalTalkTime = dict["TotalTalkTime"] as! Int64
                    }
                    if dict.keys.contains("TotalWorkTime") {
                        self.totalWorkTime = dict["TotalWorkTime"] as! Int64
                    }
                }
            }
            public var agentId: String?

            public var agentName: String?

            public var back2Back: ListHistoricalAgentSkillGroupReportResponseBody.Data.List.Back2Back?

            public var displayId: String?

            public var inbound: ListHistoricalAgentSkillGroupReportResponseBody.Data.List.Inbound?

            public var internal_: ListHistoricalAgentSkillGroupReportResponseBody.Data.List.Internal_?

            public var outbound: ListHistoricalAgentSkillGroupReportResponseBody.Data.List.Outbound?

            public var overall: ListHistoricalAgentSkillGroupReportResponseBody.Data.List.Overall?

            public var skillGroupId: String?

            public var skillGroupName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.back2Back?.validate()
                try self.inbound?.validate()
                try self.internal_?.validate()
                try self.outbound?.validate()
                try self.overall?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.agentId != nil {
                    map["AgentId"] = self.agentId!
                }
                if self.agentName != nil {
                    map["AgentName"] = self.agentName!
                }
                if self.back2Back != nil {
                    map["Back2Back"] = self.back2Back?.toMap()
                }
                if self.displayId != nil {
                    map["DisplayId"] = self.displayId!
                }
                if self.inbound != nil {
                    map["Inbound"] = self.inbound?.toMap()
                }
                if self.internal_ != nil {
                    map["Internal"] = self.internal_?.toMap()
                }
                if self.outbound != nil {
                    map["Outbound"] = self.outbound?.toMap()
                }
                if self.overall != nil {
                    map["Overall"] = self.overall?.toMap()
                }
                if self.skillGroupId != nil {
                    map["SkillGroupId"] = self.skillGroupId!
                }
                if self.skillGroupName != nil {
                    map["SkillGroupName"] = self.skillGroupName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AgentId") {
                    self.agentId = dict["AgentId"] as! String
                }
                if dict.keys.contains("AgentName") {
                    self.agentName = dict["AgentName"] as! String
                }
                if dict.keys.contains("Back2Back") {
                    var model = ListHistoricalAgentSkillGroupReportResponseBody.Data.List.Back2Back()
                    model.fromMap(dict["Back2Back"] as! [String: Any])
                    self.back2Back = model
                }
                if dict.keys.contains("DisplayId") {
                    self.displayId = dict["DisplayId"] as! String
                }
                if dict.keys.contains("Inbound") {
                    var model = ListHistoricalAgentSkillGroupReportResponseBody.Data.List.Inbound()
                    model.fromMap(dict["Inbound"] as! [String: Any])
                    self.inbound = model
                }
                if dict.keys.contains("Internal") {
                    var model = ListHistoricalAgentSkillGroupReportResponseBody.Data.List.Internal_()
                    model.fromMap(dict["Internal"] as! [String: Any])
                    self.internal_ = model
                }
                if dict.keys.contains("Outbound") {
                    var model = ListHistoricalAgentSkillGroupReportResponseBody.Data.List.Outbound()
                    model.fromMap(dict["Outbound"] as! [String: Any])
                    self.outbound = model
                }
                if dict.keys.contains("Overall") {
                    var model = ListHistoricalAgentSkillGroupReportResponseBody.Data.List.Overall()
                    model.fromMap(dict["Overall"] as! [String: Any])
                    self.overall = model
                }
                if dict.keys.contains("SkillGroupId") {
                    self.skillGroupId = dict["SkillGroupId"] as! String
                }
                if dict.keys.contains("SkillGroupName") {
                    self.skillGroupName = dict["SkillGroupName"] as! String
                }
            }
        }
        public var list: [ListHistoricalAgentSkillGroupReportResponseBody.Data.List]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.list != nil {
                var tmp : [Any] = []
                for k in self.list! {
                    tmp.append(k.toMap())
                }
                map["List"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("List") {
                var tmp : [ListHistoricalAgentSkillGroupReportResponseBody.Data.List] = []
                for v in dict["List"] as! [Any] {
                    var model = ListHistoricalAgentSkillGroupReportResponseBody.Data.List()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.list = tmp
            }
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var code: String?

    public var data: ListHistoricalAgentSkillGroupReportResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = ListHistoricalAgentSkillGroupReportResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListHistoricalAgentSkillGroupReportResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListHistoricalAgentSkillGroupReportResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListHistoricalAgentSkillGroupReportResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListHistoricalSkillGroupReportRequest : Tea.TeaModel {
    public var endTime: Int64?

    public var instanceId: String?

    public var mediaType: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var skillGroupIdList: String?

    public var startTime: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.mediaType != nil {
            map["MediaType"] = self.mediaType!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.skillGroupIdList != nil {
            map["SkillGroupIdList"] = self.skillGroupIdList!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("MediaType") {
            self.mediaType = dict["MediaType"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SkillGroupIdList") {
            self.skillGroupIdList = dict["SkillGroupIdList"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! Int64
        }
    }
}

public class ListHistoricalSkillGroupReportResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class List : Tea.TeaModel {
            public class Back2Back : Tea.TeaModel {
                public var agentHandleRate: Double?

                public var answerRate: Double?

                public var averageCustomerRingTime: Double?

                public var averageRingTime: Double?

                public var averageTalkTime: Double?

                public var callsAnswered: Int64?

                public var callsCustomerAnswered: Int64?

                public var callsDialed: Int64?

                public var customerAnswerRate: Double?

                public var maxCustomerRingTime: Int64?

                public var maxRingTime: Int64?

                public var maxTalkTime: Int64?

                public var totalCustomerRingTime: Int64?

                public var totalRingTime: Int64?

                public var totalTalkTime: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.agentHandleRate != nil {
                        map["AgentHandleRate"] = self.agentHandleRate!
                    }
                    if self.answerRate != nil {
                        map["AnswerRate"] = self.answerRate!
                    }
                    if self.averageCustomerRingTime != nil {
                        map["AverageCustomerRingTime"] = self.averageCustomerRingTime!
                    }
                    if self.averageRingTime != nil {
                        map["AverageRingTime"] = self.averageRingTime!
                    }
                    if self.averageTalkTime != nil {
                        map["AverageTalkTime"] = self.averageTalkTime!
                    }
                    if self.callsAnswered != nil {
                        map["CallsAnswered"] = self.callsAnswered!
                    }
                    if self.callsCustomerAnswered != nil {
                        map["CallsCustomerAnswered"] = self.callsCustomerAnswered!
                    }
                    if self.callsDialed != nil {
                        map["CallsDialed"] = self.callsDialed!
                    }
                    if self.customerAnswerRate != nil {
                        map["CustomerAnswerRate"] = self.customerAnswerRate!
                    }
                    if self.maxCustomerRingTime != nil {
                        map["MaxCustomerRingTime"] = self.maxCustomerRingTime!
                    }
                    if self.maxRingTime != nil {
                        map["MaxRingTime"] = self.maxRingTime!
                    }
                    if self.maxTalkTime != nil {
                        map["MaxTalkTime"] = self.maxTalkTime!
                    }
                    if self.totalCustomerRingTime != nil {
                        map["TotalCustomerRingTime"] = self.totalCustomerRingTime!
                    }
                    if self.totalRingTime != nil {
                        map["TotalRingTime"] = self.totalRingTime!
                    }
                    if self.totalTalkTime != nil {
                        map["TotalTalkTime"] = self.totalTalkTime!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AgentHandleRate") {
                        self.agentHandleRate = dict["AgentHandleRate"] as! Double
                    }
                    if dict.keys.contains("AnswerRate") {
                        self.answerRate = dict["AnswerRate"] as! Double
                    }
                    if dict.keys.contains("AverageCustomerRingTime") {
                        self.averageCustomerRingTime = dict["AverageCustomerRingTime"] as! Double
                    }
                    if dict.keys.contains("AverageRingTime") {
                        self.averageRingTime = dict["AverageRingTime"] as! Double
                    }
                    if dict.keys.contains("AverageTalkTime") {
                        self.averageTalkTime = dict["AverageTalkTime"] as! Double
                    }
                    if dict.keys.contains("CallsAnswered") {
                        self.callsAnswered = dict["CallsAnswered"] as! Int64
                    }
                    if dict.keys.contains("CallsCustomerAnswered") {
                        self.callsCustomerAnswered = dict["CallsCustomerAnswered"] as! Int64
                    }
                    if dict.keys.contains("CallsDialed") {
                        self.callsDialed = dict["CallsDialed"] as! Int64
                    }
                    if dict.keys.contains("CustomerAnswerRate") {
                        self.customerAnswerRate = dict["CustomerAnswerRate"] as! Double
                    }
                    if dict.keys.contains("MaxCustomerRingTime") {
                        self.maxCustomerRingTime = dict["MaxCustomerRingTime"] as! Int64
                    }
                    if dict.keys.contains("MaxRingTime") {
                        self.maxRingTime = dict["MaxRingTime"] as! Int64
                    }
                    if dict.keys.contains("MaxTalkTime") {
                        self.maxTalkTime = dict["MaxTalkTime"] as! Int64
                    }
                    if dict.keys.contains("TotalCustomerRingTime") {
                        self.totalCustomerRingTime = dict["TotalCustomerRingTime"] as! Int64
                    }
                    if dict.keys.contains("TotalRingTime") {
                        self.totalRingTime = dict["TotalRingTime"] as! Int64
                    }
                    if dict.keys.contains("TotalTalkTime") {
                        self.totalTalkTime = dict["TotalTalkTime"] as! Int64
                    }
                }
            }
            public class Inbound : Tea.TeaModel {
                public class AccessChannelTypeDetails : Tea.TeaModel {
                    public var accessChannelType: String?

                    public var callsOffered: Int64?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.accessChannelType != nil {
                            map["AccessChannelType"] = self.accessChannelType!
                        }
                        if self.callsOffered != nil {
                            map["CallsOffered"] = self.callsOffered!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("AccessChannelType") {
                            self.accessChannelType = dict["AccessChannelType"] as! String
                        }
                        if dict.keys.contains("CallsOffered") {
                            self.callsOffered = dict["CallsOffered"] as! Int64
                        }
                    }
                }
                public var abandonRate: Double?

                public var accessChannelTypeDetails: [ListHistoricalSkillGroupReportResponseBody.Data.List.Inbound.AccessChannelTypeDetails]?

                public var averageAbandonTime: Double?

                public var averageAbandonedInQueueTime: Double?

                public var averageAbandonedInRingTime: Double?

                public var averageFirstResponseTime: Double?

                public var averageHoldTime: Double?

                public var averageResponseTime: Double?

                public var averageRingTime: Double?

                public var averageTalkTime: Double?

                public var averageWaitTime: Double?

                public var averageWorkTime: Double?

                public var callsAbandoned: Int64?

                public var callsAbandonedInQueue: Int64?

                public var callsAbandonedInRing: Int64?

                public var callsAttendedTransferIn: Int64?

                public var callsAttendedTransferOut: Int64?

                public var callsBlindTransferIn: Int64?

                public var callsBlindTransferOut: Int64?

                public var callsHandled: Int64?

                public var callsHold: Int64?

                public var callsOffered: Int64?

                public var callsOverflow: Int64?

                public var callsQueued: Int64?

                public var callsQueuingFailed: Int64?

                public var callsQueuingOverflow: Int64?

                public var callsQueuingTimeout: Int64?

                public var callsRinged: Int64?

                public var callsTimeout: Int64?

                public var handleRate: Double?

                public var maxAbandonTime: Int64?

                public var maxAbandonedInQueueTime: Int64?

                public var maxAbandonedInRingTime: Int64?

                public var maxHoldTime: Int64?

                public var maxRingTime: Int64?

                public var maxTalkTime: Int64?

                public var maxWaitTime: Int64?

                public var maxWorkTime: Int64?

                public var satisfactionIndex: Double?

                public var satisfactionRate: Double?

                public var satisfactionSurveysOffered: Int64?

                public var satisfactionSurveysResponded: Int64?

                public var serviceLevel15: Double?

                public var serviceLevel20: Double?

                public var serviceLevel30: Double?

                public var totalAbandonTime: Int64?

                public var totalAbandonedInQueueTime: Int64?

                public var totalAbandonedInRingTime: Int64?

                public var totalHoldTime: Int64?

                public var totalMessagesSent: Int64?

                public var totalMessagesSentByAgent: Int64?

                public var totalMessagesSentByCustomer: Int64?

                public var totalRingTime: Int64?

                public var totalTalkTime: Int64?

                public var totalWaitTime: Int64?

                public var totalWorkTime: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.abandonRate != nil {
                        map["AbandonRate"] = self.abandonRate!
                    }
                    if self.accessChannelTypeDetails != nil {
                        var tmp : [Any] = []
                        for k in self.accessChannelTypeDetails! {
                            tmp.append(k.toMap())
                        }
                        map["AccessChannelTypeDetails"] = tmp
                    }
                    if self.averageAbandonTime != nil {
                        map["AverageAbandonTime"] = self.averageAbandonTime!
                    }
                    if self.averageAbandonedInQueueTime != nil {
                        map["AverageAbandonedInQueueTime"] = self.averageAbandonedInQueueTime!
                    }
                    if self.averageAbandonedInRingTime != nil {
                        map["AverageAbandonedInRingTime"] = self.averageAbandonedInRingTime!
                    }
                    if self.averageFirstResponseTime != nil {
                        map["AverageFirstResponseTime"] = self.averageFirstResponseTime!
                    }
                    if self.averageHoldTime != nil {
                        map["AverageHoldTime"] = self.averageHoldTime!
                    }
                    if self.averageResponseTime != nil {
                        map["AverageResponseTime"] = self.averageResponseTime!
                    }
                    if self.averageRingTime != nil {
                        map["AverageRingTime"] = self.averageRingTime!
                    }
                    if self.averageTalkTime != nil {
                        map["AverageTalkTime"] = self.averageTalkTime!
                    }
                    if self.averageWaitTime != nil {
                        map["AverageWaitTime"] = self.averageWaitTime!
                    }
                    if self.averageWorkTime != nil {
                        map["AverageWorkTime"] = self.averageWorkTime!
                    }
                    if self.callsAbandoned != nil {
                        map["CallsAbandoned"] = self.callsAbandoned!
                    }
                    if self.callsAbandonedInQueue != nil {
                        map["CallsAbandonedInQueue"] = self.callsAbandonedInQueue!
                    }
                    if self.callsAbandonedInRing != nil {
                        map["CallsAbandonedInRing"] = self.callsAbandonedInRing!
                    }
                    if self.callsAttendedTransferIn != nil {
                        map["CallsAttendedTransferIn"] = self.callsAttendedTransferIn!
                    }
                    if self.callsAttendedTransferOut != nil {
                        map["CallsAttendedTransferOut"] = self.callsAttendedTransferOut!
                    }
                    if self.callsBlindTransferIn != nil {
                        map["CallsBlindTransferIn"] = self.callsBlindTransferIn!
                    }
                    if self.callsBlindTransferOut != nil {
                        map["CallsBlindTransferOut"] = self.callsBlindTransferOut!
                    }
                    if self.callsHandled != nil {
                        map["CallsHandled"] = self.callsHandled!
                    }
                    if self.callsHold != nil {
                        map["CallsHold"] = self.callsHold!
                    }
                    if self.callsOffered != nil {
                        map["CallsOffered"] = self.callsOffered!
                    }
                    if self.callsOverflow != nil {
                        map["CallsOverflow"] = self.callsOverflow!
                    }
                    if self.callsQueued != nil {
                        map["CallsQueued"] = self.callsQueued!
                    }
                    if self.callsQueuingFailed != nil {
                        map["CallsQueuingFailed"] = self.callsQueuingFailed!
                    }
                    if self.callsQueuingOverflow != nil {
                        map["CallsQueuingOverflow"] = self.callsQueuingOverflow!
                    }
                    if self.callsQueuingTimeout != nil {
                        map["CallsQueuingTimeout"] = self.callsQueuingTimeout!
                    }
                    if self.callsRinged != nil {
                        map["CallsRinged"] = self.callsRinged!
                    }
                    if self.callsTimeout != nil {
                        map["CallsTimeout"] = self.callsTimeout!
                    }
                    if self.handleRate != nil {
                        map["HandleRate"] = self.handleRate!
                    }
                    if self.maxAbandonTime != nil {
                        map["MaxAbandonTime"] = self.maxAbandonTime!
                    }
                    if self.maxAbandonedInQueueTime != nil {
                        map["MaxAbandonedInQueueTime"] = self.maxAbandonedInQueueTime!
                    }
                    if self.maxAbandonedInRingTime != nil {
                        map["MaxAbandonedInRingTime"] = self.maxAbandonedInRingTime!
                    }
                    if self.maxHoldTime != nil {
                        map["MaxHoldTime"] = self.maxHoldTime!
                    }
                    if self.maxRingTime != nil {
                        map["MaxRingTime"] = self.maxRingTime!
                    }
                    if self.maxTalkTime != nil {
                        map["MaxTalkTime"] = self.maxTalkTime!
                    }
                    if self.maxWaitTime != nil {
                        map["MaxWaitTime"] = self.maxWaitTime!
                    }
                    if self.maxWorkTime != nil {
                        map["MaxWorkTime"] = self.maxWorkTime!
                    }
                    if self.satisfactionIndex != nil {
                        map["SatisfactionIndex"] = self.satisfactionIndex!
                    }
                    if self.satisfactionRate != nil {
                        map["SatisfactionRate"] = self.satisfactionRate!
                    }
                    if self.satisfactionSurveysOffered != nil {
                        map["SatisfactionSurveysOffered"] = self.satisfactionSurveysOffered!
                    }
                    if self.satisfactionSurveysResponded != nil {
                        map["SatisfactionSurveysResponded"] = self.satisfactionSurveysResponded!
                    }
                    if self.serviceLevel15 != nil {
                        map["ServiceLevel15"] = self.serviceLevel15!
                    }
                    if self.serviceLevel20 != nil {
                        map["ServiceLevel20"] = self.serviceLevel20!
                    }
                    if self.serviceLevel30 != nil {
                        map["ServiceLevel30"] = self.serviceLevel30!
                    }
                    if self.totalAbandonTime != nil {
                        map["TotalAbandonTime"] = self.totalAbandonTime!
                    }
                    if self.totalAbandonedInQueueTime != nil {
                        map["TotalAbandonedInQueueTime"] = self.totalAbandonedInQueueTime!
                    }
                    if self.totalAbandonedInRingTime != nil {
                        map["TotalAbandonedInRingTime"] = self.totalAbandonedInRingTime!
                    }
                    if self.totalHoldTime != nil {
                        map["TotalHoldTime"] = self.totalHoldTime!
                    }
                    if self.totalMessagesSent != nil {
                        map["TotalMessagesSent"] = self.totalMessagesSent!
                    }
                    if self.totalMessagesSentByAgent != nil {
                        map["TotalMessagesSentByAgent"] = self.totalMessagesSentByAgent!
                    }
                    if self.totalMessagesSentByCustomer != nil {
                        map["TotalMessagesSentByCustomer"] = self.totalMessagesSentByCustomer!
                    }
                    if self.totalRingTime != nil {
                        map["TotalRingTime"] = self.totalRingTime!
                    }
                    if self.totalTalkTime != nil {
                        map["TotalTalkTime"] = self.totalTalkTime!
                    }
                    if self.totalWaitTime != nil {
                        map["TotalWaitTime"] = self.totalWaitTime!
                    }
                    if self.totalWorkTime != nil {
                        map["TotalWorkTime"] = self.totalWorkTime!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AbandonRate") {
                        self.abandonRate = dict["AbandonRate"] as! Double
                    }
                    if dict.keys.contains("AccessChannelTypeDetails") {
                        var tmp : [ListHistoricalSkillGroupReportResponseBody.Data.List.Inbound.AccessChannelTypeDetails] = []
                        for v in dict["AccessChannelTypeDetails"] as! [Any] {
                            var model = ListHistoricalSkillGroupReportResponseBody.Data.List.Inbound.AccessChannelTypeDetails()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.accessChannelTypeDetails = tmp
                    }
                    if dict.keys.contains("AverageAbandonTime") {
                        self.averageAbandonTime = dict["AverageAbandonTime"] as! Double
                    }
                    if dict.keys.contains("AverageAbandonedInQueueTime") {
                        self.averageAbandonedInQueueTime = dict["AverageAbandonedInQueueTime"] as! Double
                    }
                    if dict.keys.contains("AverageAbandonedInRingTime") {
                        self.averageAbandonedInRingTime = dict["AverageAbandonedInRingTime"] as! Double
                    }
                    if dict.keys.contains("AverageFirstResponseTime") {
                        self.averageFirstResponseTime = dict["AverageFirstResponseTime"] as! Double
                    }
                    if dict.keys.contains("AverageHoldTime") {
                        self.averageHoldTime = dict["AverageHoldTime"] as! Double
                    }
                    if dict.keys.contains("AverageResponseTime") {
                        self.averageResponseTime = dict["AverageResponseTime"] as! Double
                    }
                    if dict.keys.contains("AverageRingTime") {
                        self.averageRingTime = dict["AverageRingTime"] as! Double
                    }
                    if dict.keys.contains("AverageTalkTime") {
                        self.averageTalkTime = dict["AverageTalkTime"] as! Double
                    }
                    if dict.keys.contains("AverageWaitTime") {
                        self.averageWaitTime = dict["AverageWaitTime"] as! Double
                    }
                    if dict.keys.contains("AverageWorkTime") {
                        self.averageWorkTime = dict["AverageWorkTime"] as! Double
                    }
                    if dict.keys.contains("CallsAbandoned") {
                        self.callsAbandoned = dict["CallsAbandoned"] as! Int64
                    }
                    if dict.keys.contains("CallsAbandonedInQueue") {
                        self.callsAbandonedInQueue = dict["CallsAbandonedInQueue"] as! Int64
                    }
                    if dict.keys.contains("CallsAbandonedInRing") {
                        self.callsAbandonedInRing = dict["CallsAbandonedInRing"] as! Int64
                    }
                    if dict.keys.contains("CallsAttendedTransferIn") {
                        self.callsAttendedTransferIn = dict["CallsAttendedTransferIn"] as! Int64
                    }
                    if dict.keys.contains("CallsAttendedTransferOut") {
                        self.callsAttendedTransferOut = dict["CallsAttendedTransferOut"] as! Int64
                    }
                    if dict.keys.contains("CallsBlindTransferIn") {
                        self.callsBlindTransferIn = dict["CallsBlindTransferIn"] as! Int64
                    }
                    if dict.keys.contains("CallsBlindTransferOut") {
                        self.callsBlindTransferOut = dict["CallsBlindTransferOut"] as! Int64
                    }
                    if dict.keys.contains("CallsHandled") {
                        self.callsHandled = dict["CallsHandled"] as! Int64
                    }
                    if dict.keys.contains("CallsHold") {
                        self.callsHold = dict["CallsHold"] as! Int64
                    }
                    if dict.keys.contains("CallsOffered") {
                        self.callsOffered = dict["CallsOffered"] as! Int64
                    }
                    if dict.keys.contains("CallsOverflow") {
                        self.callsOverflow = dict["CallsOverflow"] as! Int64
                    }
                    if dict.keys.contains("CallsQueued") {
                        self.callsQueued = dict["CallsQueued"] as! Int64
                    }
                    if dict.keys.contains("CallsQueuingFailed") {
                        self.callsQueuingFailed = dict["CallsQueuingFailed"] as! Int64
                    }
                    if dict.keys.contains("CallsQueuingOverflow") {
                        self.callsQueuingOverflow = dict["CallsQueuingOverflow"] as! Int64
                    }
                    if dict.keys.contains("CallsQueuingTimeout") {
                        self.callsQueuingTimeout = dict["CallsQueuingTimeout"] as! Int64
                    }
                    if dict.keys.contains("CallsRinged") {
                        self.callsRinged = dict["CallsRinged"] as! Int64
                    }
                    if dict.keys.contains("CallsTimeout") {
                        self.callsTimeout = dict["CallsTimeout"] as! Int64
                    }
                    if dict.keys.contains("HandleRate") {
                        self.handleRate = dict["HandleRate"] as! Double
                    }
                    if dict.keys.contains("MaxAbandonTime") {
                        self.maxAbandonTime = dict["MaxAbandonTime"] as! Int64
                    }
                    if dict.keys.contains("MaxAbandonedInQueueTime") {
                        self.maxAbandonedInQueueTime = dict["MaxAbandonedInQueueTime"] as! Int64
                    }
                    if dict.keys.contains("MaxAbandonedInRingTime") {
                        self.maxAbandonedInRingTime = dict["MaxAbandonedInRingTime"] as! Int64
                    }
                    if dict.keys.contains("MaxHoldTime") {
                        self.maxHoldTime = dict["MaxHoldTime"] as! Int64
                    }
                    if dict.keys.contains("MaxRingTime") {
                        self.maxRingTime = dict["MaxRingTime"] as! Int64
                    }
                    if dict.keys.contains("MaxTalkTime") {
                        self.maxTalkTime = dict["MaxTalkTime"] as! Int64
                    }
                    if dict.keys.contains("MaxWaitTime") {
                        self.maxWaitTime = dict["MaxWaitTime"] as! Int64
                    }
                    if dict.keys.contains("MaxWorkTime") {
                        self.maxWorkTime = dict["MaxWorkTime"] as! Int64
                    }
                    if dict.keys.contains("SatisfactionIndex") {
                        self.satisfactionIndex = dict["SatisfactionIndex"] as! Double
                    }
                    if dict.keys.contains("SatisfactionRate") {
                        self.satisfactionRate = dict["SatisfactionRate"] as! Double
                    }
                    if dict.keys.contains("SatisfactionSurveysOffered") {
                        self.satisfactionSurveysOffered = dict["SatisfactionSurveysOffered"] as! Int64
                    }
                    if dict.keys.contains("SatisfactionSurveysResponded") {
                        self.satisfactionSurveysResponded = dict["SatisfactionSurveysResponded"] as! Int64
                    }
                    if dict.keys.contains("ServiceLevel15") {
                        self.serviceLevel15 = dict["ServiceLevel15"] as! Double
                    }
                    if dict.keys.contains("ServiceLevel20") {
                        self.serviceLevel20 = dict["ServiceLevel20"] as! Double
                    }
                    if dict.keys.contains("ServiceLevel30") {
                        self.serviceLevel30 = dict["ServiceLevel30"] as! Double
                    }
                    if dict.keys.contains("TotalAbandonTime") {
                        self.totalAbandonTime = dict["TotalAbandonTime"] as! Int64
                    }
                    if dict.keys.contains("TotalAbandonedInQueueTime") {
                        self.totalAbandonedInQueueTime = dict["TotalAbandonedInQueueTime"] as! Int64
                    }
                    if dict.keys.contains("TotalAbandonedInRingTime") {
                        self.totalAbandonedInRingTime = dict["TotalAbandonedInRingTime"] as! Int64
                    }
                    if dict.keys.contains("TotalHoldTime") {
                        self.totalHoldTime = dict["TotalHoldTime"] as! Int64
                    }
                    if dict.keys.contains("TotalMessagesSent") {
                        self.totalMessagesSent = dict["TotalMessagesSent"] as! Int64
                    }
                    if dict.keys.contains("TotalMessagesSentByAgent") {
                        self.totalMessagesSentByAgent = dict["TotalMessagesSentByAgent"] as! Int64
                    }
                    if dict.keys.contains("TotalMessagesSentByCustomer") {
                        self.totalMessagesSentByCustomer = dict["TotalMessagesSentByCustomer"] as! Int64
                    }
                    if dict.keys.contains("TotalRingTime") {
                        self.totalRingTime = dict["TotalRingTime"] as! Int64
                    }
                    if dict.keys.contains("TotalTalkTime") {
                        self.totalTalkTime = dict["TotalTalkTime"] as! Int64
                    }
                    if dict.keys.contains("TotalWaitTime") {
                        self.totalWaitTime = dict["TotalWaitTime"] as! Int64
                    }
                    if dict.keys.contains("TotalWorkTime") {
                        self.totalWorkTime = dict["TotalWorkTime"] as! Int64
                    }
                }
            }
            public class Outbound : Tea.TeaModel {
                public var answerRate: Double?

                public var averageDialingTime: Double?

                public var averageHoldTime: Double?

                public var averageRingTime: Double?

                public var averageTalkTime: Double?

                public var averageWorkTime: Double?

                public var callsAnswered: Int64?

                public var callsAttendedTransferIn: Int64?

                public var callsAttendedTransferOut: Int64?

                public var callsBlindTransferIn: Int64?

                public var callsBlindTransferOut: Int64?

                public var callsDialed: Int64?

                public var callsHold: Int64?

                public var callsRinged: Int64?

                public var maxDialingTime: Int64?

                public var maxHoldTime: Int64?

                public var maxRingTime: Int64?

                public var maxTalkTime: Int64?

                public var maxWorkTime: Int64?

                public var satisfactionIndex: Double?

                public var satisfactionRate: Double?

                public var satisfactionSurveysOffered: Int64?

                public var satisfactionSurveysResponded: Int64?

                public var totalDialingTime: Int64?

                public var totalHoldTime: Int64?

                public var totalRingTime: Int64?

                public var totalTalkTime: Int64?

                public var totalWorkTime: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.answerRate != nil {
                        map["AnswerRate"] = self.answerRate!
                    }
                    if self.averageDialingTime != nil {
                        map["AverageDialingTime"] = self.averageDialingTime!
                    }
                    if self.averageHoldTime != nil {
                        map["AverageHoldTime"] = self.averageHoldTime!
                    }
                    if self.averageRingTime != nil {
                        map["AverageRingTime"] = self.averageRingTime!
                    }
                    if self.averageTalkTime != nil {
                        map["AverageTalkTime"] = self.averageTalkTime!
                    }
                    if self.averageWorkTime != nil {
                        map["AverageWorkTime"] = self.averageWorkTime!
                    }
                    if self.callsAnswered != nil {
                        map["CallsAnswered"] = self.callsAnswered!
                    }
                    if self.callsAttendedTransferIn != nil {
                        map["CallsAttendedTransferIn"] = self.callsAttendedTransferIn!
                    }
                    if self.callsAttendedTransferOut != nil {
                        map["CallsAttendedTransferOut"] = self.callsAttendedTransferOut!
                    }
                    if self.callsBlindTransferIn != nil {
                        map["CallsBlindTransferIn"] = self.callsBlindTransferIn!
                    }
                    if self.callsBlindTransferOut != nil {
                        map["CallsBlindTransferOut"] = self.callsBlindTransferOut!
                    }
                    if self.callsDialed != nil {
                        map["CallsDialed"] = self.callsDialed!
                    }
                    if self.callsHold != nil {
                        map["CallsHold"] = self.callsHold!
                    }
                    if self.callsRinged != nil {
                        map["CallsRinged"] = self.callsRinged!
                    }
                    if self.maxDialingTime != nil {
                        map["MaxDialingTime"] = self.maxDialingTime!
                    }
                    if self.maxHoldTime != nil {
                        map["MaxHoldTime"] = self.maxHoldTime!
                    }
                    if self.maxRingTime != nil {
                        map["MaxRingTime"] = self.maxRingTime!
                    }
                    if self.maxTalkTime != nil {
                        map["MaxTalkTime"] = self.maxTalkTime!
                    }
                    if self.maxWorkTime != nil {
                        map["MaxWorkTime"] = self.maxWorkTime!
                    }
                    if self.satisfactionIndex != nil {
                        map["SatisfactionIndex"] = self.satisfactionIndex!
                    }
                    if self.satisfactionRate != nil {
                        map["SatisfactionRate"] = self.satisfactionRate!
                    }
                    if self.satisfactionSurveysOffered != nil {
                        map["SatisfactionSurveysOffered"] = self.satisfactionSurveysOffered!
                    }
                    if self.satisfactionSurveysResponded != nil {
                        map["SatisfactionSurveysResponded"] = self.satisfactionSurveysResponded!
                    }
                    if self.totalDialingTime != nil {
                        map["TotalDialingTime"] = self.totalDialingTime!
                    }
                    if self.totalHoldTime != nil {
                        map["TotalHoldTime"] = self.totalHoldTime!
                    }
                    if self.totalRingTime != nil {
                        map["TotalRingTime"] = self.totalRingTime!
                    }
                    if self.totalTalkTime != nil {
                        map["TotalTalkTime"] = self.totalTalkTime!
                    }
                    if self.totalWorkTime != nil {
                        map["TotalWorkTime"] = self.totalWorkTime!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AnswerRate") {
                        self.answerRate = dict["AnswerRate"] as! Double
                    }
                    if dict.keys.contains("AverageDialingTime") {
                        self.averageDialingTime = dict["AverageDialingTime"] as! Double
                    }
                    if dict.keys.contains("AverageHoldTime") {
                        self.averageHoldTime = dict["AverageHoldTime"] as! Double
                    }
                    if dict.keys.contains("AverageRingTime") {
                        self.averageRingTime = dict["AverageRingTime"] as! Double
                    }
                    if dict.keys.contains("AverageTalkTime") {
                        self.averageTalkTime = dict["AverageTalkTime"] as! Double
                    }
                    if dict.keys.contains("AverageWorkTime") {
                        self.averageWorkTime = dict["AverageWorkTime"] as! Double
                    }
                    if dict.keys.contains("CallsAnswered") {
                        self.callsAnswered = dict["CallsAnswered"] as! Int64
                    }
                    if dict.keys.contains("CallsAttendedTransferIn") {
                        self.callsAttendedTransferIn = dict["CallsAttendedTransferIn"] as! Int64
                    }
                    if dict.keys.contains("CallsAttendedTransferOut") {
                        self.callsAttendedTransferOut = dict["CallsAttendedTransferOut"] as! Int64
                    }
                    if dict.keys.contains("CallsBlindTransferIn") {
                        self.callsBlindTransferIn = dict["CallsBlindTransferIn"] as! Int64
                    }
                    if dict.keys.contains("CallsBlindTransferOut") {
                        self.callsBlindTransferOut = dict["CallsBlindTransferOut"] as! Int64
                    }
                    if dict.keys.contains("CallsDialed") {
                        self.callsDialed = dict["CallsDialed"] as! Int64
                    }
                    if dict.keys.contains("CallsHold") {
                        self.callsHold = dict["CallsHold"] as! Int64
                    }
                    if dict.keys.contains("CallsRinged") {
                        self.callsRinged = dict["CallsRinged"] as! Int64
                    }
                    if dict.keys.contains("MaxDialingTime") {
                        self.maxDialingTime = dict["MaxDialingTime"] as! Int64
                    }
                    if dict.keys.contains("MaxHoldTime") {
                        self.maxHoldTime = dict["MaxHoldTime"] as! Int64
                    }
                    if dict.keys.contains("MaxRingTime") {
                        self.maxRingTime = dict["MaxRingTime"] as! Int64
                    }
                    if dict.keys.contains("MaxTalkTime") {
                        self.maxTalkTime = dict["MaxTalkTime"] as! Int64
                    }
                    if dict.keys.contains("MaxWorkTime") {
                        self.maxWorkTime = dict["MaxWorkTime"] as! Int64
                    }
                    if dict.keys.contains("SatisfactionIndex") {
                        self.satisfactionIndex = dict["SatisfactionIndex"] as! Double
                    }
                    if dict.keys.contains("SatisfactionRate") {
                        self.satisfactionRate = dict["SatisfactionRate"] as! Double
                    }
                    if dict.keys.contains("SatisfactionSurveysOffered") {
                        self.satisfactionSurveysOffered = dict["SatisfactionSurveysOffered"] as! Int64
                    }
                    if dict.keys.contains("SatisfactionSurveysResponded") {
                        self.satisfactionSurveysResponded = dict["SatisfactionSurveysResponded"] as! Int64
                    }
                    if dict.keys.contains("TotalDialingTime") {
                        self.totalDialingTime = dict["TotalDialingTime"] as! Int64
                    }
                    if dict.keys.contains("TotalHoldTime") {
                        self.totalHoldTime = dict["TotalHoldTime"] as! Int64
                    }
                    if dict.keys.contains("TotalRingTime") {
                        self.totalRingTime = dict["TotalRingTime"] as! Int64
                    }
                    if dict.keys.contains("TotalTalkTime") {
                        self.totalTalkTime = dict["TotalTalkTime"] as! Int64
                    }
                    if dict.keys.contains("TotalWorkTime") {
                        self.totalWorkTime = dict["TotalWorkTime"] as! Int64
                    }
                }
            }
            public class Overall : Tea.TeaModel {
                public class BreakCodeDetailList : Tea.TeaModel {
                    public var breakCode: String?

                    public var count: Int64?

                    public var duration: Int64?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.breakCode != nil {
                            map["BreakCode"] = self.breakCode!
                        }
                        if self.count != nil {
                            map["Count"] = self.count!
                        }
                        if self.duration != nil {
                            map["Duration"] = self.duration!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("BreakCode") {
                            self.breakCode = dict["BreakCode"] as! String
                        }
                        if dict.keys.contains("Count") {
                            self.count = dict["Count"] as! Int64
                        }
                        if dict.keys.contains("Duration") {
                            self.duration = dict["Duration"] as! Int64
                        }
                    }
                }
                public var averageBreakTime: Double?

                public var averageHoldTime: Double?

                public var averageReadyTime: Double?

                public var averageTalkTime: Double?

                public var averageWorkTime: Double?

                public var breakCodeDetailList: [ListHistoricalSkillGroupReportResponseBody.Data.List.Overall.BreakCodeDetailList]?

                public var maxBreakTime: Int64?

                public var maxHoldTime: Int64?

                public var maxReadyTime: Int64?

                public var maxTalkTime: Int64?

                public var maxWorkTime: Int64?

                public var occupancyRate: Double?

                public var satisfactionIndex: Double?

                public var satisfactionRate: Double?

                public var satisfactionSurveysOffered: Int64?

                public var satisfactionSurveysResponded: Int64?

                public var totalBreakTime: Int64?

                public var totalCalls: Int64?

                public var totalHoldTime: Int64?

                public var totalLoggedInTime: Int64?

                public var totalReadyTime: Int64?

                public var totalTalkTime: Int64?

                public var totalWorkTime: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.averageBreakTime != nil {
                        map["AverageBreakTime"] = self.averageBreakTime!
                    }
                    if self.averageHoldTime != nil {
                        map["AverageHoldTime"] = self.averageHoldTime!
                    }
                    if self.averageReadyTime != nil {
                        map["AverageReadyTime"] = self.averageReadyTime!
                    }
                    if self.averageTalkTime != nil {
                        map["AverageTalkTime"] = self.averageTalkTime!
                    }
                    if self.averageWorkTime != nil {
                        map["AverageWorkTime"] = self.averageWorkTime!
                    }
                    if self.breakCodeDetailList != nil {
                        var tmp : [Any] = []
                        for k in self.breakCodeDetailList! {
                            tmp.append(k.toMap())
                        }
                        map["BreakCodeDetailList"] = tmp
                    }
                    if self.maxBreakTime != nil {
                        map["MaxBreakTime"] = self.maxBreakTime!
                    }
                    if self.maxHoldTime != nil {
                        map["MaxHoldTime"] = self.maxHoldTime!
                    }
                    if self.maxReadyTime != nil {
                        map["MaxReadyTime"] = self.maxReadyTime!
                    }
                    if self.maxTalkTime != nil {
                        map["MaxTalkTime"] = self.maxTalkTime!
                    }
                    if self.maxWorkTime != nil {
                        map["MaxWorkTime"] = self.maxWorkTime!
                    }
                    if self.occupancyRate != nil {
                        map["OccupancyRate"] = self.occupancyRate!
                    }
                    if self.satisfactionIndex != nil {
                        map["SatisfactionIndex"] = self.satisfactionIndex!
                    }
                    if self.satisfactionRate != nil {
                        map["SatisfactionRate"] = self.satisfactionRate!
                    }
                    if self.satisfactionSurveysOffered != nil {
                        map["SatisfactionSurveysOffered"] = self.satisfactionSurveysOffered!
                    }
                    if self.satisfactionSurveysResponded != nil {
                        map["SatisfactionSurveysResponded"] = self.satisfactionSurveysResponded!
                    }
                    if self.totalBreakTime != nil {
                        map["TotalBreakTime"] = self.totalBreakTime!
                    }
                    if self.totalCalls != nil {
                        map["TotalCalls"] = self.totalCalls!
                    }
                    if self.totalHoldTime != nil {
                        map["TotalHoldTime"] = self.totalHoldTime!
                    }
                    if self.totalLoggedInTime != nil {
                        map["TotalLoggedInTime"] = self.totalLoggedInTime!
                    }
                    if self.totalReadyTime != nil {
                        map["TotalReadyTime"] = self.totalReadyTime!
                    }
                    if self.totalTalkTime != nil {
                        map["TotalTalkTime"] = self.totalTalkTime!
                    }
                    if self.totalWorkTime != nil {
                        map["TotalWorkTime"] = self.totalWorkTime!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AverageBreakTime") {
                        self.averageBreakTime = dict["AverageBreakTime"] as! Double
                    }
                    if dict.keys.contains("AverageHoldTime") {
                        self.averageHoldTime = dict["AverageHoldTime"] as! Double
                    }
                    if dict.keys.contains("AverageReadyTime") {
                        self.averageReadyTime = dict["AverageReadyTime"] as! Double
                    }
                    if dict.keys.contains("AverageTalkTime") {
                        self.averageTalkTime = dict["AverageTalkTime"] as! Double
                    }
                    if dict.keys.contains("AverageWorkTime") {
                        self.averageWorkTime = dict["AverageWorkTime"] as! Double
                    }
                    if dict.keys.contains("BreakCodeDetailList") {
                        var tmp : [ListHistoricalSkillGroupReportResponseBody.Data.List.Overall.BreakCodeDetailList] = []
                        for v in dict["BreakCodeDetailList"] as! [Any] {
                            var model = ListHistoricalSkillGroupReportResponseBody.Data.List.Overall.BreakCodeDetailList()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.breakCodeDetailList = tmp
                    }
                    if dict.keys.contains("MaxBreakTime") {
                        self.maxBreakTime = dict["MaxBreakTime"] as! Int64
                    }
                    if dict.keys.contains("MaxHoldTime") {
                        self.maxHoldTime = dict["MaxHoldTime"] as! Int64
                    }
                    if dict.keys.contains("MaxReadyTime") {
                        self.maxReadyTime = dict["MaxReadyTime"] as! Int64
                    }
                    if dict.keys.contains("MaxTalkTime") {
                        self.maxTalkTime = dict["MaxTalkTime"] as! Int64
                    }
                    if dict.keys.contains("MaxWorkTime") {
                        self.maxWorkTime = dict["MaxWorkTime"] as! Int64
                    }
                    if dict.keys.contains("OccupancyRate") {
                        self.occupancyRate = dict["OccupancyRate"] as! Double
                    }
                    if dict.keys.contains("SatisfactionIndex") {
                        self.satisfactionIndex = dict["SatisfactionIndex"] as! Double
                    }
                    if dict.keys.contains("SatisfactionRate") {
                        self.satisfactionRate = dict["SatisfactionRate"] as! Double
                    }
                    if dict.keys.contains("SatisfactionSurveysOffered") {
                        self.satisfactionSurveysOffered = dict["SatisfactionSurveysOffered"] as! Int64
                    }
                    if dict.keys.contains("SatisfactionSurveysResponded") {
                        self.satisfactionSurveysResponded = dict["SatisfactionSurveysResponded"] as! Int64
                    }
                    if dict.keys.contains("TotalBreakTime") {
                        self.totalBreakTime = dict["TotalBreakTime"] as! Int64
                    }
                    if dict.keys.contains("TotalCalls") {
                        self.totalCalls = dict["TotalCalls"] as! Int64
                    }
                    if dict.keys.contains("TotalHoldTime") {
                        self.totalHoldTime = dict["TotalHoldTime"] as! Int64
                    }
                    if dict.keys.contains("TotalLoggedInTime") {
                        self.totalLoggedInTime = dict["TotalLoggedInTime"] as! Int64
                    }
                    if dict.keys.contains("TotalReadyTime") {
                        self.totalReadyTime = dict["TotalReadyTime"] as! Int64
                    }
                    if dict.keys.contains("TotalTalkTime") {
                        self.totalTalkTime = dict["TotalTalkTime"] as! Int64
                    }
                    if dict.keys.contains("TotalWorkTime") {
                        self.totalWorkTime = dict["TotalWorkTime"] as! Int64
                    }
                }
            }
            public var back2Back: ListHistoricalSkillGroupReportResponseBody.Data.List.Back2Back?

            public var inbound: ListHistoricalSkillGroupReportResponseBody.Data.List.Inbound?

            public var outbound: ListHistoricalSkillGroupReportResponseBody.Data.List.Outbound?

            public var overall: ListHistoricalSkillGroupReportResponseBody.Data.List.Overall?

            public var skillGroupId: String?

            public var skillGroupName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.back2Back?.validate()
                try self.inbound?.validate()
                try self.outbound?.validate()
                try self.overall?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.back2Back != nil {
                    map["Back2Back"] = self.back2Back?.toMap()
                }
                if self.inbound != nil {
                    map["Inbound"] = self.inbound?.toMap()
                }
                if self.outbound != nil {
                    map["Outbound"] = self.outbound?.toMap()
                }
                if self.overall != nil {
                    map["Overall"] = self.overall?.toMap()
                }
                if self.skillGroupId != nil {
                    map["SkillGroupId"] = self.skillGroupId!
                }
                if self.skillGroupName != nil {
                    map["SkillGroupName"] = self.skillGroupName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Back2Back") {
                    var model = ListHistoricalSkillGroupReportResponseBody.Data.List.Back2Back()
                    model.fromMap(dict["Back2Back"] as! [String: Any])
                    self.back2Back = model
                }
                if dict.keys.contains("Inbound") {
                    var model = ListHistoricalSkillGroupReportResponseBody.Data.List.Inbound()
                    model.fromMap(dict["Inbound"] as! [String: Any])
                    self.inbound = model
                }
                if dict.keys.contains("Outbound") {
                    var model = ListHistoricalSkillGroupReportResponseBody.Data.List.Outbound()
                    model.fromMap(dict["Outbound"] as! [String: Any])
                    self.outbound = model
                }
                if dict.keys.contains("Overall") {
                    var model = ListHistoricalSkillGroupReportResponseBody.Data.List.Overall()
                    model.fromMap(dict["Overall"] as! [String: Any])
                    self.overall = model
                }
                if dict.keys.contains("SkillGroupId") {
                    self.skillGroupId = dict["SkillGroupId"] as! String
                }
                if dict.keys.contains("SkillGroupName") {
                    self.skillGroupName = dict["SkillGroupName"] as! String
                }
            }
        }
        public var list: [ListHistoricalSkillGroupReportResponseBody.Data.List]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.list != nil {
                var tmp : [Any] = []
                for k in self.list! {
                    tmp.append(k.toMap())
                }
                map["List"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("List") {
                var tmp : [ListHistoricalSkillGroupReportResponseBody.Data.List] = []
                for v in dict["List"] as! [Any] {
                    var model = ListHistoricalSkillGroupReportResponseBody.Data.List()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.list = tmp
            }
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var code: String?

    public var data: ListHistoricalSkillGroupReportResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = ListHistoricalSkillGroupReportResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListHistoricalSkillGroupReportResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListHistoricalSkillGroupReportResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListHistoricalSkillGroupReportResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListInstancesRequest : Tea.TeaModel {
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
    }
}

public class ListInstancesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class List : Tea.TeaModel {
            public class AdminList : Tea.TeaModel {
                public var displayName: String?

                public var email: String?

                public var extension_: String?

                public var instanceId: String?

                public var loginName: String?

                public var mobile: String?

                public var roleId: String?

                public var roleName: String?

                public var userId: String?

                public var workMode: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.displayName != nil {
                        map["DisplayName"] = self.displayName!
                    }
                    if self.email != nil {
                        map["Email"] = self.email!
                    }
                    if self.extension_ != nil {
                        map["Extension"] = self.extension_!
                    }
                    if self.instanceId != nil {
                        map["InstanceId"] = self.instanceId!
                    }
                    if self.loginName != nil {
                        map["LoginName"] = self.loginName!
                    }
                    if self.mobile != nil {
                        map["Mobile"] = self.mobile!
                    }
                    if self.roleId != nil {
                        map["RoleId"] = self.roleId!
                    }
                    if self.roleName != nil {
                        map["RoleName"] = self.roleName!
                    }
                    if self.userId != nil {
                        map["UserId"] = self.userId!
                    }
                    if self.workMode != nil {
                        map["WorkMode"] = self.workMode!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("DisplayName") {
                        self.displayName = dict["DisplayName"] as! String
                    }
                    if dict.keys.contains("Email") {
                        self.email = dict["Email"] as! String
                    }
                    if dict.keys.contains("Extension") {
                        self.extension_ = dict["Extension"] as! String
                    }
                    if dict.keys.contains("InstanceId") {
                        self.instanceId = dict["InstanceId"] as! String
                    }
                    if dict.keys.contains("LoginName") {
                        self.loginName = dict["LoginName"] as! String
                    }
                    if dict.keys.contains("Mobile") {
                        self.mobile = dict["Mobile"] as! String
                    }
                    if dict.keys.contains("RoleId") {
                        self.roleId = dict["RoleId"] as! String
                    }
                    if dict.keys.contains("RoleName") {
                        self.roleName = dict["RoleName"] as! String
                    }
                    if dict.keys.contains("UserId") {
                        self.userId = dict["UserId"] as! String
                    }
                    if dict.keys.contains("WorkMode") {
                        self.workMode = dict["WorkMode"] as! String
                    }
                }
            }
            public class NumberList : Tea.TeaModel {
                public var number: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.number != nil {
                        map["Number"] = self.number!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Number") {
                        self.number = dict["Number"] as! String
                    }
                }
            }
            public var adminList: [ListInstancesResponseBody.Data.List.AdminList]?

            public var aliyunUid: String?

            public var consoleUrl: String?

            public var createTime: Int64?

            public var description_: String?

            public var domainName: String?

            public var id: String?

            public var name: String?

            public var numberList: [ListInstancesResponseBody.Data.List.NumberList]?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.adminList != nil {
                    var tmp : [Any] = []
                    for k in self.adminList! {
                        tmp.append(k.toMap())
                    }
                    map["AdminList"] = tmp
                }
                if self.aliyunUid != nil {
                    map["AliyunUid"] = self.aliyunUid!
                }
                if self.consoleUrl != nil {
                    map["ConsoleUrl"] = self.consoleUrl!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.domainName != nil {
                    map["DomainName"] = self.domainName!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.numberList != nil {
                    var tmp : [Any] = []
                    for k in self.numberList! {
                        tmp.append(k.toMap())
                    }
                    map["NumberList"] = tmp
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AdminList") {
                    var tmp : [ListInstancesResponseBody.Data.List.AdminList] = []
                    for v in dict["AdminList"] as! [Any] {
                        var model = ListInstancesResponseBody.Data.List.AdminList()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.adminList = tmp
                }
                if dict.keys.contains("AliyunUid") {
                    self.aliyunUid = dict["AliyunUid"] as! String
                }
                if dict.keys.contains("ConsoleUrl") {
                    self.consoleUrl = dict["ConsoleUrl"] as! String
                }
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! Int64
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("DomainName") {
                    self.domainName = dict["DomainName"] as! String
                }
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! String
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("NumberList") {
                    var tmp : [ListInstancesResponseBody.Data.List.NumberList] = []
                    for v in dict["NumberList"] as! [Any] {
                        var model = ListInstancesResponseBody.Data.List.NumberList()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.numberList = tmp
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
            }
        }
        public var list: [ListInstancesResponseBody.Data.List]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.list != nil {
                var tmp : [Any] = []
                for k in self.list! {
                    tmp.append(k.toMap())
                }
                map["List"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("List") {
                var tmp : [ListInstancesResponseBody.Data.List] = []
                for v in dict["List"] as! [Any] {
                    var model = ListInstancesResponseBody.Data.List()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.list = tmp
            }
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var code: String?

    public var data: ListInstancesResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = ListInstancesResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListInstancesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListInstancesOfUserRequest : Tea.TeaModel {
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
    }
}

public class ListInstancesOfUserResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class List : Tea.TeaModel {
            public class AdminList : Tea.TeaModel {
                public var displayName: String?

                public var email: String?

                public var extension_: String?

                public var instanceId: String?

                public var loginName: String?

                public var mobile: String?

                public var roleId: String?

                public var roleName: String?

                public var userId: String?

                public var workMode: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.displayName != nil {
                        map["DisplayName"] = self.displayName!
                    }
                    if self.email != nil {
                        map["Email"] = self.email!
                    }
                    if self.extension_ != nil {
                        map["Extension"] = self.extension_!
                    }
                    if self.instanceId != nil {
                        map["InstanceId"] = self.instanceId!
                    }
                    if self.loginName != nil {
                        map["LoginName"] = self.loginName!
                    }
                    if self.mobile != nil {
                        map["Mobile"] = self.mobile!
                    }
                    if self.roleId != nil {
                        map["RoleId"] = self.roleId!
                    }
                    if self.roleName != nil {
                        map["RoleName"] = self.roleName!
                    }
                    if self.userId != nil {
                        map["UserId"] = self.userId!
                    }
                    if self.workMode != nil {
                        map["WorkMode"] = self.workMode!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("DisplayName") {
                        self.displayName = dict["DisplayName"] as! String
                    }
                    if dict.keys.contains("Email") {
                        self.email = dict["Email"] as! String
                    }
                    if dict.keys.contains("Extension") {
                        self.extension_ = dict["Extension"] as! String
                    }
                    if dict.keys.contains("InstanceId") {
                        self.instanceId = dict["InstanceId"] as! String
                    }
                    if dict.keys.contains("LoginName") {
                        self.loginName = dict["LoginName"] as! String
                    }
                    if dict.keys.contains("Mobile") {
                        self.mobile = dict["Mobile"] as! String
                    }
                    if dict.keys.contains("RoleId") {
                        self.roleId = dict["RoleId"] as! String
                    }
                    if dict.keys.contains("RoleName") {
                        self.roleName = dict["RoleName"] as! String
                    }
                    if dict.keys.contains("UserId") {
                        self.userId = dict["UserId"] as! String
                    }
                    if dict.keys.contains("WorkMode") {
                        self.workMode = dict["WorkMode"] as! String
                    }
                }
            }
            public class NumberList : Tea.TeaModel {
                public class SkillGroups : Tea.TeaModel {
                    public var description_: String?

                    public var displayName: String?

                    public var instanceId: String?

                    public var name: String?

                    public var phoneNumberCount: Int32?

                    public var skillGroupId: String?

                    public var userCount: Int32?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.description_ != nil {
                            map["Description"] = self.description_!
                        }
                        if self.displayName != nil {
                            map["DisplayName"] = self.displayName!
                        }
                        if self.instanceId != nil {
                            map["InstanceId"] = self.instanceId!
                        }
                        if self.name != nil {
                            map["Name"] = self.name!
                        }
                        if self.phoneNumberCount != nil {
                            map["PhoneNumberCount"] = self.phoneNumberCount!
                        }
                        if self.skillGroupId != nil {
                            map["SkillGroupId"] = self.skillGroupId!
                        }
                        if self.userCount != nil {
                            map["UserCount"] = self.userCount!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Description") {
                            self.description_ = dict["Description"] as! String
                        }
                        if dict.keys.contains("DisplayName") {
                            self.displayName = dict["DisplayName"] as! String
                        }
                        if dict.keys.contains("InstanceId") {
                            self.instanceId = dict["InstanceId"] as! String
                        }
                        if dict.keys.contains("Name") {
                            self.name = dict["Name"] as! String
                        }
                        if dict.keys.contains("PhoneNumberCount") {
                            self.phoneNumberCount = dict["PhoneNumberCount"] as! Int32
                        }
                        if dict.keys.contains("SkillGroupId") {
                            self.skillGroupId = dict["SkillGroupId"] as! String
                        }
                        if dict.keys.contains("UserCount") {
                            self.userCount = dict["UserCount"] as! Int32
                        }
                    }
                }
                public var active: Bool?

                public var city: String?

                public var contactFlowId: String?

                public var instanceId: String?

                public var number: String?

                public var province: String?

                public var skillGroups: [ListInstancesOfUserResponseBody.Data.List.NumberList.SkillGroups]?

                public var usage: String?

                public var userId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.active != nil {
                        map["Active"] = self.active!
                    }
                    if self.city != nil {
                        map["City"] = self.city!
                    }
                    if self.contactFlowId != nil {
                        map["ContactFlowId"] = self.contactFlowId!
                    }
                    if self.instanceId != nil {
                        map["InstanceId"] = self.instanceId!
                    }
                    if self.number != nil {
                        map["Number"] = self.number!
                    }
                    if self.province != nil {
                        map["Province"] = self.province!
                    }
                    if self.skillGroups != nil {
                        var tmp : [Any] = []
                        for k in self.skillGroups! {
                            tmp.append(k.toMap())
                        }
                        map["SkillGroups"] = tmp
                    }
                    if self.usage != nil {
                        map["Usage"] = self.usage!
                    }
                    if self.userId != nil {
                        map["UserId"] = self.userId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Active") {
                        self.active = dict["Active"] as! Bool
                    }
                    if dict.keys.contains("City") {
                        self.city = dict["City"] as! String
                    }
                    if dict.keys.contains("ContactFlowId") {
                        self.contactFlowId = dict["ContactFlowId"] as! String
                    }
                    if dict.keys.contains("InstanceId") {
                        self.instanceId = dict["InstanceId"] as! String
                    }
                    if dict.keys.contains("Number") {
                        self.number = dict["Number"] as! String
                    }
                    if dict.keys.contains("Province") {
                        self.province = dict["Province"] as! String
                    }
                    if dict.keys.contains("SkillGroups") {
                        var tmp : [ListInstancesOfUserResponseBody.Data.List.NumberList.SkillGroups] = []
                        for v in dict["SkillGroups"] as! [Any] {
                            var model = ListInstancesOfUserResponseBody.Data.List.NumberList.SkillGroups()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.skillGroups = tmp
                    }
                    if dict.keys.contains("Usage") {
                        self.usage = dict["Usage"] as! String
                    }
                    if dict.keys.contains("UserId") {
                        self.userId = dict["UserId"] as! String
                    }
                }
            }
            public var adminList: [ListInstancesOfUserResponseBody.Data.List.AdminList]?

            public var aliyunUid: String?

            public var consoleUrl: String?

            public var description_: String?

            public var domainName: String?

            public var id: String?

            public var name: String?

            public var numberList: [ListInstancesOfUserResponseBody.Data.List.NumberList]?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.adminList != nil {
                    var tmp : [Any] = []
                    for k in self.adminList! {
                        tmp.append(k.toMap())
                    }
                    map["AdminList"] = tmp
                }
                if self.aliyunUid != nil {
                    map["AliyunUid"] = self.aliyunUid!
                }
                if self.consoleUrl != nil {
                    map["ConsoleUrl"] = self.consoleUrl!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.domainName != nil {
                    map["DomainName"] = self.domainName!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.numberList != nil {
                    var tmp : [Any] = []
                    for k in self.numberList! {
                        tmp.append(k.toMap())
                    }
                    map["NumberList"] = tmp
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AdminList") {
                    var tmp : [ListInstancesOfUserResponseBody.Data.List.AdminList] = []
                    for v in dict["AdminList"] as! [Any] {
                        var model = ListInstancesOfUserResponseBody.Data.List.AdminList()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.adminList = tmp
                }
                if dict.keys.contains("AliyunUid") {
                    self.aliyunUid = dict["AliyunUid"] as! String
                }
                if dict.keys.contains("ConsoleUrl") {
                    self.consoleUrl = dict["ConsoleUrl"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("DomainName") {
                    self.domainName = dict["DomainName"] as! String
                }
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! String
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("NumberList") {
                    var tmp : [ListInstancesOfUserResponseBody.Data.List.NumberList] = []
                    for v in dict["NumberList"] as! [Any] {
                        var model = ListInstancesOfUserResponseBody.Data.List.NumberList()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.numberList = tmp
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
            }
        }
        public var list: [ListInstancesOfUserResponseBody.Data.List]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.list != nil {
                var tmp : [Any] = []
                for k in self.list! {
                    tmp.append(k.toMap())
                }
                map["List"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("List") {
                var tmp : [ListInstancesOfUserResponseBody.Data.List] = []
                for v in dict["List"] as! [Any] {
                    var model = ListInstancesOfUserResponseBody.Data.List()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.list = tmp
            }
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var code: String?

    public var data: ListInstancesOfUserResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = ListInstancesOfUserResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListInstancesOfUserResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListInstancesOfUserResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListInstancesOfUserResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListIntervalAgentReportRequest : Tea.TeaModel {
    public var agentId: String?

    public var endTime: Int64?

    public var instanceId: String?

    public var interval: String?

    public var mediaType: String?

    public var startTime: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.agentId != nil {
            map["AgentId"] = self.agentId!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.interval != nil {
            map["Interval"] = self.interval!
        }
        if self.mediaType != nil {
            map["MediaType"] = self.mediaType!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AgentId") {
            self.agentId = dict["AgentId"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Interval") {
            self.interval = dict["Interval"] as! String
        }
        if dict.keys.contains("MediaType") {
            self.mediaType = dict["MediaType"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! Int64
        }
    }
}

public class ListIntervalAgentReportResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Back2Back : Tea.TeaModel {
            public var agentHandleRate: Double?

            public var answerRate: Double?

            public var averageCustomerRingTime: Double?

            public var averageRingTime: Double?

            public var averageTalkTime: Double?

            public var callsAgentHandled: Int64?

            public var callsAnswered: Int64?

            public var callsCustomerAnswered: Int64?

            public var callsDialed: Int64?

            public var customerAnswerRate: Double?

            public var maxCustomerRingTime: Int64?

            public var maxRingTime: Int64?

            public var maxTalkTime: Int64?

            public var totalCustomerRingTime: Int64?

            public var totalRingTime: Int64?

            public var totalTalkTime: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.agentHandleRate != nil {
                    map["AgentHandleRate"] = self.agentHandleRate!
                }
                if self.answerRate != nil {
                    map["AnswerRate"] = self.answerRate!
                }
                if self.averageCustomerRingTime != nil {
                    map["AverageCustomerRingTime"] = self.averageCustomerRingTime!
                }
                if self.averageRingTime != nil {
                    map["AverageRingTime"] = self.averageRingTime!
                }
                if self.averageTalkTime != nil {
                    map["AverageTalkTime"] = self.averageTalkTime!
                }
                if self.callsAgentHandled != nil {
                    map["CallsAgentHandled"] = self.callsAgentHandled!
                }
                if self.callsAnswered != nil {
                    map["CallsAnswered"] = self.callsAnswered!
                }
                if self.callsCustomerAnswered != nil {
                    map["CallsCustomerAnswered"] = self.callsCustomerAnswered!
                }
                if self.callsDialed != nil {
                    map["CallsDialed"] = self.callsDialed!
                }
                if self.customerAnswerRate != nil {
                    map["CustomerAnswerRate"] = self.customerAnswerRate!
                }
                if self.maxCustomerRingTime != nil {
                    map["MaxCustomerRingTime"] = self.maxCustomerRingTime!
                }
                if self.maxRingTime != nil {
                    map["MaxRingTime"] = self.maxRingTime!
                }
                if self.maxTalkTime != nil {
                    map["MaxTalkTime"] = self.maxTalkTime!
                }
                if self.totalCustomerRingTime != nil {
                    map["TotalCustomerRingTime"] = self.totalCustomerRingTime!
                }
                if self.totalRingTime != nil {
                    map["TotalRingTime"] = self.totalRingTime!
                }
                if self.totalTalkTime != nil {
                    map["TotalTalkTime"] = self.totalTalkTime!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AgentHandleRate") {
                    self.agentHandleRate = dict["AgentHandleRate"] as! Double
                }
                if dict.keys.contains("AnswerRate") {
                    self.answerRate = dict["AnswerRate"] as! Double
                }
                if dict.keys.contains("AverageCustomerRingTime") {
                    self.averageCustomerRingTime = dict["AverageCustomerRingTime"] as! Double
                }
                if dict.keys.contains("AverageRingTime") {
                    self.averageRingTime = dict["AverageRingTime"] as! Double
                }
                if dict.keys.contains("AverageTalkTime") {
                    self.averageTalkTime = dict["AverageTalkTime"] as! Double
                }
                if dict.keys.contains("CallsAgentHandled") {
                    self.callsAgentHandled = dict["CallsAgentHandled"] as! Int64
                }
                if dict.keys.contains("CallsAnswered") {
                    self.callsAnswered = dict["CallsAnswered"] as! Int64
                }
                if dict.keys.contains("CallsCustomerAnswered") {
                    self.callsCustomerAnswered = dict["CallsCustomerAnswered"] as! Int64
                }
                if dict.keys.contains("CallsDialed") {
                    self.callsDialed = dict["CallsDialed"] as! Int64
                }
                if dict.keys.contains("CustomerAnswerRate") {
                    self.customerAnswerRate = dict["CustomerAnswerRate"] as! Double
                }
                if dict.keys.contains("MaxCustomerRingTime") {
                    self.maxCustomerRingTime = dict["MaxCustomerRingTime"] as! Int64
                }
                if dict.keys.contains("MaxRingTime") {
                    self.maxRingTime = dict["MaxRingTime"] as! Int64
                }
                if dict.keys.contains("MaxTalkTime") {
                    self.maxTalkTime = dict["MaxTalkTime"] as! Int64
                }
                if dict.keys.contains("TotalCustomerRingTime") {
                    self.totalCustomerRingTime = dict["TotalCustomerRingTime"] as! Int64
                }
                if dict.keys.contains("TotalRingTime") {
                    self.totalRingTime = dict["TotalRingTime"] as! Int64
                }
                if dict.keys.contains("TotalTalkTime") {
                    self.totalTalkTime = dict["TotalTalkTime"] as! Int64
                }
            }
        }
        public class Inbound : Tea.TeaModel {
            public class AccessChannelTypeDetails : Tea.TeaModel {
                public var accessChannelType: String?

                public var callsOffered: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.accessChannelType != nil {
                        map["AccessChannelType"] = self.accessChannelType!
                    }
                    if self.callsOffered != nil {
                        map["CallsOffered"] = self.callsOffered!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AccessChannelType") {
                        self.accessChannelType = dict["AccessChannelType"] as! String
                    }
                    if dict.keys.contains("CallsOffered") {
                        self.callsOffered = dict["CallsOffered"] as! Int64
                    }
                }
            }
            public var accessChannelTypeDetails: [ListIntervalAgentReportResponseBody.Data.Inbound.AccessChannelTypeDetails]?

            public var averageFirstResponseTime: Double?

            public var averageHoldTime: Double?

            public var averageResponseTime: Double?

            public var averageRingTime: Double?

            public var averageTalkTime: Double?

            public var averageWorkTime: Double?

            public var callsAttendedTransferIn: Int64?

            public var callsAttendedTransferOut: Int64?

            public var callsBlindTransferIn: Int64?

            public var callsBlindTransferOut: Int64?

            public var callsHandled: Int64?

            public var callsHold: Int64?

            public var callsOffered: Int64?

            public var callsRinged: Int64?

            public var handleRate: Double?

            public var maxHoldTime: Int64?

            public var maxRingTime: Int64?

            public var maxTalkTime: Int64?

            public var maxWorkTime: Int64?

            public var satisfactionIndex: Double?

            public var satisfactionRate: Double?

            public var satisfactionSurveysOffered: Int64?

            public var satisfactionSurveysResponded: Int64?

            public var serviceLevel15: Double?

            public var totalHoldTime: Int64?

            public var totalMessagesSent: Int64?

            public var totalMessagesSentByAgent: Int64?

            public var totalMessagesSentByCustomer: Int64?

            public var totalRingTime: Int64?

            public var totalTalkTime: Int64?

            public var totalWorkTime: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.accessChannelTypeDetails != nil {
                    var tmp : [Any] = []
                    for k in self.accessChannelTypeDetails! {
                        tmp.append(k.toMap())
                    }
                    map["AccessChannelTypeDetails"] = tmp
                }
                if self.averageFirstResponseTime != nil {
                    map["AverageFirstResponseTime"] = self.averageFirstResponseTime!
                }
                if self.averageHoldTime != nil {
                    map["AverageHoldTime"] = self.averageHoldTime!
                }
                if self.averageResponseTime != nil {
                    map["AverageResponseTime"] = self.averageResponseTime!
                }
                if self.averageRingTime != nil {
                    map["AverageRingTime"] = self.averageRingTime!
                }
                if self.averageTalkTime != nil {
                    map["AverageTalkTime"] = self.averageTalkTime!
                }
                if self.averageWorkTime != nil {
                    map["AverageWorkTime"] = self.averageWorkTime!
                }
                if self.callsAttendedTransferIn != nil {
                    map["CallsAttendedTransferIn"] = self.callsAttendedTransferIn!
                }
                if self.callsAttendedTransferOut != nil {
                    map["CallsAttendedTransferOut"] = self.callsAttendedTransferOut!
                }
                if self.callsBlindTransferIn != nil {
                    map["CallsBlindTransferIn"] = self.callsBlindTransferIn!
                }
                if self.callsBlindTransferOut != nil {
                    map["CallsBlindTransferOut"] = self.callsBlindTransferOut!
                }
                if self.callsHandled != nil {
                    map["CallsHandled"] = self.callsHandled!
                }
                if self.callsHold != nil {
                    map["CallsHold"] = self.callsHold!
                }
                if self.callsOffered != nil {
                    map["CallsOffered"] = self.callsOffered!
                }
                if self.callsRinged != nil {
                    map["CallsRinged"] = self.callsRinged!
                }
                if self.handleRate != nil {
                    map["HandleRate"] = self.handleRate!
                }
                if self.maxHoldTime != nil {
                    map["MaxHoldTime"] = self.maxHoldTime!
                }
                if self.maxRingTime != nil {
                    map["MaxRingTime"] = self.maxRingTime!
                }
                if self.maxTalkTime != nil {
                    map["MaxTalkTime"] = self.maxTalkTime!
                }
                if self.maxWorkTime != nil {
                    map["MaxWorkTime"] = self.maxWorkTime!
                }
                if self.satisfactionIndex != nil {
                    map["SatisfactionIndex"] = self.satisfactionIndex!
                }
                if self.satisfactionRate != nil {
                    map["SatisfactionRate"] = self.satisfactionRate!
                }
                if self.satisfactionSurveysOffered != nil {
                    map["SatisfactionSurveysOffered"] = self.satisfactionSurveysOffered!
                }
                if self.satisfactionSurveysResponded != nil {
                    map["SatisfactionSurveysResponded"] = self.satisfactionSurveysResponded!
                }
                if self.serviceLevel15 != nil {
                    map["ServiceLevel15"] = self.serviceLevel15!
                }
                if self.totalHoldTime != nil {
                    map["TotalHoldTime"] = self.totalHoldTime!
                }
                if self.totalMessagesSent != nil {
                    map["TotalMessagesSent"] = self.totalMessagesSent!
                }
                if self.totalMessagesSentByAgent != nil {
                    map["TotalMessagesSentByAgent"] = self.totalMessagesSentByAgent!
                }
                if self.totalMessagesSentByCustomer != nil {
                    map["TotalMessagesSentByCustomer"] = self.totalMessagesSentByCustomer!
                }
                if self.totalRingTime != nil {
                    map["TotalRingTime"] = self.totalRingTime!
                }
                if self.totalTalkTime != nil {
                    map["TotalTalkTime"] = self.totalTalkTime!
                }
                if self.totalWorkTime != nil {
                    map["TotalWorkTime"] = self.totalWorkTime!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AccessChannelTypeDetails") {
                    var tmp : [ListIntervalAgentReportResponseBody.Data.Inbound.AccessChannelTypeDetails] = []
                    for v in dict["AccessChannelTypeDetails"] as! [Any] {
                        var model = ListIntervalAgentReportResponseBody.Data.Inbound.AccessChannelTypeDetails()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.accessChannelTypeDetails = tmp
                }
                if dict.keys.contains("AverageFirstResponseTime") {
                    self.averageFirstResponseTime = dict["AverageFirstResponseTime"] as! Double
                }
                if dict.keys.contains("AverageHoldTime") {
                    self.averageHoldTime = dict["AverageHoldTime"] as! Double
                }
                if dict.keys.contains("AverageResponseTime") {
                    self.averageResponseTime = dict["AverageResponseTime"] as! Double
                }
                if dict.keys.contains("AverageRingTime") {
                    self.averageRingTime = dict["AverageRingTime"] as! Double
                }
                if dict.keys.contains("AverageTalkTime") {
                    self.averageTalkTime = dict["AverageTalkTime"] as! Double
                }
                if dict.keys.contains("AverageWorkTime") {
                    self.averageWorkTime = dict["AverageWorkTime"] as! Double
                }
                if dict.keys.contains("CallsAttendedTransferIn") {
                    self.callsAttendedTransferIn = dict["CallsAttendedTransferIn"] as! Int64
                }
                if dict.keys.contains("CallsAttendedTransferOut") {
                    self.callsAttendedTransferOut = dict["CallsAttendedTransferOut"] as! Int64
                }
                if dict.keys.contains("CallsBlindTransferIn") {
                    self.callsBlindTransferIn = dict["CallsBlindTransferIn"] as! Int64
                }
                if dict.keys.contains("CallsBlindTransferOut") {
                    self.callsBlindTransferOut = dict["CallsBlindTransferOut"] as! Int64
                }
                if dict.keys.contains("CallsHandled") {
                    self.callsHandled = dict["CallsHandled"] as! Int64
                }
                if dict.keys.contains("CallsHold") {
                    self.callsHold = dict["CallsHold"] as! Int64
                }
                if dict.keys.contains("CallsOffered") {
                    self.callsOffered = dict["CallsOffered"] as! Int64
                }
                if dict.keys.contains("CallsRinged") {
                    self.callsRinged = dict["CallsRinged"] as! Int64
                }
                if dict.keys.contains("HandleRate") {
                    self.handleRate = dict["HandleRate"] as! Double
                }
                if dict.keys.contains("MaxHoldTime") {
                    self.maxHoldTime = dict["MaxHoldTime"] as! Int64
                }
                if dict.keys.contains("MaxRingTime") {
                    self.maxRingTime = dict["MaxRingTime"] as! Int64
                }
                if dict.keys.contains("MaxTalkTime") {
                    self.maxTalkTime = dict["MaxTalkTime"] as! Int64
                }
                if dict.keys.contains("MaxWorkTime") {
                    self.maxWorkTime = dict["MaxWorkTime"] as! Int64
                }
                if dict.keys.contains("SatisfactionIndex") {
                    self.satisfactionIndex = dict["SatisfactionIndex"] as! Double
                }
                if dict.keys.contains("SatisfactionRate") {
                    self.satisfactionRate = dict["SatisfactionRate"] as! Double
                }
                if dict.keys.contains("SatisfactionSurveysOffered") {
                    self.satisfactionSurveysOffered = dict["SatisfactionSurveysOffered"] as! Int64
                }
                if dict.keys.contains("SatisfactionSurveysResponded") {
                    self.satisfactionSurveysResponded = dict["SatisfactionSurveysResponded"] as! Int64
                }
                if dict.keys.contains("ServiceLevel15") {
                    self.serviceLevel15 = dict["ServiceLevel15"] as! Double
                }
                if dict.keys.contains("TotalHoldTime") {
                    self.totalHoldTime = dict["TotalHoldTime"] as! Int64
                }
                if dict.keys.contains("TotalMessagesSent") {
                    self.totalMessagesSent = dict["TotalMessagesSent"] as! Int64
                }
                if dict.keys.contains("TotalMessagesSentByAgent") {
                    self.totalMessagesSentByAgent = dict["TotalMessagesSentByAgent"] as! Int64
                }
                if dict.keys.contains("TotalMessagesSentByCustomer") {
                    self.totalMessagesSentByCustomer = dict["TotalMessagesSentByCustomer"] as! Int64
                }
                if dict.keys.contains("TotalRingTime") {
                    self.totalRingTime = dict["TotalRingTime"] as! Int64
                }
                if dict.keys.contains("TotalTalkTime") {
                    self.totalTalkTime = dict["TotalTalkTime"] as! Int64
                }
                if dict.keys.contains("TotalWorkTime") {
                    self.totalWorkTime = dict["TotalWorkTime"] as! Int64
                }
            }
        }
        public class Internal_ : Tea.TeaModel {
            public var averageTalkTime: Double?

            public var callsAnswered: Int64?

            public var callsDialed: Int64?

            public var callsHandled: Int64?

            public var callsOffered: Int64?

            public var callsTalked: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.averageTalkTime != nil {
                    map["AverageTalkTime"] = self.averageTalkTime!
                }
                if self.callsAnswered != nil {
                    map["CallsAnswered"] = self.callsAnswered!
                }
                if self.callsDialed != nil {
                    map["CallsDialed"] = self.callsDialed!
                }
                if self.callsHandled != nil {
                    map["CallsHandled"] = self.callsHandled!
                }
                if self.callsOffered != nil {
                    map["CallsOffered"] = self.callsOffered!
                }
                if self.callsTalked != nil {
                    map["CallsTalked"] = self.callsTalked!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AverageTalkTime") {
                    self.averageTalkTime = dict["AverageTalkTime"] as! Double
                }
                if dict.keys.contains("CallsAnswered") {
                    self.callsAnswered = dict["CallsAnswered"] as! Int64
                }
                if dict.keys.contains("CallsDialed") {
                    self.callsDialed = dict["CallsDialed"] as! Int64
                }
                if dict.keys.contains("CallsHandled") {
                    self.callsHandled = dict["CallsHandled"] as! Int64
                }
                if dict.keys.contains("CallsOffered") {
                    self.callsOffered = dict["CallsOffered"] as! Int64
                }
                if dict.keys.contains("CallsTalked") {
                    self.callsTalked = dict["CallsTalked"] as! Int64
                }
            }
        }
        public class Outbound : Tea.TeaModel {
            public var answerRate: Double?

            public var averageDialingTime: Double?

            public var averageHoldTime: Double?

            public var averageRingTime: Double?

            public var averageTalkTime: Double?

            public var averageWorkTime: Double?

            public var callsAnswered: Int64?

            public var callsAttendedTransferIn: Int64?

            public var callsAttendedTransferOut: Int64?

            public var callsBlindTransferIn: Int64?

            public var callsBlindTransferOut: Int64?

            public var callsDialed: Int64?

            public var callsHold: Int64?

            public var callsRinged: Int64?

            public var maxDialingTime: Int64?

            public var maxHoldTime: Int64?

            public var maxRingTime: Int64?

            public var maxTalkTime: Int64?

            public var maxWorkTime: Int64?

            public var satisfactionIndex: Double?

            public var satisfactionRate: Double?

            public var satisfactionSurveysOffered: Int64?

            public var satisfactionSurveysResponded: Int64?

            public var totalDialingTime: Int64?

            public var totalHoldTime: Int64?

            public var totalRingTime: Int64?

            public var totalTalkTime: Int64?

            public var totalWorkTime: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.answerRate != nil {
                    map["AnswerRate"] = self.answerRate!
                }
                if self.averageDialingTime != nil {
                    map["AverageDialingTime"] = self.averageDialingTime!
                }
                if self.averageHoldTime != nil {
                    map["AverageHoldTime"] = self.averageHoldTime!
                }
                if self.averageRingTime != nil {
                    map["AverageRingTime"] = self.averageRingTime!
                }
                if self.averageTalkTime != nil {
                    map["AverageTalkTime"] = self.averageTalkTime!
                }
                if self.averageWorkTime != nil {
                    map["AverageWorkTime"] = self.averageWorkTime!
                }
                if self.callsAnswered != nil {
                    map["CallsAnswered"] = self.callsAnswered!
                }
                if self.callsAttendedTransferIn != nil {
                    map["CallsAttendedTransferIn"] = self.callsAttendedTransferIn!
                }
                if self.callsAttendedTransferOut != nil {
                    map["CallsAttendedTransferOut"] = self.callsAttendedTransferOut!
                }
                if self.callsBlindTransferIn != nil {
                    map["CallsBlindTransferIn"] = self.callsBlindTransferIn!
                }
                if self.callsBlindTransferOut != nil {
                    map["CallsBlindTransferOut"] = self.callsBlindTransferOut!
                }
                if self.callsDialed != nil {
                    map["CallsDialed"] = self.callsDialed!
                }
                if self.callsHold != nil {
                    map["CallsHold"] = self.callsHold!
                }
                if self.callsRinged != nil {
                    map["CallsRinged"] = self.callsRinged!
                }
                if self.maxDialingTime != nil {
                    map["MaxDialingTime"] = self.maxDialingTime!
                }
                if self.maxHoldTime != nil {
                    map["MaxHoldTime"] = self.maxHoldTime!
                }
                if self.maxRingTime != nil {
                    map["MaxRingTime"] = self.maxRingTime!
                }
                if self.maxTalkTime != nil {
                    map["MaxTalkTime"] = self.maxTalkTime!
                }
                if self.maxWorkTime != nil {
                    map["MaxWorkTime"] = self.maxWorkTime!
                }
                if self.satisfactionIndex != nil {
                    map["SatisfactionIndex"] = self.satisfactionIndex!
                }
                if self.satisfactionRate != nil {
                    map["SatisfactionRate"] = self.satisfactionRate!
                }
                if self.satisfactionSurveysOffered != nil {
                    map["SatisfactionSurveysOffered"] = self.satisfactionSurveysOffered!
                }
                if self.satisfactionSurveysResponded != nil {
                    map["SatisfactionSurveysResponded"] = self.satisfactionSurveysResponded!
                }
                if self.totalDialingTime != nil {
                    map["TotalDialingTime"] = self.totalDialingTime!
                }
                if self.totalHoldTime != nil {
                    map["TotalHoldTime"] = self.totalHoldTime!
                }
                if self.totalRingTime != nil {
                    map["TotalRingTime"] = self.totalRingTime!
                }
                if self.totalTalkTime != nil {
                    map["TotalTalkTime"] = self.totalTalkTime!
                }
                if self.totalWorkTime != nil {
                    map["TotalWorkTime"] = self.totalWorkTime!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AnswerRate") {
                    self.answerRate = dict["AnswerRate"] as! Double
                }
                if dict.keys.contains("AverageDialingTime") {
                    self.averageDialingTime = dict["AverageDialingTime"] as! Double
                }
                if dict.keys.contains("AverageHoldTime") {
                    self.averageHoldTime = dict["AverageHoldTime"] as! Double
                }
                if dict.keys.contains("AverageRingTime") {
                    self.averageRingTime = dict["AverageRingTime"] as! Double
                }
                if dict.keys.contains("AverageTalkTime") {
                    self.averageTalkTime = dict["AverageTalkTime"] as! Double
                }
                if dict.keys.contains("AverageWorkTime") {
                    self.averageWorkTime = dict["AverageWorkTime"] as! Double
                }
                if dict.keys.contains("CallsAnswered") {
                    self.callsAnswered = dict["CallsAnswered"] as! Int64
                }
                if dict.keys.contains("CallsAttendedTransferIn") {
                    self.callsAttendedTransferIn = dict["CallsAttendedTransferIn"] as! Int64
                }
                if dict.keys.contains("CallsAttendedTransferOut") {
                    self.callsAttendedTransferOut = dict["CallsAttendedTransferOut"] as! Int64
                }
                if dict.keys.contains("CallsBlindTransferIn") {
                    self.callsBlindTransferIn = dict["CallsBlindTransferIn"] as! Int64
                }
                if dict.keys.contains("CallsBlindTransferOut") {
                    self.callsBlindTransferOut = dict["CallsBlindTransferOut"] as! Int64
                }
                if dict.keys.contains("CallsDialed") {
                    self.callsDialed = dict["CallsDialed"] as! Int64
                }
                if dict.keys.contains("CallsHold") {
                    self.callsHold = dict["CallsHold"] as! Int64
                }
                if dict.keys.contains("CallsRinged") {
                    self.callsRinged = dict["CallsRinged"] as! Int64
                }
                if dict.keys.contains("MaxDialingTime") {
                    self.maxDialingTime = dict["MaxDialingTime"] as! Int64
                }
                if dict.keys.contains("MaxHoldTime") {
                    self.maxHoldTime = dict["MaxHoldTime"] as! Int64
                }
                if dict.keys.contains("MaxRingTime") {
                    self.maxRingTime = dict["MaxRingTime"] as! Int64
                }
                if dict.keys.contains("MaxTalkTime") {
                    self.maxTalkTime = dict["MaxTalkTime"] as! Int64
                }
                if dict.keys.contains("MaxWorkTime") {
                    self.maxWorkTime = dict["MaxWorkTime"] as! Int64
                }
                if dict.keys.contains("SatisfactionIndex") {
                    self.satisfactionIndex = dict["SatisfactionIndex"] as! Double
                }
                if dict.keys.contains("SatisfactionRate") {
                    self.satisfactionRate = dict["SatisfactionRate"] as! Double
                }
                if dict.keys.contains("SatisfactionSurveysOffered") {
                    self.satisfactionSurveysOffered = dict["SatisfactionSurveysOffered"] as! Int64
                }
                if dict.keys.contains("SatisfactionSurveysResponded") {
                    self.satisfactionSurveysResponded = dict["SatisfactionSurveysResponded"] as! Int64
                }
                if dict.keys.contains("TotalDialingTime") {
                    self.totalDialingTime = dict["TotalDialingTime"] as! Int64
                }
                if dict.keys.contains("TotalHoldTime") {
                    self.totalHoldTime = dict["TotalHoldTime"] as! Int64
                }
                if dict.keys.contains("TotalRingTime") {
                    self.totalRingTime = dict["TotalRingTime"] as! Int64
                }
                if dict.keys.contains("TotalTalkTime") {
                    self.totalTalkTime = dict["TotalTalkTime"] as! Int64
                }
                if dict.keys.contains("TotalWorkTime") {
                    self.totalWorkTime = dict["TotalWorkTime"] as! Int64
                }
            }
        }
        public class Overall : Tea.TeaModel {
            public class BreakCodeDetailList : Tea.TeaModel {
                public var breakCode: String?

                public var count: Int64?

                public var duration: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.breakCode != nil {
                        map["BreakCode"] = self.breakCode!
                    }
                    if self.count != nil {
                        map["Count"] = self.count!
                    }
                    if self.duration != nil {
                        map["Duration"] = self.duration!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("BreakCode") {
                        self.breakCode = dict["BreakCode"] as! String
                    }
                    if dict.keys.contains("Count") {
                        self.count = dict["Count"] as! Int64
                    }
                    if dict.keys.contains("Duration") {
                        self.duration = dict["Duration"] as! Int64
                    }
                }
            }
            public var averageBreakTime: Double?

            public var averageHoldTime: Double?

            public var averageReadyTime: Double?

            public var averageTalkTime: Double?

            public var averageWorkTime: Double?

            public var breakCodeDetailList: [ListIntervalAgentReportResponseBody.Data.Overall.BreakCodeDetailList]?

            public var firstCheckInTime: Int64?

            public var lastCheckOutTime: Int64?

            public var lastCheckoutTime: Int64?

            public var maxBreakTime: Int64?

            public var maxHoldTime: Int64?

            public var maxReadyTime: Int64?

            public var maxTalkTime: Int64?

            public var maxWorkTime: Int64?

            public var occupancyRate: Double?

            public var satisfactionIndex: Double?

            public var satisfactionRate: Double?

            public var satisfactionSurveysOffered: Int64?

            public var satisfactionSurveysResponded: Int64?

            public var totalBreakTime: Int64?

            public var totalCalls: Int64?

            public var totalHoldTime: Int64?

            public var totalLoggedInTime: Int64?

            public var totalOffSiteLoggedInTime: Int64?

            public var totalOffSiteOnlineTime: Int64?

            public var totalOfficePhoneLoggedInTime: Int64?

            public var totalOfficePhoneOnlineTime: Int64?

            public var totalOnSiteLoggedInTime: Int64?

            public var totalOnSiteOnlineTime: Int64?

            public var totalOutboundScenarioLoggedInTime: Int64?

            public var totalOutboundScenarioReadyTime: Int64?

            public var totalOutboundScenarioTime: Int64?

            public var totalReadyTime: Int64?

            public var totalTalkTime: Int64?

            public var totalWorkTime: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.averageBreakTime != nil {
                    map["AverageBreakTime"] = self.averageBreakTime!
                }
                if self.averageHoldTime != nil {
                    map["AverageHoldTime"] = self.averageHoldTime!
                }
                if self.averageReadyTime != nil {
                    map["AverageReadyTime"] = self.averageReadyTime!
                }
                if self.averageTalkTime != nil {
                    map["AverageTalkTime"] = self.averageTalkTime!
                }
                if self.averageWorkTime != nil {
                    map["AverageWorkTime"] = self.averageWorkTime!
                }
                if self.breakCodeDetailList != nil {
                    var tmp : [Any] = []
                    for k in self.breakCodeDetailList! {
                        tmp.append(k.toMap())
                    }
                    map["BreakCodeDetailList"] = tmp
                }
                if self.firstCheckInTime != nil {
                    map["FirstCheckInTime"] = self.firstCheckInTime!
                }
                if self.lastCheckOutTime != nil {
                    map["LastCheckOutTime"] = self.lastCheckOutTime!
                }
                if self.lastCheckoutTime != nil {
                    map["LastCheckoutTime"] = self.lastCheckoutTime!
                }
                if self.maxBreakTime != nil {
                    map["MaxBreakTime"] = self.maxBreakTime!
                }
                if self.maxHoldTime != nil {
                    map["MaxHoldTime"] = self.maxHoldTime!
                }
                if self.maxReadyTime != nil {
                    map["MaxReadyTime"] = self.maxReadyTime!
                }
                if self.maxTalkTime != nil {
                    map["MaxTalkTime"] = self.maxTalkTime!
                }
                if self.maxWorkTime != nil {
                    map["MaxWorkTime"] = self.maxWorkTime!
                }
                if self.occupancyRate != nil {
                    map["OccupancyRate"] = self.occupancyRate!
                }
                if self.satisfactionIndex != nil {
                    map["SatisfactionIndex"] = self.satisfactionIndex!
                }
                if self.satisfactionRate != nil {
                    map["SatisfactionRate"] = self.satisfactionRate!
                }
                if self.satisfactionSurveysOffered != nil {
                    map["SatisfactionSurveysOffered"] = self.satisfactionSurveysOffered!
                }
                if self.satisfactionSurveysResponded != nil {
                    map["SatisfactionSurveysResponded"] = self.satisfactionSurveysResponded!
                }
                if self.totalBreakTime != nil {
                    map["TotalBreakTime"] = self.totalBreakTime!
                }
                if self.totalCalls != nil {
                    map["TotalCalls"] = self.totalCalls!
                }
                if self.totalHoldTime != nil {
                    map["TotalHoldTime"] = self.totalHoldTime!
                }
                if self.totalLoggedInTime != nil {
                    map["TotalLoggedInTime"] = self.totalLoggedInTime!
                }
                if self.totalOffSiteLoggedInTime != nil {
                    map["TotalOffSiteLoggedInTime"] = self.totalOffSiteLoggedInTime!
                }
                if self.totalOffSiteOnlineTime != nil {
                    map["TotalOffSiteOnlineTime"] = self.totalOffSiteOnlineTime!
                }
                if self.totalOfficePhoneLoggedInTime != nil {
                    map["TotalOfficePhoneLoggedInTime"] = self.totalOfficePhoneLoggedInTime!
                }
                if self.totalOfficePhoneOnlineTime != nil {
                    map["TotalOfficePhoneOnlineTime"] = self.totalOfficePhoneOnlineTime!
                }
                if self.totalOnSiteLoggedInTime != nil {
                    map["TotalOnSiteLoggedInTime"] = self.totalOnSiteLoggedInTime!
                }
                if self.totalOnSiteOnlineTime != nil {
                    map["TotalOnSiteOnlineTime"] = self.totalOnSiteOnlineTime!
                }
                if self.totalOutboundScenarioLoggedInTime != nil {
                    map["TotalOutboundScenarioLoggedInTime"] = self.totalOutboundScenarioLoggedInTime!
                }
                if self.totalOutboundScenarioReadyTime != nil {
                    map["TotalOutboundScenarioReadyTime"] = self.totalOutboundScenarioReadyTime!
                }
                if self.totalOutboundScenarioTime != nil {
                    map["TotalOutboundScenarioTime"] = self.totalOutboundScenarioTime!
                }
                if self.totalReadyTime != nil {
                    map["TotalReadyTime"] = self.totalReadyTime!
                }
                if self.totalTalkTime != nil {
                    map["TotalTalkTime"] = self.totalTalkTime!
                }
                if self.totalWorkTime != nil {
                    map["TotalWorkTime"] = self.totalWorkTime!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AverageBreakTime") {
                    self.averageBreakTime = dict["AverageBreakTime"] as! Double
                }
                if dict.keys.contains("AverageHoldTime") {
                    self.averageHoldTime = dict["AverageHoldTime"] as! Double
                }
                if dict.keys.contains("AverageReadyTime") {
                    self.averageReadyTime = dict["AverageReadyTime"] as! Double
                }
                if dict.keys.contains("AverageTalkTime") {
                    self.averageTalkTime = dict["AverageTalkTime"] as! Double
                }
                if dict.keys.contains("AverageWorkTime") {
                    self.averageWorkTime = dict["AverageWorkTime"] as! Double
                }
                if dict.keys.contains("BreakCodeDetailList") {
                    var tmp : [ListIntervalAgentReportResponseBody.Data.Overall.BreakCodeDetailList] = []
                    for v in dict["BreakCodeDetailList"] as! [Any] {
                        var model = ListIntervalAgentReportResponseBody.Data.Overall.BreakCodeDetailList()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.breakCodeDetailList = tmp
                }
                if dict.keys.contains("FirstCheckInTime") {
                    self.firstCheckInTime = dict["FirstCheckInTime"] as! Int64
                }
                if dict.keys.contains("LastCheckOutTime") {
                    self.lastCheckOutTime = dict["LastCheckOutTime"] as! Int64
                }
                if dict.keys.contains("LastCheckoutTime") {
                    self.lastCheckoutTime = dict["LastCheckoutTime"] as! Int64
                }
                if dict.keys.contains("MaxBreakTime") {
                    self.maxBreakTime = dict["MaxBreakTime"] as! Int64
                }
                if dict.keys.contains("MaxHoldTime") {
                    self.maxHoldTime = dict["MaxHoldTime"] as! Int64
                }
                if dict.keys.contains("MaxReadyTime") {
                    self.maxReadyTime = dict["MaxReadyTime"] as! Int64
                }
                if dict.keys.contains("MaxTalkTime") {
                    self.maxTalkTime = dict["MaxTalkTime"] as! Int64
                }
                if dict.keys.contains("MaxWorkTime") {
                    self.maxWorkTime = dict["MaxWorkTime"] as! Int64
                }
                if dict.keys.contains("OccupancyRate") {
                    self.occupancyRate = dict["OccupancyRate"] as! Double
                }
                if dict.keys.contains("SatisfactionIndex") {
                    self.satisfactionIndex = dict["SatisfactionIndex"] as! Double
                }
                if dict.keys.contains("SatisfactionRate") {
                    self.satisfactionRate = dict["SatisfactionRate"] as! Double
                }
                if dict.keys.contains("SatisfactionSurveysOffered") {
                    self.satisfactionSurveysOffered = dict["SatisfactionSurveysOffered"] as! Int64
                }
                if dict.keys.contains("SatisfactionSurveysResponded") {
                    self.satisfactionSurveysResponded = dict["SatisfactionSurveysResponded"] as! Int64
                }
                if dict.keys.contains("TotalBreakTime") {
                    self.totalBreakTime = dict["TotalBreakTime"] as! Int64
                }
                if dict.keys.contains("TotalCalls") {
                    self.totalCalls = dict["TotalCalls"] as! Int64
                }
                if dict.keys.contains("TotalHoldTime") {
                    self.totalHoldTime = dict["TotalHoldTime"] as! Int64
                }
                if dict.keys.contains("TotalLoggedInTime") {
                    self.totalLoggedInTime = dict["TotalLoggedInTime"] as! Int64
                }
                if dict.keys.contains("TotalOffSiteLoggedInTime") {
                    self.totalOffSiteLoggedInTime = dict["TotalOffSiteLoggedInTime"] as! Int64
                }
                if dict.keys.contains("TotalOffSiteOnlineTime") {
                    self.totalOffSiteOnlineTime = dict["TotalOffSiteOnlineTime"] as! Int64
                }
                if dict.keys.contains("TotalOfficePhoneLoggedInTime") {
                    self.totalOfficePhoneLoggedInTime = dict["TotalOfficePhoneLoggedInTime"] as! Int64
                }
                if dict.keys.contains("TotalOfficePhoneOnlineTime") {
                    self.totalOfficePhoneOnlineTime = dict["TotalOfficePhoneOnlineTime"] as! Int64
                }
                if dict.keys.contains("TotalOnSiteLoggedInTime") {
                    self.totalOnSiteLoggedInTime = dict["TotalOnSiteLoggedInTime"] as! Int64
                }
                if dict.keys.contains("TotalOnSiteOnlineTime") {
                    self.totalOnSiteOnlineTime = dict["TotalOnSiteOnlineTime"] as! Int64
                }
                if dict.keys.contains("TotalOutboundScenarioLoggedInTime") {
                    self.totalOutboundScenarioLoggedInTime = dict["TotalOutboundScenarioLoggedInTime"] as! Int64
                }
                if dict.keys.contains("TotalOutboundScenarioReadyTime") {
                    self.totalOutboundScenarioReadyTime = dict["TotalOutboundScenarioReadyTime"] as! Int64
                }
                if dict.keys.contains("TotalOutboundScenarioTime") {
                    self.totalOutboundScenarioTime = dict["TotalOutboundScenarioTime"] as! Int64
                }
                if dict.keys.contains("TotalReadyTime") {
                    self.totalReadyTime = dict["TotalReadyTime"] as! Int64
                }
                if dict.keys.contains("TotalTalkTime") {
                    self.totalTalkTime = dict["TotalTalkTime"] as! Int64
                }
                if dict.keys.contains("TotalWorkTime") {
                    self.totalWorkTime = dict["TotalWorkTime"] as! Int64
                }
            }
        }
        public var back2Back: ListIntervalAgentReportResponseBody.Data.Back2Back?

        public var inbound: ListIntervalAgentReportResponseBody.Data.Inbound?

        public var internal_: ListIntervalAgentReportResponseBody.Data.Internal_?

        public var outbound: ListIntervalAgentReportResponseBody.Data.Outbound?

        public var overall: ListIntervalAgentReportResponseBody.Data.Overall?

        public var statsTime: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.back2Back?.validate()
            try self.inbound?.validate()
            try self.internal_?.validate()
            try self.outbound?.validate()
            try self.overall?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.back2Back != nil {
                map["Back2Back"] = self.back2Back?.toMap()
            }
            if self.inbound != nil {
                map["Inbound"] = self.inbound?.toMap()
            }
            if self.internal_ != nil {
                map["Internal"] = self.internal_?.toMap()
            }
            if self.outbound != nil {
                map["Outbound"] = self.outbound?.toMap()
            }
            if self.overall != nil {
                map["Overall"] = self.overall?.toMap()
            }
            if self.statsTime != nil {
                map["StatsTime"] = self.statsTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Back2Back") {
                var model = ListIntervalAgentReportResponseBody.Data.Back2Back()
                model.fromMap(dict["Back2Back"] as! [String: Any])
                self.back2Back = model
            }
            if dict.keys.contains("Inbound") {
                var model = ListIntervalAgentReportResponseBody.Data.Inbound()
                model.fromMap(dict["Inbound"] as! [String: Any])
                self.inbound = model
            }
            if dict.keys.contains("Internal") {
                var model = ListIntervalAgentReportResponseBody.Data.Internal_()
                model.fromMap(dict["Internal"] as! [String: Any])
                self.internal_ = model
            }
            if dict.keys.contains("Outbound") {
                var model = ListIntervalAgentReportResponseBody.Data.Outbound()
                model.fromMap(dict["Outbound"] as! [String: Any])
                self.outbound = model
            }
            if dict.keys.contains("Overall") {
                var model = ListIntervalAgentReportResponseBody.Data.Overall()
                model.fromMap(dict["Overall"] as! [String: Any])
                self.overall = model
            }
            if dict.keys.contains("StatsTime") {
                self.statsTime = dict["StatsTime"] as! Int64
            }
        }
    }
    public var code: String?

    public var data: [ListIntervalAgentReportResponseBody.Data]?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var tmp : [ListIntervalAgentReportResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = ListIntervalAgentReportResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListIntervalAgentReportResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListIntervalAgentReportResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListIntervalAgentReportResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListIntervalAgentSkillGroupReportRequest : Tea.TeaModel {
    public var agentId: String?

    public var endTime: Int64?

    public var instanceId: String?

    public var interval: String?

    public var skillGroupId: String?

    public var startTime: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.agentId != nil {
            map["AgentId"] = self.agentId!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.interval != nil {
            map["Interval"] = self.interval!
        }
        if self.skillGroupId != nil {
            map["SkillGroupId"] = self.skillGroupId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AgentId") {
            self.agentId = dict["AgentId"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Interval") {
            self.interval = dict["Interval"] as! String
        }
        if dict.keys.contains("SkillGroupId") {
            self.skillGroupId = dict["SkillGroupId"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! Int64
        }
    }
}

public class ListIntervalAgentSkillGroupReportResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Back2Back : Tea.TeaModel {
            public var agentAnswerRate: Double?

            public var agentHandleRate: Double?

            public var answerRate: Double?

            public var averageCustomerRingTime: Double?

            public var averageRingTime: Double?

            public var averageTalkTime: Int64?

            public var callsAgentHandled: Int64?

            public var callsAnswered: Int64?

            public var callsCustomerAnswered: Int64?

            public var callsCustomerHandled: Int64?

            public var callsDialed: Int64?

            public var customerAnswerRate: Double?

            public var customerHandleRate: Double?

            public var maxCustomerRingTime: Int64?

            public var maxRingTime: Int64?

            public var maxTalkTime: Int64?

            public var totalCustomerRingTime: Int64?

            public var totalRingTime: Int64?

            public var totalTalkTime: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.agentAnswerRate != nil {
                    map["AgentAnswerRate"] = self.agentAnswerRate!
                }
                if self.agentHandleRate != nil {
                    map["AgentHandleRate"] = self.agentHandleRate!
                }
                if self.answerRate != nil {
                    map["AnswerRate"] = self.answerRate!
                }
                if self.averageCustomerRingTime != nil {
                    map["AverageCustomerRingTime"] = self.averageCustomerRingTime!
                }
                if self.averageRingTime != nil {
                    map["AverageRingTime"] = self.averageRingTime!
                }
                if self.averageTalkTime != nil {
                    map["AverageTalkTime"] = self.averageTalkTime!
                }
                if self.callsAgentHandled != nil {
                    map["CallsAgentHandled"] = self.callsAgentHandled!
                }
                if self.callsAnswered != nil {
                    map["CallsAnswered"] = self.callsAnswered!
                }
                if self.callsCustomerAnswered != nil {
                    map["CallsCustomerAnswered"] = self.callsCustomerAnswered!
                }
                if self.callsCustomerHandled != nil {
                    map["CallsCustomerHandled"] = self.callsCustomerHandled!
                }
                if self.callsDialed != nil {
                    map["CallsDialed"] = self.callsDialed!
                }
                if self.customerAnswerRate != nil {
                    map["CustomerAnswerRate"] = self.customerAnswerRate!
                }
                if self.customerHandleRate != nil {
                    map["CustomerHandleRate"] = self.customerHandleRate!
                }
                if self.maxCustomerRingTime != nil {
                    map["MaxCustomerRingTime"] = self.maxCustomerRingTime!
                }
                if self.maxRingTime != nil {
                    map["MaxRingTime"] = self.maxRingTime!
                }
                if self.maxTalkTime != nil {
                    map["MaxTalkTime"] = self.maxTalkTime!
                }
                if self.totalCustomerRingTime != nil {
                    map["TotalCustomerRingTime"] = self.totalCustomerRingTime!
                }
                if self.totalRingTime != nil {
                    map["TotalRingTime"] = self.totalRingTime!
                }
                if self.totalTalkTime != nil {
                    map["TotalTalkTime"] = self.totalTalkTime!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AgentAnswerRate") {
                    self.agentAnswerRate = dict["AgentAnswerRate"] as! Double
                }
                if dict.keys.contains("AgentHandleRate") {
                    self.agentHandleRate = dict["AgentHandleRate"] as! Double
                }
                if dict.keys.contains("AnswerRate") {
                    self.answerRate = dict["AnswerRate"] as! Double
                }
                if dict.keys.contains("AverageCustomerRingTime") {
                    self.averageCustomerRingTime = dict["AverageCustomerRingTime"] as! Double
                }
                if dict.keys.contains("AverageRingTime") {
                    self.averageRingTime = dict["AverageRingTime"] as! Double
                }
                if dict.keys.contains("AverageTalkTime") {
                    self.averageTalkTime = dict["AverageTalkTime"] as! Int64
                }
                if dict.keys.contains("CallsAgentHandled") {
                    self.callsAgentHandled = dict["CallsAgentHandled"] as! Int64
                }
                if dict.keys.contains("CallsAnswered") {
                    self.callsAnswered = dict["CallsAnswered"] as! Int64
                }
                if dict.keys.contains("CallsCustomerAnswered") {
                    self.callsCustomerAnswered = dict["CallsCustomerAnswered"] as! Int64
                }
                if dict.keys.contains("CallsCustomerHandled") {
                    self.callsCustomerHandled = dict["CallsCustomerHandled"] as! Int64
                }
                if dict.keys.contains("CallsDialed") {
                    self.callsDialed = dict["CallsDialed"] as! Int64
                }
                if dict.keys.contains("CustomerAnswerRate") {
                    self.customerAnswerRate = dict["CustomerAnswerRate"] as! Double
                }
                if dict.keys.contains("CustomerHandleRate") {
                    self.customerHandleRate = dict["CustomerHandleRate"] as! Double
                }
                if dict.keys.contains("MaxCustomerRingTime") {
                    self.maxCustomerRingTime = dict["MaxCustomerRingTime"] as! Int64
                }
                if dict.keys.contains("MaxRingTime") {
                    self.maxRingTime = dict["MaxRingTime"] as! Int64
                }
                if dict.keys.contains("MaxTalkTime") {
                    self.maxTalkTime = dict["MaxTalkTime"] as! Int64
                }
                if dict.keys.contains("TotalCustomerRingTime") {
                    self.totalCustomerRingTime = dict["TotalCustomerRingTime"] as! Int64
                }
                if dict.keys.contains("TotalRingTime") {
                    self.totalRingTime = dict["TotalRingTime"] as! Int64
                }
                if dict.keys.contains("TotalTalkTime") {
                    self.totalTalkTime = dict["TotalTalkTime"] as! Int64
                }
            }
        }
        public class Inbound : Tea.TeaModel {
            public var averageFirstResponseTime: Double?

            public var averageHoldTime: Double?

            public var averageResponseTime: Double?

            public var averageRingTime: Double?

            public var averageTalkTime: Double?

            public var averageWorkTime: Double?

            public var callsAttendedTransferIn: Int64?

            public var callsAttendedTransferOut: Int64?

            public var callsBlindTransferIn: Int64?

            public var callsBlindTransferOut: Int64?

            public var callsHandled: Int64?

            public var callsHold: Int64?

            public var callsOffered: Int64?

            public var callsRinged: Int64?

            public var handleRate: Double?

            public var maxHoldTime: Int64?

            public var maxRingTime: Int64?

            public var maxTalkTime: Int64?

            public var maxWorkTime: Int64?

            public var satisfactionIndex: Double?

            public var satisfactionRate: Double?

            public var satisfactionSurveysOffered: Int64?

            public var satisfactionSurveysResponded: Int64?

            public var totalHoldTime: Int64?

            public var totalMessagesSent: Int64?

            public var totalMessagesSentByAgent: Int64?

            public var totalMessagesSentByCustomer: Int64?

            public var totalRingTime: Int64?

            public var totalTalkTime: Int64?

            public var totalWorkTime: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.averageFirstResponseTime != nil {
                    map["AverageFirstResponseTime"] = self.averageFirstResponseTime!
                }
                if self.averageHoldTime != nil {
                    map["AverageHoldTime"] = self.averageHoldTime!
                }
                if self.averageResponseTime != nil {
                    map["AverageResponseTime"] = self.averageResponseTime!
                }
                if self.averageRingTime != nil {
                    map["AverageRingTime"] = self.averageRingTime!
                }
                if self.averageTalkTime != nil {
                    map["AverageTalkTime"] = self.averageTalkTime!
                }
                if self.averageWorkTime != nil {
                    map["AverageWorkTime"] = self.averageWorkTime!
                }
                if self.callsAttendedTransferIn != nil {
                    map["CallsAttendedTransferIn"] = self.callsAttendedTransferIn!
                }
                if self.callsAttendedTransferOut != nil {
                    map["CallsAttendedTransferOut"] = self.callsAttendedTransferOut!
                }
                if self.callsBlindTransferIn != nil {
                    map["CallsBlindTransferIn"] = self.callsBlindTransferIn!
                }
                if self.callsBlindTransferOut != nil {
                    map["CallsBlindTransferOut"] = self.callsBlindTransferOut!
                }
                if self.callsHandled != nil {
                    map["CallsHandled"] = self.callsHandled!
                }
                if self.callsHold != nil {
                    map["CallsHold"] = self.callsHold!
                }
                if self.callsOffered != nil {
                    map["CallsOffered"] = self.callsOffered!
                }
                if self.callsRinged != nil {
                    map["CallsRinged"] = self.callsRinged!
                }
                if self.handleRate != nil {
                    map["HandleRate"] = self.handleRate!
                }
                if self.maxHoldTime != nil {
                    map["MaxHoldTime"] = self.maxHoldTime!
                }
                if self.maxRingTime != nil {
                    map["MaxRingTime"] = self.maxRingTime!
                }
                if self.maxTalkTime != nil {
                    map["MaxTalkTime"] = self.maxTalkTime!
                }
                if self.maxWorkTime != nil {
                    map["MaxWorkTime"] = self.maxWorkTime!
                }
                if self.satisfactionIndex != nil {
                    map["SatisfactionIndex"] = self.satisfactionIndex!
                }
                if self.satisfactionRate != nil {
                    map["SatisfactionRate"] = self.satisfactionRate!
                }
                if self.satisfactionSurveysOffered != nil {
                    map["SatisfactionSurveysOffered"] = self.satisfactionSurveysOffered!
                }
                if self.satisfactionSurveysResponded != nil {
                    map["SatisfactionSurveysResponded"] = self.satisfactionSurveysResponded!
                }
                if self.totalHoldTime != nil {
                    map["TotalHoldTime"] = self.totalHoldTime!
                }
                if self.totalMessagesSent != nil {
                    map["TotalMessagesSent"] = self.totalMessagesSent!
                }
                if self.totalMessagesSentByAgent != nil {
                    map["TotalMessagesSentByAgent"] = self.totalMessagesSentByAgent!
                }
                if self.totalMessagesSentByCustomer != nil {
                    map["TotalMessagesSentByCustomer"] = self.totalMessagesSentByCustomer!
                }
                if self.totalRingTime != nil {
                    map["TotalRingTime"] = self.totalRingTime!
                }
                if self.totalTalkTime != nil {
                    map["TotalTalkTime"] = self.totalTalkTime!
                }
                if self.totalWorkTime != nil {
                    map["TotalWorkTime"] = self.totalWorkTime!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AverageFirstResponseTime") {
                    self.averageFirstResponseTime = dict["AverageFirstResponseTime"] as! Double
                }
                if dict.keys.contains("AverageHoldTime") {
                    self.averageHoldTime = dict["AverageHoldTime"] as! Double
                }
                if dict.keys.contains("AverageResponseTime") {
                    self.averageResponseTime = dict["AverageResponseTime"] as! Double
                }
                if dict.keys.contains("AverageRingTime") {
                    self.averageRingTime = dict["AverageRingTime"] as! Double
                }
                if dict.keys.contains("AverageTalkTime") {
                    self.averageTalkTime = dict["AverageTalkTime"] as! Double
                }
                if dict.keys.contains("AverageWorkTime") {
                    self.averageWorkTime = dict["AverageWorkTime"] as! Double
                }
                if dict.keys.contains("CallsAttendedTransferIn") {
                    self.callsAttendedTransferIn = dict["CallsAttendedTransferIn"] as! Int64
                }
                if dict.keys.contains("CallsAttendedTransferOut") {
                    self.callsAttendedTransferOut = dict["CallsAttendedTransferOut"] as! Int64
                }
                if dict.keys.contains("CallsBlindTransferIn") {
                    self.callsBlindTransferIn = dict["CallsBlindTransferIn"] as! Int64
                }
                if dict.keys.contains("CallsBlindTransferOut") {
                    self.callsBlindTransferOut = dict["CallsBlindTransferOut"] as! Int64
                }
                if dict.keys.contains("CallsHandled") {
                    self.callsHandled = dict["CallsHandled"] as! Int64
                }
                if dict.keys.contains("CallsHold") {
                    self.callsHold = dict["CallsHold"] as! Int64
                }
                if dict.keys.contains("CallsOffered") {
                    self.callsOffered = dict["CallsOffered"] as! Int64
                }
                if dict.keys.contains("CallsRinged") {
                    self.callsRinged = dict["CallsRinged"] as! Int64
                }
                if dict.keys.contains("HandleRate") {
                    self.handleRate = dict["HandleRate"] as! Double
                }
                if dict.keys.contains("MaxHoldTime") {
                    self.maxHoldTime = dict["MaxHoldTime"] as! Int64
                }
                if dict.keys.contains("MaxRingTime") {
                    self.maxRingTime = dict["MaxRingTime"] as! Int64
                }
                if dict.keys.contains("MaxTalkTime") {
                    self.maxTalkTime = dict["MaxTalkTime"] as! Int64
                }
                if dict.keys.contains("MaxWorkTime") {
                    self.maxWorkTime = dict["MaxWorkTime"] as! Int64
                }
                if dict.keys.contains("SatisfactionIndex") {
                    self.satisfactionIndex = dict["SatisfactionIndex"] as! Double
                }
                if dict.keys.contains("SatisfactionRate") {
                    self.satisfactionRate = dict["SatisfactionRate"] as! Double
                }
                if dict.keys.contains("SatisfactionSurveysOffered") {
                    self.satisfactionSurveysOffered = dict["SatisfactionSurveysOffered"] as! Int64
                }
                if dict.keys.contains("SatisfactionSurveysResponded") {
                    self.satisfactionSurveysResponded = dict["SatisfactionSurveysResponded"] as! Int64
                }
                if dict.keys.contains("TotalHoldTime") {
                    self.totalHoldTime = dict["TotalHoldTime"] as! Int64
                }
                if dict.keys.contains("TotalMessagesSent") {
                    self.totalMessagesSent = dict["TotalMessagesSent"] as! Int64
                }
                if dict.keys.contains("TotalMessagesSentByAgent") {
                    self.totalMessagesSentByAgent = dict["TotalMessagesSentByAgent"] as! Int64
                }
                if dict.keys.contains("TotalMessagesSentByCustomer") {
                    self.totalMessagesSentByCustomer = dict["TotalMessagesSentByCustomer"] as! Int64
                }
                if dict.keys.contains("TotalRingTime") {
                    self.totalRingTime = dict["TotalRingTime"] as! Int64
                }
                if dict.keys.contains("TotalTalkTime") {
                    self.totalTalkTime = dict["TotalTalkTime"] as! Int64
                }
                if dict.keys.contains("TotalWorkTime") {
                    self.totalWorkTime = dict["TotalWorkTime"] as! Int64
                }
            }
        }
        public class Internal_ : Tea.TeaModel {
            public var averageTalkTime: Double?

            public var callsAnswered: Int64?

            public var callsDialed: Int64?

            public var callsHandled: Int64?

            public var callsOffered: Int64?

            public var callsTalk: Int64?

            public var callsTalked: Int64?

            public var maxTalkTime: Int64?

            public var totalTalkTime: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.averageTalkTime != nil {
                    map["AverageTalkTime"] = self.averageTalkTime!
                }
                if self.callsAnswered != nil {
                    map["CallsAnswered"] = self.callsAnswered!
                }
                if self.callsDialed != nil {
                    map["CallsDialed"] = self.callsDialed!
                }
                if self.callsHandled != nil {
                    map["CallsHandled"] = self.callsHandled!
                }
                if self.callsOffered != nil {
                    map["CallsOffered"] = self.callsOffered!
                }
                if self.callsTalk != nil {
                    map["CallsTalk"] = self.callsTalk!
                }
                if self.callsTalked != nil {
                    map["CallsTalked"] = self.callsTalked!
                }
                if self.maxTalkTime != nil {
                    map["MaxTalkTime"] = self.maxTalkTime!
                }
                if self.totalTalkTime != nil {
                    map["TotalTalkTime"] = self.totalTalkTime!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AverageTalkTime") {
                    self.averageTalkTime = dict["AverageTalkTime"] as! Double
                }
                if dict.keys.contains("CallsAnswered") {
                    self.callsAnswered = dict["CallsAnswered"] as! Int64
                }
                if dict.keys.contains("CallsDialed") {
                    self.callsDialed = dict["CallsDialed"] as! Int64
                }
                if dict.keys.contains("CallsHandled") {
                    self.callsHandled = dict["CallsHandled"] as! Int64
                }
                if dict.keys.contains("CallsOffered") {
                    self.callsOffered = dict["CallsOffered"] as! Int64
                }
                if dict.keys.contains("CallsTalk") {
                    self.callsTalk = dict["CallsTalk"] as! Int64
                }
                if dict.keys.contains("CallsTalked") {
                    self.callsTalked = dict["CallsTalked"] as! Int64
                }
                if dict.keys.contains("MaxTalkTime") {
                    self.maxTalkTime = dict["MaxTalkTime"] as! Int64
                }
                if dict.keys.contains("TotalTalkTime") {
                    self.totalTalkTime = dict["TotalTalkTime"] as! Int64
                }
            }
        }
        public class Outbound : Tea.TeaModel {
            public var answerRate: Double?

            public var averageDialingTime: Double?

            public var averageHoldTime: Double?

            public var averageRingTime: Double?

            public var averageTalkTime: Double?

            public var averageWorkTime: Double?

            public var callsAnswered: Int64?

            public var callsAttendedTransferIn: Int64?

            public var callsAttendedTransferOut: Int64?

            public var callsBlindTransferIn: Int64?

            public var callsBlindTransferOut: Int64?

            public var callsDialed: Int64?

            public var callsHold: Int64?

            public var callsRinged: Int64?

            public var maxDialingTime: Int64?

            public var maxHoldTime: Int64?

            public var maxRingTime: Int64?

            public var maxTalkTime: Int64?

            public var maxWorkTime: Int64?

            public var satisfactionIndex: Double?

            public var satisfactionRate: Double?

            public var satisfactionSurveysOffered: Int64?

            public var satisfactionSurveysResponded: Int64?

            public var totalDialingTime: Int64?

            public var totalHoldTime: Int64?

            public var totalRingTime: Int64?

            public var totalTalkTime: Int64?

            public var totalWorkTime: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.answerRate != nil {
                    map["AnswerRate"] = self.answerRate!
                }
                if self.averageDialingTime != nil {
                    map["AverageDialingTime"] = self.averageDialingTime!
                }
                if self.averageHoldTime != nil {
                    map["AverageHoldTime"] = self.averageHoldTime!
                }
                if self.averageRingTime != nil {
                    map["AverageRingTime"] = self.averageRingTime!
                }
                if self.averageTalkTime != nil {
                    map["AverageTalkTime"] = self.averageTalkTime!
                }
                if self.averageWorkTime != nil {
                    map["AverageWorkTime"] = self.averageWorkTime!
                }
                if self.callsAnswered != nil {
                    map["CallsAnswered"] = self.callsAnswered!
                }
                if self.callsAttendedTransferIn != nil {
                    map["CallsAttendedTransferIn"] = self.callsAttendedTransferIn!
                }
                if self.callsAttendedTransferOut != nil {
                    map["CallsAttendedTransferOut"] = self.callsAttendedTransferOut!
                }
                if self.callsBlindTransferIn != nil {
                    map["CallsBlindTransferIn"] = self.callsBlindTransferIn!
                }
                if self.callsBlindTransferOut != nil {
                    map["CallsBlindTransferOut"] = self.callsBlindTransferOut!
                }
                if self.callsDialed != nil {
                    map["CallsDialed"] = self.callsDialed!
                }
                if self.callsHold != nil {
                    map["CallsHold"] = self.callsHold!
                }
                if self.callsRinged != nil {
                    map["CallsRinged"] = self.callsRinged!
                }
                if self.maxDialingTime != nil {
                    map["MaxDialingTime"] = self.maxDialingTime!
                }
                if self.maxHoldTime != nil {
                    map["MaxHoldTime"] = self.maxHoldTime!
                }
                if self.maxRingTime != nil {
                    map["MaxRingTime"] = self.maxRingTime!
                }
                if self.maxTalkTime != nil {
                    map["MaxTalkTime"] = self.maxTalkTime!
                }
                if self.maxWorkTime != nil {
                    map["MaxWorkTime"] = self.maxWorkTime!
                }
                if self.satisfactionIndex != nil {
                    map["SatisfactionIndex"] = self.satisfactionIndex!
                }
                if self.satisfactionRate != nil {
                    map["SatisfactionRate"] = self.satisfactionRate!
                }
                if self.satisfactionSurveysOffered != nil {
                    map["SatisfactionSurveysOffered"] = self.satisfactionSurveysOffered!
                }
                if self.satisfactionSurveysResponded != nil {
                    map["SatisfactionSurveysResponded"] = self.satisfactionSurveysResponded!
                }
                if self.totalDialingTime != nil {
                    map["TotalDialingTime"] = self.totalDialingTime!
                }
                if self.totalHoldTime != nil {
                    map["TotalHoldTime"] = self.totalHoldTime!
                }
                if self.totalRingTime != nil {
                    map["TotalRingTime"] = self.totalRingTime!
                }
                if self.totalTalkTime != nil {
                    map["TotalTalkTime"] = self.totalTalkTime!
                }
                if self.totalWorkTime != nil {
                    map["TotalWorkTime"] = self.totalWorkTime!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AnswerRate") {
                    self.answerRate = dict["AnswerRate"] as! Double
                }
                if dict.keys.contains("AverageDialingTime") {
                    self.averageDialingTime = dict["AverageDialingTime"] as! Double
                }
                if dict.keys.contains("AverageHoldTime") {
                    self.averageHoldTime = dict["AverageHoldTime"] as! Double
                }
                if dict.keys.contains("AverageRingTime") {
                    self.averageRingTime = dict["AverageRingTime"] as! Double
                }
                if dict.keys.contains("AverageTalkTime") {
                    self.averageTalkTime = dict["AverageTalkTime"] as! Double
                }
                if dict.keys.contains("AverageWorkTime") {
                    self.averageWorkTime = dict["AverageWorkTime"] as! Double
                }
                if dict.keys.contains("CallsAnswered") {
                    self.callsAnswered = dict["CallsAnswered"] as! Int64
                }
                if dict.keys.contains("CallsAttendedTransferIn") {
                    self.callsAttendedTransferIn = dict["CallsAttendedTransferIn"] as! Int64
                }
                if dict.keys.contains("CallsAttendedTransferOut") {
                    self.callsAttendedTransferOut = dict["CallsAttendedTransferOut"] as! Int64
                }
                if dict.keys.contains("CallsBlindTransferIn") {
                    self.callsBlindTransferIn = dict["CallsBlindTransferIn"] as! Int64
                }
                if dict.keys.contains("CallsBlindTransferOut") {
                    self.callsBlindTransferOut = dict["CallsBlindTransferOut"] as! Int64
                }
                if dict.keys.contains("CallsDialed") {
                    self.callsDialed = dict["CallsDialed"] as! Int64
                }
                if dict.keys.contains("CallsHold") {
                    self.callsHold = dict["CallsHold"] as! Int64
                }
                if dict.keys.contains("CallsRinged") {
                    self.callsRinged = dict["CallsRinged"] as! Int64
                }
                if dict.keys.contains("MaxDialingTime") {
                    self.maxDialingTime = dict["MaxDialingTime"] as! Int64
                }
                if dict.keys.contains("MaxHoldTime") {
                    self.maxHoldTime = dict["MaxHoldTime"] as! Int64
                }
                if dict.keys.contains("MaxRingTime") {
                    self.maxRingTime = dict["MaxRingTime"] as! Int64
                }
                if dict.keys.contains("MaxTalkTime") {
                    self.maxTalkTime = dict["MaxTalkTime"] as! Int64
                }
                if dict.keys.contains("MaxWorkTime") {
                    self.maxWorkTime = dict["MaxWorkTime"] as! Int64
                }
                if dict.keys.contains("SatisfactionIndex") {
                    self.satisfactionIndex = dict["SatisfactionIndex"] as! Double
                }
                if dict.keys.contains("SatisfactionRate") {
                    self.satisfactionRate = dict["SatisfactionRate"] as! Double
                }
                if dict.keys.contains("SatisfactionSurveysOffered") {
                    self.satisfactionSurveysOffered = dict["SatisfactionSurveysOffered"] as! Int64
                }
                if dict.keys.contains("SatisfactionSurveysResponded") {
                    self.satisfactionSurveysResponded = dict["SatisfactionSurveysResponded"] as! Int64
                }
                if dict.keys.contains("TotalDialingTime") {
                    self.totalDialingTime = dict["TotalDialingTime"] as! Int64
                }
                if dict.keys.contains("TotalHoldTime") {
                    self.totalHoldTime = dict["TotalHoldTime"] as! Int64
                }
                if dict.keys.contains("TotalRingTime") {
                    self.totalRingTime = dict["TotalRingTime"] as! Int64
                }
                if dict.keys.contains("TotalTalkTime") {
                    self.totalTalkTime = dict["TotalTalkTime"] as! Int64
                }
                if dict.keys.contains("TotalWorkTime") {
                    self.totalWorkTime = dict["TotalWorkTime"] as! Int64
                }
            }
        }
        public class Overall : Tea.TeaModel {
            public class BreakCodeDetailList : Tea.TeaModel {
                public var breakCode: String?

                public var count: Int64?

                public var duration: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.breakCode != nil {
                        map["BreakCode"] = self.breakCode!
                    }
                    if self.count != nil {
                        map["Count"] = self.count!
                    }
                    if self.duration != nil {
                        map["Duration"] = self.duration!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("BreakCode") {
                        self.breakCode = dict["BreakCode"] as! String
                    }
                    if dict.keys.contains("Count") {
                        self.count = dict["Count"] as! Int64
                    }
                    if dict.keys.contains("Duration") {
                        self.duration = dict["Duration"] as! Int64
                    }
                }
            }
            public var averageBreakTime: Double?

            public var averageHoldTime: Double?

            public var averageReadyTime: Double?

            public var averageTalkTime: Double?

            public var averageWorkTime: Double?

            public var breakCodeDetailList: [ListIntervalAgentSkillGroupReportResponseBody.Data.Overall.BreakCodeDetailList]?

            public var firstCheckInTime: Int64?

            public var lastCheckOutTime: Int64?

            public var lastCheckoutTime: Int64?

            public var maxBreakTime: Int64?

            public var maxHoldTime: Int64?

            public var maxReadyTime: Int64?

            public var maxTalkTime: Int64?

            public var maxWorkTime: Int64?

            public var occupancyRate: Double?

            public var satisfactionIndex: Double?

            public var satisfactionRate: Double?

            public var satisfactionSurveysOffered: Int64?

            public var satisfactionSurveysResponded: Int64?

            public var totalBreakTime: Int64?

            public var totalCalls: Int64?

            public var totalHoldTime: Int64?

            public var totalLoggedInTime: Int64?

            public var totalOffSiteLoggedInTime: String?

            public var totalOfficePhoneLoggedInTime: String?

            public var totalOnSiteLoggedInTime: String?

            public var totalOutboundScenarioLoggedInTime: Int64?

            public var totalOutboundScenarioReadyTime: Int64?

            public var totalOutboundScenarioTime: Int64?

            public var totalReadyTime: Int64?

            public var totalTalkTime: Int64?

            public var totalWorkTime: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.averageBreakTime != nil {
                    map["AverageBreakTime"] = self.averageBreakTime!
                }
                if self.averageHoldTime != nil {
                    map["AverageHoldTime"] = self.averageHoldTime!
                }
                if self.averageReadyTime != nil {
                    map["AverageReadyTime"] = self.averageReadyTime!
                }
                if self.averageTalkTime != nil {
                    map["AverageTalkTime"] = self.averageTalkTime!
                }
                if self.averageWorkTime != nil {
                    map["AverageWorkTime"] = self.averageWorkTime!
                }
                if self.breakCodeDetailList != nil {
                    var tmp : [Any] = []
                    for k in self.breakCodeDetailList! {
                        tmp.append(k.toMap())
                    }
                    map["BreakCodeDetailList"] = tmp
                }
                if self.firstCheckInTime != nil {
                    map["FirstCheckInTime"] = self.firstCheckInTime!
                }
                if self.lastCheckOutTime != nil {
                    map["LastCheckOutTime"] = self.lastCheckOutTime!
                }
                if self.lastCheckoutTime != nil {
                    map["LastCheckoutTime"] = self.lastCheckoutTime!
                }
                if self.maxBreakTime != nil {
                    map["MaxBreakTime"] = self.maxBreakTime!
                }
                if self.maxHoldTime != nil {
                    map["MaxHoldTime"] = self.maxHoldTime!
                }
                if self.maxReadyTime != nil {
                    map["MaxReadyTime"] = self.maxReadyTime!
                }
                if self.maxTalkTime != nil {
                    map["MaxTalkTime"] = self.maxTalkTime!
                }
                if self.maxWorkTime != nil {
                    map["MaxWorkTime"] = self.maxWorkTime!
                }
                if self.occupancyRate != nil {
                    map["OccupancyRate"] = self.occupancyRate!
                }
                if self.satisfactionIndex != nil {
                    map["SatisfactionIndex"] = self.satisfactionIndex!
                }
                if self.satisfactionRate != nil {
                    map["SatisfactionRate"] = self.satisfactionRate!
                }
                if self.satisfactionSurveysOffered != nil {
                    map["SatisfactionSurveysOffered"] = self.satisfactionSurveysOffered!
                }
                if self.satisfactionSurveysResponded != nil {
                    map["SatisfactionSurveysResponded"] = self.satisfactionSurveysResponded!
                }
                if self.totalBreakTime != nil {
                    map["TotalBreakTime"] = self.totalBreakTime!
                }
                if self.totalCalls != nil {
                    map["TotalCalls"] = self.totalCalls!
                }
                if self.totalHoldTime != nil {
                    map["TotalHoldTime"] = self.totalHoldTime!
                }
                if self.totalLoggedInTime != nil {
                    map["TotalLoggedInTime"] = self.totalLoggedInTime!
                }
                if self.totalOffSiteLoggedInTime != nil {
                    map["TotalOffSiteLoggedInTime"] = self.totalOffSiteLoggedInTime!
                }
                if self.totalOfficePhoneLoggedInTime != nil {
                    map["TotalOfficePhoneLoggedInTime"] = self.totalOfficePhoneLoggedInTime!
                }
                if self.totalOnSiteLoggedInTime != nil {
                    map["TotalOnSiteLoggedInTime"] = self.totalOnSiteLoggedInTime!
                }
                if self.totalOutboundScenarioLoggedInTime != nil {
                    map["TotalOutboundScenarioLoggedInTime"] = self.totalOutboundScenarioLoggedInTime!
                }
                if self.totalOutboundScenarioReadyTime != nil {
                    map["TotalOutboundScenarioReadyTime"] = self.totalOutboundScenarioReadyTime!
                }
                if self.totalOutboundScenarioTime != nil {
                    map["TotalOutboundScenarioTime"] = self.totalOutboundScenarioTime!
                }
                if self.totalReadyTime != nil {
                    map["TotalReadyTime"] = self.totalReadyTime!
                }
                if self.totalTalkTime != nil {
                    map["TotalTalkTime"] = self.totalTalkTime!
                }
                if self.totalWorkTime != nil {
                    map["TotalWorkTime"] = self.totalWorkTime!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AverageBreakTime") {
                    self.averageBreakTime = dict["AverageBreakTime"] as! Double
                }
                if dict.keys.contains("AverageHoldTime") {
                    self.averageHoldTime = dict["AverageHoldTime"] as! Double
                }
                if dict.keys.contains("AverageReadyTime") {
                    self.averageReadyTime = dict["AverageReadyTime"] as! Double
                }
                if dict.keys.contains("AverageTalkTime") {
                    self.averageTalkTime = dict["AverageTalkTime"] as! Double
                }
                if dict.keys.contains("AverageWorkTime") {
                    self.averageWorkTime = dict["AverageWorkTime"] as! Double
                }
                if dict.keys.contains("BreakCodeDetailList") {
                    var tmp : [ListIntervalAgentSkillGroupReportResponseBody.Data.Overall.BreakCodeDetailList] = []
                    for v in dict["BreakCodeDetailList"] as! [Any] {
                        var model = ListIntervalAgentSkillGroupReportResponseBody.Data.Overall.BreakCodeDetailList()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.breakCodeDetailList = tmp
                }
                if dict.keys.contains("FirstCheckInTime") {
                    self.firstCheckInTime = dict["FirstCheckInTime"] as! Int64
                }
                if dict.keys.contains("LastCheckOutTime") {
                    self.lastCheckOutTime = dict["LastCheckOutTime"] as! Int64
                }
                if dict.keys.contains("LastCheckoutTime") {
                    self.lastCheckoutTime = dict["LastCheckoutTime"] as! Int64
                }
                if dict.keys.contains("MaxBreakTime") {
                    self.maxBreakTime = dict["MaxBreakTime"] as! Int64
                }
                if dict.keys.contains("MaxHoldTime") {
                    self.maxHoldTime = dict["MaxHoldTime"] as! Int64
                }
                if dict.keys.contains("MaxReadyTime") {
                    self.maxReadyTime = dict["MaxReadyTime"] as! Int64
                }
                if dict.keys.contains("MaxTalkTime") {
                    self.maxTalkTime = dict["MaxTalkTime"] as! Int64
                }
                if dict.keys.contains("MaxWorkTime") {
                    self.maxWorkTime = dict["MaxWorkTime"] as! Int64
                }
                if dict.keys.contains("OccupancyRate") {
                    self.occupancyRate = dict["OccupancyRate"] as! Double
                }
                if dict.keys.contains("SatisfactionIndex") {
                    self.satisfactionIndex = dict["SatisfactionIndex"] as! Double
                }
                if dict.keys.contains("SatisfactionRate") {
                    self.satisfactionRate = dict["SatisfactionRate"] as! Double
                }
                if dict.keys.contains("SatisfactionSurveysOffered") {
                    self.satisfactionSurveysOffered = dict["SatisfactionSurveysOffered"] as! Int64
                }
                if dict.keys.contains("SatisfactionSurveysResponded") {
                    self.satisfactionSurveysResponded = dict["SatisfactionSurveysResponded"] as! Int64
                }
                if dict.keys.contains("TotalBreakTime") {
                    self.totalBreakTime = dict["TotalBreakTime"] as! Int64
                }
                if dict.keys.contains("TotalCalls") {
                    self.totalCalls = dict["TotalCalls"] as! Int64
                }
                if dict.keys.contains("TotalHoldTime") {
                    self.totalHoldTime = dict["TotalHoldTime"] as! Int64
                }
                if dict.keys.contains("TotalLoggedInTime") {
                    self.totalLoggedInTime = dict["TotalLoggedInTime"] as! Int64
                }
                if dict.keys.contains("TotalOffSiteLoggedInTime") {
                    self.totalOffSiteLoggedInTime = dict["TotalOffSiteLoggedInTime"] as! String
                }
                if dict.keys.contains("TotalOfficePhoneLoggedInTime") {
                    self.totalOfficePhoneLoggedInTime = dict["TotalOfficePhoneLoggedInTime"] as! String
                }
                if dict.keys.contains("TotalOnSiteLoggedInTime") {
                    self.totalOnSiteLoggedInTime = dict["TotalOnSiteLoggedInTime"] as! String
                }
                if dict.keys.contains("TotalOutboundScenarioLoggedInTime") {
                    self.totalOutboundScenarioLoggedInTime = dict["TotalOutboundScenarioLoggedInTime"] as! Int64
                }
                if dict.keys.contains("TotalOutboundScenarioReadyTime") {
                    self.totalOutboundScenarioReadyTime = dict["TotalOutboundScenarioReadyTime"] as! Int64
                }
                if dict.keys.contains("TotalOutboundScenarioTime") {
                    self.totalOutboundScenarioTime = dict["TotalOutboundScenarioTime"] as! Int64
                }
                if dict.keys.contains("TotalReadyTime") {
                    self.totalReadyTime = dict["TotalReadyTime"] as! Int64
                }
                if dict.keys.contains("TotalTalkTime") {
                    self.totalTalkTime = dict["TotalTalkTime"] as! Int64
                }
                if dict.keys.contains("TotalWorkTime") {
                    self.totalWorkTime = dict["TotalWorkTime"] as! Int64
                }
            }
        }
        public var back2Back: ListIntervalAgentSkillGroupReportResponseBody.Data.Back2Back?

        public var inbound: ListIntervalAgentSkillGroupReportResponseBody.Data.Inbound?

        public var internal_: ListIntervalAgentSkillGroupReportResponseBody.Data.Internal_?

        public var outbound: ListIntervalAgentSkillGroupReportResponseBody.Data.Outbound?

        public var overall: ListIntervalAgentSkillGroupReportResponseBody.Data.Overall?

        public var statsTime: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.back2Back?.validate()
            try self.inbound?.validate()
            try self.internal_?.validate()
            try self.outbound?.validate()
            try self.overall?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.back2Back != nil {
                map["Back2Back"] = self.back2Back?.toMap()
            }
            if self.inbound != nil {
                map["Inbound"] = self.inbound?.toMap()
            }
            if self.internal_ != nil {
                map["Internal"] = self.internal_?.toMap()
            }
            if self.outbound != nil {
                map["Outbound"] = self.outbound?.toMap()
            }
            if self.overall != nil {
                map["Overall"] = self.overall?.toMap()
            }
            if self.statsTime != nil {
                map["StatsTime"] = self.statsTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Back2Back") {
                var model = ListIntervalAgentSkillGroupReportResponseBody.Data.Back2Back()
                model.fromMap(dict["Back2Back"] as! [String: Any])
                self.back2Back = model
            }
            if dict.keys.contains("Inbound") {
                var model = ListIntervalAgentSkillGroupReportResponseBody.Data.Inbound()
                model.fromMap(dict["Inbound"] as! [String: Any])
                self.inbound = model
            }
            if dict.keys.contains("Internal") {
                var model = ListIntervalAgentSkillGroupReportResponseBody.Data.Internal_()
                model.fromMap(dict["Internal"] as! [String: Any])
                self.internal_ = model
            }
            if dict.keys.contains("Outbound") {
                var model = ListIntervalAgentSkillGroupReportResponseBody.Data.Outbound()
                model.fromMap(dict["Outbound"] as! [String: Any])
                self.outbound = model
            }
            if dict.keys.contains("Overall") {
                var model = ListIntervalAgentSkillGroupReportResponseBody.Data.Overall()
                model.fromMap(dict["Overall"] as! [String: Any])
                self.overall = model
            }
            if dict.keys.contains("StatsTime") {
                self.statsTime = dict["StatsTime"] as! Int64
            }
        }
    }
    public var code: String?

    public var data: [ListIntervalAgentSkillGroupReportResponseBody.Data]?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var tmp : [ListIntervalAgentSkillGroupReportResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = ListIntervalAgentSkillGroupReportResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListIntervalAgentSkillGroupReportResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListIntervalAgentSkillGroupReportResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListIntervalAgentSkillGroupReportResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListIntervalInstanceReportRequest : Tea.TeaModel {
    public var endTime: Int64?

    public var instanceId: String?

    public var interval: String?

    public var startTime: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.interval != nil {
            map["Interval"] = self.interval!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Interval") {
            self.interval = dict["Interval"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! Int64
        }
    }
}

public class ListIntervalInstanceReportResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Inbound : Tea.TeaModel {
            public var abandonRate: Double?

            public var abandonedRate: Double?

            public var averageAbandonTime: Double?

            public var averageAbandonedInIVRTime: Double?

            public var averageAbandonedInQueueTime: Double?

            public var averageAbandonedInRingTime: Double?

            public var averageFirstResponseTime: Double?

            public var averageHoldTime: Double?

            public var averageResponseTime: Double?

            public var averageRingTime: Double?

            public var averageTalkTime: Double?

            public var averageWaitTime: Double?

            public var averageWorkTime: Double?

            public var callsAbandoned: Int64?

            public var callsAbandonedInIVR: Int64?

            public var callsAbandonedInQueue: Int64?

            public var callsAbandonedInRing: Int64?

            public var callsAbandonedInVoiceNavigator: Int64?

            public var callsAttendedTransferred: Int64?

            public var callsBlindTransferred: Int64?

            public var callsCausedIVRException: Int64?

            public var callsForwardToOutsideNumber: Int64?

            public var callsHandled: Int64?

            public var callsHold: Int64?

            public var callsIVRException: Int64?

            public var callsOffered: Int64?

            public var callsQueued: Int64?

            public var callsQueuingFailed: Int64?

            public var callsQueuingOverflow: Int64?

            public var callsQueuingTimeout: Int64?

            public var callsRinged: Int64?

            public var callsToVoicemail: Int64?

            public var callsVoicemail: Int64?

            public var handleRate: Double?

            public var maxAbandonTime: Int64?

            public var maxAbandonedInIVRTime: Int64?

            public var maxAbandonedInQueueTime: Int64?

            public var maxAbandonedInRingTime: Int64?

            public var maxHoldTime: Int64?

            public var maxRingTime: Int64?

            public var maxTalkTime: Int64?

            public var maxWaitTime: Int64?

            public var maxWorkTime: Int64?

            public var satisfactionIndex: Double?

            public var satisfactionRate: Double?

            public var satisfactionSurveysOffered: Int64?

            public var satisfactionSurveysResponded: Int64?

            public var serviceLevel20: Double?

            public var totalAbandonTime: Int64?

            public var totalAbandonedInIVRTime: Int64?

            public var totalAbandonedInQueueTime: Int64?

            public var totalAbandonedInRingTime: Int64?

            public var totalHoldTime: Int64?

            public var totalMessagesSent: Int64?

            public var totalMessagesSentByAgent: Int64?

            public var totalMessagesSentByCustomer: Int64?

            public var totalRingTime: Int64?

            public var totalTalkTime: Int64?

            public var totalWaitTime: Int64?

            public var totalWorkTime: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.abandonRate != nil {
                    map["AbandonRate"] = self.abandonRate!
                }
                if self.abandonedRate != nil {
                    map["AbandonedRate"] = self.abandonedRate!
                }
                if self.averageAbandonTime != nil {
                    map["AverageAbandonTime"] = self.averageAbandonTime!
                }
                if self.averageAbandonedInIVRTime != nil {
                    map["AverageAbandonedInIVRTime"] = self.averageAbandonedInIVRTime!
                }
                if self.averageAbandonedInQueueTime != nil {
                    map["AverageAbandonedInQueueTime"] = self.averageAbandonedInQueueTime!
                }
                if self.averageAbandonedInRingTime != nil {
                    map["AverageAbandonedInRingTime"] = self.averageAbandonedInRingTime!
                }
                if self.averageFirstResponseTime != nil {
                    map["AverageFirstResponseTime"] = self.averageFirstResponseTime!
                }
                if self.averageHoldTime != nil {
                    map["AverageHoldTime"] = self.averageHoldTime!
                }
                if self.averageResponseTime != nil {
                    map["AverageResponseTime"] = self.averageResponseTime!
                }
                if self.averageRingTime != nil {
                    map["AverageRingTime"] = self.averageRingTime!
                }
                if self.averageTalkTime != nil {
                    map["AverageTalkTime"] = self.averageTalkTime!
                }
                if self.averageWaitTime != nil {
                    map["AverageWaitTime"] = self.averageWaitTime!
                }
                if self.averageWorkTime != nil {
                    map["AverageWorkTime"] = self.averageWorkTime!
                }
                if self.callsAbandoned != nil {
                    map["CallsAbandoned"] = self.callsAbandoned!
                }
                if self.callsAbandonedInIVR != nil {
                    map["CallsAbandonedInIVR"] = self.callsAbandonedInIVR!
                }
                if self.callsAbandonedInQueue != nil {
                    map["CallsAbandonedInQueue"] = self.callsAbandonedInQueue!
                }
                if self.callsAbandonedInRing != nil {
                    map["CallsAbandonedInRing"] = self.callsAbandonedInRing!
                }
                if self.callsAbandonedInVoiceNavigator != nil {
                    map["CallsAbandonedInVoiceNavigator"] = self.callsAbandonedInVoiceNavigator!
                }
                if self.callsAttendedTransferred != nil {
                    map["CallsAttendedTransferred"] = self.callsAttendedTransferred!
                }
                if self.callsBlindTransferred != nil {
                    map["CallsBlindTransferred"] = self.callsBlindTransferred!
                }
                if self.callsCausedIVRException != nil {
                    map["CallsCausedIVRException"] = self.callsCausedIVRException!
                }
                if self.callsForwardToOutsideNumber != nil {
                    map["CallsForwardToOutsideNumber"] = self.callsForwardToOutsideNumber!
                }
                if self.callsHandled != nil {
                    map["CallsHandled"] = self.callsHandled!
                }
                if self.callsHold != nil {
                    map["CallsHold"] = self.callsHold!
                }
                if self.callsIVRException != nil {
                    map["CallsIVRException"] = self.callsIVRException!
                }
                if self.callsOffered != nil {
                    map["CallsOffered"] = self.callsOffered!
                }
                if self.callsQueued != nil {
                    map["CallsQueued"] = self.callsQueued!
                }
                if self.callsQueuingFailed != nil {
                    map["CallsQueuingFailed"] = self.callsQueuingFailed!
                }
                if self.callsQueuingOverflow != nil {
                    map["CallsQueuingOverflow"] = self.callsQueuingOverflow!
                }
                if self.callsQueuingTimeout != nil {
                    map["CallsQueuingTimeout"] = self.callsQueuingTimeout!
                }
                if self.callsRinged != nil {
                    map["CallsRinged"] = self.callsRinged!
                }
                if self.callsToVoicemail != nil {
                    map["CallsToVoicemail"] = self.callsToVoicemail!
                }
                if self.callsVoicemail != nil {
                    map["CallsVoicemail"] = self.callsVoicemail!
                }
                if self.handleRate != nil {
                    map["HandleRate"] = self.handleRate!
                }
                if self.maxAbandonTime != nil {
                    map["MaxAbandonTime"] = self.maxAbandonTime!
                }
                if self.maxAbandonedInIVRTime != nil {
                    map["MaxAbandonedInIVRTime"] = self.maxAbandonedInIVRTime!
                }
                if self.maxAbandonedInQueueTime != nil {
                    map["MaxAbandonedInQueueTime"] = self.maxAbandonedInQueueTime!
                }
                if self.maxAbandonedInRingTime != nil {
                    map["MaxAbandonedInRingTime"] = self.maxAbandonedInRingTime!
                }
                if self.maxHoldTime != nil {
                    map["MaxHoldTime"] = self.maxHoldTime!
                }
                if self.maxRingTime != nil {
                    map["MaxRingTime"] = self.maxRingTime!
                }
                if self.maxTalkTime != nil {
                    map["MaxTalkTime"] = self.maxTalkTime!
                }
                if self.maxWaitTime != nil {
                    map["MaxWaitTime"] = self.maxWaitTime!
                }
                if self.maxWorkTime != nil {
                    map["MaxWorkTime"] = self.maxWorkTime!
                }
                if self.satisfactionIndex != nil {
                    map["SatisfactionIndex"] = self.satisfactionIndex!
                }
                if self.satisfactionRate != nil {
                    map["SatisfactionRate"] = self.satisfactionRate!
                }
                if self.satisfactionSurveysOffered != nil {
                    map["SatisfactionSurveysOffered"] = self.satisfactionSurveysOffered!
                }
                if self.satisfactionSurveysResponded != nil {
                    map["SatisfactionSurveysResponded"] = self.satisfactionSurveysResponded!
                }
                if self.serviceLevel20 != nil {
                    map["ServiceLevel20"] = self.serviceLevel20!
                }
                if self.totalAbandonTime != nil {
                    map["TotalAbandonTime"] = self.totalAbandonTime!
                }
                if self.totalAbandonedInIVRTime != nil {
                    map["TotalAbandonedInIVRTime"] = self.totalAbandonedInIVRTime!
                }
                if self.totalAbandonedInQueueTime != nil {
                    map["TotalAbandonedInQueueTime"] = self.totalAbandonedInQueueTime!
                }
                if self.totalAbandonedInRingTime != nil {
                    map["TotalAbandonedInRingTime"] = self.totalAbandonedInRingTime!
                }
                if self.totalHoldTime != nil {
                    map["TotalHoldTime"] = self.totalHoldTime!
                }
                if self.totalMessagesSent != nil {
                    map["TotalMessagesSent"] = self.totalMessagesSent!
                }
                if self.totalMessagesSentByAgent != nil {
                    map["TotalMessagesSentByAgent"] = self.totalMessagesSentByAgent!
                }
                if self.totalMessagesSentByCustomer != nil {
                    map["TotalMessagesSentByCustomer"] = self.totalMessagesSentByCustomer!
                }
                if self.totalRingTime != nil {
                    map["TotalRingTime"] = self.totalRingTime!
                }
                if self.totalTalkTime != nil {
                    map["TotalTalkTime"] = self.totalTalkTime!
                }
                if self.totalWaitTime != nil {
                    map["TotalWaitTime"] = self.totalWaitTime!
                }
                if self.totalWorkTime != nil {
                    map["TotalWorkTime"] = self.totalWorkTime!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AbandonRate") {
                    self.abandonRate = dict["AbandonRate"] as! Double
                }
                if dict.keys.contains("AbandonedRate") {
                    self.abandonedRate = dict["AbandonedRate"] as! Double
                }
                if dict.keys.contains("AverageAbandonTime") {
                    self.averageAbandonTime = dict["AverageAbandonTime"] as! Double
                }
                if dict.keys.contains("AverageAbandonedInIVRTime") {
                    self.averageAbandonedInIVRTime = dict["AverageAbandonedInIVRTime"] as! Double
                }
                if dict.keys.contains("AverageAbandonedInQueueTime") {
                    self.averageAbandonedInQueueTime = dict["AverageAbandonedInQueueTime"] as! Double
                }
                if dict.keys.contains("AverageAbandonedInRingTime") {
                    self.averageAbandonedInRingTime = dict["AverageAbandonedInRingTime"] as! Double
                }
                if dict.keys.contains("AverageFirstResponseTime") {
                    self.averageFirstResponseTime = dict["AverageFirstResponseTime"] as! Double
                }
                if dict.keys.contains("AverageHoldTime") {
                    self.averageHoldTime = dict["AverageHoldTime"] as! Double
                }
                if dict.keys.contains("AverageResponseTime") {
                    self.averageResponseTime = dict["AverageResponseTime"] as! Double
                }
                if dict.keys.contains("AverageRingTime") {
                    self.averageRingTime = dict["AverageRingTime"] as! Double
                }
                if dict.keys.contains("AverageTalkTime") {
                    self.averageTalkTime = dict["AverageTalkTime"] as! Double
                }
                if dict.keys.contains("AverageWaitTime") {
                    self.averageWaitTime = dict["AverageWaitTime"] as! Double
                }
                if dict.keys.contains("AverageWorkTime") {
                    self.averageWorkTime = dict["AverageWorkTime"] as! Double
                }
                if dict.keys.contains("CallsAbandoned") {
                    self.callsAbandoned = dict["CallsAbandoned"] as! Int64
                }
                if dict.keys.contains("CallsAbandonedInIVR") {
                    self.callsAbandonedInIVR = dict["CallsAbandonedInIVR"] as! Int64
                }
                if dict.keys.contains("CallsAbandonedInQueue") {
                    self.callsAbandonedInQueue = dict["CallsAbandonedInQueue"] as! Int64
                }
                if dict.keys.contains("CallsAbandonedInRing") {
                    self.callsAbandonedInRing = dict["CallsAbandonedInRing"] as! Int64
                }
                if dict.keys.contains("CallsAbandonedInVoiceNavigator") {
                    self.callsAbandonedInVoiceNavigator = dict["CallsAbandonedInVoiceNavigator"] as! Int64
                }
                if dict.keys.contains("CallsAttendedTransferred") {
                    self.callsAttendedTransferred = dict["CallsAttendedTransferred"] as! Int64
                }
                if dict.keys.contains("CallsBlindTransferred") {
                    self.callsBlindTransferred = dict["CallsBlindTransferred"] as! Int64
                }
                if dict.keys.contains("CallsCausedIVRException") {
                    self.callsCausedIVRException = dict["CallsCausedIVRException"] as! Int64
                }
                if dict.keys.contains("CallsForwardToOutsideNumber") {
                    self.callsForwardToOutsideNumber = dict["CallsForwardToOutsideNumber"] as! Int64
                }
                if dict.keys.contains("CallsHandled") {
                    self.callsHandled = dict["CallsHandled"] as! Int64
                }
                if dict.keys.contains("CallsHold") {
                    self.callsHold = dict["CallsHold"] as! Int64
                }
                if dict.keys.contains("CallsIVRException") {
                    self.callsIVRException = dict["CallsIVRException"] as! Int64
                }
                if dict.keys.contains("CallsOffered") {
                    self.callsOffered = dict["CallsOffered"] as! Int64
                }
                if dict.keys.contains("CallsQueued") {
                    self.callsQueued = dict["CallsQueued"] as! Int64
                }
                if dict.keys.contains("CallsQueuingFailed") {
                    self.callsQueuingFailed = dict["CallsQueuingFailed"] as! Int64
                }
                if dict.keys.contains("CallsQueuingOverflow") {
                    self.callsQueuingOverflow = dict["CallsQueuingOverflow"] as! Int64
                }
                if dict.keys.contains("CallsQueuingTimeout") {
                    self.callsQueuingTimeout = dict["CallsQueuingTimeout"] as! Int64
                }
                if dict.keys.contains("CallsRinged") {
                    self.callsRinged = dict["CallsRinged"] as! Int64
                }
                if dict.keys.contains("CallsToVoicemail") {
                    self.callsToVoicemail = dict["CallsToVoicemail"] as! Int64
                }
                if dict.keys.contains("CallsVoicemail") {
                    self.callsVoicemail = dict["CallsVoicemail"] as! Int64
                }
                if dict.keys.contains("HandleRate") {
                    self.handleRate = dict["HandleRate"] as! Double
                }
                if dict.keys.contains("MaxAbandonTime") {
                    self.maxAbandonTime = dict["MaxAbandonTime"] as! Int64
                }
                if dict.keys.contains("MaxAbandonedInIVRTime") {
                    self.maxAbandonedInIVRTime = dict["MaxAbandonedInIVRTime"] as! Int64
                }
                if dict.keys.contains("MaxAbandonedInQueueTime") {
                    self.maxAbandonedInQueueTime = dict["MaxAbandonedInQueueTime"] as! Int64
                }
                if dict.keys.contains("MaxAbandonedInRingTime") {
                    self.maxAbandonedInRingTime = dict["MaxAbandonedInRingTime"] as! Int64
                }
                if dict.keys.contains("MaxHoldTime") {
                    self.maxHoldTime = dict["MaxHoldTime"] as! Int64
                }
                if dict.keys.contains("MaxRingTime") {
                    self.maxRingTime = dict["MaxRingTime"] as! Int64
                }
                if dict.keys.contains("MaxTalkTime") {
                    self.maxTalkTime = dict["MaxTalkTime"] as! Int64
                }
                if dict.keys.contains("MaxWaitTime") {
                    self.maxWaitTime = dict["MaxWaitTime"] as! Int64
                }
                if dict.keys.contains("MaxWorkTime") {
                    self.maxWorkTime = dict["MaxWorkTime"] as! Int64
                }
                if dict.keys.contains("SatisfactionIndex") {
                    self.satisfactionIndex = dict["SatisfactionIndex"] as! Double
                }
                if dict.keys.contains("SatisfactionRate") {
                    self.satisfactionRate = dict["SatisfactionRate"] as! Double
                }
                if dict.keys.contains("SatisfactionSurveysOffered") {
                    self.satisfactionSurveysOffered = dict["SatisfactionSurveysOffered"] as! Int64
                }
                if dict.keys.contains("SatisfactionSurveysResponded") {
                    self.satisfactionSurveysResponded = dict["SatisfactionSurveysResponded"] as! Int64
                }
                if dict.keys.contains("ServiceLevel20") {
                    self.serviceLevel20 = dict["ServiceLevel20"] as! Double
                }
                if dict.keys.contains("TotalAbandonTime") {
                    self.totalAbandonTime = dict["TotalAbandonTime"] as! Int64
                }
                if dict.keys.contains("TotalAbandonedInIVRTime") {
                    self.totalAbandonedInIVRTime = dict["TotalAbandonedInIVRTime"] as! Int64
                }
                if dict.keys.contains("TotalAbandonedInQueueTime") {
                    self.totalAbandonedInQueueTime = dict["TotalAbandonedInQueueTime"] as! Int64
                }
                if dict.keys.contains("TotalAbandonedInRingTime") {
                    self.totalAbandonedInRingTime = dict["TotalAbandonedInRingTime"] as! Int64
                }
                if dict.keys.contains("TotalHoldTime") {
                    self.totalHoldTime = dict["TotalHoldTime"] as! Int64
                }
                if dict.keys.contains("TotalMessagesSent") {
                    self.totalMessagesSent = dict["TotalMessagesSent"] as! Int64
                }
                if dict.keys.contains("TotalMessagesSentByAgent") {
                    self.totalMessagesSentByAgent = dict["TotalMessagesSentByAgent"] as! Int64
                }
                if dict.keys.contains("TotalMessagesSentByCustomer") {
                    self.totalMessagesSentByCustomer = dict["TotalMessagesSentByCustomer"] as! Int64
                }
                if dict.keys.contains("TotalRingTime") {
                    self.totalRingTime = dict["TotalRingTime"] as! Int64
                }
                if dict.keys.contains("TotalTalkTime") {
                    self.totalTalkTime = dict["TotalTalkTime"] as! Int64
                }
                if dict.keys.contains("TotalWaitTime") {
                    self.totalWaitTime = dict["TotalWaitTime"] as! Int64
                }
                if dict.keys.contains("TotalWorkTime") {
                    self.totalWorkTime = dict["TotalWorkTime"] as! Int64
                }
            }
        }
        public class Outbound : Tea.TeaModel {
            public var answerRate: Double?

            public var averageDialingTime: Double?

            public var averageHoldTime: Double?

            public var averageRingTime: Double?

            public var averageTalkTime: Double?

            public var averageWorkTime: Double?

            public var callsAnswered: Int64?

            public var callsAttendedTransferred: Int64?

            public var callsBlindTransferred: Int64?

            public var callsDialed: Int64?

            public var callsHold: Int64?

            public var callsRinged: Int64?

            public var maxDialingTime: Int64?

            public var maxHoldTime: Int64?

            public var maxRingTime: Int64?

            public var maxTalkTime: Int64?

            public var maxWorkTime: Int64?

            public var satisfactionIndex: Double?

            public var satisfactionRate: Double?

            public var satisfactionSurveysOffered: Int64?

            public var satisfactionSurveysResponded: Int64?

            public var totalDialingTime: Int64?

            public var totalHoldTime: Int64?

            public var totalRingTime: Int64?

            public var totalTalkTime: Int64?

            public var totalWorkTime: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.answerRate != nil {
                    map["AnswerRate"] = self.answerRate!
                }
                if self.averageDialingTime != nil {
                    map["AverageDialingTime"] = self.averageDialingTime!
                }
                if self.averageHoldTime != nil {
                    map["AverageHoldTime"] = self.averageHoldTime!
                }
                if self.averageRingTime != nil {
                    map["AverageRingTime"] = self.averageRingTime!
                }
                if self.averageTalkTime != nil {
                    map["AverageTalkTime"] = self.averageTalkTime!
                }
                if self.averageWorkTime != nil {
                    map["AverageWorkTime"] = self.averageWorkTime!
                }
                if self.callsAnswered != nil {
                    map["CallsAnswered"] = self.callsAnswered!
                }
                if self.callsAttendedTransferred != nil {
                    map["CallsAttendedTransferred"] = self.callsAttendedTransferred!
                }
                if self.callsBlindTransferred != nil {
                    map["CallsBlindTransferred"] = self.callsBlindTransferred!
                }
                if self.callsDialed != nil {
                    map["CallsDialed"] = self.callsDialed!
                }
                if self.callsHold != nil {
                    map["CallsHold"] = self.callsHold!
                }
                if self.callsRinged != nil {
                    map["CallsRinged"] = self.callsRinged!
                }
                if self.maxDialingTime != nil {
                    map["MaxDialingTime"] = self.maxDialingTime!
                }
                if self.maxHoldTime != nil {
                    map["MaxHoldTime"] = self.maxHoldTime!
                }
                if self.maxRingTime != nil {
                    map["MaxRingTime"] = self.maxRingTime!
                }
                if self.maxTalkTime != nil {
                    map["MaxTalkTime"] = self.maxTalkTime!
                }
                if self.maxWorkTime != nil {
                    map["MaxWorkTime"] = self.maxWorkTime!
                }
                if self.satisfactionIndex != nil {
                    map["SatisfactionIndex"] = self.satisfactionIndex!
                }
                if self.satisfactionRate != nil {
                    map["SatisfactionRate"] = self.satisfactionRate!
                }
                if self.satisfactionSurveysOffered != nil {
                    map["SatisfactionSurveysOffered"] = self.satisfactionSurveysOffered!
                }
                if self.satisfactionSurveysResponded != nil {
                    map["SatisfactionSurveysResponded"] = self.satisfactionSurveysResponded!
                }
                if self.totalDialingTime != nil {
                    map["TotalDialingTime"] = self.totalDialingTime!
                }
                if self.totalHoldTime != nil {
                    map["TotalHoldTime"] = self.totalHoldTime!
                }
                if self.totalRingTime != nil {
                    map["TotalRingTime"] = self.totalRingTime!
                }
                if self.totalTalkTime != nil {
                    map["TotalTalkTime"] = self.totalTalkTime!
                }
                if self.totalWorkTime != nil {
                    map["TotalWorkTime"] = self.totalWorkTime!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AnswerRate") {
                    self.answerRate = dict["AnswerRate"] as! Double
                }
                if dict.keys.contains("AverageDialingTime") {
                    self.averageDialingTime = dict["AverageDialingTime"] as! Double
                }
                if dict.keys.contains("AverageHoldTime") {
                    self.averageHoldTime = dict["AverageHoldTime"] as! Double
                }
                if dict.keys.contains("AverageRingTime") {
                    self.averageRingTime = dict["AverageRingTime"] as! Double
                }
                if dict.keys.contains("AverageTalkTime") {
                    self.averageTalkTime = dict["AverageTalkTime"] as! Double
                }
                if dict.keys.contains("AverageWorkTime") {
                    self.averageWorkTime = dict["AverageWorkTime"] as! Double
                }
                if dict.keys.contains("CallsAnswered") {
                    self.callsAnswered = dict["CallsAnswered"] as! Int64
                }
                if dict.keys.contains("CallsAttendedTransferred") {
                    self.callsAttendedTransferred = dict["CallsAttendedTransferred"] as! Int64
                }
                if dict.keys.contains("CallsBlindTransferred") {
                    self.callsBlindTransferred = dict["CallsBlindTransferred"] as! Int64
                }
                if dict.keys.contains("CallsDialed") {
                    self.callsDialed = dict["CallsDialed"] as! Int64
                }
                if dict.keys.contains("CallsHold") {
                    self.callsHold = dict["CallsHold"] as! Int64
                }
                if dict.keys.contains("CallsRinged") {
                    self.callsRinged = dict["CallsRinged"] as! Int64
                }
                if dict.keys.contains("MaxDialingTime") {
                    self.maxDialingTime = dict["MaxDialingTime"] as! Int64
                }
                if dict.keys.contains("MaxHoldTime") {
                    self.maxHoldTime = dict["MaxHoldTime"] as! Int64
                }
                if dict.keys.contains("MaxRingTime") {
                    self.maxRingTime = dict["MaxRingTime"] as! Int64
                }
                if dict.keys.contains("MaxTalkTime") {
                    self.maxTalkTime = dict["MaxTalkTime"] as! Int64
                }
                if dict.keys.contains("MaxWorkTime") {
                    self.maxWorkTime = dict["MaxWorkTime"] as! Int64
                }
                if dict.keys.contains("SatisfactionIndex") {
                    self.satisfactionIndex = dict["SatisfactionIndex"] as! Double
                }
                if dict.keys.contains("SatisfactionRate") {
                    self.satisfactionRate = dict["SatisfactionRate"] as! Double
                }
                if dict.keys.contains("SatisfactionSurveysOffered") {
                    self.satisfactionSurveysOffered = dict["SatisfactionSurveysOffered"] as! Int64
                }
                if dict.keys.contains("SatisfactionSurveysResponded") {
                    self.satisfactionSurveysResponded = dict["SatisfactionSurveysResponded"] as! Int64
                }
                if dict.keys.contains("TotalDialingTime") {
                    self.totalDialingTime = dict["TotalDialingTime"] as! Int64
                }
                if dict.keys.contains("TotalHoldTime") {
                    self.totalHoldTime = dict["TotalHoldTime"] as! Int64
                }
                if dict.keys.contains("TotalRingTime") {
                    self.totalRingTime = dict["TotalRingTime"] as! Int64
                }
                if dict.keys.contains("TotalTalkTime") {
                    self.totalTalkTime = dict["TotalTalkTime"] as! Int64
                }
                if dict.keys.contains("TotalWorkTime") {
                    self.totalWorkTime = dict["TotalWorkTime"] as! Int64
                }
            }
        }
        public class Overall : Tea.TeaModel {
            public var averageBreakTime: Double?

            public var averageHoldTime: Double?

            public var averageReadyTime: Double?

            public var averageTalkTime: Double?

            public var averageWorkTime: Double?

            public var maxBreakTime: Int64?

            public var maxHoldTime: Int64?

            public var maxReadyTime: Int64?

            public var maxTalkTime: Int64?

            public var maxWorkTime: Int64?

            public var occupancyRate: Double?

            public var satisfactionIndex: Double?

            public var satisfactionRate: Double?

            public var satisfactionSurveysOffered: Int64?

            public var satisfactionSurveysResponded: Int64?

            public var totalBreakTime: Int64?

            public var totalCalls: Int64?

            public var totalHoldTime: Int64?

            public var totalLoggedInTime: Int64?

            public var totalReadyTime: Int64?

            public var totalTalkTime: Int64?

            public var totalWorkTime: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.averageBreakTime != nil {
                    map["AverageBreakTime"] = self.averageBreakTime!
                }
                if self.averageHoldTime != nil {
                    map["AverageHoldTime"] = self.averageHoldTime!
                }
                if self.averageReadyTime != nil {
                    map["AverageReadyTime"] = self.averageReadyTime!
                }
                if self.averageTalkTime != nil {
                    map["AverageTalkTime"] = self.averageTalkTime!
                }
                if self.averageWorkTime != nil {
                    map["AverageWorkTime"] = self.averageWorkTime!
                }
                if self.maxBreakTime != nil {
                    map["MaxBreakTime"] = self.maxBreakTime!
                }
                if self.maxHoldTime != nil {
                    map["MaxHoldTime"] = self.maxHoldTime!
                }
                if self.maxReadyTime != nil {
                    map["MaxReadyTime"] = self.maxReadyTime!
                }
                if self.maxTalkTime != nil {
                    map["MaxTalkTime"] = self.maxTalkTime!
                }
                if self.maxWorkTime != nil {
                    map["MaxWorkTime"] = self.maxWorkTime!
                }
                if self.occupancyRate != nil {
                    map["OccupancyRate"] = self.occupancyRate!
                }
                if self.satisfactionIndex != nil {
                    map["SatisfactionIndex"] = self.satisfactionIndex!
                }
                if self.satisfactionRate != nil {
                    map["SatisfactionRate"] = self.satisfactionRate!
                }
                if self.satisfactionSurveysOffered != nil {
                    map["SatisfactionSurveysOffered"] = self.satisfactionSurveysOffered!
                }
                if self.satisfactionSurveysResponded != nil {
                    map["SatisfactionSurveysResponded"] = self.satisfactionSurveysResponded!
                }
                if self.totalBreakTime != nil {
                    map["TotalBreakTime"] = self.totalBreakTime!
                }
                if self.totalCalls != nil {
                    map["TotalCalls"] = self.totalCalls!
                }
                if self.totalHoldTime != nil {
                    map["TotalHoldTime"] = self.totalHoldTime!
                }
                if self.totalLoggedInTime != nil {
                    map["TotalLoggedInTime"] = self.totalLoggedInTime!
                }
                if self.totalReadyTime != nil {
                    map["TotalReadyTime"] = self.totalReadyTime!
                }
                if self.totalTalkTime != nil {
                    map["TotalTalkTime"] = self.totalTalkTime!
                }
                if self.totalWorkTime != nil {
                    map["TotalWorkTime"] = self.totalWorkTime!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AverageBreakTime") {
                    self.averageBreakTime = dict["AverageBreakTime"] as! Double
                }
                if dict.keys.contains("AverageHoldTime") {
                    self.averageHoldTime = dict["AverageHoldTime"] as! Double
                }
                if dict.keys.contains("AverageReadyTime") {
                    self.averageReadyTime = dict["AverageReadyTime"] as! Double
                }
                if dict.keys.contains("AverageTalkTime") {
                    self.averageTalkTime = dict["AverageTalkTime"] as! Double
                }
                if dict.keys.contains("AverageWorkTime") {
                    self.averageWorkTime = dict["AverageWorkTime"] as! Double
                }
                if dict.keys.contains("MaxBreakTime") {
                    self.maxBreakTime = dict["MaxBreakTime"] as! Int64
                }
                if dict.keys.contains("MaxHoldTime") {
                    self.maxHoldTime = dict["MaxHoldTime"] as! Int64
                }
                if dict.keys.contains("MaxReadyTime") {
                    self.maxReadyTime = dict["MaxReadyTime"] as! Int64
                }
                if dict.keys.contains("MaxTalkTime") {
                    self.maxTalkTime = dict["MaxTalkTime"] as! Int64
                }
                if dict.keys.contains("MaxWorkTime") {
                    self.maxWorkTime = dict["MaxWorkTime"] as! Int64
                }
                if dict.keys.contains("OccupancyRate") {
                    self.occupancyRate = dict["OccupancyRate"] as! Double
                }
                if dict.keys.contains("SatisfactionIndex") {
                    self.satisfactionIndex = dict["SatisfactionIndex"] as! Double
                }
                if dict.keys.contains("SatisfactionRate") {
                    self.satisfactionRate = dict["SatisfactionRate"] as! Double
                }
                if dict.keys.contains("SatisfactionSurveysOffered") {
                    self.satisfactionSurveysOffered = dict["SatisfactionSurveysOffered"] as! Int64
                }
                if dict.keys.contains("SatisfactionSurveysResponded") {
                    self.satisfactionSurveysResponded = dict["SatisfactionSurveysResponded"] as! Int64
                }
                if dict.keys.contains("TotalBreakTime") {
                    self.totalBreakTime = dict["TotalBreakTime"] as! Int64
                }
                if dict.keys.contains("TotalCalls") {
                    self.totalCalls = dict["TotalCalls"] as! Int64
                }
                if dict.keys.contains("TotalHoldTime") {
                    self.totalHoldTime = dict["TotalHoldTime"] as! Int64
                }
                if dict.keys.contains("TotalLoggedInTime") {
                    self.totalLoggedInTime = dict["TotalLoggedInTime"] as! Int64
                }
                if dict.keys.contains("TotalReadyTime") {
                    self.totalReadyTime = dict["TotalReadyTime"] as! Int64
                }
                if dict.keys.contains("TotalTalkTime") {
                    self.totalTalkTime = dict["TotalTalkTime"] as! Int64
                }
                if dict.keys.contains("TotalWorkTime") {
                    self.totalWorkTime = dict["TotalWorkTime"] as! Int64
                }
            }
        }
        public var inbound: ListIntervalInstanceReportResponseBody.Data.Inbound?

        public var outbound: ListIntervalInstanceReportResponseBody.Data.Outbound?

        public var overall: ListIntervalInstanceReportResponseBody.Data.Overall?

        public var statsTime: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.inbound?.validate()
            try self.outbound?.validate()
            try self.overall?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.inbound != nil {
                map["Inbound"] = self.inbound?.toMap()
            }
            if self.outbound != nil {
                map["Outbound"] = self.outbound?.toMap()
            }
            if self.overall != nil {
                map["Overall"] = self.overall?.toMap()
            }
            if self.statsTime != nil {
                map["StatsTime"] = self.statsTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Inbound") {
                var model = ListIntervalInstanceReportResponseBody.Data.Inbound()
                model.fromMap(dict["Inbound"] as! [String: Any])
                self.inbound = model
            }
            if dict.keys.contains("Outbound") {
                var model = ListIntervalInstanceReportResponseBody.Data.Outbound()
                model.fromMap(dict["Outbound"] as! [String: Any])
                self.outbound = model
            }
            if dict.keys.contains("Overall") {
                var model = ListIntervalInstanceReportResponseBody.Data.Overall()
                model.fromMap(dict["Overall"] as! [String: Any])
                self.overall = model
            }
            if dict.keys.contains("StatsTime") {
                self.statsTime = dict["StatsTime"] as! Int64
            }
        }
    }
    public var code: String?

    public var data: [ListIntervalInstanceReportResponseBody.Data]?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var tmp : [ListIntervalInstanceReportResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = ListIntervalInstanceReportResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListIntervalInstanceReportResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListIntervalInstanceReportResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListIntervalInstanceReportResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListIntervalSkillGroupReportRequest : Tea.TeaModel {
    public var endTime: Int64?

    public var instanceId: String?

    public var interval: String?

    public var mediaType: String?

    public var skillGroupId: String?

    public var startTime: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.interval != nil {
            map["Interval"] = self.interval!
        }
        if self.mediaType != nil {
            map["MediaType"] = self.mediaType!
        }
        if self.skillGroupId != nil {
            map["SkillGroupId"] = self.skillGroupId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Interval") {
            self.interval = dict["Interval"] as! String
        }
        if dict.keys.contains("MediaType") {
            self.mediaType = dict["MediaType"] as! String
        }
        if dict.keys.contains("SkillGroupId") {
            self.skillGroupId = dict["SkillGroupId"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! Int64
        }
    }
}

public class ListIntervalSkillGroupReportResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Back2Back : Tea.TeaModel {
            public var agentHandleRate: Double?

            public var answerRate: String?

            public var averageCustomerRingTime: Double?

            public var averageRingTime: Double?

            public var averageTalkTime: String?

            public var callsAgentHandled: Int64?

            public var callsAnswered: Int64?

            public var callsCustomerAnswered: Int64?

            public var callsDialed: Int64?

            public var customerAnswerRate: Double?

            public var maxCustomerRingTime: Int64?

            public var maxRingTime: Int64?

            public var maxTalkTime: String?

            public var totalCustomerRingTime: Int64?

            public var totalRingTime: Int64?

            public var totalTalkTime: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.agentHandleRate != nil {
                    map["AgentHandleRate"] = self.agentHandleRate!
                }
                if self.answerRate != nil {
                    map["AnswerRate"] = self.answerRate!
                }
                if self.averageCustomerRingTime != nil {
                    map["AverageCustomerRingTime"] = self.averageCustomerRingTime!
                }
                if self.averageRingTime != nil {
                    map["AverageRingTime"] = self.averageRingTime!
                }
                if self.averageTalkTime != nil {
                    map["AverageTalkTime"] = self.averageTalkTime!
                }
                if self.callsAgentHandled != nil {
                    map["CallsAgentHandled"] = self.callsAgentHandled!
                }
                if self.callsAnswered != nil {
                    map["CallsAnswered"] = self.callsAnswered!
                }
                if self.callsCustomerAnswered != nil {
                    map["CallsCustomerAnswered"] = self.callsCustomerAnswered!
                }
                if self.callsDialed != nil {
                    map["CallsDialed"] = self.callsDialed!
                }
                if self.customerAnswerRate != nil {
                    map["CustomerAnswerRate"] = self.customerAnswerRate!
                }
                if self.maxCustomerRingTime != nil {
                    map["MaxCustomerRingTime"] = self.maxCustomerRingTime!
                }
                if self.maxRingTime != nil {
                    map["MaxRingTime"] = self.maxRingTime!
                }
                if self.maxTalkTime != nil {
                    map["MaxTalkTime"] = self.maxTalkTime!
                }
                if self.totalCustomerRingTime != nil {
                    map["TotalCustomerRingTime"] = self.totalCustomerRingTime!
                }
                if self.totalRingTime != nil {
                    map["TotalRingTime"] = self.totalRingTime!
                }
                if self.totalTalkTime != nil {
                    map["TotalTalkTime"] = self.totalTalkTime!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AgentHandleRate") {
                    self.agentHandleRate = dict["AgentHandleRate"] as! Double
                }
                if dict.keys.contains("AnswerRate") {
                    self.answerRate = dict["AnswerRate"] as! String
                }
                if dict.keys.contains("AverageCustomerRingTime") {
                    self.averageCustomerRingTime = dict["AverageCustomerRingTime"] as! Double
                }
                if dict.keys.contains("AverageRingTime") {
                    self.averageRingTime = dict["AverageRingTime"] as! Double
                }
                if dict.keys.contains("AverageTalkTime") {
                    self.averageTalkTime = dict["AverageTalkTime"] as! String
                }
                if dict.keys.contains("CallsAgentHandled") {
                    self.callsAgentHandled = dict["CallsAgentHandled"] as! Int64
                }
                if dict.keys.contains("CallsAnswered") {
                    self.callsAnswered = dict["CallsAnswered"] as! Int64
                }
                if dict.keys.contains("CallsCustomerAnswered") {
                    self.callsCustomerAnswered = dict["CallsCustomerAnswered"] as! Int64
                }
                if dict.keys.contains("CallsDialed") {
                    self.callsDialed = dict["CallsDialed"] as! Int64
                }
                if dict.keys.contains("CustomerAnswerRate") {
                    self.customerAnswerRate = dict["CustomerAnswerRate"] as! Double
                }
                if dict.keys.contains("MaxCustomerRingTime") {
                    self.maxCustomerRingTime = dict["MaxCustomerRingTime"] as! Int64
                }
                if dict.keys.contains("MaxRingTime") {
                    self.maxRingTime = dict["MaxRingTime"] as! Int64
                }
                if dict.keys.contains("MaxTalkTime") {
                    self.maxTalkTime = dict["MaxTalkTime"] as! String
                }
                if dict.keys.contains("TotalCustomerRingTime") {
                    self.totalCustomerRingTime = dict["TotalCustomerRingTime"] as! Int64
                }
                if dict.keys.contains("TotalRingTime") {
                    self.totalRingTime = dict["TotalRingTime"] as! Int64
                }
                if dict.keys.contains("TotalTalkTime") {
                    self.totalTalkTime = dict["TotalTalkTime"] as! Int64
                }
            }
        }
        public class Inbound : Tea.TeaModel {
            public var abandonRate: Double?

            public var averageAbandonTime: Double?

            public var averageAbandonedInQueueTime: Double?

            public var averageAbandonedInRingTime: Double?

            public var averageFirstResponseTime: Double?

            public var averageHoldTime: Double?

            public var averageResponseTime: Double?

            public var averageRingTime: Double?

            public var averageTalkTime: Double?

            public var averageWaitTime: Double?

            public var averageWorkTime: Double?

            public var callsAbandoned: Int64?

            public var callsAbandonedInQueue: Int64?

            public var callsAbandonedInRing: Int64?

            public var callsAttendedTransferIn: Int64?

            public var callsAttendedTransferOut: Int64?

            public var callsBlindTransferIn: Int64?

            public var callsBlindTransferOut: Int64?

            public var callsHandled: Int64?

            public var callsHold: Int64?

            public var callsOffered: Int64?

            public var callsOverflow: Int64?

            public var callsQueued: Int64?

            public var callsQueuingOverflow: Int64?

            public var callsQueuingTimeout: Int64?

            public var callsRinged: Int64?

            public var callsTimeout: Int64?

            public var handleRate: Double?

            public var maxAbandonTime: Int64?

            public var maxAbandonedInQueueTime: Int64?

            public var maxAbandonedInRingTime: Int64?

            public var maxHoldTime: Int64?

            public var maxRingTime: Int64?

            public var maxTalkTime: Int64?

            public var maxWaitTime: Int64?

            public var maxWorkTime: Int64?

            public var satisfactionIndex: Double?

            public var satisfactionRate: Double?

            public var satisfactionSurveysOffered: Int64?

            public var satisfactionSurveysResponded: Int64?

            public var serviceLevel20: Double?

            public var totalAbandonTime: Int64?

            public var totalAbandonedInQueueTime: Int64?

            public var totalAbandonedInRingTime: Int64?

            public var totalHoldTime: Int64?

            public var totalMessagesSent: Int64?

            public var totalMessagesSentByAgent: Int64?

            public var totalMessagesSentByCustomer: Int64?

            public var totalRingTime: Int64?

            public var totalTalkTime: Int64?

            public var totalWaitTime: Int64?

            public var totalWorkTime: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.abandonRate != nil {
                    map["AbandonRate"] = self.abandonRate!
                }
                if self.averageAbandonTime != nil {
                    map["AverageAbandonTime"] = self.averageAbandonTime!
                }
                if self.averageAbandonedInQueueTime != nil {
                    map["AverageAbandonedInQueueTime"] = self.averageAbandonedInQueueTime!
                }
                if self.averageAbandonedInRingTime != nil {
                    map["AverageAbandonedInRingTime"] = self.averageAbandonedInRingTime!
                }
                if self.averageFirstResponseTime != nil {
                    map["AverageFirstResponseTime"] = self.averageFirstResponseTime!
                }
                if self.averageHoldTime != nil {
                    map["AverageHoldTime"] = self.averageHoldTime!
                }
                if self.averageResponseTime != nil {
                    map["AverageResponseTime"] = self.averageResponseTime!
                }
                if self.averageRingTime != nil {
                    map["AverageRingTime"] = self.averageRingTime!
                }
                if self.averageTalkTime != nil {
                    map["AverageTalkTime"] = self.averageTalkTime!
                }
                if self.averageWaitTime != nil {
                    map["AverageWaitTime"] = self.averageWaitTime!
                }
                if self.averageWorkTime != nil {
                    map["AverageWorkTime"] = self.averageWorkTime!
                }
                if self.callsAbandoned != nil {
                    map["CallsAbandoned"] = self.callsAbandoned!
                }
                if self.callsAbandonedInQueue != nil {
                    map["CallsAbandonedInQueue"] = self.callsAbandonedInQueue!
                }
                if self.callsAbandonedInRing != nil {
                    map["CallsAbandonedInRing"] = self.callsAbandonedInRing!
                }
                if self.callsAttendedTransferIn != nil {
                    map["CallsAttendedTransferIn"] = self.callsAttendedTransferIn!
                }
                if self.callsAttendedTransferOut != nil {
                    map["CallsAttendedTransferOut"] = self.callsAttendedTransferOut!
                }
                if self.callsBlindTransferIn != nil {
                    map["CallsBlindTransferIn"] = self.callsBlindTransferIn!
                }
                if self.callsBlindTransferOut != nil {
                    map["CallsBlindTransferOut"] = self.callsBlindTransferOut!
                }
                if self.callsHandled != nil {
                    map["CallsHandled"] = self.callsHandled!
                }
                if self.callsHold != nil {
                    map["CallsHold"] = self.callsHold!
                }
                if self.callsOffered != nil {
                    map["CallsOffered"] = self.callsOffered!
                }
                if self.callsOverflow != nil {
                    map["CallsOverflow"] = self.callsOverflow!
                }
                if self.callsQueued != nil {
                    map["CallsQueued"] = self.callsQueued!
                }
                if self.callsQueuingOverflow != nil {
                    map["CallsQueuingOverflow"] = self.callsQueuingOverflow!
                }
                if self.callsQueuingTimeout != nil {
                    map["CallsQueuingTimeout"] = self.callsQueuingTimeout!
                }
                if self.callsRinged != nil {
                    map["CallsRinged"] = self.callsRinged!
                }
                if self.callsTimeout != nil {
                    map["CallsTimeout"] = self.callsTimeout!
                }
                if self.handleRate != nil {
                    map["HandleRate"] = self.handleRate!
                }
                if self.maxAbandonTime != nil {
                    map["MaxAbandonTime"] = self.maxAbandonTime!
                }
                if self.maxAbandonedInQueueTime != nil {
                    map["MaxAbandonedInQueueTime"] = self.maxAbandonedInQueueTime!
                }
                if self.maxAbandonedInRingTime != nil {
                    map["MaxAbandonedInRingTime"] = self.maxAbandonedInRingTime!
                }
                if self.maxHoldTime != nil {
                    map["MaxHoldTime"] = self.maxHoldTime!
                }
                if self.maxRingTime != nil {
                    map["MaxRingTime"] = self.maxRingTime!
                }
                if self.maxTalkTime != nil {
                    map["MaxTalkTime"] = self.maxTalkTime!
                }
                if self.maxWaitTime != nil {
                    map["MaxWaitTime"] = self.maxWaitTime!
                }
                if self.maxWorkTime != nil {
                    map["MaxWorkTime"] = self.maxWorkTime!
                }
                if self.satisfactionIndex != nil {
                    map["SatisfactionIndex"] = self.satisfactionIndex!
                }
                if self.satisfactionRate != nil {
                    map["SatisfactionRate"] = self.satisfactionRate!
                }
                if self.satisfactionSurveysOffered != nil {
                    map["SatisfactionSurveysOffered"] = self.satisfactionSurveysOffered!
                }
                if self.satisfactionSurveysResponded != nil {
                    map["SatisfactionSurveysResponded"] = self.satisfactionSurveysResponded!
                }
                if self.serviceLevel20 != nil {
                    map["ServiceLevel20"] = self.serviceLevel20!
                }
                if self.totalAbandonTime != nil {
                    map["TotalAbandonTime"] = self.totalAbandonTime!
                }
                if self.totalAbandonedInQueueTime != nil {
                    map["TotalAbandonedInQueueTime"] = self.totalAbandonedInQueueTime!
                }
                if self.totalAbandonedInRingTime != nil {
                    map["TotalAbandonedInRingTime"] = self.totalAbandonedInRingTime!
                }
                if self.totalHoldTime != nil {
                    map["TotalHoldTime"] = self.totalHoldTime!
                }
                if self.totalMessagesSent != nil {
                    map["TotalMessagesSent"] = self.totalMessagesSent!
                }
                if self.totalMessagesSentByAgent != nil {
                    map["TotalMessagesSentByAgent"] = self.totalMessagesSentByAgent!
                }
                if self.totalMessagesSentByCustomer != nil {
                    map["TotalMessagesSentByCustomer"] = self.totalMessagesSentByCustomer!
                }
                if self.totalRingTime != nil {
                    map["TotalRingTime"] = self.totalRingTime!
                }
                if self.totalTalkTime != nil {
                    map["TotalTalkTime"] = self.totalTalkTime!
                }
                if self.totalWaitTime != nil {
                    map["TotalWaitTime"] = self.totalWaitTime!
                }
                if self.totalWorkTime != nil {
                    map["TotalWorkTime"] = self.totalWorkTime!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AbandonRate") {
                    self.abandonRate = dict["AbandonRate"] as! Double
                }
                if dict.keys.contains("AverageAbandonTime") {
                    self.averageAbandonTime = dict["AverageAbandonTime"] as! Double
                }
                if dict.keys.contains("AverageAbandonedInQueueTime") {
                    self.averageAbandonedInQueueTime = dict["AverageAbandonedInQueueTime"] as! Double
                }
                if dict.keys.contains("AverageAbandonedInRingTime") {
                    self.averageAbandonedInRingTime = dict["AverageAbandonedInRingTime"] as! Double
                }
                if dict.keys.contains("AverageFirstResponseTime") {
                    self.averageFirstResponseTime = dict["AverageFirstResponseTime"] as! Double
                }
                if dict.keys.contains("AverageHoldTime") {
                    self.averageHoldTime = dict["AverageHoldTime"] as! Double
                }
                if dict.keys.contains("AverageResponseTime") {
                    self.averageResponseTime = dict["AverageResponseTime"] as! Double
                }
                if dict.keys.contains("AverageRingTime") {
                    self.averageRingTime = dict["AverageRingTime"] as! Double
                }
                if dict.keys.contains("AverageTalkTime") {
                    self.averageTalkTime = dict["AverageTalkTime"] as! Double
                }
                if dict.keys.contains("AverageWaitTime") {
                    self.averageWaitTime = dict["AverageWaitTime"] as! Double
                }
                if dict.keys.contains("AverageWorkTime") {
                    self.averageWorkTime = dict["AverageWorkTime"] as! Double
                }
                if dict.keys.contains("CallsAbandoned") {
                    self.callsAbandoned = dict["CallsAbandoned"] as! Int64
                }
                if dict.keys.contains("CallsAbandonedInQueue") {
                    self.callsAbandonedInQueue = dict["CallsAbandonedInQueue"] as! Int64
                }
                if dict.keys.contains("CallsAbandonedInRing") {
                    self.callsAbandonedInRing = dict["CallsAbandonedInRing"] as! Int64
                }
                if dict.keys.contains("CallsAttendedTransferIn") {
                    self.callsAttendedTransferIn = dict["CallsAttendedTransferIn"] as! Int64
                }
                if dict.keys.contains("CallsAttendedTransferOut") {
                    self.callsAttendedTransferOut = dict["CallsAttendedTransferOut"] as! Int64
                }
                if dict.keys.contains("CallsBlindTransferIn") {
                    self.callsBlindTransferIn = dict["CallsBlindTransferIn"] as! Int64
                }
                if dict.keys.contains("CallsBlindTransferOut") {
                    self.callsBlindTransferOut = dict["CallsBlindTransferOut"] as! Int64
                }
                if dict.keys.contains("CallsHandled") {
                    self.callsHandled = dict["CallsHandled"] as! Int64
                }
                if dict.keys.contains("CallsHold") {
                    self.callsHold = dict["CallsHold"] as! Int64
                }
                if dict.keys.contains("CallsOffered") {
                    self.callsOffered = dict["CallsOffered"] as! Int64
                }
                if dict.keys.contains("CallsOverflow") {
                    self.callsOverflow = dict["CallsOverflow"] as! Int64
                }
                if dict.keys.contains("CallsQueued") {
                    self.callsQueued = dict["CallsQueued"] as! Int64
                }
                if dict.keys.contains("CallsQueuingOverflow") {
                    self.callsQueuingOverflow = dict["CallsQueuingOverflow"] as! Int64
                }
                if dict.keys.contains("CallsQueuingTimeout") {
                    self.callsQueuingTimeout = dict["CallsQueuingTimeout"] as! Int64
                }
                if dict.keys.contains("CallsRinged") {
                    self.callsRinged = dict["CallsRinged"] as! Int64
                }
                if dict.keys.contains("CallsTimeout") {
                    self.callsTimeout = dict["CallsTimeout"] as! Int64
                }
                if dict.keys.contains("HandleRate") {
                    self.handleRate = dict["HandleRate"] as! Double
                }
                if dict.keys.contains("MaxAbandonTime") {
                    self.maxAbandonTime = dict["MaxAbandonTime"] as! Int64
                }
                if dict.keys.contains("MaxAbandonedInQueueTime") {
                    self.maxAbandonedInQueueTime = dict["MaxAbandonedInQueueTime"] as! Int64
                }
                if dict.keys.contains("MaxAbandonedInRingTime") {
                    self.maxAbandonedInRingTime = dict["MaxAbandonedInRingTime"] as! Int64
                }
                if dict.keys.contains("MaxHoldTime") {
                    self.maxHoldTime = dict["MaxHoldTime"] as! Int64
                }
                if dict.keys.contains("MaxRingTime") {
                    self.maxRingTime = dict["MaxRingTime"] as! Int64
                }
                if dict.keys.contains("MaxTalkTime") {
                    self.maxTalkTime = dict["MaxTalkTime"] as! Int64
                }
                if dict.keys.contains("MaxWaitTime") {
                    self.maxWaitTime = dict["MaxWaitTime"] as! Int64
                }
                if dict.keys.contains("MaxWorkTime") {
                    self.maxWorkTime = dict["MaxWorkTime"] as! Int64
                }
                if dict.keys.contains("SatisfactionIndex") {
                    self.satisfactionIndex = dict["SatisfactionIndex"] as! Double
                }
                if dict.keys.contains("SatisfactionRate") {
                    self.satisfactionRate = dict["SatisfactionRate"] as! Double
                }
                if dict.keys.contains("SatisfactionSurveysOffered") {
                    self.satisfactionSurveysOffered = dict["SatisfactionSurveysOffered"] as! Int64
                }
                if dict.keys.contains("SatisfactionSurveysResponded") {
                    self.satisfactionSurveysResponded = dict["SatisfactionSurveysResponded"] as! Int64
                }
                if dict.keys.contains("ServiceLevel20") {
                    self.serviceLevel20 = dict["ServiceLevel20"] as! Double
                }
                if dict.keys.contains("TotalAbandonTime") {
                    self.totalAbandonTime = dict["TotalAbandonTime"] as! Int64
                }
                if dict.keys.contains("TotalAbandonedInQueueTime") {
                    self.totalAbandonedInQueueTime = dict["TotalAbandonedInQueueTime"] as! Int64
                }
                if dict.keys.contains("TotalAbandonedInRingTime") {
                    self.totalAbandonedInRingTime = dict["TotalAbandonedInRingTime"] as! Int64
                }
                if dict.keys.contains("TotalHoldTime") {
                    self.totalHoldTime = dict["TotalHoldTime"] as! Int64
                }
                if dict.keys.contains("TotalMessagesSent") {
                    self.totalMessagesSent = dict["TotalMessagesSent"] as! Int64
                }
                if dict.keys.contains("TotalMessagesSentByAgent") {
                    self.totalMessagesSentByAgent = dict["TotalMessagesSentByAgent"] as! Int64
                }
                if dict.keys.contains("TotalMessagesSentByCustomer") {
                    self.totalMessagesSentByCustomer = dict["TotalMessagesSentByCustomer"] as! Int64
                }
                if dict.keys.contains("TotalRingTime") {
                    self.totalRingTime = dict["TotalRingTime"] as! Int64
                }
                if dict.keys.contains("TotalTalkTime") {
                    self.totalTalkTime = dict["TotalTalkTime"] as! Int64
                }
                if dict.keys.contains("TotalWaitTime") {
                    self.totalWaitTime = dict["TotalWaitTime"] as! Int64
                }
                if dict.keys.contains("TotalWorkTime") {
                    self.totalWorkTime = dict["TotalWorkTime"] as! Int64
                }
            }
        }
        public class Outbound : Tea.TeaModel {
            public var answerRate: Double?

            public var averageDialingTime: Double?

            public var averageHoldTime: Double?

            public var averageRingTime: Double?

            public var averageTalkTime: Double?

            public var averageWorkTime: Double?

            public var callsAnswered: Int64?

            public var callsAttendedTransferIn: Int64?

            public var callsAttendedTransferOut: Int64?

            public var callsBlindTransferIn: Int64?

            public var callsBlindTransferOut: Int64?

            public var callsDialed: Int64?

            public var callsHold: Int64?

            public var callsRinged: Int64?

            public var maxDialingTime: Int64?

            public var maxHoldTime: Int64?

            public var maxRingTime: Int64?

            public var maxTalkTime: Int64?

            public var maxWorkTime: Int64?

            public var satisfactionIndex: Double?

            public var satisfactionRate: Double?

            public var satisfactionSurveysOffered: Int64?

            public var satisfactionSurveysResponded: Int64?

            public var totalDialingTime: Int64?

            public var totalHoldTime: Int64?

            public var totalRingTime: Int64?

            public var totalTalkTime: Int64?

            public var totalWorkTime: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.answerRate != nil {
                    map["AnswerRate"] = self.answerRate!
                }
                if self.averageDialingTime != nil {
                    map["AverageDialingTime"] = self.averageDialingTime!
                }
                if self.averageHoldTime != nil {
                    map["AverageHoldTime"] = self.averageHoldTime!
                }
                if self.averageRingTime != nil {
                    map["AverageRingTime"] = self.averageRingTime!
                }
                if self.averageTalkTime != nil {
                    map["AverageTalkTime"] = self.averageTalkTime!
                }
                if self.averageWorkTime != nil {
                    map["AverageWorkTime"] = self.averageWorkTime!
                }
                if self.callsAnswered != nil {
                    map["CallsAnswered"] = self.callsAnswered!
                }
                if self.callsAttendedTransferIn != nil {
                    map["CallsAttendedTransferIn"] = self.callsAttendedTransferIn!
                }
                if self.callsAttendedTransferOut != nil {
                    map["CallsAttendedTransferOut"] = self.callsAttendedTransferOut!
                }
                if self.callsBlindTransferIn != nil {
                    map["CallsBlindTransferIn"] = self.callsBlindTransferIn!
                }
                if self.callsBlindTransferOut != nil {
                    map["CallsBlindTransferOut"] = self.callsBlindTransferOut!
                }
                if self.callsDialed != nil {
                    map["CallsDialed"] = self.callsDialed!
                }
                if self.callsHold != nil {
                    map["CallsHold"] = self.callsHold!
                }
                if self.callsRinged != nil {
                    map["CallsRinged"] = self.callsRinged!
                }
                if self.maxDialingTime != nil {
                    map["MaxDialingTime"] = self.maxDialingTime!
                }
                if self.maxHoldTime != nil {
                    map["MaxHoldTime"] = self.maxHoldTime!
                }
                if self.maxRingTime != nil {
                    map["MaxRingTime"] = self.maxRingTime!
                }
                if self.maxTalkTime != nil {
                    map["MaxTalkTime"] = self.maxTalkTime!
                }
                if self.maxWorkTime != nil {
                    map["MaxWorkTime"] = self.maxWorkTime!
                }
                if self.satisfactionIndex != nil {
                    map["SatisfactionIndex"] = self.satisfactionIndex!
                }
                if self.satisfactionRate != nil {
                    map["SatisfactionRate"] = self.satisfactionRate!
                }
                if self.satisfactionSurveysOffered != nil {
                    map["SatisfactionSurveysOffered"] = self.satisfactionSurveysOffered!
                }
                if self.satisfactionSurveysResponded != nil {
                    map["SatisfactionSurveysResponded"] = self.satisfactionSurveysResponded!
                }
                if self.totalDialingTime != nil {
                    map["TotalDialingTime"] = self.totalDialingTime!
                }
                if self.totalHoldTime != nil {
                    map["TotalHoldTime"] = self.totalHoldTime!
                }
                if self.totalRingTime != nil {
                    map["TotalRingTime"] = self.totalRingTime!
                }
                if self.totalTalkTime != nil {
                    map["TotalTalkTime"] = self.totalTalkTime!
                }
                if self.totalWorkTime != nil {
                    map["TotalWorkTime"] = self.totalWorkTime!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AnswerRate") {
                    self.answerRate = dict["AnswerRate"] as! Double
                }
                if dict.keys.contains("AverageDialingTime") {
                    self.averageDialingTime = dict["AverageDialingTime"] as! Double
                }
                if dict.keys.contains("AverageHoldTime") {
                    self.averageHoldTime = dict["AverageHoldTime"] as! Double
                }
                if dict.keys.contains("AverageRingTime") {
                    self.averageRingTime = dict["AverageRingTime"] as! Double
                }
                if dict.keys.contains("AverageTalkTime") {
                    self.averageTalkTime = dict["AverageTalkTime"] as! Double
                }
                if dict.keys.contains("AverageWorkTime") {
                    self.averageWorkTime = dict["AverageWorkTime"] as! Double
                }
                if dict.keys.contains("CallsAnswered") {
                    self.callsAnswered = dict["CallsAnswered"] as! Int64
                }
                if dict.keys.contains("CallsAttendedTransferIn") {
                    self.callsAttendedTransferIn = dict["CallsAttendedTransferIn"] as! Int64
                }
                if dict.keys.contains("CallsAttendedTransferOut") {
                    self.callsAttendedTransferOut = dict["CallsAttendedTransferOut"] as! Int64
                }
                if dict.keys.contains("CallsBlindTransferIn") {
                    self.callsBlindTransferIn = dict["CallsBlindTransferIn"] as! Int64
                }
                if dict.keys.contains("CallsBlindTransferOut") {
                    self.callsBlindTransferOut = dict["CallsBlindTransferOut"] as! Int64
                }
                if dict.keys.contains("CallsDialed") {
                    self.callsDialed = dict["CallsDialed"] as! Int64
                }
                if dict.keys.contains("CallsHold") {
                    self.callsHold = dict["CallsHold"] as! Int64
                }
                if dict.keys.contains("CallsRinged") {
                    self.callsRinged = dict["CallsRinged"] as! Int64
                }
                if dict.keys.contains("MaxDialingTime") {
                    self.maxDialingTime = dict["MaxDialingTime"] as! Int64
                }
                if dict.keys.contains("MaxHoldTime") {
                    self.maxHoldTime = dict["MaxHoldTime"] as! Int64
                }
                if dict.keys.contains("MaxRingTime") {
                    self.maxRingTime = dict["MaxRingTime"] as! Int64
                }
                if dict.keys.contains("MaxTalkTime") {
                    self.maxTalkTime = dict["MaxTalkTime"] as! Int64
                }
                if dict.keys.contains("MaxWorkTime") {
                    self.maxWorkTime = dict["MaxWorkTime"] as! Int64
                }
                if dict.keys.contains("SatisfactionIndex") {
                    self.satisfactionIndex = dict["SatisfactionIndex"] as! Double
                }
                if dict.keys.contains("SatisfactionRate") {
                    self.satisfactionRate = dict["SatisfactionRate"] as! Double
                }
                if dict.keys.contains("SatisfactionSurveysOffered") {
                    self.satisfactionSurveysOffered = dict["SatisfactionSurveysOffered"] as! Int64
                }
                if dict.keys.contains("SatisfactionSurveysResponded") {
                    self.satisfactionSurveysResponded = dict["SatisfactionSurveysResponded"] as! Int64
                }
                if dict.keys.contains("TotalDialingTime") {
                    self.totalDialingTime = dict["TotalDialingTime"] as! Int64
                }
                if dict.keys.contains("TotalHoldTime") {
                    self.totalHoldTime = dict["TotalHoldTime"] as! Int64
                }
                if dict.keys.contains("TotalRingTime") {
                    self.totalRingTime = dict["TotalRingTime"] as! Int64
                }
                if dict.keys.contains("TotalTalkTime") {
                    self.totalTalkTime = dict["TotalTalkTime"] as! Int64
                }
                if dict.keys.contains("TotalWorkTime") {
                    self.totalWorkTime = dict["TotalWorkTime"] as! Int64
                }
            }
        }
        public class Overall : Tea.TeaModel {
            public class BreakCodeDetailList : Tea.TeaModel {
                public var breakCode: String?

                public var count: Int64?

                public var duration: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.breakCode != nil {
                        map["BreakCode"] = self.breakCode!
                    }
                    if self.count != nil {
                        map["Count"] = self.count!
                    }
                    if self.duration != nil {
                        map["Duration"] = self.duration!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("BreakCode") {
                        self.breakCode = dict["BreakCode"] as! String
                    }
                    if dict.keys.contains("Count") {
                        self.count = dict["Count"] as! Int64
                    }
                    if dict.keys.contains("Duration") {
                        self.duration = dict["Duration"] as! Int64
                    }
                }
            }
            public var averageBreakTime: Double?

            public var averageHoldTime: Double?

            public var averageReadyTime: Double?

            public var averageTalkTime: Double?

            public var averageWorkTime: Double?

            public var breakCodeDetailList: [ListIntervalSkillGroupReportResponseBody.Data.Overall.BreakCodeDetailList]?

            public var maxBreakTime: Int64?

            public var maxHoldTime: Int64?

            public var maxReadyTime: Int64?

            public var maxTalkTime: Int64?

            public var maxWorkTime: Int64?

            public var occupancyRate: Double?

            public var satisfactionIndex: Double?

            public var satisfactionRate: Double?

            public var satisfactionSurveysOffered: Int64?

            public var satisfactionSurveysResponded: Int64?

            public var totalBreakTime: Int64?

            public var totalCalls: Int64?

            public var totalHoldTime: Int64?

            public var totalLoggedInTime: Int64?

            public var totalReadyTime: Int64?

            public var totalTalkTime: Int64?

            public var totalWorkTime: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.averageBreakTime != nil {
                    map["AverageBreakTime"] = self.averageBreakTime!
                }
                if self.averageHoldTime != nil {
                    map["AverageHoldTime"] = self.averageHoldTime!
                }
                if self.averageReadyTime != nil {
                    map["AverageReadyTime"] = self.averageReadyTime!
                }
                if self.averageTalkTime != nil {
                    map["AverageTalkTime"] = self.averageTalkTime!
                }
                if self.averageWorkTime != nil {
                    map["AverageWorkTime"] = self.averageWorkTime!
                }
                if self.breakCodeDetailList != nil {
                    var tmp : [Any] = []
                    for k in self.breakCodeDetailList! {
                        tmp.append(k.toMap())
                    }
                    map["BreakCodeDetailList"] = tmp
                }
                if self.maxBreakTime != nil {
                    map["MaxBreakTime"] = self.maxBreakTime!
                }
                if self.maxHoldTime != nil {
                    map["MaxHoldTime"] = self.maxHoldTime!
                }
                if self.maxReadyTime != nil {
                    map["MaxReadyTime"] = self.maxReadyTime!
                }
                if self.maxTalkTime != nil {
                    map["MaxTalkTime"] = self.maxTalkTime!
                }
                if self.maxWorkTime != nil {
                    map["MaxWorkTime"] = self.maxWorkTime!
                }
                if self.occupancyRate != nil {
                    map["OccupancyRate"] = self.occupancyRate!
                }
                if self.satisfactionIndex != nil {
                    map["SatisfactionIndex"] = self.satisfactionIndex!
                }
                if self.satisfactionRate != nil {
                    map["SatisfactionRate"] = self.satisfactionRate!
                }
                if self.satisfactionSurveysOffered != nil {
                    map["SatisfactionSurveysOffered"] = self.satisfactionSurveysOffered!
                }
                if self.satisfactionSurveysResponded != nil {
                    map["SatisfactionSurveysResponded"] = self.satisfactionSurveysResponded!
                }
                if self.totalBreakTime != nil {
                    map["TotalBreakTime"] = self.totalBreakTime!
                }
                if self.totalCalls != nil {
                    map["TotalCalls"] = self.totalCalls!
                }
                if self.totalHoldTime != nil {
                    map["TotalHoldTime"] = self.totalHoldTime!
                }
                if self.totalLoggedInTime != nil {
                    map["TotalLoggedInTime"] = self.totalLoggedInTime!
                }
                if self.totalReadyTime != nil {
                    map["TotalReadyTime"] = self.totalReadyTime!
                }
                if self.totalTalkTime != nil {
                    map["TotalTalkTime"] = self.totalTalkTime!
                }
                if self.totalWorkTime != nil {
                    map["TotalWorkTime"] = self.totalWorkTime!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AverageBreakTime") {
                    self.averageBreakTime = dict["AverageBreakTime"] as! Double
                }
                if dict.keys.contains("AverageHoldTime") {
                    self.averageHoldTime = dict["AverageHoldTime"] as! Double
                }
                if dict.keys.contains("AverageReadyTime") {
                    self.averageReadyTime = dict["AverageReadyTime"] as! Double
                }
                if dict.keys.contains("AverageTalkTime") {
                    self.averageTalkTime = dict["AverageTalkTime"] as! Double
                }
                if dict.keys.contains("AverageWorkTime") {
                    self.averageWorkTime = dict["AverageWorkTime"] as! Double
                }
                if dict.keys.contains("BreakCodeDetailList") {
                    var tmp : [ListIntervalSkillGroupReportResponseBody.Data.Overall.BreakCodeDetailList] = []
                    for v in dict["BreakCodeDetailList"] as! [Any] {
                        var model = ListIntervalSkillGroupReportResponseBody.Data.Overall.BreakCodeDetailList()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.breakCodeDetailList = tmp
                }
                if dict.keys.contains("MaxBreakTime") {
                    self.maxBreakTime = dict["MaxBreakTime"] as! Int64
                }
                if dict.keys.contains("MaxHoldTime") {
                    self.maxHoldTime = dict["MaxHoldTime"] as! Int64
                }
                if dict.keys.contains("MaxReadyTime") {
                    self.maxReadyTime = dict["MaxReadyTime"] as! Int64
                }
                if dict.keys.contains("MaxTalkTime") {
                    self.maxTalkTime = dict["MaxTalkTime"] as! Int64
                }
                if dict.keys.contains("MaxWorkTime") {
                    self.maxWorkTime = dict["MaxWorkTime"] as! Int64
                }
                if dict.keys.contains("OccupancyRate") {
                    self.occupancyRate = dict["OccupancyRate"] as! Double
                }
                if dict.keys.contains("SatisfactionIndex") {
                    self.satisfactionIndex = dict["SatisfactionIndex"] as! Double
                }
                if dict.keys.contains("SatisfactionRate") {
                    self.satisfactionRate = dict["SatisfactionRate"] as! Double
                }
                if dict.keys.contains("SatisfactionSurveysOffered") {
                    self.satisfactionSurveysOffered = dict["SatisfactionSurveysOffered"] as! Int64
                }
                if dict.keys.contains("SatisfactionSurveysResponded") {
                    self.satisfactionSurveysResponded = dict["SatisfactionSurveysResponded"] as! Int64
                }
                if dict.keys.contains("TotalBreakTime") {
                    self.totalBreakTime = dict["TotalBreakTime"] as! Int64
                }
                if dict.keys.contains("TotalCalls") {
                    self.totalCalls = dict["TotalCalls"] as! Int64
                }
                if dict.keys.contains("TotalHoldTime") {
                    self.totalHoldTime = dict["TotalHoldTime"] as! Int64
                }
                if dict.keys.contains("TotalLoggedInTime") {
                    self.totalLoggedInTime = dict["TotalLoggedInTime"] as! Int64
                }
                if dict.keys.contains("TotalReadyTime") {
                    self.totalReadyTime = dict["TotalReadyTime"] as! Int64
                }
                if dict.keys.contains("TotalTalkTime") {
                    self.totalTalkTime = dict["TotalTalkTime"] as! Int64
                }
                if dict.keys.contains("TotalWorkTime") {
                    self.totalWorkTime = dict["TotalWorkTime"] as! Int64
                }
            }
        }
        public var back2Back: ListIntervalSkillGroupReportResponseBody.Data.Back2Back?

        public var inbound: ListIntervalSkillGroupReportResponseBody.Data.Inbound?

        public var outbound: ListIntervalSkillGroupReportResponseBody.Data.Outbound?

        public var overall: ListIntervalSkillGroupReportResponseBody.Data.Overall?

        public var statsTime: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.back2Back?.validate()
            try self.inbound?.validate()
            try self.outbound?.validate()
            try self.overall?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.back2Back != nil {
                map["Back2Back"] = self.back2Back?.toMap()
            }
            if self.inbound != nil {
                map["Inbound"] = self.inbound?.toMap()
            }
            if self.outbound != nil {
                map["Outbound"] = self.outbound?.toMap()
            }
            if self.overall != nil {
                map["Overall"] = self.overall?.toMap()
            }
            if self.statsTime != nil {
                map["StatsTime"] = self.statsTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Back2Back") {
                var model = ListIntervalSkillGroupReportResponseBody.Data.Back2Back()
                model.fromMap(dict["Back2Back"] as! [String: Any])
                self.back2Back = model
            }
            if dict.keys.contains("Inbound") {
                var model = ListIntervalSkillGroupReportResponseBody.Data.Inbound()
                model.fromMap(dict["Inbound"] as! [String: Any])
                self.inbound = model
            }
            if dict.keys.contains("Outbound") {
                var model = ListIntervalSkillGroupReportResponseBody.Data.Outbound()
                model.fromMap(dict["Outbound"] as! [String: Any])
                self.outbound = model
            }
            if dict.keys.contains("Overall") {
                var model = ListIntervalSkillGroupReportResponseBody.Data.Overall()
                model.fromMap(dict["Overall"] as! [String: Any])
                self.overall = model
            }
            if dict.keys.contains("StatsTime") {
                self.statsTime = dict["StatsTime"] as! Int64
            }
        }
    }
    public var code: String?

    public var data: [ListIntervalSkillGroupReportResponseBody.Data]?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var tmp : [ListIntervalSkillGroupReportResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = ListIntervalSkillGroupReportResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListIntervalSkillGroupReportResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListIntervalSkillGroupReportResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListIntervalSkillGroupReportResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListIvrTrackingDetailsRequest : Tea.TeaModel {
    public var contactId: String?

    public var instanceId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.contactId != nil {
            map["ContactId"] = self.contactId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ContactId") {
            self.contactId = dict["ContactId"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
    }
}

public class ListIvrTrackingDetailsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class List : Tea.TeaModel {
            public var callee: String?

            public var caller: String?

            public var channelId: String?

            public var channelVariables: String?

            public var contactId: String?

            public var enterTime: Int64?

            public var flowId: String?

            public var flowName: String?

            public var instance: String?

            public var leaveTime: Int64?

            public var nodeExitCode: String?

            public var nodeId: String?

            public var nodeName: String?

            public var nodeProperties: [String: Any]?

            public var nodeType: String?

            public var nodeVariables: [String: Any]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.callee != nil {
                    map["Callee"] = self.callee!
                }
                if self.caller != nil {
                    map["Caller"] = self.caller!
                }
                if self.channelId != nil {
                    map["ChannelId"] = self.channelId!
                }
                if self.channelVariables != nil {
                    map["ChannelVariables"] = self.channelVariables!
                }
                if self.contactId != nil {
                    map["ContactId"] = self.contactId!
                }
                if self.enterTime != nil {
                    map["EnterTime"] = self.enterTime!
                }
                if self.flowId != nil {
                    map["FlowId"] = self.flowId!
                }
                if self.flowName != nil {
                    map["FlowName"] = self.flowName!
                }
                if self.instance != nil {
                    map["Instance"] = self.instance!
                }
                if self.leaveTime != nil {
                    map["LeaveTime"] = self.leaveTime!
                }
                if self.nodeExitCode != nil {
                    map["NodeExitCode"] = self.nodeExitCode!
                }
                if self.nodeId != nil {
                    map["NodeId"] = self.nodeId!
                }
                if self.nodeName != nil {
                    map["NodeName"] = self.nodeName!
                }
                if self.nodeProperties != nil {
                    map["NodeProperties"] = self.nodeProperties!
                }
                if self.nodeType != nil {
                    map["NodeType"] = self.nodeType!
                }
                if self.nodeVariables != nil {
                    map["NodeVariables"] = self.nodeVariables!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Callee") {
                    self.callee = dict["Callee"] as! String
                }
                if dict.keys.contains("Caller") {
                    self.caller = dict["Caller"] as! String
                }
                if dict.keys.contains("ChannelId") {
                    self.channelId = dict["ChannelId"] as! String
                }
                if dict.keys.contains("ChannelVariables") {
                    self.channelVariables = dict["ChannelVariables"] as! String
                }
                if dict.keys.contains("ContactId") {
                    self.contactId = dict["ContactId"] as! String
                }
                if dict.keys.contains("EnterTime") {
                    self.enterTime = dict["EnterTime"] as! Int64
                }
                if dict.keys.contains("FlowId") {
                    self.flowId = dict["FlowId"] as! String
                }
                if dict.keys.contains("FlowName") {
                    self.flowName = dict["FlowName"] as! String
                }
                if dict.keys.contains("Instance") {
                    self.instance = dict["Instance"] as! String
                }
                if dict.keys.contains("LeaveTime") {
                    self.leaveTime = dict["LeaveTime"] as! Int64
                }
                if dict.keys.contains("NodeExitCode") {
                    self.nodeExitCode = dict["NodeExitCode"] as! String
                }
                if dict.keys.contains("NodeId") {
                    self.nodeId = dict["NodeId"] as! String
                }
                if dict.keys.contains("NodeName") {
                    self.nodeName = dict["NodeName"] as! String
                }
                if dict.keys.contains("NodeProperties") {
                    self.nodeProperties = dict["NodeProperties"] as! [String: Any]
                }
                if dict.keys.contains("NodeType") {
                    self.nodeType = dict["NodeType"] as! String
                }
                if dict.keys.contains("NodeVariables") {
                    self.nodeVariables = dict["NodeVariables"] as! [String: Any]
                }
            }
        }
        public var list: [ListIvrTrackingDetailsResponseBody.Data.List]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.list != nil {
                var tmp : [Any] = []
                for k in self.list! {
                    tmp.append(k.toMap())
                }
                map["List"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("List") {
                var tmp : [ListIvrTrackingDetailsResponseBody.Data.List] = []
                for v in dict["List"] as! [Any] {
                    var model = ListIvrTrackingDetailsResponseBody.Data.List()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.list = tmp
            }
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var code: String?

    public var data: ListIvrTrackingDetailsResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = ListIvrTrackingDetailsResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListIvrTrackingDetailsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListIvrTrackingDetailsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListIvrTrackingDetailsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListLegacyAgentEventLogsRequest : Tea.TeaModel {
    public var agentId: String?

    public var endTime: Int64?

    public var instanceId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var startTime: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.agentId != nil {
            map["AgentId"] = self.agentId!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AgentId") {
            self.agentId = dict["AgentId"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! Int64
        }
    }
}

public class ListLegacyAgentEventLogsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class List : Tea.TeaModel {
            public var agentDropCall: String?

            public var agentNo: String?

            public var callDir: String?

            public var callId: String?

            public var callMode: String?

            public var callType: String?

            public var calleeId: String?

            public var callerId: String?

            public var connId: String?

            public var event: String?

            public var groupNo: String?

            public var outboundScenario: Bool?

            public var phoneNo: String?

            public var statisticDate: String?

            public var targetRequest: String?

            public var targetSelect: String?

            public var tenantId: String?

            public var transferNumber: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.agentDropCall != nil {
                    map["AgentDropCall"] = self.agentDropCall!
                }
                if self.agentNo != nil {
                    map["AgentNo"] = self.agentNo!
                }
                if self.callDir != nil {
                    map["CallDir"] = self.callDir!
                }
                if self.callId != nil {
                    map["CallId"] = self.callId!
                }
                if self.callMode != nil {
                    map["CallMode"] = self.callMode!
                }
                if self.callType != nil {
                    map["CallType"] = self.callType!
                }
                if self.calleeId != nil {
                    map["CalleeId"] = self.calleeId!
                }
                if self.callerId != nil {
                    map["CallerId"] = self.callerId!
                }
                if self.connId != nil {
                    map["ConnId"] = self.connId!
                }
                if self.event != nil {
                    map["Event"] = self.event!
                }
                if self.groupNo != nil {
                    map["GroupNo"] = self.groupNo!
                }
                if self.outboundScenario != nil {
                    map["OutboundScenario"] = self.outboundScenario!
                }
                if self.phoneNo != nil {
                    map["PhoneNo"] = self.phoneNo!
                }
                if self.statisticDate != nil {
                    map["StatisticDate"] = self.statisticDate!
                }
                if self.targetRequest != nil {
                    map["TargetRequest"] = self.targetRequest!
                }
                if self.targetSelect != nil {
                    map["TargetSelect"] = self.targetSelect!
                }
                if self.tenantId != nil {
                    map["TenantId"] = self.tenantId!
                }
                if self.transferNumber != nil {
                    map["TransferNumber"] = self.transferNumber!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AgentDropCall") {
                    self.agentDropCall = dict["AgentDropCall"] as! String
                }
                if dict.keys.contains("AgentNo") {
                    self.agentNo = dict["AgentNo"] as! String
                }
                if dict.keys.contains("CallDir") {
                    self.callDir = dict["CallDir"] as! String
                }
                if dict.keys.contains("CallId") {
                    self.callId = dict["CallId"] as! String
                }
                if dict.keys.contains("CallMode") {
                    self.callMode = dict["CallMode"] as! String
                }
                if dict.keys.contains("CallType") {
                    self.callType = dict["CallType"] as! String
                }
                if dict.keys.contains("CalleeId") {
                    self.calleeId = dict["CalleeId"] as! String
                }
                if dict.keys.contains("CallerId") {
                    self.callerId = dict["CallerId"] as! String
                }
                if dict.keys.contains("ConnId") {
                    self.connId = dict["ConnId"] as! String
                }
                if dict.keys.contains("Event") {
                    self.event = dict["Event"] as! String
                }
                if dict.keys.contains("GroupNo") {
                    self.groupNo = dict["GroupNo"] as! String
                }
                if dict.keys.contains("OutboundScenario") {
                    self.outboundScenario = dict["OutboundScenario"] as! Bool
                }
                if dict.keys.contains("PhoneNo") {
                    self.phoneNo = dict["PhoneNo"] as! String
                }
                if dict.keys.contains("StatisticDate") {
                    self.statisticDate = dict["StatisticDate"] as! String
                }
                if dict.keys.contains("TargetRequest") {
                    self.targetRequest = dict["TargetRequest"] as! String
                }
                if dict.keys.contains("TargetSelect") {
                    self.targetSelect = dict["TargetSelect"] as! String
                }
                if dict.keys.contains("TenantId") {
                    self.tenantId = dict["TenantId"] as! String
                }
                if dict.keys.contains("TransferNumber") {
                    self.transferNumber = dict["TransferNumber"] as! String
                }
            }
        }
        public var list: [ListLegacyAgentEventLogsResponseBody.Data.List]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.list != nil {
                var tmp : [Any] = []
                for k in self.list! {
                    tmp.append(k.toMap())
                }
                map["List"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("List") {
                var tmp : [ListLegacyAgentEventLogsResponseBody.Data.List] = []
                for v in dict["List"] as! [Any] {
                    var model = ListLegacyAgentEventLogsResponseBody.Data.List()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.list = tmp
            }
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var code: String?

    public var data: ListLegacyAgentEventLogsResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = ListLegacyAgentEventLogsResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListLegacyAgentEventLogsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListLegacyAgentEventLogsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListLegacyAgentEventLogsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListLegacyAgentStatusLogsRequest : Tea.TeaModel {
    public var agentId: String?

    public var endTime: Int64?

    public var instanceId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var startTime: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.agentId != nil {
            map["AgentId"] = self.agentId!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AgentId") {
            self.agentId = dict["AgentId"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! Int64
        }
    }
}

public class ListLegacyAgentStatusLogsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class List : Tea.TeaModel {
            public var agentDropCall: String?

            public var agentNo: String?

            public var aliHangupCause: String?

            public var callDir: String?

            public var callId: String?

            public var callType: String?

            public var calleeId: String?

            public var callerId: String?

            public var connId: String?

            public var extend1: String?

            public var extend2: String?

            public var extend3: String?

            public var extend4: String?

            public var groupNo: String?

            public var monitedAgentNo: String?

            public var monitedAgentPhoneNo: String?

            public var outboundScenario: Bool?

            public var phoneNo: String?

            public var statisticDate: String?

            public var statisticTime: Int32?

            public var status: String?

            public var targetRequest: String?

            public var targetSelect: String?

            public var tenantId: String?

            public var transferNo: String?

            public var transferNumber: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.agentDropCall != nil {
                    map["AgentDropCall"] = self.agentDropCall!
                }
                if self.agentNo != nil {
                    map["AgentNo"] = self.agentNo!
                }
                if self.aliHangupCause != nil {
                    map["AliHangupCause"] = self.aliHangupCause!
                }
                if self.callDir != nil {
                    map["CallDir"] = self.callDir!
                }
                if self.callId != nil {
                    map["CallId"] = self.callId!
                }
                if self.callType != nil {
                    map["CallType"] = self.callType!
                }
                if self.calleeId != nil {
                    map["CalleeId"] = self.calleeId!
                }
                if self.callerId != nil {
                    map["CallerId"] = self.callerId!
                }
                if self.connId != nil {
                    map["ConnId"] = self.connId!
                }
                if self.extend1 != nil {
                    map["Extend1"] = self.extend1!
                }
                if self.extend2 != nil {
                    map["Extend2"] = self.extend2!
                }
                if self.extend3 != nil {
                    map["Extend3"] = self.extend3!
                }
                if self.extend4 != nil {
                    map["Extend4"] = self.extend4!
                }
                if self.groupNo != nil {
                    map["GroupNo"] = self.groupNo!
                }
                if self.monitedAgentNo != nil {
                    map["MonitedAgentNo"] = self.monitedAgentNo!
                }
                if self.monitedAgentPhoneNo != nil {
                    map["MonitedAgentPhoneNo"] = self.monitedAgentPhoneNo!
                }
                if self.outboundScenario != nil {
                    map["OutboundScenario"] = self.outboundScenario!
                }
                if self.phoneNo != nil {
                    map["PhoneNo"] = self.phoneNo!
                }
                if self.statisticDate != nil {
                    map["StatisticDate"] = self.statisticDate!
                }
                if self.statisticTime != nil {
                    map["StatisticTime"] = self.statisticTime!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.targetRequest != nil {
                    map["TargetRequest"] = self.targetRequest!
                }
                if self.targetSelect != nil {
                    map["TargetSelect"] = self.targetSelect!
                }
                if self.tenantId != nil {
                    map["TenantId"] = self.tenantId!
                }
                if self.transferNo != nil {
                    map["TransferNo"] = self.transferNo!
                }
                if self.transferNumber != nil {
                    map["TransferNumber"] = self.transferNumber!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AgentDropCall") {
                    self.agentDropCall = dict["AgentDropCall"] as! String
                }
                if dict.keys.contains("AgentNo") {
                    self.agentNo = dict["AgentNo"] as! String
                }
                if dict.keys.contains("AliHangupCause") {
                    self.aliHangupCause = dict["AliHangupCause"] as! String
                }
                if dict.keys.contains("CallDir") {
                    self.callDir = dict["CallDir"] as! String
                }
                if dict.keys.contains("CallId") {
                    self.callId = dict["CallId"] as! String
                }
                if dict.keys.contains("CallType") {
                    self.callType = dict["CallType"] as! String
                }
                if dict.keys.contains("CalleeId") {
                    self.calleeId = dict["CalleeId"] as! String
                }
                if dict.keys.contains("CallerId") {
                    self.callerId = dict["CallerId"] as! String
                }
                if dict.keys.contains("ConnId") {
                    self.connId = dict["ConnId"] as! String
                }
                if dict.keys.contains("Extend1") {
                    self.extend1 = dict["Extend1"] as! String
                }
                if dict.keys.contains("Extend2") {
                    self.extend2 = dict["Extend2"] as! String
                }
                if dict.keys.contains("Extend3") {
                    self.extend3 = dict["Extend3"] as! String
                }
                if dict.keys.contains("Extend4") {
                    self.extend4 = dict["Extend4"] as! String
                }
                if dict.keys.contains("GroupNo") {
                    self.groupNo = dict["GroupNo"] as! String
                }
                if dict.keys.contains("MonitedAgentNo") {
                    self.monitedAgentNo = dict["MonitedAgentNo"] as! String
                }
                if dict.keys.contains("MonitedAgentPhoneNo") {
                    self.monitedAgentPhoneNo = dict["MonitedAgentPhoneNo"] as! String
                }
                if dict.keys.contains("OutboundScenario") {
                    self.outboundScenario = dict["OutboundScenario"] as! Bool
                }
                if dict.keys.contains("PhoneNo") {
                    self.phoneNo = dict["PhoneNo"] as! String
                }
                if dict.keys.contains("StatisticDate") {
                    self.statisticDate = dict["StatisticDate"] as! String
                }
                if dict.keys.contains("StatisticTime") {
                    self.statisticTime = dict["StatisticTime"] as! Int32
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("TargetRequest") {
                    self.targetRequest = dict["TargetRequest"] as! String
                }
                if dict.keys.contains("TargetSelect") {
                    self.targetSelect = dict["TargetSelect"] as! String
                }
                if dict.keys.contains("TenantId") {
                    self.tenantId = dict["TenantId"] as! String
                }
                if dict.keys.contains("TransferNo") {
                    self.transferNo = dict["TransferNo"] as! String
                }
                if dict.keys.contains("TransferNumber") {
                    self.transferNumber = dict["TransferNumber"] as! String
                }
            }
        }
        public var list: [ListLegacyAgentStatusLogsResponseBody.Data.List]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.list != nil {
                var tmp : [Any] = []
                for k in self.list! {
                    tmp.append(k.toMap())
                }
                map["List"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("List") {
                var tmp : [ListLegacyAgentStatusLogsResponseBody.Data.List] = []
                for v in dict["List"] as! [Any] {
                    var model = ListLegacyAgentStatusLogsResponseBody.Data.List()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.list = tmp
            }
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var code: String?

    public var data: ListLegacyAgentStatusLogsResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = ListLegacyAgentStatusLogsResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListLegacyAgentStatusLogsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListLegacyAgentStatusLogsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListLegacyAgentStatusLogsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListLegacyAppraiseLogsRequest : Tea.TeaModel {
    public var endTime: Int64?

    public var instanceId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var startTime: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! Int64
        }
    }
}

public class ListLegacyAppraiseLogsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class List : Tea.TeaModel {
            public var acid: String?

            public var contactType: String?

            public var id: Int64?

            public var instanceId: String?

            public var keyMarkRelation: String?

            public var note: String?

            public var parentNote: String?

            public var pressKey: String?

            public var ramId: String?

            public var skillGroupId: String?

            public var statisticDate: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.acid != nil {
                    map["Acid"] = self.acid!
                }
                if self.contactType != nil {
                    map["ContactType"] = self.contactType!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.keyMarkRelation != nil {
                    map["KeyMarkRelation"] = self.keyMarkRelation!
                }
                if self.note != nil {
                    map["Note"] = self.note!
                }
                if self.parentNote != nil {
                    map["ParentNote"] = self.parentNote!
                }
                if self.pressKey != nil {
                    map["PressKey"] = self.pressKey!
                }
                if self.ramId != nil {
                    map["RamId"] = self.ramId!
                }
                if self.skillGroupId != nil {
                    map["SkillGroupId"] = self.skillGroupId!
                }
                if self.statisticDate != nil {
                    map["StatisticDate"] = self.statisticDate!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Acid") {
                    self.acid = dict["Acid"] as! String
                }
                if dict.keys.contains("ContactType") {
                    self.contactType = dict["ContactType"] as! String
                }
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! Int64
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("KeyMarkRelation") {
                    self.keyMarkRelation = dict["KeyMarkRelation"] as! String
                }
                if dict.keys.contains("Note") {
                    self.note = dict["Note"] as! String
                }
                if dict.keys.contains("ParentNote") {
                    self.parentNote = dict["ParentNote"] as! String
                }
                if dict.keys.contains("PressKey") {
                    self.pressKey = dict["PressKey"] as! String
                }
                if dict.keys.contains("RamId") {
                    self.ramId = dict["RamId"] as! String
                }
                if dict.keys.contains("SkillGroupId") {
                    self.skillGroupId = dict["SkillGroupId"] as! String
                }
                if dict.keys.contains("StatisticDate") {
                    self.statisticDate = dict["StatisticDate"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var list: [ListLegacyAppraiseLogsResponseBody.Data.List]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.list != nil {
                var tmp : [Any] = []
                for k in self.list! {
                    tmp.append(k.toMap())
                }
                map["List"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("List") {
                var tmp : [ListLegacyAppraiseLogsResponseBody.Data.List] = []
                for v in dict["List"] as! [Any] {
                    var model = ListLegacyAppraiseLogsResponseBody.Data.List()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.list = tmp
            }
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var code: String?

    public var data: ListLegacyAppraiseLogsResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = ListLegacyAppraiseLogsResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListLegacyAppraiseLogsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListLegacyAppraiseLogsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListLegacyAppraiseLogsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListLegacyQueueEventLogsRequest : Tea.TeaModel {
    public var endTime: Int64?

    public var instanceId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var skillGroupId: String?

    public var startTime: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.skillGroupId != nil {
            map["SkillGroupId"] = self.skillGroupId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SkillGroupId") {
            self.skillGroupId = dict["SkillGroupId"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! Int64
        }
    }
}

public class ListLegacyQueueEventLogsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class List : Tea.TeaModel {
            public var acid: String?

            public var ani: String?

            public var answerPhone: String?

            public var answerTime: Int64?

            public var cause: String?

            public var dnis: String?

            public var id: Int64?

            public var queueTime: Int64?

            public var statisticDate: String?

            public var tenantId: String?

            public var vq: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.acid != nil {
                    map["Acid"] = self.acid!
                }
                if self.ani != nil {
                    map["Ani"] = self.ani!
                }
                if self.answerPhone != nil {
                    map["AnswerPhone"] = self.answerPhone!
                }
                if self.answerTime != nil {
                    map["AnswerTime"] = self.answerTime!
                }
                if self.cause != nil {
                    map["Cause"] = self.cause!
                }
                if self.dnis != nil {
                    map["Dnis"] = self.dnis!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.queueTime != nil {
                    map["QueueTime"] = self.queueTime!
                }
                if self.statisticDate != nil {
                    map["StatisticDate"] = self.statisticDate!
                }
                if self.tenantId != nil {
                    map["TenantId"] = self.tenantId!
                }
                if self.vq != nil {
                    map["Vq"] = self.vq!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Acid") {
                    self.acid = dict["Acid"] as! String
                }
                if dict.keys.contains("Ani") {
                    self.ani = dict["Ani"] as! String
                }
                if dict.keys.contains("AnswerPhone") {
                    self.answerPhone = dict["AnswerPhone"] as! String
                }
                if dict.keys.contains("AnswerTime") {
                    self.answerTime = dict["AnswerTime"] as! Int64
                }
                if dict.keys.contains("Cause") {
                    self.cause = dict["Cause"] as! String
                }
                if dict.keys.contains("Dnis") {
                    self.dnis = dict["Dnis"] as! String
                }
                if dict.keys.contains("Id") {
                    self.id = dict["Id"] as! Int64
                }
                if dict.keys.contains("QueueTime") {
                    self.queueTime = dict["QueueTime"] as! Int64
                }
                if dict.keys.contains("StatisticDate") {
                    self.statisticDate = dict["StatisticDate"] as! String
                }
                if dict.keys.contains("TenantId") {
                    self.tenantId = dict["TenantId"] as! String
                }
                if dict.keys.contains("Vq") {
                    self.vq = dict["Vq"] as! String
                }
            }
        }
        public var list: [ListLegacyQueueEventLogsResponseBody.Data.List]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.list != nil {
                var tmp : [Any] = []
                for k in self.list! {
                    tmp.append(k.toMap())
                }
                map["List"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("List") {
                var tmp : [ListLegacyQueueEventLogsResponseBody.Data.List] = []
                for v in dict["List"] as! [Any] {
                    var model = ListLegacyQueueEventLogsResponseBody.Data.List()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.list = tmp
            }
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var code: String?

    public var data: ListLegacyQueueEventLogsResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = ListLegacyQueueEventLogsResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListLegacyQueueEventLogsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListLegacyQueueEventLogsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListLegacyQueueEventLogsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListMonoRecordingsRequest : Tea.TeaModel {
    public var contactId: String?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.contactId != nil {
            map["ContactId"] = self.contactId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ContactId") {
            self.contactId = dict["ContactId"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
    }
}

public class ListMonoRecordingsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var agentId: String?

        public var agentName: String?

        public var contactId: String?

        public var duration: String?

        public var fileName: String?

        public var fileUrl: String?

        public var ramId: String?

        public var skillGroupId: String?

        public var startTime: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.agentId != nil {
                map["AgentId"] = self.agentId!
            }
            if self.agentName != nil {
                map["AgentName"] = self.agentName!
            }
            if self.contactId != nil {
                map["ContactId"] = self.contactId!
            }
            if self.duration != nil {
                map["Duration"] = self.duration!
            }
            if self.fileName != nil {
                map["FileName"] = self.fileName!
            }
            if self.fileUrl != nil {
                map["FileUrl"] = self.fileUrl!
            }
            if self.ramId != nil {
                map["RamId"] = self.ramId!
            }
            if self.skillGroupId != nil {
                map["SkillGroupId"] = self.skillGroupId!
            }
            if self.startTime != nil {
                map["StartTime"] = self.startTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AgentId") {
                self.agentId = dict["AgentId"] as! String
            }
            if dict.keys.contains("AgentName") {
                self.agentName = dict["AgentName"] as! String
            }
            if dict.keys.contains("ContactId") {
                self.contactId = dict["ContactId"] as! String
            }
            if dict.keys.contains("Duration") {
                self.duration = dict["Duration"] as! String
            }
            if dict.keys.contains("FileName") {
                self.fileName = dict["FileName"] as! String
            }
            if dict.keys.contains("FileUrl") {
                self.fileUrl = dict["FileUrl"] as! String
            }
            if dict.keys.contains("RamId") {
                self.ramId = dict["RamId"] as! String
            }
            if dict.keys.contains("SkillGroupId") {
                self.skillGroupId = dict["SkillGroupId"] as! String
            }
            if dict.keys.contains("StartTime") {
                self.startTime = dict["StartTime"] as! String
            }
        }
    }
    public var code: String?

    public var data: [ListMonoRecordingsResponseBody.Data]?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var tmp : [ListMonoRecordingsResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = ListMonoRecordingsResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListMonoRecordingsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListMonoRecordingsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListMonoRecordingsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListMultiChannelRecordingsRequest : Tea.TeaModel {
    public var contactId: String?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.contactId != nil {
            map["ContactId"] = self.contactId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ContactId") {
            self.contactId = dict["ContactId"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
    }
}

public class ListMultiChannelRecordingsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class HoldTimeSegments : Tea.TeaModel {
            public var endTime: Int64?

            public var startTime: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.endTime != nil {
                    map["EndTime"] = self.endTime!
                }
                if self.startTime != nil {
                    map["StartTime"] = self.startTime!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("EndTime") {
                    self.endTime = dict["EndTime"] as! Int64
                }
                if dict.keys.contains("StartTime") {
                    self.startTime = dict["StartTime"] as! Int64
                }
            }
        }
        public var agentChannelId: String?

        public var agentId: String?

        public var agentName: String?

        public var contactId: String?

        public var duration: String?

        public var fileName: String?

        public var fileUrl: String?

        public var holdTimeSegments: [ListMultiChannelRecordingsResponseBody.Data.HoldTimeSegments]?

        public var ramId: String?

        public var skillGroupId: String?

        public var startTime: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.agentChannelId != nil {
                map["AgentChannelId"] = self.agentChannelId!
            }
            if self.agentId != nil {
                map["AgentId"] = self.agentId!
            }
            if self.agentName != nil {
                map["AgentName"] = self.agentName!
            }
            if self.contactId != nil {
                map["ContactId"] = self.contactId!
            }
            if self.duration != nil {
                map["Duration"] = self.duration!
            }
            if self.fileName != nil {
                map["FileName"] = self.fileName!
            }
            if self.fileUrl != nil {
                map["FileUrl"] = self.fileUrl!
            }
            if self.holdTimeSegments != nil {
                var tmp : [Any] = []
                for k in self.holdTimeSegments! {
                    tmp.append(k.toMap())
                }
                map["HoldTimeSegments"] = tmp
            }
            if self.ramId != nil {
                map["RamId"] = self.ramId!
            }
            if self.skillGroupId != nil {
                map["SkillGroupId"] = self.skillGroupId!
            }
            if self.startTime != nil {
                map["StartTime"] = self.startTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AgentChannelId") {
                self.agentChannelId = dict["AgentChannelId"] as! String
            }
            if dict.keys.contains("AgentId") {
                self.agentId = dict["AgentId"] as! String
            }
            if dict.keys.contains("AgentName") {
                self.agentName = dict["AgentName"] as! String
            }
            if dict.keys.contains("ContactId") {
                self.contactId = dict["ContactId"] as! String
            }
            if dict.keys.contains("Duration") {
                self.duration = dict["Duration"] as! String
            }
            if dict.keys.contains("FileName") {
                self.fileName = dict["FileName"] as! String
            }
            if dict.keys.contains("FileUrl") {
                self.fileUrl = dict["FileUrl"] as! String
            }
            if dict.keys.contains("HoldTimeSegments") {
                var tmp : [ListMultiChannelRecordingsResponseBody.Data.HoldTimeSegments] = []
                for v in dict["HoldTimeSegments"] as! [Any] {
                    var model = ListMultiChannelRecordingsResponseBody.Data.HoldTimeSegments()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.holdTimeSegments = tmp
            }
            if dict.keys.contains("RamId") {
                self.ramId = dict["RamId"] as! String
            }
            if dict.keys.contains("SkillGroupId") {
                self.skillGroupId = dict["SkillGroupId"] as! String
            }
            if dict.keys.contains("StartTime") {
                self.startTime = dict["StartTime"] as! Int64
            }
        }
    }
    public var code: String?

    public var data: [ListMultiChannelRecordingsResponseBody.Data]?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var tmp : [ListMultiChannelRecordingsResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = ListMultiChannelRecordingsResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListMultiChannelRecordingsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListMultiChannelRecordingsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListMultiChannelRecordingsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListOutboundNumbersOfUserRequest : Tea.TeaModel {
    public var instanceId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var skillGroupIdList: String?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.skillGroupIdList != nil {
            map["SkillGroupIdList"] = self.skillGroupIdList!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SkillGroupIdList") {
            self.skillGroupIdList = dict["SkillGroupIdList"] as! String
        }
        if dict.keys.contains("UserId") {
            self.userId = dict["UserId"] as! String
        }
    }
}

public class ListOutboundNumbersOfUserResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class List : Tea.TeaModel {
            public var city: String?

            public var number: String?

            public var province: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.city != nil {
                    map["City"] = self.city!
                }
                if self.number != nil {
                    map["Number"] = self.number!
                }
                if self.province != nil {
                    map["Province"] = self.province!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("City") {
                    self.city = dict["City"] as! String
                }
                if dict.keys.contains("Number") {
                    self.number = dict["Number"] as! String
                }
                if dict.keys.contains("Province") {
                    self.province = dict["Province"] as! String
                }
            }
        }
        public var list: [ListOutboundNumbersOfUserResponseBody.Data.List]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.list != nil {
                var tmp : [Any] = []
                for k in self.list! {
                    tmp.append(k.toMap())
                }
                map["List"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("List") {
                var tmp : [ListOutboundNumbersOfUserResponseBody.Data.List] = []
                for v in dict["List"] as! [Any] {
                    var model = ListOutboundNumbersOfUserResponseBody.Data.List()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.list = tmp
            }
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var code: String?

    public var data: ListOutboundNumbersOfUserResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = ListOutboundNumbersOfUserResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListOutboundNumbersOfUserResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListOutboundNumbersOfUserResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListOutboundNumbersOfUserResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListPersonalNumbersOfUserRequest : Tea.TeaModel {
    public var instanceId: String?

    public var isMember: Bool?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var searchPattern: String?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.isMember != nil {
            map["IsMember"] = self.isMember!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.searchPattern != nil {
            map["SearchPattern"] = self.searchPattern!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("IsMember") {
            self.isMember = dict["IsMember"] as! Bool
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SearchPattern") {
            self.searchPattern = dict["SearchPattern"] as! String
        }
        if dict.keys.contains("UserId") {
            self.userId = dict["UserId"] as! String
        }
    }
}

public class ListPersonalNumbersOfUserResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class List : Tea.TeaModel {
            public var active: Bool?

            public var city: String?

            public var contactFlowId: String?

            public var instanceId: String?

            public var number: String?

            public var province: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.active != nil {
                    map["Active"] = self.active!
                }
                if self.city != nil {
                    map["City"] = self.city!
                }
                if self.contactFlowId != nil {
                    map["ContactFlowId"] = self.contactFlowId!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.number != nil {
                    map["Number"] = self.number!
                }
                if self.province != nil {
                    map["Province"] = self.province!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Active") {
                    self.active = dict["Active"] as! Bool
                }
                if dict.keys.contains("City") {
                    self.city = dict["City"] as! String
                }
                if dict.keys.contains("ContactFlowId") {
                    self.contactFlowId = dict["ContactFlowId"] as! String
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("Number") {
                    self.number = dict["Number"] as! String
                }
                if dict.keys.contains("Province") {
                    self.province = dict["Province"] as! String
                }
            }
        }
        public var list: [ListPersonalNumbersOfUserResponseBody.Data.List]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.list != nil {
                var tmp : [Any] = []
                for k in self.list! {
                    tmp.append(k.toMap())
                }
                map["List"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("List") {
                var tmp : [ListPersonalNumbersOfUserResponseBody.Data.List] = []
                for v in dict["List"] as! [Any] {
                    var model = ListPersonalNumbersOfUserResponseBody.Data.List()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.list = tmp
            }
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var code: String?

    public var data: ListPersonalNumbersOfUserResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = ListPersonalNumbersOfUserResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListPersonalNumbersOfUserResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListPersonalNumbersOfUserResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListPersonalNumbersOfUserResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListPhoneNumbersRequest : Tea.TeaModel {
    public var active: Bool?

    public var instanceId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var searchPattern: String?

    public var usage: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.active != nil {
            map["Active"] = self.active!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.searchPattern != nil {
            map["SearchPattern"] = self.searchPattern!
        }
        if self.usage != nil {
            map["Usage"] = self.usage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Active") {
            self.active = dict["Active"] as! Bool
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SearchPattern") {
            self.searchPattern = dict["SearchPattern"] as! String
        }
        if dict.keys.contains("Usage") {
            self.usage = dict["Usage"] as! String
        }
    }
}

public class ListPhoneNumbersResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class List : Tea.TeaModel {
            public class SkillGroups : Tea.TeaModel {
                public var displayName: String?

                public var instanceId: String?

                public var name: String?

                public var skillGroupId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.displayName != nil {
                        map["DisplayName"] = self.displayName!
                    }
                    if self.instanceId != nil {
                        map["InstanceId"] = self.instanceId!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.skillGroupId != nil {
                        map["SkillGroupId"] = self.skillGroupId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("DisplayName") {
                        self.displayName = dict["DisplayName"] as! String
                    }
                    if dict.keys.contains("InstanceId") {
                        self.instanceId = dict["InstanceId"] as! String
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("SkillGroupId") {
                        self.skillGroupId = dict["SkillGroupId"] as! String
                    }
                }
            }
            public var active: Bool?

            public var city: String?

            public var contactFlowId: String?

            public var contactFlowName: String?

            public var createTime: String?

            public var instanceId: String?

            public var number: String?

            public var provider: String?

            public var province: String?

            public var skillGroups: [ListPhoneNumbersResponseBody.Data.List.SkillGroups]?

            public var tags: String?

            public var usage: String?

            public var userId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.active != nil {
                    map["Active"] = self.active!
                }
                if self.city != nil {
                    map["City"] = self.city!
                }
                if self.contactFlowId != nil {
                    map["ContactFlowId"] = self.contactFlowId!
                }
                if self.contactFlowName != nil {
                    map["ContactFlowName"] = self.contactFlowName!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.number != nil {
                    map["Number"] = self.number!
                }
                if self.provider != nil {
                    map["Provider"] = self.provider!
                }
                if self.province != nil {
                    map["Province"] = self.province!
                }
                if self.skillGroups != nil {
                    var tmp : [Any] = []
                    for k in self.skillGroups! {
                        tmp.append(k.toMap())
                    }
                    map["SkillGroups"] = tmp
                }
                if self.tags != nil {
                    map["Tags"] = self.tags!
                }
                if self.usage != nil {
                    map["Usage"] = self.usage!
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Active") {
                    self.active = dict["Active"] as! Bool
                }
                if dict.keys.contains("City") {
                    self.city = dict["City"] as! String
                }
                if dict.keys.contains("ContactFlowId") {
                    self.contactFlowId = dict["ContactFlowId"] as! String
                }
                if dict.keys.contains("ContactFlowName") {
                    self.contactFlowName = dict["ContactFlowName"] as! String
                }
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! String
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("Number") {
                    self.number = dict["Number"] as! String
                }
                if dict.keys.contains("Provider") {
                    self.provider = dict["Provider"] as! String
                }
                if dict.keys.contains("Province") {
                    self.province = dict["Province"] as! String
                }
                if dict.keys.contains("SkillGroups") {
                    var tmp : [ListPhoneNumbersResponseBody.Data.List.SkillGroups] = []
                    for v in dict["SkillGroups"] as! [Any] {
                        var model = ListPhoneNumbersResponseBody.Data.List.SkillGroups()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.skillGroups = tmp
                }
                if dict.keys.contains("Tags") {
                    self.tags = dict["Tags"] as! String
                }
                if dict.keys.contains("Usage") {
                    self.usage = dict["Usage"] as! String
                }
                if dict.keys.contains("UserId") {
                    self.userId = dict["UserId"] as! String
                }
            }
        }
        public var list: [ListPhoneNumbersResponseBody.Data.List]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.list != nil {
                var tmp : [Any] = []
                for k in self.list! {
                    tmp.append(k.toMap())
                }
                map["List"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("List") {
                var tmp : [ListPhoneNumbersResponseBody.Data.List] = []
                for v in dict["List"] as! [Any] {
                    var model = ListPhoneNumbersResponseBody.Data.List()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.list = tmp
            }
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var code: String?

    public var data: ListPhoneNumbersResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = ListPhoneNumbersResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListPhoneNumbersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListPhoneNumbersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListPhoneNumbersResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListPhoneNumbersOfSkillGroupRequest : Tea.TeaModel {
    public var active: Bool?

    public var instanceId: String?

    public var isMember: Bool?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var searchPattern: String?

    public var skillGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.active != nil {
            map["Active"] = self.active!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.isMember != nil {
            map["IsMember"] = self.isMember!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.searchPattern != nil {
            map["SearchPattern"] = self.searchPattern!
        }
        if self.skillGroupId != nil {
            map["SkillGroupId"] = self.skillGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Active") {
            self.active = dict["Active"] as! Bool
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("IsMember") {
            self.isMember = dict["IsMember"] as! Bool
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SearchPattern") {
            self.searchPattern = dict["SearchPattern"] as! String
        }
        if dict.keys.contains("SkillGroupId") {
            self.skillGroupId = dict["SkillGroupId"] as! String
        }
    }
}

public class ListPhoneNumbersOfSkillGroupResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class List : Tea.TeaModel {
            public var active: Bool?

            public var city: String?

            public var contactFlowId: String?

            public var instanceId: String?

            public var number: String?

            public var province: String?

            public var usage: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.active != nil {
                    map["Active"] = self.active!
                }
                if self.city != nil {
                    map["City"] = self.city!
                }
                if self.contactFlowId != nil {
                    map["ContactFlowId"] = self.contactFlowId!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.number != nil {
                    map["Number"] = self.number!
                }
                if self.province != nil {
                    map["Province"] = self.province!
                }
                if self.usage != nil {
                    map["Usage"] = self.usage!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Active") {
                    self.active = dict["Active"] as! Bool
                }
                if dict.keys.contains("City") {
                    self.city = dict["City"] as! String
                }
                if dict.keys.contains("ContactFlowId") {
                    self.contactFlowId = dict["ContactFlowId"] as! String
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("Number") {
                    self.number = dict["Number"] as! String
                }
                if dict.keys.contains("Province") {
                    self.province = dict["Province"] as! String
                }
                if dict.keys.contains("Usage") {
                    self.usage = dict["Usage"] as! String
                }
            }
        }
        public var list: [ListPhoneNumbersOfSkillGroupResponseBody.Data.List]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.list != nil {
                var tmp : [Any] = []
                for k in self.list! {
                    tmp.append(k.toMap())
                }
                map["List"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("List") {
                var tmp : [ListPhoneNumbersOfSkillGroupResponseBody.Data.List] = []
                for v in dict["List"] as! [Any] {
                    var model = ListPhoneNumbersOfSkillGroupResponseBody.Data.List()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.list = tmp
            }
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var code: String?

    public var data: ListPhoneNumbersOfSkillGroupResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = ListPhoneNumbersOfSkillGroupResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListPhoneNumbersOfSkillGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListPhoneNumbersOfSkillGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListPhoneNumbersOfSkillGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListPrivilegesOfUserRequest : Tea.TeaModel {
    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
    }
}

public class ListPrivilegesOfUserResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var instanceId: String?

        public var name: String?

        public var scope: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.scope != nil {
                map["Scope"] = self.scope!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("InstanceId") {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Scope") {
                self.scope = dict["Scope"] as! String
            }
        }
    }
    public var code: String?

    public var data: [ListPrivilegesOfUserResponseBody.Data]?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var tmp : [ListPrivilegesOfUserResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = ListPrivilegesOfUserResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListPrivilegesOfUserResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListPrivilegesOfUserResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListPrivilegesOfUserResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListRamUsersRequest : Tea.TeaModel {
    public var instanceId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var searchPattern: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.searchPattern != nil {
            map["SearchPattern"] = self.searchPattern!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SearchPattern") {
            self.searchPattern = dict["SearchPattern"] as! String
        }
    }
}

public class ListRamUsersResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class List : Tea.TeaModel {
            public var aliyunUid: Int64?

            public var displayName: String?

            public var email: String?

            public var loginName: String?

            public var mobile: String?

            public var primary: Bool?

            public var ramId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.aliyunUid != nil {
                    map["AliyunUid"] = self.aliyunUid!
                }
                if self.displayName != nil {
                    map["DisplayName"] = self.displayName!
                }
                if self.email != nil {
                    map["Email"] = self.email!
                }
                if self.loginName != nil {
                    map["LoginName"] = self.loginName!
                }
                if self.mobile != nil {
                    map["Mobile"] = self.mobile!
                }
                if self.primary != nil {
                    map["Primary"] = self.primary!
                }
                if self.ramId != nil {
                    map["RamId"] = self.ramId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AliyunUid") {
                    self.aliyunUid = dict["AliyunUid"] as! Int64
                }
                if dict.keys.contains("DisplayName") {
                    self.displayName = dict["DisplayName"] as! String
                }
                if dict.keys.contains("Email") {
                    self.email = dict["Email"] as! String
                }
                if dict.keys.contains("LoginName") {
                    self.loginName = dict["LoginName"] as! String
                }
                if dict.keys.contains("Mobile") {
                    self.mobile = dict["Mobile"] as! String
                }
                if dict.keys.contains("Primary") {
                    self.primary = dict["Primary"] as! Bool
                }
                if dict.keys.contains("RamId") {
                    self.ramId = dict["RamId"] as! String
                }
            }
        }
        public var list: [ListRamUsersResponseBody.Data.List]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.list != nil {
                var tmp : [Any] = []
                for k in self.list! {
                    tmp.append(k.toMap())
                }
                map["List"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("List") {
                var tmp : [ListRamUsersResponseBody.Data.List] = []
                for v in dict["List"] as! [Any] {
                    var model = ListRamUsersResponseBody.Data.List()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.list = tmp
            }
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var code: String?

    public var data: ListRamUsersResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var params: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.params != nil {
            map["Params"] = self.params!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = ListRamUsersResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Params") {
            self.params = dict["Params"] as! [String]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListRamUsersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListRamUsersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListRamUsersResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListRealtimeAgentStatesRequest : Tea.TeaModel {
    public var agentIdList: String?

    public var agentName: String?

    public var callTypeList: String?

    public var instanceId: String?

    public var mediaType: String?

    public var outboundScenario: Bool?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var query: String?

    public var skillGroupId: String?

    public var stateList: String?

    public var workModeList: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.agentIdList != nil {
            map["AgentIdList"] = self.agentIdList!
        }
        if self.agentName != nil {
            map["AgentName"] = self.agentName!
        }
        if self.callTypeList != nil {
            map["CallTypeList"] = self.callTypeList!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.mediaType != nil {
            map["MediaType"] = self.mediaType!
        }
        if self.outboundScenario != nil {
            map["OutboundScenario"] = self.outboundScenario!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.query != nil {
            map["Query"] = self.query!
        }
        if self.skillGroupId != nil {
            map["SkillGroupId"] = self.skillGroupId!
        }
        if self.stateList != nil {
            map["StateList"] = self.stateList!
        }
        if self.workModeList != nil {
            map["WorkModeList"] = self.workModeList!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AgentIdList") {
            self.agentIdList = dict["AgentIdList"] as! String
        }
        if dict.keys.contains("AgentName") {
            self.agentName = dict["AgentName"] as! String
        }
        if dict.keys.contains("CallTypeList") {
            self.callTypeList = dict["CallTypeList"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("MediaType") {
            self.mediaType = dict["MediaType"] as! String
        }
        if dict.keys.contains("OutboundScenario") {
            self.outboundScenario = dict["OutboundScenario"] as! Bool
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("Query") {
            self.query = dict["Query"] as! String
        }
        if dict.keys.contains("SkillGroupId") {
            self.skillGroupId = dict["SkillGroupId"] as! String
        }
        if dict.keys.contains("StateList") {
            self.stateList = dict["StateList"] as! String
        }
        if dict.keys.contains("WorkModeList") {
            self.workModeList = dict["WorkModeList"] as! String
        }
    }
}

public class ListRealtimeAgentStatesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class List : Tea.TeaModel {
            public var agentId: String?

            public var agentName: String?

            public var callType: String?

            public var counterParty: String?

            public var duration: Int64?

            public var extension_: String?

            public var instanceId: String?

            public var mobile: String?

            public var outboundScenario: Bool?

            public var skillGroupIdList: [String]?

            public var skillGroupNameList: [String]?

            public var state: String?

            public var stateCode: String?

            public var stateTime: Int64?

            public var workMode: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.agentId != nil {
                    map["AgentId"] = self.agentId!
                }
                if self.agentName != nil {
                    map["AgentName"] = self.agentName!
                }
                if self.callType != nil {
                    map["CallType"] = self.callType!
                }
                if self.counterParty != nil {
                    map["CounterParty"] = self.counterParty!
                }
                if self.duration != nil {
                    map["Duration"] = self.duration!
                }
                if self.extension_ != nil {
                    map["Extension"] = self.extension_!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.mobile != nil {
                    map["Mobile"] = self.mobile!
                }
                if self.outboundScenario != nil {
                    map["OutboundScenario"] = self.outboundScenario!
                }
                if self.skillGroupIdList != nil {
                    map["SkillGroupIdList"] = self.skillGroupIdList!
                }
                if self.skillGroupNameList != nil {
                    map["SkillGroupNameList"] = self.skillGroupNameList!
                }
                if self.state != nil {
                    map["State"] = self.state!
                }
                if self.stateCode != nil {
                    map["StateCode"] = self.stateCode!
                }
                if self.stateTime != nil {
                    map["StateTime"] = self.stateTime!
                }
                if self.workMode != nil {
                    map["WorkMode"] = self.workMode!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AgentId") {
                    self.agentId = dict["AgentId"] as! String
                }
                if dict.keys.contains("AgentName") {
                    self.agentName = dict["AgentName"] as! String
                }
                if dict.keys.contains("CallType") {
                    self.callType = dict["CallType"] as! String
                }
                if dict.keys.contains("CounterParty") {
                    self.counterParty = dict["CounterParty"] as! String
                }
                if dict.keys.contains("Duration") {
                    self.duration = dict["Duration"] as! Int64
                }
                if dict.keys.contains("Extension") {
                    self.extension_ = dict["Extension"] as! String
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("Mobile") {
                    self.mobile = dict["Mobile"] as! String
                }
                if dict.keys.contains("OutboundScenario") {
                    self.outboundScenario = dict["OutboundScenario"] as! Bool
                }
                if dict.keys.contains("SkillGroupIdList") {
                    self.skillGroupIdList = dict["SkillGroupIdList"] as! [String]
                }
                if dict.keys.contains("SkillGroupNameList") {
                    self.skillGroupNameList = dict["SkillGroupNameList"] as! [String]
                }
                if dict.keys.contains("State") {
                    self.state = dict["State"] as! String
                }
                if dict.keys.contains("StateCode") {
                    self.stateCode = dict["StateCode"] as! String
                }
                if dict.keys.contains("StateTime") {
                    self.stateTime = dict["StateTime"] as! Int64
                }
                if dict.keys.contains("WorkMode") {
                    self.workMode = dict["WorkMode"] as! String
                }
            }
        }
        public var list: [ListRealtimeAgentStatesResponseBody.Data.List]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.list != nil {
                var tmp : [Any] = []
                for k in self.list! {
                    tmp.append(k.toMap())
                }
                map["List"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("List") {
                var tmp : [ListRealtimeAgentStatesResponseBody.Data.List] = []
                for v in dict["List"] as! [Any] {
                    var model = ListRealtimeAgentStatesResponseBody.Data.List()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.list = tmp
            }
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var code: String?

    public var data: ListRealtimeAgentStatesResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = ListRealtimeAgentStatesResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListRealtimeAgentStatesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListRealtimeAgentStatesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListRealtimeAgentStatesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListRealtimeSkillGroupStatesRequest : Tea.TeaModel {
    public var instanceId: String?

    public var mediaType: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var skillGroupIdList: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.mediaType != nil {
            map["MediaType"] = self.mediaType!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.skillGroupIdList != nil {
            map["SkillGroupIdList"] = self.skillGroupIdList!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("MediaType") {
            self.mediaType = dict["MediaType"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SkillGroupIdList") {
            self.skillGroupIdList = dict["SkillGroupIdList"] as! String
        }
    }
}

public class ListRealtimeSkillGroupStatesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class List : Tea.TeaModel {
            public class BreakCodeDetailList : Tea.TeaModel {
                public var breakCode: String?

                public var count: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.breakCode != nil {
                        map["BreakCode"] = self.breakCode!
                    }
                    if self.count != nil {
                        map["Count"] = self.count!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("BreakCode") {
                        self.breakCode = dict["BreakCode"] as! String
                    }
                    if dict.keys.contains("Count") {
                        self.count = dict["Count"] as! Int64
                    }
                }
            }
            public var breakCodeDetailList: [ListRealtimeSkillGroupStatesResponseBody.Data.List.BreakCodeDetailList]?

            public var breakingAgents: Int64?

            public var instanceId: String?

            public var loggedInAgents: Int64?

            public var longestWaitingTime: Int64?

            public var outboundScenarioReadyAgents: Int64?

            public var readyAgents: Int64?

            public var skillGroupId: String?

            public var skillGroupName: String?

            public var talkingAgents: Int64?

            public var totalAgents: Int64?

            public var waitingCalls: Int64?

            public var workingAgents: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.breakCodeDetailList != nil {
                    var tmp : [Any] = []
                    for k in self.breakCodeDetailList! {
                        tmp.append(k.toMap())
                    }
                    map["BreakCodeDetailList"] = tmp
                }
                if self.breakingAgents != nil {
                    map["BreakingAgents"] = self.breakingAgents!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.loggedInAgents != nil {
                    map["LoggedInAgents"] = self.loggedInAgents!
                }
                if self.longestWaitingTime != nil {
                    map["LongestWaitingTime"] = self.longestWaitingTime!
                }
                if self.outboundScenarioReadyAgents != nil {
                    map["OutboundScenarioReadyAgents"] = self.outboundScenarioReadyAgents!
                }
                if self.readyAgents != nil {
                    map["ReadyAgents"] = self.readyAgents!
                }
                if self.skillGroupId != nil {
                    map["SkillGroupId"] = self.skillGroupId!
                }
                if self.skillGroupName != nil {
                    map["SkillGroupName"] = self.skillGroupName!
                }
                if self.talkingAgents != nil {
                    map["TalkingAgents"] = self.talkingAgents!
                }
                if self.totalAgents != nil {
                    map["TotalAgents"] = self.totalAgents!
                }
                if self.waitingCalls != nil {
                    map["WaitingCalls"] = self.waitingCalls!
                }
                if self.workingAgents != nil {
                    map["WorkingAgents"] = self.workingAgents!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BreakCodeDetailList") {
                    var tmp : [ListRealtimeSkillGroupStatesResponseBody.Data.List.BreakCodeDetailList] = []
                    for v in dict["BreakCodeDetailList"] as! [Any] {
                        var model = ListRealtimeSkillGroupStatesResponseBody.Data.List.BreakCodeDetailList()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.breakCodeDetailList = tmp
                }
                if dict.keys.contains("BreakingAgents") {
                    self.breakingAgents = dict["BreakingAgents"] as! Int64
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("LoggedInAgents") {
                    self.loggedInAgents = dict["LoggedInAgents"] as! Int64
                }
                if dict.keys.contains("LongestWaitingTime") {
                    self.longestWaitingTime = dict["LongestWaitingTime"] as! Int64
                }
                if dict.keys.contains("OutboundScenarioReadyAgents") {
                    self.outboundScenarioReadyAgents = dict["OutboundScenarioReadyAgents"] as! Int64
                }
                if dict.keys.contains("ReadyAgents") {
                    self.readyAgents = dict["ReadyAgents"] as! Int64
                }
                if dict.keys.contains("SkillGroupId") {
                    self.skillGroupId = dict["SkillGroupId"] as! String
                }
                if dict.keys.contains("SkillGroupName") {
                    self.skillGroupName = dict["SkillGroupName"] as! String
                }
                if dict.keys.contains("TalkingAgents") {
                    self.talkingAgents = dict["TalkingAgents"] as! Int64
                }
                if dict.keys.contains("TotalAgents") {
                    self.totalAgents = dict["TotalAgents"] as! Int64
                }
                if dict.keys.contains("WaitingCalls") {
                    self.waitingCalls = dict["WaitingCalls"] as! Int64
                }
                if dict.keys.contains("WorkingAgents") {
                    self.workingAgents = dict["WorkingAgents"] as! Int64
                }
            }
        }
        public var list: [ListRealtimeSkillGroupStatesResponseBody.Data.List]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.list != nil {
                var tmp : [Any] = []
                for k in self.list! {
                    tmp.append(k.toMap())
                }
                map["List"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("List") {
                var tmp : [ListRealtimeSkillGroupStatesResponseBody.Data.List] = []
                for v in dict["List"] as! [Any] {
                    var model = ListRealtimeSkillGroupStatesResponseBody.Data.List()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.list = tmp
            }
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var code: String?

    public var data: ListRealtimeSkillGroupStatesResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = ListRealtimeSkillGroupStatesResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListRealtimeSkillGroupStatesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListRealtimeSkillGroupStatesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListRealtimeSkillGroupStatesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListRecentCallDetailRecordsRequest : Tea.TeaModel {
    public var criteria: String?

    public var endTime: Int64?

    public var instanceId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var startTime: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.criteria != nil {
            map["Criteria"] = self.criteria!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Criteria") {
            self.criteria = dict["Criteria"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! Int64
        }
    }
}

public class ListRecentCallDetailRecordsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class List : Tea.TeaModel {
            public var agentIds: String?

            public var callDuration: String?

            public var calledNumber: String?

            public var callingNumber: String?

            public var contactDisposition: String?

            public var contactId: String?

            public var contactType: String?

            public var duration: Int64?

            public var instanceId: String?

            public var skillGroupIds: String?

            public var startTime: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.agentIds != nil {
                    map["AgentIds"] = self.agentIds!
                }
                if self.callDuration != nil {
                    map["CallDuration"] = self.callDuration!
                }
                if self.calledNumber != nil {
                    map["CalledNumber"] = self.calledNumber!
                }
                if self.callingNumber != nil {
                    map["CallingNumber"] = self.callingNumber!
                }
                if self.contactDisposition != nil {
                    map["ContactDisposition"] = self.contactDisposition!
                }
                if self.contactId != nil {
                    map["ContactId"] = self.contactId!
                }
                if self.contactType != nil {
                    map["ContactType"] = self.contactType!
                }
                if self.duration != nil {
                    map["Duration"] = self.duration!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.skillGroupIds != nil {
                    map["SkillGroupIds"] = self.skillGroupIds!
                }
                if self.startTime != nil {
                    map["StartTime"] = self.startTime!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AgentIds") {
                    self.agentIds = dict["AgentIds"] as! String
                }
                if dict.keys.contains("CallDuration") {
                    self.callDuration = dict["CallDuration"] as! String
                }
                if dict.keys.contains("CalledNumber") {
                    self.calledNumber = dict["CalledNumber"] as! String
                }
                if dict.keys.contains("CallingNumber") {
                    self.callingNumber = dict["CallingNumber"] as! String
                }
                if dict.keys.contains("ContactDisposition") {
                    self.contactDisposition = dict["ContactDisposition"] as! String
                }
                if dict.keys.contains("ContactId") {
                    self.contactId = dict["ContactId"] as! String
                }
                if dict.keys.contains("ContactType") {
                    self.contactType = dict["ContactType"] as! String
                }
                if dict.keys.contains("Duration") {
                    self.duration = dict["Duration"] as! Int64
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("SkillGroupIds") {
                    self.skillGroupIds = dict["SkillGroupIds"] as! String
                }
                if dict.keys.contains("StartTime") {
                    self.startTime = dict["StartTime"] as! Int64
                }
            }
        }
        public var list: [ListRecentCallDetailRecordsResponseBody.Data.List]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.list != nil {
                var tmp : [Any] = []
                for k in self.list! {
                    tmp.append(k.toMap())
                }
                map["List"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("List") {
                var tmp : [ListRecentCallDetailRecordsResponseBody.Data.List] = []
                for v in dict["List"] as! [Any] {
                    var model = ListRecentCallDetailRecordsResponseBody.Data.List()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.list = tmp
            }
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var code: String?

    public var data: ListRecentCallDetailRecordsResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = ListRecentCallDetailRecordsResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListRecentCallDetailRecordsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListRecentCallDetailRecordsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListRecentCallDetailRecordsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListRolesRequest : Tea.TeaModel {
    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
    }
}

public class ListRolesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var name: String?

        public var roleId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.roleId != nil {
                map["RoleId"] = self.roleId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("RoleId") {
                self.roleId = dict["RoleId"] as! String
            }
        }
    }
    public var code: String?

    public var data: [ListRolesResponseBody.Data]?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var tmp : [ListRolesResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = ListRolesResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListRolesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListRolesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListRolesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListSkillGroupStatesRequest : Tea.TeaModel {
    public var instanceId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var skillGroupIds: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.skillGroupIds != nil {
            map["SkillGroupIds"] = self.skillGroupIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SkillGroupIds") {
            self.skillGroupIds = dict["SkillGroupIds"] as! String
        }
    }
}

public class ListSkillGroupStatesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class List : Tea.TeaModel {
            public var averageWaitingTime: Int64?

            public var breakingAgents: Int64?

            public var inboundTalkingAgents: Int64?

            public var instanceId: String?

            public var loggedInAgents: Int64?

            public var longestCall: Int64?

            public var outboundScenarioReadyAgents: Int64?

            public var outboundTalkingAgents: Int64?

            public var readyAgents: Int64?

            public var skillGroupId: String?

            public var skillGroupName: String?

            public var talkingAgents: Int64?

            public var waitingCalls: Int64?

            public var waitingCallsLevel10: Int64?

            public var waitingCallsLevel20: Int64?

            public var waitingCallsLevel30: Int64?

            public var workingAgents: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.averageWaitingTime != nil {
                    map["AverageWaitingTime"] = self.averageWaitingTime!
                }
                if self.breakingAgents != nil {
                    map["BreakingAgents"] = self.breakingAgents!
                }
                if self.inboundTalkingAgents != nil {
                    map["InboundTalkingAgents"] = self.inboundTalkingAgents!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.loggedInAgents != nil {
                    map["LoggedInAgents"] = self.loggedInAgents!
                }
                if self.longestCall != nil {
                    map["LongestCall"] = self.longestCall!
                }
                if self.outboundScenarioReadyAgents != nil {
                    map["OutboundScenarioReadyAgents"] = self.outboundScenarioReadyAgents!
                }
                if self.outboundTalkingAgents != nil {
                    map["OutboundTalkingAgents"] = self.outboundTalkingAgents!
                }
                if self.readyAgents != nil {
                    map["ReadyAgents"] = self.readyAgents!
                }
                if self.skillGroupId != nil {
                    map["SkillGroupId"] = self.skillGroupId!
                }
                if self.skillGroupName != nil {
                    map["SkillGroupName"] = self.skillGroupName!
                }
                if self.talkingAgents != nil {
                    map["TalkingAgents"] = self.talkingAgents!
                }
                if self.waitingCalls != nil {
                    map["WaitingCalls"] = self.waitingCalls!
                }
                if self.waitingCallsLevel10 != nil {
                    map["WaitingCallsLevel10"] = self.waitingCallsLevel10!
                }
                if self.waitingCallsLevel20 != nil {
                    map["WaitingCallsLevel20"] = self.waitingCallsLevel20!
                }
                if self.waitingCallsLevel30 != nil {
                    map["WaitingCallsLevel30"] = self.waitingCallsLevel30!
                }
                if self.workingAgents != nil {
                    map["WorkingAgents"] = self.workingAgents!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AverageWaitingTime") {
                    self.averageWaitingTime = dict["AverageWaitingTime"] as! Int64
                }
                if dict.keys.contains("BreakingAgents") {
                    self.breakingAgents = dict["BreakingAgents"] as! Int64
                }
                if dict.keys.contains("InboundTalkingAgents") {
                    self.inboundTalkingAgents = dict["InboundTalkingAgents"] as! Int64
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("LoggedInAgents") {
                    self.loggedInAgents = dict["LoggedInAgents"] as! Int64
                }
                if dict.keys.contains("LongestCall") {
                    self.longestCall = dict["LongestCall"] as! Int64
                }
                if dict.keys.contains("OutboundScenarioReadyAgents") {
                    self.outboundScenarioReadyAgents = dict["OutboundScenarioReadyAgents"] as! Int64
                }
                if dict.keys.contains("OutboundTalkingAgents") {
                    self.outboundTalkingAgents = dict["OutboundTalkingAgents"] as! Int64
                }
                if dict.keys.contains("ReadyAgents") {
                    self.readyAgents = dict["ReadyAgents"] as! Int64
                }
                if dict.keys.contains("SkillGroupId") {
                    self.skillGroupId = dict["SkillGroupId"] as! String
                }
                if dict.keys.contains("SkillGroupName") {
                    self.skillGroupName = dict["SkillGroupName"] as! String
                }
                if dict.keys.contains("TalkingAgents") {
                    self.talkingAgents = dict["TalkingAgents"] as! Int64
                }
                if dict.keys.contains("WaitingCalls") {
                    self.waitingCalls = dict["WaitingCalls"] as! Int64
                }
                if dict.keys.contains("WaitingCallsLevel10") {
                    self.waitingCallsLevel10 = dict["WaitingCallsLevel10"] as! Int64
                }
                if dict.keys.contains("WaitingCallsLevel20") {
                    self.waitingCallsLevel20 = dict["WaitingCallsLevel20"] as! Int64
                }
                if dict.keys.contains("WaitingCallsLevel30") {
                    self.waitingCallsLevel30 = dict["WaitingCallsLevel30"] as! Int64
                }
                if dict.keys.contains("WorkingAgents") {
                    self.workingAgents = dict["WorkingAgents"] as! Int64
                }
            }
        }
        public var list: [ListSkillGroupStatesResponseBody.Data.List]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.list != nil {
                var tmp : [Any] = []
                for k in self.list! {
                    tmp.append(k.toMap())
                }
                map["List"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("List") {
                var tmp : [ListSkillGroupStatesResponseBody.Data.List] = []
                for v in dict["List"] as! [Any] {
                    var model = ListSkillGroupStatesResponseBody.Data.List()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.list = tmp
            }
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var code: String?

    public var data: ListSkillGroupStatesResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = ListSkillGroupStatesResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListSkillGroupStatesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListSkillGroupStatesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListSkillGroupStatesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListSkillGroupSummaryReportsSinceMidnightRequest : Tea.TeaModel {
    public var instanceId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var skillGroups: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.skillGroups != nil {
            map["SkillGroups"] = self.skillGroups!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SkillGroups") {
            self.skillGroups = dict["SkillGroups"] as! String
        }
    }
}

public class ListSkillGroupSummaryReportsSinceMidnightResponseBody : Tea.TeaModel {
    public class PagedSkillGroupSummaryReport : Tea.TeaModel {
        public class List : Tea.TeaModel {
            public class Inbound : Tea.TeaModel {
                public var abandonedInQueueOfQueueCount: Int64?

                public var answeredByAgentOfQueueCount: Int64?

                public var answeredByAgentOfQueueMaxWaitTimeDuration: Int64?

                public var answeredByAgentOfQueueWaitTimeDuration: Int64?

                public var averageRingTime: Int64?

                public var averageTalkTime: Int64?

                public var averageWorkTime: Int64?

                public var callsAbandoned: Int64?

                public var callsAttendedTransferOut: Int64?

                public var callsBlindTransferOut: Int64?

                public var callsHandled: Int64?

                public var callsOffered: Int64?

                public var callsOverflow: String?

                public var callsQueuingCanceled: String?

                public var callsQueuingFailure: String?

                public var callsQueuingRerouted: String?

                public var callsQueuingTimeout: Int64?

                public var callsServiceLevel10: Int64?

                public var callsServiceLevel20: Int64?

                public var callsServiceLevel30: Int64?

                public var callsTimeout: Int64?

                public var giveUpByAgentOfQueueCount: Int64?

                public var handleRate: Double?

                public var inComingQueueOfQueueCount: Int64?

                public var maxRingTime: Int64?

                public var maxTalkTime: String?

                public var maxWorkTime: Int64?

                public var overFlowInQueueOfQueueCount: Int64?

                public var queueMaxWaitTimeDuration: Int64?

                public var queueWaitTimeDuration: Int64?

                public var satisfactionIndex: Double?

                public var satisfactionSurveysOffered: Int64?

                public var satisfactionSurveysResponded: Int64?

                public var serviceLevel20: Double?

                public var totalRingTime: Int64?

                public var totalTalkTime: Int64?

                public var totalWorkTime: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.abandonedInQueueOfQueueCount != nil {
                        map["AbandonedInQueueOfQueueCount"] = self.abandonedInQueueOfQueueCount!
                    }
                    if self.answeredByAgentOfQueueCount != nil {
                        map["AnsweredByAgentOfQueueCount"] = self.answeredByAgentOfQueueCount!
                    }
                    if self.answeredByAgentOfQueueMaxWaitTimeDuration != nil {
                        map["AnsweredByAgentOfQueueMaxWaitTimeDuration"] = self.answeredByAgentOfQueueMaxWaitTimeDuration!
                    }
                    if self.answeredByAgentOfQueueWaitTimeDuration != nil {
                        map["AnsweredByAgentOfQueueWaitTimeDuration"] = self.answeredByAgentOfQueueWaitTimeDuration!
                    }
                    if self.averageRingTime != nil {
                        map["AverageRingTime"] = self.averageRingTime!
                    }
                    if self.averageTalkTime != nil {
                        map["AverageTalkTime"] = self.averageTalkTime!
                    }
                    if self.averageWorkTime != nil {
                        map["AverageWorkTime"] = self.averageWorkTime!
                    }
                    if self.callsAbandoned != nil {
                        map["CallsAbandoned"] = self.callsAbandoned!
                    }
                    if self.callsAttendedTransferOut != nil {
                        map["CallsAttendedTransferOut"] = self.callsAttendedTransferOut!
                    }
                    if self.callsBlindTransferOut != nil {
                        map["CallsBlindTransferOut"] = self.callsBlindTransferOut!
                    }
                    if self.callsHandled != nil {
                        map["CallsHandled"] = self.callsHandled!
                    }
                    if self.callsOffered != nil {
                        map["CallsOffered"] = self.callsOffered!
                    }
                    if self.callsOverflow != nil {
                        map["CallsOverflow"] = self.callsOverflow!
                    }
                    if self.callsQueuingCanceled != nil {
                        map["CallsQueuingCanceled"] = self.callsQueuingCanceled!
                    }
                    if self.callsQueuingFailure != nil {
                        map["CallsQueuingFailure"] = self.callsQueuingFailure!
                    }
                    if self.callsQueuingRerouted != nil {
                        map["CallsQueuingRerouted"] = self.callsQueuingRerouted!
                    }
                    if self.callsQueuingTimeout != nil {
                        map["CallsQueuingTimeout"] = self.callsQueuingTimeout!
                    }
                    if self.callsServiceLevel10 != nil {
                        map["CallsServiceLevel10"] = self.callsServiceLevel10!
                    }
                    if self.callsServiceLevel20 != nil {
                        map["CallsServiceLevel20"] = self.callsServiceLevel20!
                    }
                    if self.callsServiceLevel30 != nil {
                        map["CallsServiceLevel30"] = self.callsServiceLevel30!
                    }
                    if self.callsTimeout != nil {
                        map["CallsTimeout"] = self.callsTimeout!
                    }
                    if self.giveUpByAgentOfQueueCount != nil {
                        map["GiveUpByAgentOfQueueCount"] = self.giveUpByAgentOfQueueCount!
                    }
                    if self.handleRate != nil {
                        map["HandleRate"] = self.handleRate!
                    }
                    if self.inComingQueueOfQueueCount != nil {
                        map["InComingQueueOfQueueCount"] = self.inComingQueueOfQueueCount!
                    }
                    if self.maxRingTime != nil {
                        map["MaxRingTime"] = self.maxRingTime!
                    }
                    if self.maxTalkTime != nil {
                        map["MaxTalkTime"] = self.maxTalkTime!
                    }
                    if self.maxWorkTime != nil {
                        map["MaxWorkTime"] = self.maxWorkTime!
                    }
                    if self.overFlowInQueueOfQueueCount != nil {
                        map["OverFlowInQueueOfQueueCount"] = self.overFlowInQueueOfQueueCount!
                    }
                    if self.queueMaxWaitTimeDuration != nil {
                        map["QueueMaxWaitTimeDuration"] = self.queueMaxWaitTimeDuration!
                    }
                    if self.queueWaitTimeDuration != nil {
                        map["QueueWaitTimeDuration"] = self.queueWaitTimeDuration!
                    }
                    if self.satisfactionIndex != nil {
                        map["SatisfactionIndex"] = self.satisfactionIndex!
                    }
                    if self.satisfactionSurveysOffered != nil {
                        map["SatisfactionSurveysOffered"] = self.satisfactionSurveysOffered!
                    }
                    if self.satisfactionSurveysResponded != nil {
                        map["SatisfactionSurveysResponded"] = self.satisfactionSurveysResponded!
                    }
                    if self.serviceLevel20 != nil {
                        map["ServiceLevel20"] = self.serviceLevel20!
                    }
                    if self.totalRingTime != nil {
                        map["TotalRingTime"] = self.totalRingTime!
                    }
                    if self.totalTalkTime != nil {
                        map["TotalTalkTime"] = self.totalTalkTime!
                    }
                    if self.totalWorkTime != nil {
                        map["TotalWorkTime"] = self.totalWorkTime!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AbandonedInQueueOfQueueCount") {
                        self.abandonedInQueueOfQueueCount = dict["AbandonedInQueueOfQueueCount"] as! Int64
                    }
                    if dict.keys.contains("AnsweredByAgentOfQueueCount") {
                        self.answeredByAgentOfQueueCount = dict["AnsweredByAgentOfQueueCount"] as! Int64
                    }
                    if dict.keys.contains("AnsweredByAgentOfQueueMaxWaitTimeDuration") {
                        self.answeredByAgentOfQueueMaxWaitTimeDuration = dict["AnsweredByAgentOfQueueMaxWaitTimeDuration"] as! Int64
                    }
                    if dict.keys.contains("AnsweredByAgentOfQueueWaitTimeDuration") {
                        self.answeredByAgentOfQueueWaitTimeDuration = dict["AnsweredByAgentOfQueueWaitTimeDuration"] as! Int64
                    }
                    if dict.keys.contains("AverageRingTime") {
                        self.averageRingTime = dict["AverageRingTime"] as! Int64
                    }
                    if dict.keys.contains("AverageTalkTime") {
                        self.averageTalkTime = dict["AverageTalkTime"] as! Int64
                    }
                    if dict.keys.contains("AverageWorkTime") {
                        self.averageWorkTime = dict["AverageWorkTime"] as! Int64
                    }
                    if dict.keys.contains("CallsAbandoned") {
                        self.callsAbandoned = dict["CallsAbandoned"] as! Int64
                    }
                    if dict.keys.contains("CallsAttendedTransferOut") {
                        self.callsAttendedTransferOut = dict["CallsAttendedTransferOut"] as! Int64
                    }
                    if dict.keys.contains("CallsBlindTransferOut") {
                        self.callsBlindTransferOut = dict["CallsBlindTransferOut"] as! Int64
                    }
                    if dict.keys.contains("CallsHandled") {
                        self.callsHandled = dict["CallsHandled"] as! Int64
                    }
                    if dict.keys.contains("CallsOffered") {
                        self.callsOffered = dict["CallsOffered"] as! Int64
                    }
                    if dict.keys.contains("CallsOverflow") {
                        self.callsOverflow = dict["CallsOverflow"] as! String
                    }
                    if dict.keys.contains("CallsQueuingCanceled") {
                        self.callsQueuingCanceled = dict["CallsQueuingCanceled"] as! String
                    }
                    if dict.keys.contains("CallsQueuingFailure") {
                        self.callsQueuingFailure = dict["CallsQueuingFailure"] as! String
                    }
                    if dict.keys.contains("CallsQueuingRerouted") {
                        self.callsQueuingRerouted = dict["CallsQueuingRerouted"] as! String
                    }
                    if dict.keys.contains("CallsQueuingTimeout") {
                        self.callsQueuingTimeout = dict["CallsQueuingTimeout"] as! Int64
                    }
                    if dict.keys.contains("CallsServiceLevel10") {
                        self.callsServiceLevel10 = dict["CallsServiceLevel10"] as! Int64
                    }
                    if dict.keys.contains("CallsServiceLevel20") {
                        self.callsServiceLevel20 = dict["CallsServiceLevel20"] as! Int64
                    }
                    if dict.keys.contains("CallsServiceLevel30") {
                        self.callsServiceLevel30 = dict["CallsServiceLevel30"] as! Int64
                    }
                    if dict.keys.contains("CallsTimeout") {
                        self.callsTimeout = dict["CallsTimeout"] as! Int64
                    }
                    if dict.keys.contains("GiveUpByAgentOfQueueCount") {
                        self.giveUpByAgentOfQueueCount = dict["GiveUpByAgentOfQueueCount"] as! Int64
                    }
                    if dict.keys.contains("HandleRate") {
                        self.handleRate = dict["HandleRate"] as! Double
                    }
                    if dict.keys.contains("InComingQueueOfQueueCount") {
                        self.inComingQueueOfQueueCount = dict["InComingQueueOfQueueCount"] as! Int64
                    }
                    if dict.keys.contains("MaxRingTime") {
                        self.maxRingTime = dict["MaxRingTime"] as! Int64
                    }
                    if dict.keys.contains("MaxTalkTime") {
                        self.maxTalkTime = dict["MaxTalkTime"] as! String
                    }
                    if dict.keys.contains("MaxWorkTime") {
                        self.maxWorkTime = dict["MaxWorkTime"] as! Int64
                    }
                    if dict.keys.contains("OverFlowInQueueOfQueueCount") {
                        self.overFlowInQueueOfQueueCount = dict["OverFlowInQueueOfQueueCount"] as! Int64
                    }
                    if dict.keys.contains("QueueMaxWaitTimeDuration") {
                        self.queueMaxWaitTimeDuration = dict["QueueMaxWaitTimeDuration"] as! Int64
                    }
                    if dict.keys.contains("QueueWaitTimeDuration") {
                        self.queueWaitTimeDuration = dict["QueueWaitTimeDuration"] as! Int64
                    }
                    if dict.keys.contains("SatisfactionIndex") {
                        self.satisfactionIndex = dict["SatisfactionIndex"] as! Double
                    }
                    if dict.keys.contains("SatisfactionSurveysOffered") {
                        self.satisfactionSurveysOffered = dict["SatisfactionSurveysOffered"] as! Int64
                    }
                    if dict.keys.contains("SatisfactionSurveysResponded") {
                        self.satisfactionSurveysResponded = dict["SatisfactionSurveysResponded"] as! Int64
                    }
                    if dict.keys.contains("ServiceLevel20") {
                        self.serviceLevel20 = dict["ServiceLevel20"] as! Double
                    }
                    if dict.keys.contains("TotalRingTime") {
                        self.totalRingTime = dict["TotalRingTime"] as! Int64
                    }
                    if dict.keys.contains("TotalTalkTime") {
                        self.totalTalkTime = dict["TotalTalkTime"] as! Int64
                    }
                    if dict.keys.contains("TotalWorkTime") {
                        self.totalWorkTime = dict["TotalWorkTime"] as! Int64
                    }
                }
            }
            public class Outbound : Tea.TeaModel {
                public var answerRate: Double?

                public var averageDialingTime: Int64?

                public var averageTalkTime: Int64?

                public var averageWorkTime: Int64?

                public var callsAbandoned: Int64?

                public var callsAgentHandled: Int64?

                public var callsAnswered: Int64?

                public var callsDialed: Int64?

                public var callsOffered: Int64?

                public var callsQueuingCancelled: Int64?

                public var callsQueuingFailed: Int64?

                public var callsQueuingFailure: Int64?

                public var callsQueuingOverflow: Int64?

                public var callsQueuingRerouted: Int64?

                public var callsQueuingTimeout: Int64?

                public var callsServiceLevel30: String?

                public var callsServiceLevel30V2: Int64?

                public var maxDialingTime: Int64?

                public var maxTalkTime: Int64?

                public var maxWorkTime: Int64?

                public var satisfactionIndex: Double?

                public var satisfactionSurveysOffered: Int64?

                public var satisfactionSurveysResponded: Int64?

                public var totalDialingTime: Int64?

                public var totalTalkTime: Int64?

                public var totalWaitTime: Int64?

                public var totalWorkTime: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.answerRate != nil {
                        map["AnswerRate"] = self.answerRate!
                    }
                    if self.averageDialingTime != nil {
                        map["AverageDialingTime"] = self.averageDialingTime!
                    }
                    if self.averageTalkTime != nil {
                        map["AverageTalkTime"] = self.averageTalkTime!
                    }
                    if self.averageWorkTime != nil {
                        map["AverageWorkTime"] = self.averageWorkTime!
                    }
                    if self.callsAbandoned != nil {
                        map["CallsAbandoned"] = self.callsAbandoned!
                    }
                    if self.callsAgentHandled != nil {
                        map["CallsAgentHandled"] = self.callsAgentHandled!
                    }
                    if self.callsAnswered != nil {
                        map["CallsAnswered"] = self.callsAnswered!
                    }
                    if self.callsDialed != nil {
                        map["CallsDialed"] = self.callsDialed!
                    }
                    if self.callsOffered != nil {
                        map["CallsOffered"] = self.callsOffered!
                    }
                    if self.callsQueuingCancelled != nil {
                        map["CallsQueuingCancelled"] = self.callsQueuingCancelled!
                    }
                    if self.callsQueuingFailed != nil {
                        map["CallsQueuingFailed"] = self.callsQueuingFailed!
                    }
                    if self.callsQueuingFailure != nil {
                        map["CallsQueuingFailure"] = self.callsQueuingFailure!
                    }
                    if self.callsQueuingOverflow != nil {
                        map["CallsQueuingOverflow"] = self.callsQueuingOverflow!
                    }
                    if self.callsQueuingRerouted != nil {
                        map["CallsQueuingRerouted"] = self.callsQueuingRerouted!
                    }
                    if self.callsQueuingTimeout != nil {
                        map["CallsQueuingTimeout"] = self.callsQueuingTimeout!
                    }
                    if self.callsServiceLevel30 != nil {
                        map["CallsServiceLevel30"] = self.callsServiceLevel30!
                    }
                    if self.callsServiceLevel30V2 != nil {
                        map["CallsServiceLevel30V2"] = self.callsServiceLevel30V2!
                    }
                    if self.maxDialingTime != nil {
                        map["MaxDialingTime"] = self.maxDialingTime!
                    }
                    if self.maxTalkTime != nil {
                        map["MaxTalkTime"] = self.maxTalkTime!
                    }
                    if self.maxWorkTime != nil {
                        map["MaxWorkTime"] = self.maxWorkTime!
                    }
                    if self.satisfactionIndex != nil {
                        map["SatisfactionIndex"] = self.satisfactionIndex!
                    }
                    if self.satisfactionSurveysOffered != nil {
                        map["SatisfactionSurveysOffered"] = self.satisfactionSurveysOffered!
                    }
                    if self.satisfactionSurveysResponded != nil {
                        map["SatisfactionSurveysResponded"] = self.satisfactionSurveysResponded!
                    }
                    if self.totalDialingTime != nil {
                        map["TotalDialingTime"] = self.totalDialingTime!
                    }
                    if self.totalTalkTime != nil {
                        map["TotalTalkTime"] = self.totalTalkTime!
                    }
                    if self.totalWaitTime != nil {
                        map["TotalWaitTime"] = self.totalWaitTime!
                    }
                    if self.totalWorkTime != nil {
                        map["TotalWorkTime"] = self.totalWorkTime!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AnswerRate") {
                        self.answerRate = dict["AnswerRate"] as! Double
                    }
                    if dict.keys.contains("AverageDialingTime") {
                        self.averageDialingTime = dict["AverageDialingTime"] as! Int64
                    }
                    if dict.keys.contains("AverageTalkTime") {
                        self.averageTalkTime = dict["AverageTalkTime"] as! Int64
                    }
                    if dict.keys.contains("AverageWorkTime") {
                        self.averageWorkTime = dict["AverageWorkTime"] as! Int64
                    }
                    if dict.keys.contains("CallsAbandoned") {
                        self.callsAbandoned = dict["CallsAbandoned"] as! Int64
                    }
                    if dict.keys.contains("CallsAgentHandled") {
                        self.callsAgentHandled = dict["CallsAgentHandled"] as! Int64
                    }
                    if dict.keys.contains("CallsAnswered") {
                        self.callsAnswered = dict["CallsAnswered"] as! Int64
                    }
                    if dict.keys.contains("CallsDialed") {
                        self.callsDialed = dict["CallsDialed"] as! Int64
                    }
                    if dict.keys.contains("CallsOffered") {
                        self.callsOffered = dict["CallsOffered"] as! Int64
                    }
                    if dict.keys.contains("CallsQueuingCancelled") {
                        self.callsQueuingCancelled = dict["CallsQueuingCancelled"] as! Int64
                    }
                    if dict.keys.contains("CallsQueuingFailed") {
                        self.callsQueuingFailed = dict["CallsQueuingFailed"] as! Int64
                    }
                    if dict.keys.contains("CallsQueuingFailure") {
                        self.callsQueuingFailure = dict["CallsQueuingFailure"] as! Int64
                    }
                    if dict.keys.contains("CallsQueuingOverflow") {
                        self.callsQueuingOverflow = dict["CallsQueuingOverflow"] as! Int64
                    }
                    if dict.keys.contains("CallsQueuingRerouted") {
                        self.callsQueuingRerouted = dict["CallsQueuingRerouted"] as! Int64
                    }
                    if dict.keys.contains("CallsQueuingTimeout") {
                        self.callsQueuingTimeout = dict["CallsQueuingTimeout"] as! Int64
                    }
                    if dict.keys.contains("CallsServiceLevel30") {
                        self.callsServiceLevel30 = dict["CallsServiceLevel30"] as! String
                    }
                    if dict.keys.contains("CallsServiceLevel30V2") {
                        self.callsServiceLevel30V2 = dict["CallsServiceLevel30V2"] as! Int64
                    }
                    if dict.keys.contains("MaxDialingTime") {
                        self.maxDialingTime = dict["MaxDialingTime"] as! Int64
                    }
                    if dict.keys.contains("MaxTalkTime") {
                        self.maxTalkTime = dict["MaxTalkTime"] as! Int64
                    }
                    if dict.keys.contains("MaxWorkTime") {
                        self.maxWorkTime = dict["MaxWorkTime"] as! Int64
                    }
                    if dict.keys.contains("SatisfactionIndex") {
                        self.satisfactionIndex = dict["SatisfactionIndex"] as! Double
                    }
                    if dict.keys.contains("SatisfactionSurveysOffered") {
                        self.satisfactionSurveysOffered = dict["SatisfactionSurveysOffered"] as! Int64
                    }
                    if dict.keys.contains("SatisfactionSurveysResponded") {
                        self.satisfactionSurveysResponded = dict["SatisfactionSurveysResponded"] as! Int64
                    }
                    if dict.keys.contains("TotalDialingTime") {
                        self.totalDialingTime = dict["TotalDialingTime"] as! Int64
                    }
                    if dict.keys.contains("TotalTalkTime") {
                        self.totalTalkTime = dict["TotalTalkTime"] as! Int64
                    }
                    if dict.keys.contains("TotalWaitTime") {
                        self.totalWaitTime = dict["TotalWaitTime"] as! Int64
                    }
                    if dict.keys.contains("TotalWorkTime") {
                        self.totalWorkTime = dict["TotalWorkTime"] as! Int64
                    }
                }
            }
            public class Overall : Tea.TeaModel {
                public var averageReadyTime: Int64?

                public var averageTalkTime: Int64?

                public var averageWorkTime: Int64?

                public var maxReadyTime: Int64?

                public var maxTalkTime: Int64?

                public var maxWorkTime: Int64?

                public var occupancyRate: Double?

                public var satisfactionIndex: Double?

                public var satisfactionSurveysOffered: Int64?

                public var satisfactionSurveysResponded: Int64?

                public var totalBreakTime: Int64?

                public var totalCalls: Int64?

                public var totalLoggedInTime: Int64?

                public var totalReadyTime: Int64?

                public var totalTalkTime: Int64?

                public var totalWorkTime: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.averageReadyTime != nil {
                        map["AverageReadyTime"] = self.averageReadyTime!
                    }
                    if self.averageTalkTime != nil {
                        map["AverageTalkTime"] = self.averageTalkTime!
                    }
                    if self.averageWorkTime != nil {
                        map["AverageWorkTime"] = self.averageWorkTime!
                    }
                    if self.maxReadyTime != nil {
                        map["MaxReadyTime"] = self.maxReadyTime!
                    }
                    if self.maxTalkTime != nil {
                        map["MaxTalkTime"] = self.maxTalkTime!
                    }
                    if self.maxWorkTime != nil {
                        map["MaxWorkTime"] = self.maxWorkTime!
                    }
                    if self.occupancyRate != nil {
                        map["OccupancyRate"] = self.occupancyRate!
                    }
                    if self.satisfactionIndex != nil {
                        map["SatisfactionIndex"] = self.satisfactionIndex!
                    }
                    if self.satisfactionSurveysOffered != nil {
                        map["SatisfactionSurveysOffered"] = self.satisfactionSurveysOffered!
                    }
                    if self.satisfactionSurveysResponded != nil {
                        map["SatisfactionSurveysResponded"] = self.satisfactionSurveysResponded!
                    }
                    if self.totalBreakTime != nil {
                        map["TotalBreakTime"] = self.totalBreakTime!
                    }
                    if self.totalCalls != nil {
                        map["TotalCalls"] = self.totalCalls!
                    }
                    if self.totalLoggedInTime != nil {
                        map["TotalLoggedInTime"] = self.totalLoggedInTime!
                    }
                    if self.totalReadyTime != nil {
                        map["TotalReadyTime"] = self.totalReadyTime!
                    }
                    if self.totalTalkTime != nil {
                        map["TotalTalkTime"] = self.totalTalkTime!
                    }
                    if self.totalWorkTime != nil {
                        map["TotalWorkTime"] = self.totalWorkTime!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AverageReadyTime") {
                        self.averageReadyTime = dict["AverageReadyTime"] as! Int64
                    }
                    if dict.keys.contains("AverageTalkTime") {
                        self.averageTalkTime = dict["AverageTalkTime"] as! Int64
                    }
                    if dict.keys.contains("AverageWorkTime") {
                        self.averageWorkTime = dict["AverageWorkTime"] as! Int64
                    }
                    if dict.keys.contains("MaxReadyTime") {
                        self.maxReadyTime = dict["MaxReadyTime"] as! Int64
                    }
                    if dict.keys.contains("MaxTalkTime") {
                        self.maxTalkTime = dict["MaxTalkTime"] as! Int64
                    }
                    if dict.keys.contains("MaxWorkTime") {
                        self.maxWorkTime = dict["MaxWorkTime"] as! Int64
                    }
                    if dict.keys.contains("OccupancyRate") {
                        self.occupancyRate = dict["OccupancyRate"] as! Double
                    }
                    if dict.keys.contains("SatisfactionIndex") {
                        self.satisfactionIndex = dict["SatisfactionIndex"] as! Double
                    }
                    if dict.keys.contains("SatisfactionSurveysOffered") {
                        self.satisfactionSurveysOffered = dict["SatisfactionSurveysOffered"] as! Int64
                    }
                    if dict.keys.contains("SatisfactionSurveysResponded") {
                        self.satisfactionSurveysResponded = dict["SatisfactionSurveysResponded"] as! Int64
                    }
                    if dict.keys.contains("TotalBreakTime") {
                        self.totalBreakTime = dict["TotalBreakTime"] as! Int64
                    }
                    if dict.keys.contains("TotalCalls") {
                        self.totalCalls = dict["TotalCalls"] as! Int64
                    }
                    if dict.keys.contains("TotalLoggedInTime") {
                        self.totalLoggedInTime = dict["TotalLoggedInTime"] as! Int64
                    }
                    if dict.keys.contains("TotalReadyTime") {
                        self.totalReadyTime = dict["TotalReadyTime"] as! Int64
                    }
                    if dict.keys.contains("TotalTalkTime") {
                        self.totalTalkTime = dict["TotalTalkTime"] as! Int64
                    }
                    if dict.keys.contains("TotalWorkTime") {
                        self.totalWorkTime = dict["TotalWorkTime"] as! Int64
                    }
                }
            }
            public var inbound: ListSkillGroupSummaryReportsSinceMidnightResponseBody.PagedSkillGroupSummaryReport.List.Inbound?

            public var instanceId: String?

            public var outbound: ListSkillGroupSummaryReportsSinceMidnightResponseBody.PagedSkillGroupSummaryReport.List.Outbound?

            public var overall: ListSkillGroupSummaryReportsSinceMidnightResponseBody.PagedSkillGroupSummaryReport.List.Overall?

            public var skillGroupId: String?

            public var skillGroupName: String?

            public var timestamp: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.inbound?.validate()
                try self.outbound?.validate()
                try self.overall?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.inbound != nil {
                    map["Inbound"] = self.inbound?.toMap()
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.outbound != nil {
                    map["Outbound"] = self.outbound?.toMap()
                }
                if self.overall != nil {
                    map["Overall"] = self.overall?.toMap()
                }
                if self.skillGroupId != nil {
                    map["SkillGroupId"] = self.skillGroupId!
                }
                if self.skillGroupName != nil {
                    map["SkillGroupName"] = self.skillGroupName!
                }
                if self.timestamp != nil {
                    map["Timestamp"] = self.timestamp!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Inbound") {
                    var model = ListSkillGroupSummaryReportsSinceMidnightResponseBody.PagedSkillGroupSummaryReport.List.Inbound()
                    model.fromMap(dict["Inbound"] as! [String: Any])
                    self.inbound = model
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("Outbound") {
                    var model = ListSkillGroupSummaryReportsSinceMidnightResponseBody.PagedSkillGroupSummaryReport.List.Outbound()
                    model.fromMap(dict["Outbound"] as! [String: Any])
                    self.outbound = model
                }
                if dict.keys.contains("Overall") {
                    var model = ListSkillGroupSummaryReportsSinceMidnightResponseBody.PagedSkillGroupSummaryReport.List.Overall()
                    model.fromMap(dict["Overall"] as! [String: Any])
                    self.overall = model
                }
                if dict.keys.contains("SkillGroupId") {
                    self.skillGroupId = dict["SkillGroupId"] as! String
                }
                if dict.keys.contains("SkillGroupName") {
                    self.skillGroupName = dict["SkillGroupName"] as! String
                }
                if dict.keys.contains("Timestamp") {
                    self.timestamp = dict["Timestamp"] as! String
                }
            }
        }
        public var list: [ListSkillGroupSummaryReportsSinceMidnightResponseBody.PagedSkillGroupSummaryReport.List]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.list != nil {
                var tmp : [Any] = []
                for k in self.list! {
                    tmp.append(k.toMap())
                }
                map["List"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("List") {
                var tmp : [ListSkillGroupSummaryReportsSinceMidnightResponseBody.PagedSkillGroupSummaryReport.List] = []
                for v in dict["List"] as! [Any] {
                    var model = ListSkillGroupSummaryReportsSinceMidnightResponseBody.PagedSkillGroupSummaryReport.List()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.list = tmp
            }
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var code: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var pagedSkillGroupSummaryReport: ListSkillGroupSummaryReportsSinceMidnightResponseBody.PagedSkillGroupSummaryReport?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pagedSkillGroupSummaryReport?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.pagedSkillGroupSummaryReport != nil {
            map["PagedSkillGroupSummaryReport"] = self.pagedSkillGroupSummaryReport?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("PagedSkillGroupSummaryReport") {
            var model = ListSkillGroupSummaryReportsSinceMidnightResponseBody.PagedSkillGroupSummaryReport()
            model.fromMap(dict["PagedSkillGroupSummaryReport"] as! [String: Any])
            self.pagedSkillGroupSummaryReport = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListSkillGroupSummaryReportsSinceMidnightResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListSkillGroupSummaryReportsSinceMidnightResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListSkillGroupSummaryReportsSinceMidnightResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListSkillGroupsRequest : Tea.TeaModel {
    public var instanceId: String?

    public var mediaType: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var searchPattern: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.mediaType != nil {
            map["MediaType"] = self.mediaType!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.searchPattern != nil {
            map["SearchPattern"] = self.searchPattern!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("MediaType") {
            self.mediaType = dict["MediaType"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SearchPattern") {
            self.searchPattern = dict["SearchPattern"] as! String
        }
    }
}

public class ListSkillGroupsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class List : Tea.TeaModel {
            public var description_: String?

            public var displayName: String?

            public var instanceId: String?

            public var mediaType: String?

            public var phoneNumberCount: Int32?

            public var skillGroupId: String?

            public var skillGroupName: String?

            public var userCount: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.displayName != nil {
                    map["DisplayName"] = self.displayName!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.mediaType != nil {
                    map["MediaType"] = self.mediaType!
                }
                if self.phoneNumberCount != nil {
                    map["PhoneNumberCount"] = self.phoneNumberCount!
                }
                if self.skillGroupId != nil {
                    map["SkillGroupId"] = self.skillGroupId!
                }
                if self.skillGroupName != nil {
                    map["SkillGroupName"] = self.skillGroupName!
                }
                if self.userCount != nil {
                    map["UserCount"] = self.userCount!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("DisplayName") {
                    self.displayName = dict["DisplayName"] as! String
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("MediaType") {
                    self.mediaType = dict["MediaType"] as! String
                }
                if dict.keys.contains("PhoneNumberCount") {
                    self.phoneNumberCount = dict["PhoneNumberCount"] as! Int32
                }
                if dict.keys.contains("SkillGroupId") {
                    self.skillGroupId = dict["SkillGroupId"] as! String
                }
                if dict.keys.contains("SkillGroupName") {
                    self.skillGroupName = dict["SkillGroupName"] as! String
                }
                if dict.keys.contains("UserCount") {
                    self.userCount = dict["UserCount"] as! Int32
                }
            }
        }
        public var list: [ListSkillGroupsResponseBody.Data.List]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.list != nil {
                var tmp : [Any] = []
                for k in self.list! {
                    tmp.append(k.toMap())
                }
                map["List"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("List") {
                var tmp : [ListSkillGroupsResponseBody.Data.List] = []
                for v in dict["List"] as! [Any] {
                    var model = ListSkillGroupsResponseBody.Data.List()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.list = tmp
            }
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var code: String?

    public var data: ListSkillGroupsResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = ListSkillGroupsResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListSkillGroupsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListSkillGroupsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListSkillGroupsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListSkillLevelsOfUserRequest : Tea.TeaModel {
    public var instanceId: String?

    public var isMember: Bool?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var searchPattern: String?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.isMember != nil {
            map["IsMember"] = self.isMember!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.searchPattern != nil {
            map["SearchPattern"] = self.searchPattern!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("IsMember") {
            self.isMember = dict["IsMember"] as! Bool
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SearchPattern") {
            self.searchPattern = dict["SearchPattern"] as! String
        }
        if dict.keys.contains("UserId") {
            self.userId = dict["UserId"] as! String
        }
    }
}

public class ListSkillLevelsOfUserResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class List : Tea.TeaModel {
            public var mediaType: String?

            public var skillGroupId: String?

            public var skillGroupName: String?

            public var skillLevel: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.mediaType != nil {
                    map["MediaType"] = self.mediaType!
                }
                if self.skillGroupId != nil {
                    map["SkillGroupId"] = self.skillGroupId!
                }
                if self.skillGroupName != nil {
                    map["SkillGroupName"] = self.skillGroupName!
                }
                if self.skillLevel != nil {
                    map["SkillLevel"] = self.skillLevel!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("MediaType") {
                    self.mediaType = dict["MediaType"] as! String
                }
                if dict.keys.contains("SkillGroupId") {
                    self.skillGroupId = dict["SkillGroupId"] as! String
                }
                if dict.keys.contains("SkillGroupName") {
                    self.skillGroupName = dict["SkillGroupName"] as! String
                }
                if dict.keys.contains("SkillLevel") {
                    self.skillLevel = dict["SkillLevel"] as! String
                }
            }
        }
        public var list: [ListSkillLevelsOfUserResponseBody.Data.List]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.list != nil {
                var tmp : [Any] = []
                for k in self.list! {
                    tmp.append(k.toMap())
                }
                map["List"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("List") {
                var tmp : [ListSkillLevelsOfUserResponseBody.Data.List] = []
                for v in dict["List"] as! [Any] {
                    var model = ListSkillLevelsOfUserResponseBody.Data.List()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.list = tmp
            }
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var code: String?

    public var data: ListSkillLevelsOfUserResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = ListSkillLevelsOfUserResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListSkillLevelsOfUserResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListSkillLevelsOfUserResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListSkillLevelsOfUserResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListTicketTasksRequest : Tea.TeaModel {
    public var instanceId: String?

    public var ticketId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.ticketId != nil {
            map["TicketId"] = self.ticketId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("TicketId") {
            self.ticketId = dict["TicketId"] as! String
        }
    }
}

public class ListTicketTasksResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var action: String?

        public var assignee: String?

        public var assigneeName: String?

        public var comment: String?

        public var endTime: Int64?

        public var fileKeys: [String]?

        public var fileUrls: [String]?

        public var instanceId: String?

        public var startTime: Int64?

        public var taskDefinitionNodeId: String?

        public var taskDefinitionNodeType: String?

        public var taskId: String?

        public var taskName: String?

        public var ticketId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.action != nil {
                map["Action"] = self.action!
            }
            if self.assignee != nil {
                map["Assignee"] = self.assignee!
            }
            if self.assigneeName != nil {
                map["AssigneeName"] = self.assigneeName!
            }
            if self.comment != nil {
                map["Comment"] = self.comment!
            }
            if self.endTime != nil {
                map["EndTime"] = self.endTime!
            }
            if self.fileKeys != nil {
                map["FileKeys"] = self.fileKeys!
            }
            if self.fileUrls != nil {
                map["FileUrls"] = self.fileUrls!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.startTime != nil {
                map["StartTime"] = self.startTime!
            }
            if self.taskDefinitionNodeId != nil {
                map["TaskDefinitionNodeId"] = self.taskDefinitionNodeId!
            }
            if self.taskDefinitionNodeType != nil {
                map["TaskDefinitionNodeType"] = self.taskDefinitionNodeType!
            }
            if self.taskId != nil {
                map["TaskId"] = self.taskId!
            }
            if self.taskName != nil {
                map["TaskName"] = self.taskName!
            }
            if self.ticketId != nil {
                map["TicketId"] = self.ticketId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Action") {
                self.action = dict["Action"] as! String
            }
            if dict.keys.contains("Assignee") {
                self.assignee = dict["Assignee"] as! String
            }
            if dict.keys.contains("AssigneeName") {
                self.assigneeName = dict["AssigneeName"] as! String
            }
            if dict.keys.contains("Comment") {
                self.comment = dict["Comment"] as! String
            }
            if dict.keys.contains("EndTime") {
                self.endTime = dict["EndTime"] as! Int64
            }
            if dict.keys.contains("FileKeys") {
                self.fileKeys = dict["FileKeys"] as! [String]
            }
            if dict.keys.contains("FileUrls") {
                self.fileUrls = dict["FileUrls"] as! [String]
            }
            if dict.keys.contains("InstanceId") {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("StartTime") {
                self.startTime = dict["StartTime"] as! Int64
            }
            if dict.keys.contains("TaskDefinitionNodeId") {
                self.taskDefinitionNodeId = dict["TaskDefinitionNodeId"] as! String
            }
            if dict.keys.contains("TaskDefinitionNodeType") {
                self.taskDefinitionNodeType = dict["TaskDefinitionNodeType"] as! String
            }
            if dict.keys.contains("TaskId") {
                self.taskId = dict["TaskId"] as! String
            }
            if dict.keys.contains("TaskName") {
                self.taskName = dict["TaskName"] as! String
            }
            if dict.keys.contains("TicketId") {
                self.ticketId = dict["TicketId"] as! String
            }
        }
    }
    public var code: String?

    public var data: [ListTicketTasksResponseBody.Data]?

    public var httpStatusCode: Int32?

    public var message: String?

    public var params: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.params != nil {
            map["Params"] = self.params!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var tmp : [ListTicketTasksResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = ListTicketTasksResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Params") {
            self.params = dict["Params"] as! [String]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListTicketTasksResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListTicketTasksResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListTicketTasksResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListTicketTemplatesRequest : Tea.TeaModel {
    public var categoryId: String?

    public var instanceId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var searchPattern: String?

    public var state: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.categoryId != nil {
            map["CategoryId"] = self.categoryId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.searchPattern != nil {
            map["SearchPattern"] = self.searchPattern!
        }
        if self.state != nil {
            map["State"] = self.state!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CategoryId") {
            self.categoryId = dict["CategoryId"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SearchPattern") {
            self.searchPattern = dict["SearchPattern"] as! String
        }
        if dict.keys.contains("State") {
            self.state = dict["State"] as! String
        }
    }
}

public class ListTicketTemplatesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class List : Tea.TeaModel {
            public class TicketFields : Tea.TeaModel {
                public var array: Bool?

                public var attribute: String?

                public var createdTime: Int64?

                public var creator: String?

                public var dataType: String?

                public var description_: String?

                public var disabled: Bool?

                public var displayName: String?

                public var displayOrder: Int32?

                public var editorType: String?

                public var maxLength: Int32?

                public var maximum: Double?

                public var minLength: Int32?

                public var minimum: Double?

                public var name: String?

                public var pattern: String?

                public var patternErrorMessage: String?

                public var readOnly: Bool?

                public var required_: Bool?

                public var system: Bool?

                public var updatedTime: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.array != nil {
                        map["Array"] = self.array!
                    }
                    if self.attribute != nil {
                        map["Attribute"] = self.attribute!
                    }
                    if self.createdTime != nil {
                        map["CreatedTime"] = self.createdTime!
                    }
                    if self.creator != nil {
                        map["Creator"] = self.creator!
                    }
                    if self.dataType != nil {
                        map["DataType"] = self.dataType!
                    }
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.disabled != nil {
                        map["Disabled"] = self.disabled!
                    }
                    if self.displayName != nil {
                        map["DisplayName"] = self.displayName!
                    }
                    if self.displayOrder != nil {
                        map["DisplayOrder"] = self.displayOrder!
                    }
                    if self.editorType != nil {
                        map["EditorType"] = self.editorType!
                    }
                    if self.maxLength != nil {
                        map["MaxLength"] = self.maxLength!
                    }
                    if self.maximum != nil {
                        map["Maximum"] = self.maximum!
                    }
                    if self.minLength != nil {
                        map["MinLength"] = self.minLength!
                    }
                    if self.minimum != nil {
                        map["Minimum"] = self.minimum!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.pattern != nil {
                        map["Pattern"] = self.pattern!
                    }
                    if self.patternErrorMessage != nil {
                        map["PatternErrorMessage"] = self.patternErrorMessage!
                    }
                    if self.readOnly != nil {
                        map["ReadOnly"] = self.readOnly!
                    }
                    if self.required_ != nil {
                        map["Required"] = self.required_!
                    }
                    if self.system != nil {
                        map["System"] = self.system!
                    }
                    if self.updatedTime != nil {
                        map["UpdatedTime"] = self.updatedTime!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Array") {
                        self.array = dict["Array"] as! Bool
                    }
                    if dict.keys.contains("Attribute") {
                        self.attribute = dict["Attribute"] as! String
                    }
                    if dict.keys.contains("CreatedTime") {
                        self.createdTime = dict["CreatedTime"] as! Int64
                    }
                    if dict.keys.contains("Creator") {
                        self.creator = dict["Creator"] as! String
                    }
                    if dict.keys.contains("DataType") {
                        self.dataType = dict["DataType"] as! String
                    }
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("Disabled") {
                        self.disabled = dict["Disabled"] as! Bool
                    }
                    if dict.keys.contains("DisplayName") {
                        self.displayName = dict["DisplayName"] as! String
                    }
                    if dict.keys.contains("DisplayOrder") {
                        self.displayOrder = dict["DisplayOrder"] as! Int32
                    }
                    if dict.keys.contains("EditorType") {
                        self.editorType = dict["EditorType"] as! String
                    }
                    if dict.keys.contains("MaxLength") {
                        self.maxLength = dict["MaxLength"] as! Int32
                    }
                    if dict.keys.contains("Maximum") {
                        self.maximum = dict["Maximum"] as! Double
                    }
                    if dict.keys.contains("MinLength") {
                        self.minLength = dict["MinLength"] as! Int32
                    }
                    if dict.keys.contains("Minimum") {
                        self.minimum = dict["Minimum"] as! Double
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Pattern") {
                        self.pattern = dict["Pattern"] as! String
                    }
                    if dict.keys.contains("PatternErrorMessage") {
                        self.patternErrorMessage = dict["PatternErrorMessage"] as! String
                    }
                    if dict.keys.contains("ReadOnly") {
                        self.readOnly = dict["ReadOnly"] as! Bool
                    }
                    if dict.keys.contains("Required") {
                        self.required_ = dict["Required"] as! Bool
                    }
                    if dict.keys.contains("System") {
                        self.system = dict["System"] as! Bool
                    }
                    if dict.keys.contains("UpdatedTime") {
                        self.updatedTime = dict["UpdatedTime"] as! Int64
                    }
                }
            }
            public var appliedVersion: String?

            public var categoryId: String?

            public var editor: String?

            public var instanceId: String?

            public var latestVersion: String?

            public var name: String?

            public var processDefinition: String?

            public var state: String?

            public var templateId: String?

            public var ticketFields: [ListTicketTemplatesResponseBody.Data.List.TicketFields]?

            public var updatedTime: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.appliedVersion != nil {
                    map["AppliedVersion"] = self.appliedVersion!
                }
                if self.categoryId != nil {
                    map["CategoryId"] = self.categoryId!
                }
                if self.editor != nil {
                    map["Editor"] = self.editor!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.latestVersion != nil {
                    map["LatestVersion"] = self.latestVersion!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.processDefinition != nil {
                    map["ProcessDefinition"] = self.processDefinition!
                }
                if self.state != nil {
                    map["State"] = self.state!
                }
                if self.templateId != nil {
                    map["TemplateId"] = self.templateId!
                }
                if self.ticketFields != nil {
                    var tmp : [Any] = []
                    for k in self.ticketFields! {
                        tmp.append(k.toMap())
                    }
                    map["TicketFields"] = tmp
                }
                if self.updatedTime != nil {
                    map["UpdatedTime"] = self.updatedTime!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AppliedVersion") {
                    self.appliedVersion = dict["AppliedVersion"] as! String
                }
                if dict.keys.contains("CategoryId") {
                    self.categoryId = dict["CategoryId"] as! String
                }
                if dict.keys.contains("Editor") {
                    self.editor = dict["Editor"] as! String
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("LatestVersion") {
                    self.latestVersion = dict["LatestVersion"] as! String
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("ProcessDefinition") {
                    self.processDefinition = dict["ProcessDefinition"] as! String
                }
                if dict.keys.contains("State") {
                    self.state = dict["State"] as! String
                }
                if dict.keys.contains("TemplateId") {
                    self.templateId = dict["TemplateId"] as! String
                }
                if dict.keys.contains("TicketFields") {
                    var tmp : [ListTicketTemplatesResponseBody.Data.List.TicketFields] = []
                    for v in dict["TicketFields"] as! [Any] {
                        var model = ListTicketTemplatesResponseBody.Data.List.TicketFields()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.ticketFields = tmp
                }
                if dict.keys.contains("UpdatedTime") {
                    self.updatedTime = dict["UpdatedTime"] as! Int64
                }
            }
        }
        public var list: [ListTicketTemplatesResponseBody.Data.List]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.list != nil {
                var tmp : [Any] = []
                for k in self.list! {
                    tmp.append(k.toMap())
                }
                map["List"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("List") {
                var tmp : [ListTicketTemplatesResponseBody.Data.List] = []
                for v in dict["List"] as! [Any] {
                    var model = ListTicketTemplatesResponseBody.Data.List()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.list = tmp
            }
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var code: String?

    public var data: ListTicketTemplatesResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var params: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.params != nil {
            map["Params"] = self.params!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = ListTicketTemplatesResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Params") {
            self.params = dict["Params"] as! [String]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListTicketTemplatesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListTicketTemplatesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListTicketTemplatesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListTicketsRequest : Tea.TeaModel {
    public var assignee: String?

    public var assigneeType: String?

    public var categoryId: String?

    public var creator: String?

    public var customerId: String?

    public var endTime: Int64?

    public var instanceId: String?

    public var jobIdList: String?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var participant: String?

    public var startTime: Int64?

    public var state: String?

    public var ticketId: String?

    public var title: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.assignee != nil {
            map["Assignee"] = self.assignee!
        }
        if self.assigneeType != nil {
            map["AssigneeType"] = self.assigneeType!
        }
        if self.categoryId != nil {
            map["CategoryId"] = self.categoryId!
        }
        if self.creator != nil {
            map["Creator"] = self.creator!
        }
        if self.customerId != nil {
            map["CustomerId"] = self.customerId!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.jobIdList != nil {
            map["JobIdList"] = self.jobIdList!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.participant != nil {
            map["Participant"] = self.participant!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.state != nil {
            map["State"] = self.state!
        }
        if self.ticketId != nil {
            map["TicketId"] = self.ticketId!
        }
        if self.title != nil {
            map["Title"] = self.title!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Assignee") {
            self.assignee = dict["Assignee"] as! String
        }
        if dict.keys.contains("AssigneeType") {
            self.assigneeType = dict["AssigneeType"] as! String
        }
        if dict.keys.contains("CategoryId") {
            self.categoryId = dict["CategoryId"] as! String
        }
        if dict.keys.contains("Creator") {
            self.creator = dict["Creator"] as! String
        }
        if dict.keys.contains("CustomerId") {
            self.customerId = dict["CustomerId"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("JobIdList") {
            self.jobIdList = dict["JobIdList"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("Participant") {
            self.participant = dict["Participant"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! Int64
        }
        if dict.keys.contains("State") {
            self.state = dict["State"] as! String
        }
        if dict.keys.contains("TicketId") {
            self.ticketId = dict["TicketId"] as! String
        }
        if dict.keys.contains("Title") {
            self.title = dict["Title"] as! String
        }
    }
}

public class ListTicketsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class List : Tea.TeaModel {
            public var assignee: String?

            public var assigneeName: String?

            public var categoryId: String?

            public var categoryName: String?

            public var closeCode: String?

            public var comment: String?

            public var context: String?

            public var createdTime: String?

            public var creator: String?

            public var creatorName: String?

            public var currentTaskId: String?

            public var currentTaskName: String?

            public var currentTaskStartTime: Int64?

            public var customerId: String?

            public var endTime: Int64?

            public var instanceId: String?

            public var jobId: String?

            public var source: String?

            public var startTime: Int64?

            public var state: String?

            public var templateId: String?

            public var templateVersion: String?

            public var ticketId: String?

            public var title: String?

            public var updatedTime: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.assignee != nil {
                    map["Assignee"] = self.assignee!
                }
                if self.assigneeName != nil {
                    map["AssigneeName"] = self.assigneeName!
                }
                if self.categoryId != nil {
                    map["CategoryId"] = self.categoryId!
                }
                if self.categoryName != nil {
                    map["CategoryName"] = self.categoryName!
                }
                if self.closeCode != nil {
                    map["CloseCode"] = self.closeCode!
                }
                if self.comment != nil {
                    map["Comment"] = self.comment!
                }
                if self.context != nil {
                    map["Context"] = self.context!
                }
                if self.createdTime != nil {
                    map["CreatedTime"] = self.createdTime!
                }
                if self.creator != nil {
                    map["Creator"] = self.creator!
                }
                if self.creatorName != nil {
                    map["CreatorName"] = self.creatorName!
                }
                if self.currentTaskId != nil {
                    map["CurrentTaskId"] = self.currentTaskId!
                }
                if self.currentTaskName != nil {
                    map["CurrentTaskName"] = self.currentTaskName!
                }
                if self.currentTaskStartTime != nil {
                    map["CurrentTaskStartTime"] = self.currentTaskStartTime!
                }
                if self.customerId != nil {
                    map["CustomerId"] = self.customerId!
                }
                if self.endTime != nil {
                    map["EndTime"] = self.endTime!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.jobId != nil {
                    map["JobId"] = self.jobId!
                }
                if self.source != nil {
                    map["Source"] = self.source!
                }
                if self.startTime != nil {
                    map["StartTime"] = self.startTime!
                }
                if self.state != nil {
                    map["State"] = self.state!
                }
                if self.templateId != nil {
                    map["TemplateId"] = self.templateId!
                }
                if self.templateVersion != nil {
                    map["TemplateVersion"] = self.templateVersion!
                }
                if self.ticketId != nil {
                    map["TicketId"] = self.ticketId!
                }
                if self.title != nil {
                    map["Title"] = self.title!
                }
                if self.updatedTime != nil {
                    map["UpdatedTime"] = self.updatedTime!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Assignee") {
                    self.assignee = dict["Assignee"] as! String
                }
                if dict.keys.contains("AssigneeName") {
                    self.assigneeName = dict["AssigneeName"] as! String
                }
                if dict.keys.contains("CategoryId") {
                    self.categoryId = dict["CategoryId"] as! String
                }
                if dict.keys.contains("CategoryName") {
                    self.categoryName = dict["CategoryName"] as! String
                }
                if dict.keys.contains("CloseCode") {
                    self.closeCode = dict["CloseCode"] as! String
                }
                if dict.keys.contains("Comment") {
                    self.comment = dict["Comment"] as! String
                }
                if dict.keys.contains("Context") {
                    self.context = dict["Context"] as! String
                }
                if dict.keys.contains("CreatedTime") {
                    self.createdTime = dict["CreatedTime"] as! String
                }
                if dict.keys.contains("Creator") {
                    self.creator = dict["Creator"] as! String
                }
                if dict.keys.contains("CreatorName") {
                    self.creatorName = dict["CreatorName"] as! String
                }
                if dict.keys.contains("CurrentTaskId") {
                    self.currentTaskId = dict["CurrentTaskId"] as! String
                }
                if dict.keys.contains("CurrentTaskName") {
                    self.currentTaskName = dict["CurrentTaskName"] as! String
                }
                if dict.keys.contains("CurrentTaskStartTime") {
                    self.currentTaskStartTime = dict["CurrentTaskStartTime"] as! Int64
                }
                if dict.keys.contains("CustomerId") {
                    self.customerId = dict["CustomerId"] as! String
                }
                if dict.keys.contains("EndTime") {
                    self.endTime = dict["EndTime"] as! Int64
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("JobId") {
                    self.jobId = dict["JobId"] as! String
                }
                if dict.keys.contains("Source") {
                    self.source = dict["Source"] as! String
                }
                if dict.keys.contains("StartTime") {
                    self.startTime = dict["StartTime"] as! Int64
                }
                if dict.keys.contains("State") {
                    self.state = dict["State"] as! String
                }
                if dict.keys.contains("TemplateId") {
                    self.templateId = dict["TemplateId"] as! String
                }
                if dict.keys.contains("TemplateVersion") {
                    self.templateVersion = dict["TemplateVersion"] as! String
                }
                if dict.keys.contains("TicketId") {
                    self.ticketId = dict["TicketId"] as! String
                }
                if dict.keys.contains("Title") {
                    self.title = dict["Title"] as! String
                }
                if dict.keys.contains("UpdatedTime") {
                    self.updatedTime = dict["UpdatedTime"] as! String
                }
            }
        }
        public var list: [ListTicketsResponseBody.Data.List]?

        public var pageNumber: Int64?

        public var pageSize: Int64?

        public var totalCount: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.list != nil {
                var tmp : [Any] = []
                for k in self.list! {
                    tmp.append(k.toMap())
                }
                map["List"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("List") {
                var tmp : [ListTicketsResponseBody.Data.List] = []
                for v in dict["List"] as! [Any] {
                    var model = ListTicketsResponseBody.Data.List()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.list = tmp
            }
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int64
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int64
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int64
            }
        }
    }
    public var code: String?

    public var data: ListTicketsResponseBody.Data?

    public var httpStatusCode: Int64?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = ListTicketsResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int64
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListTicketsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListTicketsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListTicketsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListUnassignedNumbersRequest : Tea.TeaModel {
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var searchPattern: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.searchPattern != nil {
            map["SearchPattern"] = self.searchPattern!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SearchPattern") {
            self.searchPattern = dict["SearchPattern"] as! String
        }
    }
}

public class ListUnassignedNumbersResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class List : Tea.TeaModel {
            public var city: String?

            public var number: String?

            public var province: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.city != nil {
                    map["City"] = self.city!
                }
                if self.number != nil {
                    map["Number"] = self.number!
                }
                if self.province != nil {
                    map["Province"] = self.province!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("City") {
                    self.city = dict["City"] as! String
                }
                if dict.keys.contains("Number") {
                    self.number = dict["Number"] as! String
                }
                if dict.keys.contains("Province") {
                    self.province = dict["Province"] as! String
                }
            }
        }
        public var list: [ListUnassignedNumbersResponseBody.Data.List]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.list != nil {
                var tmp : [Any] = []
                for k in self.list! {
                    tmp.append(k.toMap())
                }
                map["List"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("List") {
                var tmp : [ListUnassignedNumbersResponseBody.Data.List] = []
                for v in dict["List"] as! [Any] {
                    var model = ListUnassignedNumbersResponseBody.Data.List()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.list = tmp
            }
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var code: String?

    public var data: ListUnassignedNumbersResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = ListUnassignedNumbersResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListUnassignedNumbersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListUnassignedNumbersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListUnassignedNumbersResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListUserLevelsOfSkillGroupRequest : Tea.TeaModel {
    public var instanceId: String?

    public var isMember: Bool?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var searchPattern: String?

    public var skillGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.isMember != nil {
            map["IsMember"] = self.isMember!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.searchPattern != nil {
            map["SearchPattern"] = self.searchPattern!
        }
        if self.skillGroupId != nil {
            map["SkillGroupId"] = self.skillGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("IsMember") {
            self.isMember = dict["IsMember"] as! Bool
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SearchPattern") {
            self.searchPattern = dict["SearchPattern"] as! String
        }
        if dict.keys.contains("SkillGroupId") {
            self.skillGroupId = dict["SkillGroupId"] as! String
        }
    }
}

public class ListUserLevelsOfSkillGroupResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class List : Tea.TeaModel {
            public var displayName: String?

            public var loginName: String?

            public var ramId: String?

            public var roleId: String?

            public var roleName: String?

            public var skillGroupId: String?

            public var skillGroupName: String?

            public var skillLevel: Int32?

            public var userId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.displayName != nil {
                    map["DisplayName"] = self.displayName!
                }
                if self.loginName != nil {
                    map["LoginName"] = self.loginName!
                }
                if self.ramId != nil {
                    map["RamId"] = self.ramId!
                }
                if self.roleId != nil {
                    map["RoleId"] = self.roleId!
                }
                if self.roleName != nil {
                    map["RoleName"] = self.roleName!
                }
                if self.skillGroupId != nil {
                    map["SkillGroupId"] = self.skillGroupId!
                }
                if self.skillGroupName != nil {
                    map["SkillGroupName"] = self.skillGroupName!
                }
                if self.skillLevel != nil {
                    map["SkillLevel"] = self.skillLevel!
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DisplayName") {
                    self.displayName = dict["DisplayName"] as! String
                }
                if dict.keys.contains("LoginName") {
                    self.loginName = dict["LoginName"] as! String
                }
                if dict.keys.contains("RamId") {
                    self.ramId = dict["RamId"] as! String
                }
                if dict.keys.contains("RoleId") {
                    self.roleId = dict["RoleId"] as! String
                }
                if dict.keys.contains("RoleName") {
                    self.roleName = dict["RoleName"] as! String
                }
                if dict.keys.contains("SkillGroupId") {
                    self.skillGroupId = dict["SkillGroupId"] as! String
                }
                if dict.keys.contains("SkillGroupName") {
                    self.skillGroupName = dict["SkillGroupName"] as! String
                }
                if dict.keys.contains("SkillLevel") {
                    self.skillLevel = dict["SkillLevel"] as! Int32
                }
                if dict.keys.contains("UserId") {
                    self.userId = dict["UserId"] as! String
                }
            }
        }
        public var list: [ListUserLevelsOfSkillGroupResponseBody.Data.List]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.list != nil {
                var tmp : [Any] = []
                for k in self.list! {
                    tmp.append(k.toMap())
                }
                map["List"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("List") {
                var tmp : [ListUserLevelsOfSkillGroupResponseBody.Data.List] = []
                for v in dict["List"] as! [Any] {
                    var model = ListUserLevelsOfSkillGroupResponseBody.Data.List()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.list = tmp
            }
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var code: String?

    public var data: ListUserLevelsOfSkillGroupResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = ListUserLevelsOfSkillGroupResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListUserLevelsOfSkillGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListUserLevelsOfSkillGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListUserLevelsOfSkillGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListUsersRequest : Tea.TeaModel {
    public var instanceId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var searchPattern: String?

    public var skillGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.searchPattern != nil {
            map["SearchPattern"] = self.searchPattern!
        }
        if self.skillGroupId != nil {
            map["SkillGroupId"] = self.skillGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SearchPattern") {
            self.searchPattern = dict["SearchPattern"] as! String
        }
        if dict.keys.contains("SkillGroupId") {
            self.skillGroupId = dict["SkillGroupId"] as! String
        }
    }
}

public class ListUsersResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class List : Tea.TeaModel {
            public class PersonalOutboundNumberList : Tea.TeaModel {
                public var active: Bool?

                public var city: String?

                public var number: String?

                public var province: String?

                public var usage: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.active != nil {
                        map["Active"] = self.active!
                    }
                    if self.city != nil {
                        map["City"] = self.city!
                    }
                    if self.number != nil {
                        map["Number"] = self.number!
                    }
                    if self.province != nil {
                        map["Province"] = self.province!
                    }
                    if self.usage != nil {
                        map["Usage"] = self.usage!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Active") {
                        self.active = dict["Active"] as! Bool
                    }
                    if dict.keys.contains("City") {
                        self.city = dict["City"] as! String
                    }
                    if dict.keys.contains("Number") {
                        self.number = dict["Number"] as! String
                    }
                    if dict.keys.contains("Province") {
                        self.province = dict["Province"] as! String
                    }
                    if dict.keys.contains("Usage") {
                        self.usage = dict["Usage"] as! String
                    }
                }
            }
            public class SkillLevelList : Tea.TeaModel {
                public var skillGroupId: String?

                public var skillGroupName: String?

                public var skillLevel: Int32?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.skillGroupId != nil {
                        map["SkillGroupId"] = self.skillGroupId!
                    }
                    if self.skillGroupName != nil {
                        map["SkillGroupName"] = self.skillGroupName!
                    }
                    if self.skillLevel != nil {
                        map["SkillLevel"] = self.skillLevel!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("SkillGroupId") {
                        self.skillGroupId = dict["SkillGroupId"] as! String
                    }
                    if dict.keys.contains("SkillGroupName") {
                        self.skillGroupName = dict["SkillGroupName"] as! String
                    }
                    if dict.keys.contains("SkillLevel") {
                        self.skillLevel = dict["SkillLevel"] as! Int32
                    }
                }
            }
            public var deviceExt: String?

            public var deviceId: String?

            public var deviceState: String?

            public var displayId: String?

            public var displayName: String?

            public var email: String?

            public var extension_: String?

            public var loginName: String?

            public var mobile: String?

            public var personalOutboundNumberList: [ListUsersResponseBody.Data.List.PersonalOutboundNumberList]?

            public var primary: Bool?

            public var primaryAccount: Bool?

            public var ramId: Int64?

            public var roleId: String?

            public var roleName: String?

            public var skillLevelList: [ListUsersResponseBody.Data.List.SkillLevelList]?

            public var userId: String?

            public var workMode: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.deviceExt != nil {
                    map["DeviceExt"] = self.deviceExt!
                }
                if self.deviceId != nil {
                    map["DeviceId"] = self.deviceId!
                }
                if self.deviceState != nil {
                    map["DeviceState"] = self.deviceState!
                }
                if self.displayId != nil {
                    map["DisplayId"] = self.displayId!
                }
                if self.displayName != nil {
                    map["DisplayName"] = self.displayName!
                }
                if self.email != nil {
                    map["Email"] = self.email!
                }
                if self.extension_ != nil {
                    map["Extension"] = self.extension_!
                }
                if self.loginName != nil {
                    map["LoginName"] = self.loginName!
                }
                if self.mobile != nil {
                    map["Mobile"] = self.mobile!
                }
                if self.personalOutboundNumberList != nil {
                    var tmp : [Any] = []
                    for k in self.personalOutboundNumberList! {
                        tmp.append(k.toMap())
                    }
                    map["PersonalOutboundNumberList"] = tmp
                }
                if self.primary != nil {
                    map["Primary"] = self.primary!
                }
                if self.primaryAccount != nil {
                    map["PrimaryAccount"] = self.primaryAccount!
                }
                if self.ramId != nil {
                    map["RamId"] = self.ramId!
                }
                if self.roleId != nil {
                    map["RoleId"] = self.roleId!
                }
                if self.roleName != nil {
                    map["RoleName"] = self.roleName!
                }
                if self.skillLevelList != nil {
                    var tmp : [Any] = []
                    for k in self.skillLevelList! {
                        tmp.append(k.toMap())
                    }
                    map["SkillLevelList"] = tmp
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                if self.workMode != nil {
                    map["WorkMode"] = self.workMode!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DeviceExt") {
                    self.deviceExt = dict["DeviceExt"] as! String
                }
                if dict.keys.contains("DeviceId") {
                    self.deviceId = dict["DeviceId"] as! String
                }
                if dict.keys.contains("DeviceState") {
                    self.deviceState = dict["DeviceState"] as! String
                }
                if dict.keys.contains("DisplayId") {
                    self.displayId = dict["DisplayId"] as! String
                }
                if dict.keys.contains("DisplayName") {
                    self.displayName = dict["DisplayName"] as! String
                }
                if dict.keys.contains("Email") {
                    self.email = dict["Email"] as! String
                }
                if dict.keys.contains("Extension") {
                    self.extension_ = dict["Extension"] as! String
                }
                if dict.keys.contains("LoginName") {
                    self.loginName = dict["LoginName"] as! String
                }
                if dict.keys.contains("Mobile") {
                    self.mobile = dict["Mobile"] as! String
                }
                if dict.keys.contains("PersonalOutboundNumberList") {
                    var tmp : [ListUsersResponseBody.Data.List.PersonalOutboundNumberList] = []
                    for v in dict["PersonalOutboundNumberList"] as! [Any] {
                        var model = ListUsersResponseBody.Data.List.PersonalOutboundNumberList()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.personalOutboundNumberList = tmp
                }
                if dict.keys.contains("Primary") {
                    self.primary = dict["Primary"] as! Bool
                }
                if dict.keys.contains("PrimaryAccount") {
                    self.primaryAccount = dict["PrimaryAccount"] as! Bool
                }
                if dict.keys.contains("RamId") {
                    self.ramId = dict["RamId"] as! Int64
                }
                if dict.keys.contains("RoleId") {
                    self.roleId = dict["RoleId"] as! String
                }
                if dict.keys.contains("RoleName") {
                    self.roleName = dict["RoleName"] as! String
                }
                if dict.keys.contains("SkillLevelList") {
                    var tmp : [ListUsersResponseBody.Data.List.SkillLevelList] = []
                    for v in dict["SkillLevelList"] as! [Any] {
                        var model = ListUsersResponseBody.Data.List.SkillLevelList()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.skillLevelList = tmp
                }
                if dict.keys.contains("UserId") {
                    self.userId = dict["UserId"] as! String
                }
                if dict.keys.contains("WorkMode") {
                    self.workMode = dict["WorkMode"] as! String
                }
            }
        }
        public var list: [ListUsersResponseBody.Data.List]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.list != nil {
                var tmp : [Any] = []
                for k in self.list! {
                    tmp.append(k.toMap())
                }
                map["List"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("List") {
                var tmp : [ListUsersResponseBody.Data.List] = []
                for v in dict["List"] as! [Any] {
                    var model = ListUsersResponseBody.Data.List()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.list = tmp
            }
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var code: String?

    public var data: ListUsersResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var params: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.params != nil {
            map["Params"] = self.params!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = ListUsersResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Params") {
            self.params = dict["Params"] as! [String]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListUsersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListUsersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListUsersResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListVoicemailsRequest : Tea.TeaModel {
    public var caller: String?

    public var contactId: String?

    public var endTime: Int64?

    public var instanceId: String?

    public var name: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var startTime: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.caller != nil {
            map["Caller"] = self.caller!
        }
        if self.contactId != nil {
            map["ContactId"] = self.contactId!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Caller") {
            self.caller = dict["Caller"] as! String
        }
        if dict.keys.contains("ContactId") {
            self.contactId = dict["ContactId"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! Int64
        }
    }
}

public class ListVoicemailsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class List : Tea.TeaModel {
            public var callee: String?

            public var caller: String?

            public var cdrStartTime: Int64?

            public var contactId: String?

            public var duration: Int64?

            public var instanceId: String?

            public var name: String?

            public var recordingDuration: Int64?

            public var startTime: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.callee != nil {
                    map["Callee"] = self.callee!
                }
                if self.caller != nil {
                    map["Caller"] = self.caller!
                }
                if self.cdrStartTime != nil {
                    map["CdrStartTime"] = self.cdrStartTime!
                }
                if self.contactId != nil {
                    map["ContactId"] = self.contactId!
                }
                if self.duration != nil {
                    map["Duration"] = self.duration!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.recordingDuration != nil {
                    map["RecordingDuration"] = self.recordingDuration!
                }
                if self.startTime != nil {
                    map["StartTime"] = self.startTime!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Callee") {
                    self.callee = dict["Callee"] as! String
                }
                if dict.keys.contains("Caller") {
                    self.caller = dict["Caller"] as! String
                }
                if dict.keys.contains("CdrStartTime") {
                    self.cdrStartTime = dict["CdrStartTime"] as! Int64
                }
                if dict.keys.contains("ContactId") {
                    self.contactId = dict["ContactId"] as! String
                }
                if dict.keys.contains("Duration") {
                    self.duration = dict["Duration"] as! Int64
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("RecordingDuration") {
                    self.recordingDuration = dict["RecordingDuration"] as! Int64
                }
                if dict.keys.contains("StartTime") {
                    self.startTime = dict["StartTime"] as! String
                }
            }
        }
        public var list: [ListVoicemailsResponseBody.Data.List]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.list != nil {
                var tmp : [Any] = []
                for k in self.list! {
                    tmp.append(k.toMap())
                }
                map["List"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("List") {
                var tmp : [ListVoicemailsResponseBody.Data.List] = []
                for v in dict["List"] as! [Any] {
                    var model = ListVoicemailsResponseBody.Data.List()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.list = tmp
            }
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var code: String?

    public var data: ListVoicemailsResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = ListVoicemailsResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListVoicemailsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListVoicemailsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListVoicemailsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListWaitingChatsRequest : Tea.TeaModel {
    public var instanceId: String?

    public var skillGroupIdList: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.skillGroupIdList != nil {
            map["SkillGroupIdList"] = self.skillGroupIdList!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("SkillGroupIdList") {
            self.skillGroupIdList = dict["SkillGroupIdList"] as! String
        }
    }
}

public class ListWaitingChatsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Messages : Tea.TeaModel {
            public var content: String?

            public var senderId: String?

            public var senderType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.content != nil {
                    map["Content"] = self.content!
                }
                if self.senderId != nil {
                    map["SenderId"] = self.senderId!
                }
                if self.senderType != nil {
                    map["SenderType"] = self.senderType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Content") {
                    self.content = dict["Content"] as! String
                }
                if dict.keys.contains("SenderId") {
                    self.senderId = dict["SenderId"] as! String
                }
                if dict.keys.contains("SenderType") {
                    self.senderType = dict["SenderType"] as! String
                }
            }
        }
        public class UserList : Tea.TeaModel {
            public var avatarUrl: String?

            public var userId: String?

            public var userName: String?

            public var userType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.avatarUrl != nil {
                    map["AvatarUrl"] = self.avatarUrl!
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                if self.userName != nil {
                    map["UserName"] = self.userName!
                }
                if self.userType != nil {
                    map["UserType"] = self.userType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AvatarUrl") {
                    self.avatarUrl = dict["AvatarUrl"] as! String
                }
                if dict.keys.contains("UserId") {
                    self.userId = dict["UserId"] as! String
                }
                if dict.keys.contains("UserName") {
                    self.userName = dict["UserName"] as! String
                }
                if dict.keys.contains("UserType") {
                    self.userType = dict["UserType"] as! String
                }
            }
        }
        public var accessChannelId: String?

        public var accessChannelType: String?

        public var beingAssigned: Bool?

        public var chatConversationId: String?

        public var enqueueTime: Int64?

        public var jobId: String?

        public var messages: [ListWaitingChatsResponseBody.Data.Messages]?

        public var skillGroupId: String?

        public var userList: [ListWaitingChatsResponseBody.Data.UserList]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accessChannelId != nil {
                map["AccessChannelId"] = self.accessChannelId!
            }
            if self.accessChannelType != nil {
                map["AccessChannelType"] = self.accessChannelType!
            }
            if self.beingAssigned != nil {
                map["BeingAssigned"] = self.beingAssigned!
            }
            if self.chatConversationId != nil {
                map["ChatConversationId"] = self.chatConversationId!
            }
            if self.enqueueTime != nil {
                map["EnqueueTime"] = self.enqueueTime!
            }
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            if self.messages != nil {
                var tmp : [Any] = []
                for k in self.messages! {
                    tmp.append(k.toMap())
                }
                map["Messages"] = tmp
            }
            if self.skillGroupId != nil {
                map["SkillGroupId"] = self.skillGroupId!
            }
            if self.userList != nil {
                var tmp : [Any] = []
                for k in self.userList! {
                    tmp.append(k.toMap())
                }
                map["UserList"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AccessChannelId") {
                self.accessChannelId = dict["AccessChannelId"] as! String
            }
            if dict.keys.contains("AccessChannelType") {
                self.accessChannelType = dict["AccessChannelType"] as! String
            }
            if dict.keys.contains("BeingAssigned") {
                self.beingAssigned = dict["BeingAssigned"] as! Bool
            }
            if dict.keys.contains("ChatConversationId") {
                self.chatConversationId = dict["ChatConversationId"] as! String
            }
            if dict.keys.contains("EnqueueTime") {
                self.enqueueTime = dict["EnqueueTime"] as! Int64
            }
            if dict.keys.contains("JobId") {
                self.jobId = dict["JobId"] as! String
            }
            if dict.keys.contains("Messages") {
                var tmp : [ListWaitingChatsResponseBody.Data.Messages] = []
                for v in dict["Messages"] as! [Any] {
                    var model = ListWaitingChatsResponseBody.Data.Messages()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.messages = tmp
            }
            if dict.keys.contains("SkillGroupId") {
                self.skillGroupId = dict["SkillGroupId"] as! String
            }
            if dict.keys.contains("UserList") {
                var tmp : [ListWaitingChatsResponseBody.Data.UserList] = []
                for v in dict["UserList"] as! [Any] {
                    var model = ListWaitingChatsResponseBody.Data.UserList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.userList = tmp
            }
        }
    }
    public var code: String?

    public var data: [ListWaitingChatsResponseBody.Data]?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var tmp : [ListWaitingChatsResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = ListWaitingChatsResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListWaitingChatsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListWaitingChatsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListWaitingChatsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class MakeCallRequest : Tea.TeaModel {
    public var callee: String?

    public var caller: String?

    public var deviceId: String?

    public var flashSmsVariables: String?

    public var instanceId: String?

    public var maskedCallee: String?

    public var mediaType: String?

    public var tags: String?

    public var timeoutSeconds: Int32?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.callee != nil {
            map["Callee"] = self.callee!
        }
        if self.caller != nil {
            map["Caller"] = self.caller!
        }
        if self.deviceId != nil {
            map["DeviceId"] = self.deviceId!
        }
        if self.flashSmsVariables != nil {
            map["FlashSmsVariables"] = self.flashSmsVariables!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.maskedCallee != nil {
            map["MaskedCallee"] = self.maskedCallee!
        }
        if self.mediaType != nil {
            map["MediaType"] = self.mediaType!
        }
        if self.tags != nil {
            map["Tags"] = self.tags!
        }
        if self.timeoutSeconds != nil {
            map["TimeoutSeconds"] = self.timeoutSeconds!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Callee") {
            self.callee = dict["Callee"] as! String
        }
        if dict.keys.contains("Caller") {
            self.caller = dict["Caller"] as! String
        }
        if dict.keys.contains("DeviceId") {
            self.deviceId = dict["DeviceId"] as! String
        }
        if dict.keys.contains("FlashSmsVariables") {
            self.flashSmsVariables = dict["FlashSmsVariables"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("MaskedCallee") {
            self.maskedCallee = dict["MaskedCallee"] as! String
        }
        if dict.keys.contains("MediaType") {
            self.mediaType = dict["MediaType"] as! String
        }
        if dict.keys.contains("Tags") {
            self.tags = dict["Tags"] as! String
        }
        if dict.keys.contains("TimeoutSeconds") {
            self.timeoutSeconds = dict["TimeoutSeconds"] as! Int32
        }
        if dict.keys.contains("UserId") {
            self.userId = dict["UserId"] as! String
        }
    }
}

public class MakeCallResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class CallContext : Tea.TeaModel {
            public class ChannelContexts : Tea.TeaModel {
                public var callType: String?

                public var channelFlags: String?

                public var channelId: String?

                public var channelState: String?

                public var destination: String?

                public var jobId: String?

                public var mediaType: String?

                public var originator: String?

                public var releaseInitiator: String?

                public var releaseReason: String?

                public var timestamp: Int64?

                public var userExtension: String?

                public var userId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.callType != nil {
                        map["CallType"] = self.callType!
                    }
                    if self.channelFlags != nil {
                        map["ChannelFlags"] = self.channelFlags!
                    }
                    if self.channelId != nil {
                        map["ChannelId"] = self.channelId!
                    }
                    if self.channelState != nil {
                        map["ChannelState"] = self.channelState!
                    }
                    if self.destination != nil {
                        map["Destination"] = self.destination!
                    }
                    if self.jobId != nil {
                        map["JobId"] = self.jobId!
                    }
                    if self.mediaType != nil {
                        map["MediaType"] = self.mediaType!
                    }
                    if self.originator != nil {
                        map["Originator"] = self.originator!
                    }
                    if self.releaseInitiator != nil {
                        map["ReleaseInitiator"] = self.releaseInitiator!
                    }
                    if self.releaseReason != nil {
                        map["ReleaseReason"] = self.releaseReason!
                    }
                    if self.timestamp != nil {
                        map["Timestamp"] = self.timestamp!
                    }
                    if self.userExtension != nil {
                        map["UserExtension"] = self.userExtension!
                    }
                    if self.userId != nil {
                        map["UserId"] = self.userId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("CallType") {
                        self.callType = dict["CallType"] as! String
                    }
                    if dict.keys.contains("ChannelFlags") {
                        self.channelFlags = dict["ChannelFlags"] as! String
                    }
                    if dict.keys.contains("ChannelId") {
                        self.channelId = dict["ChannelId"] as! String
                    }
                    if dict.keys.contains("ChannelState") {
                        self.channelState = dict["ChannelState"] as! String
                    }
                    if dict.keys.contains("Destination") {
                        self.destination = dict["Destination"] as! String
                    }
                    if dict.keys.contains("JobId") {
                        self.jobId = dict["JobId"] as! String
                    }
                    if dict.keys.contains("MediaType") {
                        self.mediaType = dict["MediaType"] as! String
                    }
                    if dict.keys.contains("Originator") {
                        self.originator = dict["Originator"] as! String
                    }
                    if dict.keys.contains("ReleaseInitiator") {
                        self.releaseInitiator = dict["ReleaseInitiator"] as! String
                    }
                    if dict.keys.contains("ReleaseReason") {
                        self.releaseReason = dict["ReleaseReason"] as! String
                    }
                    if dict.keys.contains("Timestamp") {
                        self.timestamp = dict["Timestamp"] as! Int64
                    }
                    if dict.keys.contains("UserExtension") {
                        self.userExtension = dict["UserExtension"] as! String
                    }
                    if dict.keys.contains("UserId") {
                        self.userId = dict["UserId"] as! String
                    }
                }
            }
            public var callType: String?

            public var channelContexts: [MakeCallResponseBody.Data.CallContext.ChannelContexts]?

            public var instanceId: String?

            public var jobId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.callType != nil {
                    map["CallType"] = self.callType!
                }
                if self.channelContexts != nil {
                    var tmp : [Any] = []
                    for k in self.channelContexts! {
                        tmp.append(k.toMap())
                    }
                    map["ChannelContexts"] = tmp
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.jobId != nil {
                    map["JobId"] = self.jobId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CallType") {
                    self.callType = dict["CallType"] as! String
                }
                if dict.keys.contains("ChannelContexts") {
                    var tmp : [MakeCallResponseBody.Data.CallContext.ChannelContexts] = []
                    for v in dict["ChannelContexts"] as! [Any] {
                        var model = MakeCallResponseBody.Data.CallContext.ChannelContexts()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.channelContexts = tmp
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("JobId") {
                    self.jobId = dict["JobId"] as! String
                }
            }
        }
        public class UserContext : Tea.TeaModel {
            public var breakCode: String?

            public var deviceId: String?

            public var extension_: String?

            public var instanceId: String?

            public var jobId: String?

            public var outboundScenario: Bool?

            public var signedSkillGroupIdList: [String]?

            public var userId: String?

            public var userState: String?

            public var workMode: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.breakCode != nil {
                    map["BreakCode"] = self.breakCode!
                }
                if self.deviceId != nil {
                    map["DeviceId"] = self.deviceId!
                }
                if self.extension_ != nil {
                    map["Extension"] = self.extension_!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.jobId != nil {
                    map["JobId"] = self.jobId!
                }
                if self.outboundScenario != nil {
                    map["OutboundScenario"] = self.outboundScenario!
                }
                if self.signedSkillGroupIdList != nil {
                    map["SignedSkillGroupIdList"] = self.signedSkillGroupIdList!
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                if self.userState != nil {
                    map["UserState"] = self.userState!
                }
                if self.workMode != nil {
                    map["WorkMode"] = self.workMode!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BreakCode") {
                    self.breakCode = dict["BreakCode"] as! String
                }
                if dict.keys.contains("DeviceId") {
                    self.deviceId = dict["DeviceId"] as! String
                }
                if dict.keys.contains("Extension") {
                    self.extension_ = dict["Extension"] as! String
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("JobId") {
                    self.jobId = dict["JobId"] as! String
                }
                if dict.keys.contains("OutboundScenario") {
                    self.outboundScenario = dict["OutboundScenario"] as! Bool
                }
                if dict.keys.contains("SignedSkillGroupIdList") {
                    self.signedSkillGroupIdList = dict["SignedSkillGroupIdList"] as! [String]
                }
                if dict.keys.contains("UserId") {
                    self.userId = dict["UserId"] as! String
                }
                if dict.keys.contains("UserState") {
                    self.userState = dict["UserState"] as! String
                }
                if dict.keys.contains("WorkMode") {
                    self.workMode = dict["WorkMode"] as! String
                }
            }
        }
        public var callContext: MakeCallResponseBody.Data.CallContext?

        public var contextId: Int64?

        public var userContext: MakeCallResponseBody.Data.UserContext?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.callContext?.validate()
            try self.userContext?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.callContext != nil {
                map["CallContext"] = self.callContext?.toMap()
            }
            if self.contextId != nil {
                map["ContextId"] = self.contextId!
            }
            if self.userContext != nil {
                map["UserContext"] = self.userContext?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CallContext") {
                var model = MakeCallResponseBody.Data.CallContext()
                model.fromMap(dict["CallContext"] as! [String: Any])
                self.callContext = model
            }
            if dict.keys.contains("ContextId") {
                self.contextId = dict["ContextId"] as! Int64
            }
            if dict.keys.contains("UserContext") {
                var model = MakeCallResponseBody.Data.UserContext()
                model.fromMap(dict["UserContext"] as! [String: Any])
                self.userContext = model
            }
        }
    }
    public var code: String?

    public var data: MakeCallResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var params: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.params != nil {
            map["Params"] = self.params!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = MakeCallResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Params") {
            self.params = dict["Params"] as! [String]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class MakeCallResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: MakeCallResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = MakeCallResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyAudioFileRequest : Tea.TeaModel {
    public var audioFileName: String?

    public var audioResourceId: String?

    public var instanceId: String?

    public var name: String?

    public var ossFileKey: String?

    public var usage: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.audioFileName != nil {
            map["AudioFileName"] = self.audioFileName!
        }
        if self.audioResourceId != nil {
            map["AudioResourceId"] = self.audioResourceId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.ossFileKey != nil {
            map["OssFileKey"] = self.ossFileKey!
        }
        if self.usage != nil {
            map["Usage"] = self.usage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AudioFileName") {
            self.audioFileName = dict["AudioFileName"] as! String
        }
        if dict.keys.contains("AudioResourceId") {
            self.audioResourceId = dict["AudioResourceId"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("OssFileKey") {
            self.ossFileKey = dict["OssFileKey"] as! String
        }
        if dict.keys.contains("Usage") {
            self.usage = dict["Usage"] as! String
        }
    }
}

public class ModifyAudioFileResponseBody : Tea.TeaModel {
    public var code: String?

    public var data: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyAudioFileResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyAudioFileResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyAudioFileResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyCustomCallTaggingRequest : Tea.TeaModel {
    public var callTagNameList: String?

    public var description_: String?

    public var instanceId: String?

    public var number: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.callTagNameList != nil {
            map["CallTagNameList"] = self.callTagNameList!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.number != nil {
            map["Number"] = self.number!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CallTagNameList") {
            self.callTagNameList = dict["CallTagNameList"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Number") {
            self.number = dict["Number"] as! String
        }
    }
}

public class ModifyCustomCallTaggingResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyCustomCallTaggingResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyCustomCallTaggingResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyCustomCallTaggingResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyInstanceRequest : Tea.TeaModel {
    public var description_: String?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
    }
}

public class ModifyInstanceResponseBody : Tea.TeaModel {
    public var code: String?

    public var data: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyPhoneNumberRequest : Tea.TeaModel {
    public var contactFlowId: String?

    public var instanceId: String?

    public var number: String?

    public var usage: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.contactFlowId != nil {
            map["ContactFlowId"] = self.contactFlowId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.number != nil {
            map["Number"] = self.number!
        }
        if self.usage != nil {
            map["Usage"] = self.usage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ContactFlowId") {
            self.contactFlowId = dict["ContactFlowId"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Number") {
            self.number = dict["Number"] as! String
        }
        if dict.keys.contains("Usage") {
            self.usage = dict["Usage"] as! String
        }
    }
}

public class ModifyPhoneNumberResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyPhoneNumberResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyPhoneNumberResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyPhoneNumberResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifySkillGroupRequest : Tea.TeaModel {
    public var description_: String?

    public var displayName: String?

    public var instanceId: String?

    public var skillGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.displayName != nil {
            map["DisplayName"] = self.displayName!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.skillGroupId != nil {
            map["SkillGroupId"] = self.skillGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("DisplayName") {
            self.displayName = dict["DisplayName"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("SkillGroupId") {
            self.skillGroupId = dict["SkillGroupId"] as! String
        }
    }
}

public class ModifySkillGroupResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifySkillGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifySkillGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifySkillGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifySkillLevelsOfUserRequest : Tea.TeaModel {
    public var instanceId: String?

    public var skillLevelList: String?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.skillLevelList != nil {
            map["SkillLevelList"] = self.skillLevelList!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("SkillLevelList") {
            self.skillLevelList = dict["SkillLevelList"] as! String
        }
        if dict.keys.contains("UserId") {
            self.userId = dict["UserId"] as! String
        }
    }
}

public class ModifySkillLevelsOfUserResponseBody : Tea.TeaModel {
    public var code: String?

    public var data: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifySkillLevelsOfUserResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifySkillLevelsOfUserResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifySkillLevelsOfUserResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyUserRequest : Tea.TeaModel {
    public var avatarUrl: String?

    public var displayId: String?

    public var displayName: String?

    public var force: Bool?

    public var instanceId: String?

    public var mobile: String?

    public var nickname: String?

    public var roleId: String?

    public var userId: String?

    public var workMode: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.avatarUrl != nil {
            map["AvatarUrl"] = self.avatarUrl!
        }
        if self.displayId != nil {
            map["DisplayId"] = self.displayId!
        }
        if self.displayName != nil {
            map["DisplayName"] = self.displayName!
        }
        if self.force != nil {
            map["Force"] = self.force!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.mobile != nil {
            map["Mobile"] = self.mobile!
        }
        if self.nickname != nil {
            map["Nickname"] = self.nickname!
        }
        if self.roleId != nil {
            map["RoleId"] = self.roleId!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        if self.workMode != nil {
            map["WorkMode"] = self.workMode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AvatarUrl") {
            self.avatarUrl = dict["AvatarUrl"] as! String
        }
        if dict.keys.contains("DisplayId") {
            self.displayId = dict["DisplayId"] as! String
        }
        if dict.keys.contains("DisplayName") {
            self.displayName = dict["DisplayName"] as! String
        }
        if dict.keys.contains("Force") {
            self.force = dict["Force"] as! Bool
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Mobile") {
            self.mobile = dict["Mobile"] as! String
        }
        if dict.keys.contains("Nickname") {
            self.nickname = dict["Nickname"] as! String
        }
        if dict.keys.contains("RoleId") {
            self.roleId = dict["RoleId"] as! String
        }
        if dict.keys.contains("UserId") {
            self.userId = dict["UserId"] as! String
        }
        if dict.keys.contains("WorkMode") {
            self.workMode = dict["WorkMode"] as! String
        }
    }
}

public class ModifyUserResponseBody : Tea.TeaModel {
    public var code: String?

    public var data: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var params: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.params != nil {
            map["Params"] = self.params!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Params") {
            self.params = dict["Params"] as! [String]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyUserResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyUserResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyUserResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyUserLevelsOfSkillGroupRequest : Tea.TeaModel {
    public var instanceId: String?

    public var skillGroupId: String?

    public var userLevelList: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.skillGroupId != nil {
            map["SkillGroupId"] = self.skillGroupId!
        }
        if self.userLevelList != nil {
            map["UserLevelList"] = self.userLevelList!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("SkillGroupId") {
            self.skillGroupId = dict["SkillGroupId"] as! String
        }
        if dict.keys.contains("UserLevelList") {
            self.userLevelList = dict["UserLevelList"] as! String
        }
    }
}

public class ModifyUserLevelsOfSkillGroupResponseBody : Tea.TeaModel {
    public var code: String?

    public var data: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyUserLevelsOfSkillGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyUserLevelsOfSkillGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyUserLevelsOfSkillGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class MonitorCallRequest : Tea.TeaModel {
    public var deviceId: String?

    public var instanceId: String?

    public var monitoredUserId: String?

    public var timeoutSeconds: Int32?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.deviceId != nil {
            map["DeviceId"] = self.deviceId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.monitoredUserId != nil {
            map["MonitoredUserId"] = self.monitoredUserId!
        }
        if self.timeoutSeconds != nil {
            map["TimeoutSeconds"] = self.timeoutSeconds!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DeviceId") {
            self.deviceId = dict["DeviceId"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("MonitoredUserId") {
            self.monitoredUserId = dict["MonitoredUserId"] as! String
        }
        if dict.keys.contains("TimeoutSeconds") {
            self.timeoutSeconds = dict["TimeoutSeconds"] as! Int32
        }
        if dict.keys.contains("UserId") {
            self.userId = dict["UserId"] as! String
        }
    }
}

public class MonitorCallResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class CallContext : Tea.TeaModel {
            public class ChannelContexts : Tea.TeaModel {
                public var callType: String?

                public var channelFlags: String?

                public var channelId: String?

                public var channelState: String?

                public var destination: String?

                public var index: Int32?

                public var jobId: String?

                public var originator: String?

                public var releaseInitiator: String?

                public var releaseReason: String?

                public var skillGroupId: String?

                public var timestamp: Int64?

                public var userExtension: String?

                public var userId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.callType != nil {
                        map["CallType"] = self.callType!
                    }
                    if self.channelFlags != nil {
                        map["ChannelFlags"] = self.channelFlags!
                    }
                    if self.channelId != nil {
                        map["ChannelId"] = self.channelId!
                    }
                    if self.channelState != nil {
                        map["ChannelState"] = self.channelState!
                    }
                    if self.destination != nil {
                        map["Destination"] = self.destination!
                    }
                    if self.index != nil {
                        map["Index"] = self.index!
                    }
                    if self.jobId != nil {
                        map["JobId"] = self.jobId!
                    }
                    if self.originator != nil {
                        map["Originator"] = self.originator!
                    }
                    if self.releaseInitiator != nil {
                        map["ReleaseInitiator"] = self.releaseInitiator!
                    }
                    if self.releaseReason != nil {
                        map["ReleaseReason"] = self.releaseReason!
                    }
                    if self.skillGroupId != nil {
                        map["SkillGroupId"] = self.skillGroupId!
                    }
                    if self.timestamp != nil {
                        map["Timestamp"] = self.timestamp!
                    }
                    if self.userExtension != nil {
                        map["UserExtension"] = self.userExtension!
                    }
                    if self.userId != nil {
                        map["UserId"] = self.userId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("CallType") {
                        self.callType = dict["CallType"] as! String
                    }
                    if dict.keys.contains("ChannelFlags") {
                        self.channelFlags = dict["ChannelFlags"] as! String
                    }
                    if dict.keys.contains("ChannelId") {
                        self.channelId = dict["ChannelId"] as! String
                    }
                    if dict.keys.contains("ChannelState") {
                        self.channelState = dict["ChannelState"] as! String
                    }
                    if dict.keys.contains("Destination") {
                        self.destination = dict["Destination"] as! String
                    }
                    if dict.keys.contains("Index") {
                        self.index = dict["Index"] as! Int32
                    }
                    if dict.keys.contains("JobId") {
                        self.jobId = dict["JobId"] as! String
                    }
                    if dict.keys.contains("Originator") {
                        self.originator = dict["Originator"] as! String
                    }
                    if dict.keys.contains("ReleaseInitiator") {
                        self.releaseInitiator = dict["ReleaseInitiator"] as! String
                    }
                    if dict.keys.contains("ReleaseReason") {
                        self.releaseReason = dict["ReleaseReason"] as! String
                    }
                    if dict.keys.contains("SkillGroupId") {
                        self.skillGroupId = dict["SkillGroupId"] as! String
                    }
                    if dict.keys.contains("Timestamp") {
                        self.timestamp = dict["Timestamp"] as! Int64
                    }
                    if dict.keys.contains("UserExtension") {
                        self.userExtension = dict["UserExtension"] as! String
                    }
                    if dict.keys.contains("UserId") {
                        self.userId = dict["UserId"] as! String
                    }
                }
            }
            public var callType: String?

            public var channelContexts: [MonitorCallResponseBody.Data.CallContext.ChannelContexts]?

            public var instanceId: String?

            public var jobId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.callType != nil {
                    map["CallType"] = self.callType!
                }
                if self.channelContexts != nil {
                    var tmp : [Any] = []
                    for k in self.channelContexts! {
                        tmp.append(k.toMap())
                    }
                    map["ChannelContexts"] = tmp
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.jobId != nil {
                    map["JobId"] = self.jobId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CallType") {
                    self.callType = dict["CallType"] as! String
                }
                if dict.keys.contains("ChannelContexts") {
                    var tmp : [MonitorCallResponseBody.Data.CallContext.ChannelContexts] = []
                    for v in dict["ChannelContexts"] as! [Any] {
                        var model = MonitorCallResponseBody.Data.CallContext.ChannelContexts()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.channelContexts = tmp
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("JobId") {
                    self.jobId = dict["JobId"] as! String
                }
            }
        }
        public class UserContext : Tea.TeaModel {
            public var breakCode: String?

            public var deviceId: String?

            public var extension_: String?

            public var heartbeat: Int64?

            public var instanceId: String?

            public var jobId: String?

            public var mobile: String?

            public var outboundScenario: Bool?

            public var reserved: Int64?

            public var signedSkillGroupIdList: [String]?

            public var userId: String?

            public var userState: String?

            public var workMode: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.breakCode != nil {
                    map["BreakCode"] = self.breakCode!
                }
                if self.deviceId != nil {
                    map["DeviceId"] = self.deviceId!
                }
                if self.extension_ != nil {
                    map["Extension"] = self.extension_!
                }
                if self.heartbeat != nil {
                    map["Heartbeat"] = self.heartbeat!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.jobId != nil {
                    map["JobId"] = self.jobId!
                }
                if self.mobile != nil {
                    map["Mobile"] = self.mobile!
                }
                if self.outboundScenario != nil {
                    map["OutboundScenario"] = self.outboundScenario!
                }
                if self.reserved != nil {
                    map["Reserved"] = self.reserved!
                }
                if self.signedSkillGroupIdList != nil {
                    map["SignedSkillGroupIdList"] = self.signedSkillGroupIdList!
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                if self.userState != nil {
                    map["UserState"] = self.userState!
                }
                if self.workMode != nil {
                    map["WorkMode"] = self.workMode!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BreakCode") {
                    self.breakCode = dict["BreakCode"] as! String
                }
                if dict.keys.contains("DeviceId") {
                    self.deviceId = dict["DeviceId"] as! String
                }
                if dict.keys.contains("Extension") {
                    self.extension_ = dict["Extension"] as! String
                }
                if dict.keys.contains("Heartbeat") {
                    self.heartbeat = dict["Heartbeat"] as! Int64
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("JobId") {
                    self.jobId = dict["JobId"] as! String
                }
                if dict.keys.contains("Mobile") {
                    self.mobile = dict["Mobile"] as! String
                }
                if dict.keys.contains("OutboundScenario") {
                    self.outboundScenario = dict["OutboundScenario"] as! Bool
                }
                if dict.keys.contains("Reserved") {
                    self.reserved = dict["Reserved"] as! Int64
                }
                if dict.keys.contains("SignedSkillGroupIdList") {
                    self.signedSkillGroupIdList = dict["SignedSkillGroupIdList"] as! [String]
                }
                if dict.keys.contains("UserId") {
                    self.userId = dict["UserId"] as! String
                }
                if dict.keys.contains("UserState") {
                    self.userState = dict["UserState"] as! String
                }
                if dict.keys.contains("WorkMode") {
                    self.workMode = dict["WorkMode"] as! String
                }
            }
        }
        public var callContext: MonitorCallResponseBody.Data.CallContext?

        public var userContext: MonitorCallResponseBody.Data.UserContext?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.callContext?.validate()
            try self.userContext?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.callContext != nil {
                map["CallContext"] = self.callContext?.toMap()
            }
            if self.userContext != nil {
                map["UserContext"] = self.userContext?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CallContext") {
                var model = MonitorCallResponseBody.Data.CallContext()
                model.fromMap(dict["CallContext"] as! [String: Any])
                self.callContext = model
            }
            if dict.keys.contains("UserContext") {
                var model = MonitorCallResponseBody.Data.UserContext()
                model.fromMap(dict["UserContext"] as! [String: Any])
                self.userContext = model
            }
        }
    }
    public var code: String?

    public var data: MonitorCallResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var params: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.params != nil {
            map["Params"] = self.params!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = MonitorCallResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Params") {
            self.params = dict["Params"] as! [String]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class MonitorCallResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: MonitorCallResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = MonitorCallResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class MuteCallRequest : Tea.TeaModel {
    public var channelId: String?

    public var deviceId: String?

    public var instanceId: String?

    public var jobId: String?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.channelId != nil {
            map["ChannelId"] = self.channelId!
        }
        if self.deviceId != nil {
            map["DeviceId"] = self.deviceId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ChannelId") {
            self.channelId = dict["ChannelId"] as! String
        }
        if dict.keys.contains("DeviceId") {
            self.deviceId = dict["DeviceId"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("UserId") {
            self.userId = dict["UserId"] as! String
        }
    }
}

public class MuteCallResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class CallContext : Tea.TeaModel {
            public class ChannelContexts : Tea.TeaModel {
                public var callType: String?

                public var channelFlags: String?

                public var channelId: String?

                public var channelState: String?

                public var destination: String?

                public var index: Int32?

                public var jobId: String?

                public var originator: String?

                public var releaseInitiator: String?

                public var releaseReason: String?

                public var skillGroupId: String?

                public var timestamp: Int64?

                public var userExtension: String?

                public var userId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.callType != nil {
                        map["CallType"] = self.callType!
                    }
                    if self.channelFlags != nil {
                        map["ChannelFlags"] = self.channelFlags!
                    }
                    if self.channelId != nil {
                        map["ChannelId"] = self.channelId!
                    }
                    if self.channelState != nil {
                        map["ChannelState"] = self.channelState!
                    }
                    if self.destination != nil {
                        map["Destination"] = self.destination!
                    }
                    if self.index != nil {
                        map["Index"] = self.index!
                    }
                    if self.jobId != nil {
                        map["JobId"] = self.jobId!
                    }
                    if self.originator != nil {
                        map["Originator"] = self.originator!
                    }
                    if self.releaseInitiator != nil {
                        map["ReleaseInitiator"] = self.releaseInitiator!
                    }
                    if self.releaseReason != nil {
                        map["ReleaseReason"] = self.releaseReason!
                    }
                    if self.skillGroupId != nil {
                        map["SkillGroupId"] = self.skillGroupId!
                    }
                    if self.timestamp != nil {
                        map["Timestamp"] = self.timestamp!
                    }
                    if self.userExtension != nil {
                        map["UserExtension"] = self.userExtension!
                    }
                    if self.userId != nil {
                        map["UserId"] = self.userId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("CallType") {
                        self.callType = dict["CallType"] as! String
                    }
                    if dict.keys.contains("ChannelFlags") {
                        self.channelFlags = dict["ChannelFlags"] as! String
                    }
                    if dict.keys.contains("ChannelId") {
                        self.channelId = dict["ChannelId"] as! String
                    }
                    if dict.keys.contains("ChannelState") {
                        self.channelState = dict["ChannelState"] as! String
                    }
                    if dict.keys.contains("Destination") {
                        self.destination = dict["Destination"] as! String
                    }
                    if dict.keys.contains("Index") {
                        self.index = dict["Index"] as! Int32
                    }
                    if dict.keys.contains("JobId") {
                        self.jobId = dict["JobId"] as! String
                    }
                    if dict.keys.contains("Originator") {
                        self.originator = dict["Originator"] as! String
                    }
                    if dict.keys.contains("ReleaseInitiator") {
                        self.releaseInitiator = dict["ReleaseInitiator"] as! String
                    }
                    if dict.keys.contains("ReleaseReason") {
                        self.releaseReason = dict["ReleaseReason"] as! String
                    }
                    if dict.keys.contains("SkillGroupId") {
                        self.skillGroupId = dict["SkillGroupId"] as! String
                    }
                    if dict.keys.contains("Timestamp") {
                        self.timestamp = dict["Timestamp"] as! Int64
                    }
                    if dict.keys.contains("UserExtension") {
                        self.userExtension = dict["UserExtension"] as! String
                    }
                    if dict.keys.contains("UserId") {
                        self.userId = dict["UserId"] as! String
                    }
                }
            }
            public var callType: String?

            public var channelContexts: [MuteCallResponseBody.Data.CallContext.ChannelContexts]?

            public var instanceId: String?

            public var jobId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.callType != nil {
                    map["CallType"] = self.callType!
                }
                if self.channelContexts != nil {
                    var tmp : [Any] = []
                    for k in self.channelContexts! {
                        tmp.append(k.toMap())
                    }
                    map["ChannelContexts"] = tmp
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.jobId != nil {
                    map["JobId"] = self.jobId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CallType") {
                    self.callType = dict["CallType"] as! String
                }
                if dict.keys.contains("ChannelContexts") {
                    var tmp : [MuteCallResponseBody.Data.CallContext.ChannelContexts] = []
                    for v in dict["ChannelContexts"] as! [Any] {
                        var model = MuteCallResponseBody.Data.CallContext.ChannelContexts()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.channelContexts = tmp
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("JobId") {
                    self.jobId = dict["JobId"] as! String
                }
            }
        }
        public class UserContext : Tea.TeaModel {
            public var breakCode: String?

            public var deviceId: String?

            public var extension_: String?

            public var heartbeat: Int64?

            public var instanceId: String?

            public var jobId: String?

            public var mobile: String?

            public var outboundScenario: Bool?

            public var reserved: Int64?

            public var signedSkillGroupIdList: [String]?

            public var userId: String?

            public var userState: String?

            public var workMode: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.breakCode != nil {
                    map["BreakCode"] = self.breakCode!
                }
                if self.deviceId != nil {
                    map["DeviceId"] = self.deviceId!
                }
                if self.extension_ != nil {
                    map["Extension"] = self.extension_!
                }
                if self.heartbeat != nil {
                    map["Heartbeat"] = self.heartbeat!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.jobId != nil {
                    map["JobId"] = self.jobId!
                }
                if self.mobile != nil {
                    map["Mobile"] = self.mobile!
                }
                if self.outboundScenario != nil {
                    map["OutboundScenario"] = self.outboundScenario!
                }
                if self.reserved != nil {
                    map["Reserved"] = self.reserved!
                }
                if self.signedSkillGroupIdList != nil {
                    map["SignedSkillGroupIdList"] = self.signedSkillGroupIdList!
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                if self.userState != nil {
                    map["UserState"] = self.userState!
                }
                if self.workMode != nil {
                    map["WorkMode"] = self.workMode!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BreakCode") {
                    self.breakCode = dict["BreakCode"] as! String
                }
                if dict.keys.contains("DeviceId") {
                    self.deviceId = dict["DeviceId"] as! String
                }
                if dict.keys.contains("Extension") {
                    self.extension_ = dict["Extension"] as! String
                }
                if dict.keys.contains("Heartbeat") {
                    self.heartbeat = dict["Heartbeat"] as! Int64
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("JobId") {
                    self.jobId = dict["JobId"] as! String
                }
                if dict.keys.contains("Mobile") {
                    self.mobile = dict["Mobile"] as! String
                }
                if dict.keys.contains("OutboundScenario") {
                    self.outboundScenario = dict["OutboundScenario"] as! Bool
                }
                if dict.keys.contains("Reserved") {
                    self.reserved = dict["Reserved"] as! Int64
                }
                if dict.keys.contains("SignedSkillGroupIdList") {
                    self.signedSkillGroupIdList = dict["SignedSkillGroupIdList"] as! [String]
                }
                if dict.keys.contains("UserId") {
                    self.userId = dict["UserId"] as! String
                }
                if dict.keys.contains("UserState") {
                    self.userState = dict["UserState"] as! String
                }
                if dict.keys.contains("WorkMode") {
                    self.workMode = dict["WorkMode"] as! String
                }
            }
        }
        public var callContext: MuteCallResponseBody.Data.CallContext?

        public var userContext: MuteCallResponseBody.Data.UserContext?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.callContext?.validate()
            try self.userContext?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.callContext != nil {
                map["CallContext"] = self.callContext?.toMap()
            }
            if self.userContext != nil {
                map["UserContext"] = self.userContext?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CallContext") {
                var model = MuteCallResponseBody.Data.CallContext()
                model.fromMap(dict["CallContext"] as! [String: Any])
                self.callContext = model
            }
            if dict.keys.contains("UserContext") {
                var model = MuteCallResponseBody.Data.UserContext()
                model.fromMap(dict["UserContext"] as! [String: Any])
                self.userContext = model
            }
        }
    }
    public var code: String?

    public var data: MuteCallResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var params: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.params != nil {
            map["Params"] = self.params!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = MuteCallResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Params") {
            self.params = dict["Params"] as! [String]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class MuteCallResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: MuteCallResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = MuteCallResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class PauseCampaignRequest : Tea.TeaModel {
    public var campaignId: String?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.campaignId != nil {
            map["CampaignId"] = self.campaignId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CampaignId") {
            self.campaignId = dict["CampaignId"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
    }
}

public class PauseCampaignResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpStatusCode: String?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class PauseCampaignResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: PauseCampaignResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = PauseCampaignResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class PickOutboundNumbersRequest : Tea.TeaModel {
    public var calledNumber: String?

    public var count: Int32?

    public var instanceId: String?

    public var skillGroupIdList: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.calledNumber != nil {
            map["CalledNumber"] = self.calledNumber!
        }
        if self.count != nil {
            map["Count"] = self.count!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.skillGroupIdList != nil {
            map["SkillGroupIdList"] = self.skillGroupIdList!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CalledNumber") {
            self.calledNumber = dict["CalledNumber"] as! String
        }
        if dict.keys.contains("Count") {
            self.count = dict["Count"] as! Int32
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("SkillGroupIdList") {
            self.skillGroupIdList = dict["SkillGroupIdList"] as! String
        }
    }
}

public class PickOutboundNumbersResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Callee : Tea.TeaModel {
            public var city: String?

            public var number: String?

            public var province: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.city != nil {
                    map["City"] = self.city!
                }
                if self.number != nil {
                    map["Number"] = self.number!
                }
                if self.province != nil {
                    map["Province"] = self.province!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("City") {
                    self.city = dict["City"] as! String
                }
                if dict.keys.contains("Number") {
                    self.number = dict["Number"] as! String
                }
                if dict.keys.contains("Province") {
                    self.province = dict["Province"] as! String
                }
            }
        }
        public class Caller : Tea.TeaModel {
            public var city: String?

            public var number: String?

            public var province: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.city != nil {
                    map["City"] = self.city!
                }
                if self.number != nil {
                    map["Number"] = self.number!
                }
                if self.province != nil {
                    map["Province"] = self.province!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("City") {
                    self.city = dict["City"] as! String
                }
                if dict.keys.contains("Number") {
                    self.number = dict["Number"] as! String
                }
                if dict.keys.contains("Province") {
                    self.province = dict["Province"] as! String
                }
            }
        }
        public var callee: PickOutboundNumbersResponseBody.Data.Callee?

        public var caller: PickOutboundNumbersResponseBody.Data.Caller?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.callee?.validate()
            try self.caller?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.callee != nil {
                map["Callee"] = self.callee?.toMap()
            }
            if self.caller != nil {
                map["Caller"] = self.caller?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Callee") {
                var model = PickOutboundNumbersResponseBody.Data.Callee()
                model.fromMap(dict["Callee"] as! [String: Any])
                self.callee = model
            }
            if dict.keys.contains("Caller") {
                var model = PickOutboundNumbersResponseBody.Data.Caller()
                model.fromMap(dict["Caller"] as! [String: Any])
                self.caller = model
            }
        }
    }
    public var code: String?

    public var data: [PickOutboundNumbersResponseBody.Data]?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var tmp : [PickOutboundNumbersResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = PickOutboundNumbersResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class PickOutboundNumbersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: PickOutboundNumbersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = PickOutboundNumbersResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class PollUserStatusRequest : Tea.TeaModel {
    public var deviceId: String?

    public var instanceId: String?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.deviceId != nil {
            map["DeviceId"] = self.deviceId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DeviceId") {
            self.deviceId = dict["DeviceId"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("UserId") {
            self.userId = dict["UserId"] as! String
        }
    }
}

public class PollUserStatusResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class CallContext : Tea.TeaModel {
            public class ChannelContexts : Tea.TeaModel {
                public var callType: String?

                public var channelFlags: String?

                public var channelId: String?

                public var channelState: String?

                public var channelVariables: String?

                public var destination: String?

                public var index: Int32?

                public var jobId: String?

                public var originator: String?

                public var releaseInitiator: String?

                public var releaseReason: String?

                public var skillGroupId: String?

                public var timestamp: Int64?

                public var userExtension: String?

                public var userId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.callType != nil {
                        map["CallType"] = self.callType!
                    }
                    if self.channelFlags != nil {
                        map["ChannelFlags"] = self.channelFlags!
                    }
                    if self.channelId != nil {
                        map["ChannelId"] = self.channelId!
                    }
                    if self.channelState != nil {
                        map["ChannelState"] = self.channelState!
                    }
                    if self.channelVariables != nil {
                        map["ChannelVariables"] = self.channelVariables!
                    }
                    if self.destination != nil {
                        map["Destination"] = self.destination!
                    }
                    if self.index != nil {
                        map["Index"] = self.index!
                    }
                    if self.jobId != nil {
                        map["JobId"] = self.jobId!
                    }
                    if self.originator != nil {
                        map["Originator"] = self.originator!
                    }
                    if self.releaseInitiator != nil {
                        map["ReleaseInitiator"] = self.releaseInitiator!
                    }
                    if self.releaseReason != nil {
                        map["ReleaseReason"] = self.releaseReason!
                    }
                    if self.skillGroupId != nil {
                        map["SkillGroupId"] = self.skillGroupId!
                    }
                    if self.timestamp != nil {
                        map["Timestamp"] = self.timestamp!
                    }
                    if self.userExtension != nil {
                        map["UserExtension"] = self.userExtension!
                    }
                    if self.userId != nil {
                        map["UserId"] = self.userId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("CallType") {
                        self.callType = dict["CallType"] as! String
                    }
                    if dict.keys.contains("ChannelFlags") {
                        self.channelFlags = dict["ChannelFlags"] as! String
                    }
                    if dict.keys.contains("ChannelId") {
                        self.channelId = dict["ChannelId"] as! String
                    }
                    if dict.keys.contains("ChannelState") {
                        self.channelState = dict["ChannelState"] as! String
                    }
                    if dict.keys.contains("ChannelVariables") {
                        self.channelVariables = dict["ChannelVariables"] as! String
                    }
                    if dict.keys.contains("Destination") {
                        self.destination = dict["Destination"] as! String
                    }
                    if dict.keys.contains("Index") {
                        self.index = dict["Index"] as! Int32
                    }
                    if dict.keys.contains("JobId") {
                        self.jobId = dict["JobId"] as! String
                    }
                    if dict.keys.contains("Originator") {
                        self.originator = dict["Originator"] as! String
                    }
                    if dict.keys.contains("ReleaseInitiator") {
                        self.releaseInitiator = dict["ReleaseInitiator"] as! String
                    }
                    if dict.keys.contains("ReleaseReason") {
                        self.releaseReason = dict["ReleaseReason"] as! String
                    }
                    if dict.keys.contains("SkillGroupId") {
                        self.skillGroupId = dict["SkillGroupId"] as! String
                    }
                    if dict.keys.contains("Timestamp") {
                        self.timestamp = dict["Timestamp"] as! Int64
                    }
                    if dict.keys.contains("UserExtension") {
                        self.userExtension = dict["UserExtension"] as! String
                    }
                    if dict.keys.contains("UserId") {
                        self.userId = dict["UserId"] as! String
                    }
                }
            }
            public var callType: String?

            public var callVariables: String?

            public var channelContexts: [PollUserStatusResponseBody.Data.CallContext.ChannelContexts]?

            public var instanceId: String?

            public var jobId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.callType != nil {
                    map["CallType"] = self.callType!
                }
                if self.callVariables != nil {
                    map["CallVariables"] = self.callVariables!
                }
                if self.channelContexts != nil {
                    var tmp : [Any] = []
                    for k in self.channelContexts! {
                        tmp.append(k.toMap())
                    }
                    map["ChannelContexts"] = tmp
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.jobId != nil {
                    map["JobId"] = self.jobId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CallType") {
                    self.callType = dict["CallType"] as! String
                }
                if dict.keys.contains("CallVariables") {
                    self.callVariables = dict["CallVariables"] as! String
                }
                if dict.keys.contains("ChannelContexts") {
                    var tmp : [PollUserStatusResponseBody.Data.CallContext.ChannelContexts] = []
                    for v in dict["ChannelContexts"] as! [Any] {
                        var model = PollUserStatusResponseBody.Data.CallContext.ChannelContexts()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.channelContexts = tmp
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("JobId") {
                    self.jobId = dict["JobId"] as! String
                }
            }
        }
        public class ChatContexts : Tea.TeaModel {
            public class Members : Tea.TeaModel {
                public var index: Int32?

                public var releaseInitiator: String?

                public var releaseReason: String?

                public var skillGroupId: String?

                public var status: String?

                public var userId: String?

                public var userType: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.index != nil {
                        map["Index"] = self.index!
                    }
                    if self.releaseInitiator != nil {
                        map["ReleaseInitiator"] = self.releaseInitiator!
                    }
                    if self.releaseReason != nil {
                        map["ReleaseReason"] = self.releaseReason!
                    }
                    if self.skillGroupId != nil {
                        map["SkillGroupId"] = self.skillGroupId!
                    }
                    if self.status != nil {
                        map["Status"] = self.status!
                    }
                    if self.userId != nil {
                        map["UserId"] = self.userId!
                    }
                    if self.userType != nil {
                        map["UserType"] = self.userType!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Index") {
                        self.index = dict["Index"] as! Int32
                    }
                    if dict.keys.contains("ReleaseInitiator") {
                        self.releaseInitiator = dict["ReleaseInitiator"] as! String
                    }
                    if dict.keys.contains("ReleaseReason") {
                        self.releaseReason = dict["ReleaseReason"] as! String
                    }
                    if dict.keys.contains("SkillGroupId") {
                        self.skillGroupId = dict["SkillGroupId"] as! String
                    }
                    if dict.keys.contains("Status") {
                        self.status = dict["Status"] as! String
                    }
                    if dict.keys.contains("UserId") {
                        self.userId = dict["UserId"] as! String
                    }
                    if dict.keys.contains("UserType") {
                        self.userType = dict["UserType"] as! String
                    }
                }
            }
            public var callVariables: String?

            public var chatType: String?

            public var instanceId: String?

            public var jobId: String?

            public var members: [PollUserStatusResponseBody.Data.ChatContexts.Members]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.callVariables != nil {
                    map["CallVariables"] = self.callVariables!
                }
                if self.chatType != nil {
                    map["ChatType"] = self.chatType!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.jobId != nil {
                    map["JobId"] = self.jobId!
                }
                if self.members != nil {
                    var tmp : [Any] = []
                    for k in self.members! {
                        tmp.append(k.toMap())
                    }
                    map["Members"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CallVariables") {
                    self.callVariables = dict["CallVariables"] as! String
                }
                if dict.keys.contains("ChatType") {
                    self.chatType = dict["ChatType"] as! String
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("JobId") {
                    self.jobId = dict["JobId"] as! String
                }
                if dict.keys.contains("Members") {
                    var tmp : [PollUserStatusResponseBody.Data.ChatContexts.Members] = []
                    for v in dict["Members"] as! [Any] {
                        var model = PollUserStatusResponseBody.Data.ChatContexts.Members()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.members = tmp
                }
            }
        }
        public class UserContext : Tea.TeaModel {
            public class ParallelJobList : Tea.TeaModel {
                public var jobId: String?

                public var status: String?

                public var timestamp: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.jobId != nil {
                        map["JobId"] = self.jobId!
                    }
                    if self.status != nil {
                        map["Status"] = self.status!
                    }
                    if self.timestamp != nil {
                        map["Timestamp"] = self.timestamp!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("JobId") {
                        self.jobId = dict["JobId"] as! String
                    }
                    if dict.keys.contains("Status") {
                        self.status = dict["Status"] as! String
                    }
                    if dict.keys.contains("Timestamp") {
                        self.timestamp = dict["Timestamp"] as! Int64
                    }
                }
            }
            public var breakCode: String?

            public var deviceId: String?

            public var extension_: String?

            public var heartbeat: Int64?

            public var instanceId: String?

            public var jobId: String?

            public var mobile: String?

            public var outboundScenario: Bool?

            public var parallelJobList: [PollUserStatusResponseBody.Data.UserContext.ParallelJobList]?

            public var reserved: Int64?

            public var signedSkillGroupIdList: [String]?

            public var userId: String?

            public var userState: String?

            public var workMode: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.breakCode != nil {
                    map["BreakCode"] = self.breakCode!
                }
                if self.deviceId != nil {
                    map["DeviceId"] = self.deviceId!
                }
                if self.extension_ != nil {
                    map["Extension"] = self.extension_!
                }
                if self.heartbeat != nil {
                    map["Heartbeat"] = self.heartbeat!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.jobId != nil {
                    map["JobId"] = self.jobId!
                }
                if self.mobile != nil {
                    map["Mobile"] = self.mobile!
                }
                if self.outboundScenario != nil {
                    map["OutboundScenario"] = self.outboundScenario!
                }
                if self.parallelJobList != nil {
                    var tmp : [Any] = []
                    for k in self.parallelJobList! {
                        tmp.append(k.toMap())
                    }
                    map["ParallelJobList"] = tmp
                }
                if self.reserved != nil {
                    map["Reserved"] = self.reserved!
                }
                if self.signedSkillGroupIdList != nil {
                    map["SignedSkillGroupIdList"] = self.signedSkillGroupIdList!
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                if self.userState != nil {
                    map["UserState"] = self.userState!
                }
                if self.workMode != nil {
                    map["WorkMode"] = self.workMode!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BreakCode") {
                    self.breakCode = dict["BreakCode"] as! String
                }
                if dict.keys.contains("DeviceId") {
                    self.deviceId = dict["DeviceId"] as! String
                }
                if dict.keys.contains("Extension") {
                    self.extension_ = dict["Extension"] as! String
                }
                if dict.keys.contains("Heartbeat") {
                    self.heartbeat = dict["Heartbeat"] as! Int64
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("JobId") {
                    self.jobId = dict["JobId"] as! String
                }
                if dict.keys.contains("Mobile") {
                    self.mobile = dict["Mobile"] as! String
                }
                if dict.keys.contains("OutboundScenario") {
                    self.outboundScenario = dict["OutboundScenario"] as! Bool
                }
                if dict.keys.contains("ParallelJobList") {
                    var tmp : [PollUserStatusResponseBody.Data.UserContext.ParallelJobList] = []
                    for v in dict["ParallelJobList"] as! [Any] {
                        var model = PollUserStatusResponseBody.Data.UserContext.ParallelJobList()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.parallelJobList = tmp
                }
                if dict.keys.contains("Reserved") {
                    self.reserved = dict["Reserved"] as! Int64
                }
                if dict.keys.contains("SignedSkillGroupIdList") {
                    self.signedSkillGroupIdList = dict["SignedSkillGroupIdList"] as! [String]
                }
                if dict.keys.contains("UserId") {
                    self.userId = dict["UserId"] as! String
                }
                if dict.keys.contains("UserState") {
                    self.userState = dict["UserState"] as! String
                }
                if dict.keys.contains("WorkMode") {
                    self.workMode = dict["WorkMode"] as! String
                }
            }
        }
        public var callContext: PollUserStatusResponseBody.Data.CallContext?

        public var chatContexts: [PollUserStatusResponseBody.Data.ChatContexts]?

        public var contextId: Int64?

        public var userContext: PollUserStatusResponseBody.Data.UserContext?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.callContext?.validate()
            try self.userContext?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.callContext != nil {
                map["CallContext"] = self.callContext?.toMap()
            }
            if self.chatContexts != nil {
                var tmp : [Any] = []
                for k in self.chatContexts! {
                    tmp.append(k.toMap())
                }
                map["ChatContexts"] = tmp
            }
            if self.contextId != nil {
                map["ContextId"] = self.contextId!
            }
            if self.userContext != nil {
                map["UserContext"] = self.userContext?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CallContext") {
                var model = PollUserStatusResponseBody.Data.CallContext()
                model.fromMap(dict["CallContext"] as! [String: Any])
                self.callContext = model
            }
            if dict.keys.contains("ChatContexts") {
                var tmp : [PollUserStatusResponseBody.Data.ChatContexts] = []
                for v in dict["ChatContexts"] as! [Any] {
                    var model = PollUserStatusResponseBody.Data.ChatContexts()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.chatContexts = tmp
            }
            if dict.keys.contains("ContextId") {
                self.contextId = dict["ContextId"] as! Int64
            }
            if dict.keys.contains("UserContext") {
                var model = PollUserStatusResponseBody.Data.UserContext()
                model.fromMap(dict["UserContext"] as! [String: Any])
                self.userContext = model
            }
        }
    }
    public var code: String?

    public var data: PollUserStatusResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var params: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.params != nil {
            map["Params"] = self.params!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = PollUserStatusResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Params") {
            self.params = dict["Params"] as! [String]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class PollUserStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: PollUserStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = PollUserStatusResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ProcessAliMeCallbackOfStagingRequest : Tea.TeaModel {
    public var data: String?

    public var token: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.token != nil {
            map["Token"] = self.token!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("Token") {
            self.token = dict["Token"] as! String
        }
    }
}

public class ProcessAliMeCallbackOfStagingResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var result: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.result != nil {
                map["Result"] = self.result!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Result") {
                self.result = dict["Result"] as! String
            }
        }
    }
    public var code: String?

    public var data: ProcessAliMeCallbackOfStagingResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = ProcessAliMeCallbackOfStagingResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ProcessAliMeCallbackOfStagingResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ProcessAliMeCallbackOfStagingResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ProcessAliMeCallbackOfStagingResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class PublishContactFlowRequest : Tea.TeaModel {
    public var contactFlowId: String?

    public var draftId: String?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.contactFlowId != nil {
            map["ContactFlowId"] = self.contactFlowId!
        }
        if self.draftId != nil {
            map["DraftId"] = self.draftId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ContactFlowId") {
            self.contactFlowId = dict["ContactFlowId"] as! String
        }
        if dict.keys.contains("DraftId") {
            self.draftId = dict["DraftId"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
    }
}

public class PublishContactFlowResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class PublishContactFlowResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: PublishContactFlowResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = PublishContactFlowResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ReadyForServiceRequest : Tea.TeaModel {
    public var deviceId: String?

    public var instanceId: String?

    public var outboundScenario: Bool?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.deviceId != nil {
            map["DeviceId"] = self.deviceId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.outboundScenario != nil {
            map["OutboundScenario"] = self.outboundScenario!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DeviceId") {
            self.deviceId = dict["DeviceId"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("OutboundScenario") {
            self.outboundScenario = dict["OutboundScenario"] as! Bool
        }
        if dict.keys.contains("UserId") {
            self.userId = dict["UserId"] as! String
        }
    }
}

public class ReadyForServiceResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var breakCode: String?

        public var deviceId: String?

        public var extension_: String?

        public var instanceId: String?

        public var jobId: String?

        public var outboundScenario: Bool?

        public var signedSkillGroupIdList: [String]?

        public var userId: String?

        public var userState: String?

        public var workMode: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.breakCode != nil {
                map["BreakCode"] = self.breakCode!
            }
            if self.deviceId != nil {
                map["DeviceId"] = self.deviceId!
            }
            if self.extension_ != nil {
                map["Extension"] = self.extension_!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            if self.outboundScenario != nil {
                map["OutboundScenario"] = self.outboundScenario!
            }
            if self.signedSkillGroupIdList != nil {
                map["SignedSkillGroupIdList"] = self.signedSkillGroupIdList!
            }
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            if self.userState != nil {
                map["UserState"] = self.userState!
            }
            if self.workMode != nil {
                map["WorkMode"] = self.workMode!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BreakCode") {
                self.breakCode = dict["BreakCode"] as! String
            }
            if dict.keys.contains("DeviceId") {
                self.deviceId = dict["DeviceId"] as! String
            }
            if dict.keys.contains("Extension") {
                self.extension_ = dict["Extension"] as! String
            }
            if dict.keys.contains("InstanceId") {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("JobId") {
                self.jobId = dict["JobId"] as! String
            }
            if dict.keys.contains("OutboundScenario") {
                self.outboundScenario = dict["OutboundScenario"] as! Bool
            }
            if dict.keys.contains("SignedSkillGroupIdList") {
                self.signedSkillGroupIdList = dict["SignedSkillGroupIdList"] as! [String]
            }
            if dict.keys.contains("UserId") {
                self.userId = dict["UserId"] as! String
            }
            if dict.keys.contains("UserState") {
                self.userState = dict["UserState"] as! String
            }
            if dict.keys.contains("WorkMode") {
                self.workMode = dict["WorkMode"] as! String
            }
        }
    }
    public var code: String?

    public var data: ReadyForServiceResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var params: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.params != nil {
            map["Params"] = self.params!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = ReadyForServiceResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Params") {
            self.params = dict["Params"] as! [String]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ReadyForServiceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ReadyForServiceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ReadyForServiceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RedialCallRequest : Tea.TeaModel {
    public var callee: String?

    public var caller: String?

    public var deviceId: String?

    public var instanceId: String?

    public var jobId: String?

    public var tags: String?

    public var timeoutSeconds: Int32?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.callee != nil {
            map["Callee"] = self.callee!
        }
        if self.caller != nil {
            map["Caller"] = self.caller!
        }
        if self.deviceId != nil {
            map["DeviceId"] = self.deviceId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.tags != nil {
            map["Tags"] = self.tags!
        }
        if self.timeoutSeconds != nil {
            map["TimeoutSeconds"] = self.timeoutSeconds!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Callee") {
            self.callee = dict["Callee"] as! String
        }
        if dict.keys.contains("Caller") {
            self.caller = dict["Caller"] as! String
        }
        if dict.keys.contains("DeviceId") {
            self.deviceId = dict["DeviceId"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("Tags") {
            self.tags = dict["Tags"] as! String
        }
        if dict.keys.contains("TimeoutSeconds") {
            self.timeoutSeconds = dict["TimeoutSeconds"] as! Int32
        }
        if dict.keys.contains("UserId") {
            self.userId = dict["UserId"] as! String
        }
    }
}

public class RedialCallResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class CallContext : Tea.TeaModel {
            public class ChannelContexts : Tea.TeaModel {
                public var callType: String?

                public var channelFlags: String?

                public var channelId: String?

                public var channelState: String?

                public var destination: String?

                public var jobId: String?

                public var originator: String?

                public var releaseInitiator: String?

                public var releaseReason: String?

                public var timestamp: Int64?

                public var userExtension: String?

                public var userId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.callType != nil {
                        map["CallType"] = self.callType!
                    }
                    if self.channelFlags != nil {
                        map["ChannelFlags"] = self.channelFlags!
                    }
                    if self.channelId != nil {
                        map["ChannelId"] = self.channelId!
                    }
                    if self.channelState != nil {
                        map["ChannelState"] = self.channelState!
                    }
                    if self.destination != nil {
                        map["Destination"] = self.destination!
                    }
                    if self.jobId != nil {
                        map["JobId"] = self.jobId!
                    }
                    if self.originator != nil {
                        map["Originator"] = self.originator!
                    }
                    if self.releaseInitiator != nil {
                        map["ReleaseInitiator"] = self.releaseInitiator!
                    }
                    if self.releaseReason != nil {
                        map["ReleaseReason"] = self.releaseReason!
                    }
                    if self.timestamp != nil {
                        map["Timestamp"] = self.timestamp!
                    }
                    if self.userExtension != nil {
                        map["UserExtension"] = self.userExtension!
                    }
                    if self.userId != nil {
                        map["UserId"] = self.userId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("CallType") {
                        self.callType = dict["CallType"] as! String
                    }
                    if dict.keys.contains("ChannelFlags") {
                        self.channelFlags = dict["ChannelFlags"] as! String
                    }
                    if dict.keys.contains("ChannelId") {
                        self.channelId = dict["ChannelId"] as! String
                    }
                    if dict.keys.contains("ChannelState") {
                        self.channelState = dict["ChannelState"] as! String
                    }
                    if dict.keys.contains("Destination") {
                        self.destination = dict["Destination"] as! String
                    }
                    if dict.keys.contains("JobId") {
                        self.jobId = dict["JobId"] as! String
                    }
                    if dict.keys.contains("Originator") {
                        self.originator = dict["Originator"] as! String
                    }
                    if dict.keys.contains("ReleaseInitiator") {
                        self.releaseInitiator = dict["ReleaseInitiator"] as! String
                    }
                    if dict.keys.contains("ReleaseReason") {
                        self.releaseReason = dict["ReleaseReason"] as! String
                    }
                    if dict.keys.contains("Timestamp") {
                        self.timestamp = dict["Timestamp"] as! Int64
                    }
                    if dict.keys.contains("UserExtension") {
                        self.userExtension = dict["UserExtension"] as! String
                    }
                    if dict.keys.contains("UserId") {
                        self.userId = dict["UserId"] as! String
                    }
                }
            }
            public var callType: String?

            public var channelContexts: [RedialCallResponseBody.Data.CallContext.ChannelContexts]?

            public var instanceId: String?

            public var jobId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.callType != nil {
                    map["CallType"] = self.callType!
                }
                if self.channelContexts != nil {
                    var tmp : [Any] = []
                    for k in self.channelContexts! {
                        tmp.append(k.toMap())
                    }
                    map["ChannelContexts"] = tmp
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.jobId != nil {
                    map["JobId"] = self.jobId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CallType") {
                    self.callType = dict["CallType"] as! String
                }
                if dict.keys.contains("ChannelContexts") {
                    var tmp : [RedialCallResponseBody.Data.CallContext.ChannelContexts] = []
                    for v in dict["ChannelContexts"] as! [Any] {
                        var model = RedialCallResponseBody.Data.CallContext.ChannelContexts()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.channelContexts = tmp
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("JobId") {
                    self.jobId = dict["JobId"] as! String
                }
            }
        }
        public class UserContext : Tea.TeaModel {
            public var breakCode: String?

            public var deviceId: String?

            public var extension_: String?

            public var instanceId: String?

            public var jobId: String?

            public var outboundScenario: Bool?

            public var signedSkillGroupIdList: [String]?

            public var userId: String?

            public var userState: String?

            public var workMode: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.breakCode != nil {
                    map["BreakCode"] = self.breakCode!
                }
                if self.deviceId != nil {
                    map["DeviceId"] = self.deviceId!
                }
                if self.extension_ != nil {
                    map["Extension"] = self.extension_!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.jobId != nil {
                    map["JobId"] = self.jobId!
                }
                if self.outboundScenario != nil {
                    map["OutboundScenario"] = self.outboundScenario!
                }
                if self.signedSkillGroupIdList != nil {
                    map["SignedSkillGroupIdList"] = self.signedSkillGroupIdList!
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                if self.userState != nil {
                    map["UserState"] = self.userState!
                }
                if self.workMode != nil {
                    map["WorkMode"] = self.workMode!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BreakCode") {
                    self.breakCode = dict["BreakCode"] as! String
                }
                if dict.keys.contains("DeviceId") {
                    self.deviceId = dict["DeviceId"] as! String
                }
                if dict.keys.contains("Extension") {
                    self.extension_ = dict["Extension"] as! String
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("JobId") {
                    self.jobId = dict["JobId"] as! String
                }
                if dict.keys.contains("OutboundScenario") {
                    self.outboundScenario = dict["OutboundScenario"] as! Bool
                }
                if dict.keys.contains("SignedSkillGroupIdList") {
                    self.signedSkillGroupIdList = dict["SignedSkillGroupIdList"] as! [String]
                }
                if dict.keys.contains("UserId") {
                    self.userId = dict["UserId"] as! String
                }
                if dict.keys.contains("UserState") {
                    self.userState = dict["UserState"] as! String
                }
                if dict.keys.contains("WorkMode") {
                    self.workMode = dict["WorkMode"] as! String
                }
            }
        }
        public var callContext: RedialCallResponseBody.Data.CallContext?

        public var contextId: Int64?

        public var userContext: RedialCallResponseBody.Data.UserContext?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.callContext?.validate()
            try self.userContext?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.callContext != nil {
                map["CallContext"] = self.callContext?.toMap()
            }
            if self.contextId != nil {
                map["ContextId"] = self.contextId!
            }
            if self.userContext != nil {
                map["UserContext"] = self.userContext?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CallContext") {
                var model = RedialCallResponseBody.Data.CallContext()
                model.fromMap(dict["CallContext"] as! [String: Any])
                self.callContext = model
            }
            if dict.keys.contains("ContextId") {
                self.contextId = dict["ContextId"] as! Int64
            }
            if dict.keys.contains("UserContext") {
                var model = RedialCallResponseBody.Data.UserContext()
                model.fromMap(dict["UserContext"] as! [String: Any])
                self.userContext = model
            }
        }
    }
    public var code: String?

    public var data: RedialCallResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var params: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.params != nil {
            map["Params"] = self.params!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = RedialCallResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Params") {
            self.params = dict["Params"] as! [String]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class RedialCallResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RedialCallResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RedialCallResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RegisterDeviceRequest : Tea.TeaModel {
    public var deviceId: String?

    public var instanceId: String?

    public var password: String?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.deviceId != nil {
            map["DeviceId"] = self.deviceId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.password != nil {
            map["Password"] = self.password!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DeviceId") {
            self.deviceId = dict["DeviceId"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Password") {
            self.password = dict["Password"] as! String
        }
        if dict.keys.contains("UserId") {
            self.userId = dict["UserId"] as! String
        }
    }
}

public class RegisterDeviceResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var params: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.params != nil {
            map["Params"] = self.params!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Params") {
            self.params = dict["Params"] as! [String]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class RegisterDeviceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RegisterDeviceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RegisterDeviceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RegisterDevicesRequest : Tea.TeaModel {
    public var deviceId: String?

    public var instanceId: String?

    public var password: String?

    public var userIdListJson: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.deviceId != nil {
            map["DeviceId"] = self.deviceId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.password != nil {
            map["Password"] = self.password!
        }
        if self.userIdListJson != nil {
            map["UserIdListJson"] = self.userIdListJson!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DeviceId") {
            self.deviceId = dict["DeviceId"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Password") {
            self.password = dict["Password"] as! String
        }
        if dict.keys.contains("UserIdListJson") {
            self.userIdListJson = dict["UserIdListJson"] as! String
        }
    }
}

public class RegisterDevicesResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var params: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.params != nil {
            map["Params"] = self.params!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Params") {
            self.params = dict["Params"] as! [String]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class RegisterDevicesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RegisterDevicesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RegisterDevicesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RejectChatRequest : Tea.TeaModel {
    public var instanceId: String?

    public var jobId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
    }
}

public class RejectChatResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class RejectChatResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RejectChatResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RejectChatResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RejectTicketRequest : Tea.TeaModel {
    public var comment: String?

    public var instanceId: String?

    public var ticketId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.comment != nil {
            map["Comment"] = self.comment!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.ticketId != nil {
            map["TicketId"] = self.ticketId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Comment") {
            self.comment = dict["Comment"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("TicketId") {
            self.ticketId = dict["TicketId"] as! String
        }
    }
}

public class RejectTicketResponseBody : Tea.TeaModel {
    public var code: String?

    public var data: Any?

    public var httpStatusCode: Int32?

    public var message: String?

    public var params: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.params != nil {
            map["Params"] = self.params!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Any
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Params") {
            self.params = dict["Params"] as! [String]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class RejectTicketResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RejectTicketResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RejectTicketResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ReleaseCallRequest : Tea.TeaModel {
    public var channelId: String?

    public var deviceId: String?

    public var instanceId: String?

    public var jobId: String?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.channelId != nil {
            map["ChannelId"] = self.channelId!
        }
        if self.deviceId != nil {
            map["DeviceId"] = self.deviceId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ChannelId") {
            self.channelId = dict["ChannelId"] as! String
        }
        if dict.keys.contains("DeviceId") {
            self.deviceId = dict["DeviceId"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("UserId") {
            self.userId = dict["UserId"] as! String
        }
    }
}

public class ReleaseCallResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class CallContext : Tea.TeaModel {
            public class ChannelContexts : Tea.TeaModel {
                public var callType: String?

                public var channelId: String?

                public var channelState: String?

                public var channelVariables: String?

                public var destination: String?

                public var jobId: String?

                public var originator: String?

                public var releaseInitiator: String?

                public var releaseReason: String?

                public var timestamp: Int64?

                public var userExtension: String?

                public var userId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.callType != nil {
                        map["CallType"] = self.callType!
                    }
                    if self.channelId != nil {
                        map["ChannelId"] = self.channelId!
                    }
                    if self.channelState != nil {
                        map["ChannelState"] = self.channelState!
                    }
                    if self.channelVariables != nil {
                        map["ChannelVariables"] = self.channelVariables!
                    }
                    if self.destination != nil {
                        map["Destination"] = self.destination!
                    }
                    if self.jobId != nil {
                        map["JobId"] = self.jobId!
                    }
                    if self.originator != nil {
                        map["Originator"] = self.originator!
                    }
                    if self.releaseInitiator != nil {
                        map["ReleaseInitiator"] = self.releaseInitiator!
                    }
                    if self.releaseReason != nil {
                        map["ReleaseReason"] = self.releaseReason!
                    }
                    if self.timestamp != nil {
                        map["Timestamp"] = self.timestamp!
                    }
                    if self.userExtension != nil {
                        map["UserExtension"] = self.userExtension!
                    }
                    if self.userId != nil {
                        map["UserId"] = self.userId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("CallType") {
                        self.callType = dict["CallType"] as! String
                    }
                    if dict.keys.contains("ChannelId") {
                        self.channelId = dict["ChannelId"] as! String
                    }
                    if dict.keys.contains("ChannelState") {
                        self.channelState = dict["ChannelState"] as! String
                    }
                    if dict.keys.contains("ChannelVariables") {
                        self.channelVariables = dict["ChannelVariables"] as! String
                    }
                    if dict.keys.contains("Destination") {
                        self.destination = dict["Destination"] as! String
                    }
                    if dict.keys.contains("JobId") {
                        self.jobId = dict["JobId"] as! String
                    }
                    if dict.keys.contains("Originator") {
                        self.originator = dict["Originator"] as! String
                    }
                    if dict.keys.contains("ReleaseInitiator") {
                        self.releaseInitiator = dict["ReleaseInitiator"] as! String
                    }
                    if dict.keys.contains("ReleaseReason") {
                        self.releaseReason = dict["ReleaseReason"] as! String
                    }
                    if dict.keys.contains("Timestamp") {
                        self.timestamp = dict["Timestamp"] as! Int64
                    }
                    if dict.keys.contains("UserExtension") {
                        self.userExtension = dict["UserExtension"] as! String
                    }
                    if dict.keys.contains("UserId") {
                        self.userId = dict["UserId"] as! String
                    }
                }
            }
            public var channelContexts: [ReleaseCallResponseBody.Data.CallContext.ChannelContexts]?

            public var instanceId: String?

            public var jobId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.channelContexts != nil {
                    var tmp : [Any] = []
                    for k in self.channelContexts! {
                        tmp.append(k.toMap())
                    }
                    map["ChannelContexts"] = tmp
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.jobId != nil {
                    map["JobId"] = self.jobId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ChannelContexts") {
                    var tmp : [ReleaseCallResponseBody.Data.CallContext.ChannelContexts] = []
                    for v in dict["ChannelContexts"] as! [Any] {
                        var model = ReleaseCallResponseBody.Data.CallContext.ChannelContexts()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.channelContexts = tmp
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("JobId") {
                    self.jobId = dict["JobId"] as! String
                }
            }
        }
        public class UserContext : Tea.TeaModel {
            public var breakCode: String?

            public var deviceId: String?

            public var extension_: String?

            public var instanceId: String?

            public var jobId: String?

            public var outboundScenario: Bool?

            public var signedSkillGroupIdList: [String]?

            public var userId: String?

            public var userState: String?

            public var workMode: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.breakCode != nil {
                    map["BreakCode"] = self.breakCode!
                }
                if self.deviceId != nil {
                    map["DeviceId"] = self.deviceId!
                }
                if self.extension_ != nil {
                    map["Extension"] = self.extension_!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.jobId != nil {
                    map["JobId"] = self.jobId!
                }
                if self.outboundScenario != nil {
                    map["OutboundScenario"] = self.outboundScenario!
                }
                if self.signedSkillGroupIdList != nil {
                    map["SignedSkillGroupIdList"] = self.signedSkillGroupIdList!
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                if self.userState != nil {
                    map["UserState"] = self.userState!
                }
                if self.workMode != nil {
                    map["WorkMode"] = self.workMode!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BreakCode") {
                    self.breakCode = dict["BreakCode"] as! String
                }
                if dict.keys.contains("DeviceId") {
                    self.deviceId = dict["DeviceId"] as! String
                }
                if dict.keys.contains("Extension") {
                    self.extension_ = dict["Extension"] as! String
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("JobId") {
                    self.jobId = dict["JobId"] as! String
                }
                if dict.keys.contains("OutboundScenario") {
                    self.outboundScenario = dict["OutboundScenario"] as! Bool
                }
                if dict.keys.contains("SignedSkillGroupIdList") {
                    self.signedSkillGroupIdList = dict["SignedSkillGroupIdList"] as! [String]
                }
                if dict.keys.contains("UserId") {
                    self.userId = dict["UserId"] as! String
                }
                if dict.keys.contains("UserState") {
                    self.userState = dict["UserState"] as! String
                }
                if dict.keys.contains("WorkMode") {
                    self.workMode = dict["WorkMode"] as! String
                }
            }
        }
        public var callContext: ReleaseCallResponseBody.Data.CallContext?

        public var contextId: Int64?

        public var userContext: ReleaseCallResponseBody.Data.UserContext?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.callContext?.validate()
            try self.userContext?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.callContext != nil {
                map["CallContext"] = self.callContext?.toMap()
            }
            if self.contextId != nil {
                map["ContextId"] = self.contextId!
            }
            if self.userContext != nil {
                map["UserContext"] = self.userContext?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CallContext") {
                var model = ReleaseCallResponseBody.Data.CallContext()
                model.fromMap(dict["CallContext"] as! [String: Any])
                self.callContext = model
            }
            if dict.keys.contains("ContextId") {
                self.contextId = dict["ContextId"] as! Int64
            }
            if dict.keys.contains("UserContext") {
                var model = ReleaseCallResponseBody.Data.UserContext()
                model.fromMap(dict["UserContext"] as! [String: Any])
                self.userContext = model
            }
        }
    }
    public var code: String?

    public var data: ReleaseCallResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var params: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.params != nil {
            map["Params"] = self.params!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = ReleaseCallResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Params") {
            self.params = dict["Params"] as! [String]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ReleaseCallResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ReleaseCallResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ReleaseCallResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ReleaseChatRequest : Tea.TeaModel {
    public var instanceId: String?

    public var jobId: String?

    public var token: String?

    public var userId: String?

    public var userType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.token != nil {
            map["Token"] = self.token!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        if self.userType != nil {
            map["UserType"] = self.userType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("Token") {
            self.token = dict["Token"] as! String
        }
        if dict.keys.contains("UserId") {
            self.userId = dict["UserId"] as! String
        }
        if dict.keys.contains("UserType") {
            self.userType = dict["UserType"] as! String
        }
    }
}

public class ReleaseChatResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ReleaseChatResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ReleaseChatResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ReleaseChatResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RemoveBlacklistCallTaggingRequest : Tea.TeaModel {
    public var instanceId: String?

    public var jobId: String?

    public var number: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.number != nil {
            map["Number"] = self.number!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("Number") {
            self.number = dict["Number"] as! String
        }
    }
}

public class RemoveBlacklistCallTaggingResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class RemoveBlacklistCallTaggingResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RemoveBlacklistCallTaggingResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RemoveBlacklistCallTaggingResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RemoveDoNotCallNumbersRequest : Tea.TeaModel {
    public var instanceId: String?

    public var numberList: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.numberList != nil {
            map["NumberList"] = self.numberList!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("NumberList") {
            self.numberList = dict["NumberList"] as! String
        }
    }
}

public class RemoveDoNotCallNumbersResponseBody : Tea.TeaModel {
    public var code: String?

    public var data: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var params: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.params != nil {
            map["Params"] = self.params!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Params") {
            self.params = dict["Params"] as! [String]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class RemoveDoNotCallNumbersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RemoveDoNotCallNumbersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RemoveDoNotCallNumbersResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RemovePersonalNumbersFromUserRequest : Tea.TeaModel {
    public var instanceId: String?

    public var numberList: String?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.numberList != nil {
            map["NumberList"] = self.numberList!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("NumberList") {
            self.numberList = dict["NumberList"] as! String
        }
        if dict.keys.contains("UserId") {
            self.userId = dict["UserId"] as! String
        }
    }
}

public class RemovePersonalNumbersFromUserResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class RemovePersonalNumbersFromUserResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RemovePersonalNumbersFromUserResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RemovePersonalNumbersFromUserResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RemovePhoneNumberFromSkillGroupsRequest : Tea.TeaModel {
    public var instanceId: String?

    public var number: String?

    public var skillGroupIdList: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.number != nil {
            map["Number"] = self.number!
        }
        if self.skillGroupIdList != nil {
            map["SkillGroupIdList"] = self.skillGroupIdList!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Number") {
            self.number = dict["Number"] as! String
        }
        if dict.keys.contains("SkillGroupIdList") {
            self.skillGroupIdList = dict["SkillGroupIdList"] as! String
        }
    }
}

public class RemovePhoneNumberFromSkillGroupsResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class RemovePhoneNumberFromSkillGroupsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RemovePhoneNumberFromSkillGroupsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RemovePhoneNumberFromSkillGroupsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RemovePhoneNumbersRequest : Tea.TeaModel {
    public var force: Bool?

    public var instanceId: String?

    public var numberList: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.force != nil {
            map["Force"] = self.force!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.numberList != nil {
            map["NumberList"] = self.numberList!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Force") {
            self.force = dict["Force"] as! Bool
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("NumberList") {
            self.numberList = dict["NumberList"] as! String
        }
    }
}

public class RemovePhoneNumbersResponseBody : Tea.TeaModel {
    public var code: String?

    public var data: [String]?

    public var httpStatusCode: Int32?

    public var message: String?

    public var params: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.params != nil {
            map["Params"] = self.params!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! [String]
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Params") {
            self.params = dict["Params"] as! [String]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class RemovePhoneNumbersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RemovePhoneNumbersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RemovePhoneNumbersResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RemovePhoneNumbersFromSkillGroupRequest : Tea.TeaModel {
    public var instanceId: String?

    public var numberList: String?

    public var skillGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.numberList != nil {
            map["NumberList"] = self.numberList!
        }
        if self.skillGroupId != nil {
            map["SkillGroupId"] = self.skillGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("NumberList") {
            self.numberList = dict["NumberList"] as! String
        }
        if dict.keys.contains("SkillGroupId") {
            self.skillGroupId = dict["SkillGroupId"] as! String
        }
    }
}

public class RemovePhoneNumbersFromSkillGroupResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class RemovePhoneNumbersFromSkillGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RemovePhoneNumbersFromSkillGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RemovePhoneNumbersFromSkillGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RemoveSkillGroupsFromUserRequest : Tea.TeaModel {
    public var instanceId: String?

    public var skillGroupIdList: String?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.skillGroupIdList != nil {
            map["SkillGroupIdList"] = self.skillGroupIdList!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("SkillGroupIdList") {
            self.skillGroupIdList = dict["SkillGroupIdList"] as! String
        }
        if dict.keys.contains("UserId") {
            self.userId = dict["UserId"] as! String
        }
    }
}

public class RemoveSkillGroupsFromUserResponseBody : Tea.TeaModel {
    public var code: String?

    public var data: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class RemoveSkillGroupsFromUserResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RemoveSkillGroupsFromUserResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RemoveSkillGroupsFromUserResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RemoveUsersRequest : Tea.TeaModel {
    public var filePath: String?

    public var force: Bool?

    public var instanceId: String?

    public var notificationEmail: String?

    public var userIdList: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.filePath != nil {
            map["FilePath"] = self.filePath!
        }
        if self.force != nil {
            map["Force"] = self.force!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.notificationEmail != nil {
            map["NotificationEmail"] = self.notificationEmail!
        }
        if self.userIdList != nil {
            map["UserIdList"] = self.userIdList!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FilePath") {
            self.filePath = dict["FilePath"] as! String
        }
        if dict.keys.contains("Force") {
            self.force = dict["Force"] as! Bool
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("NotificationEmail") {
            self.notificationEmail = dict["NotificationEmail"] as! String
        }
        if dict.keys.contains("UserIdList") {
            self.userIdList = dict["UserIdList"] as! String
        }
    }
}

public class RemoveUsersResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var params: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.params != nil {
            map["Params"] = self.params!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Params") {
            self.params = dict["Params"] as! [String]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class RemoveUsersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RemoveUsersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RemoveUsersResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RemoveUsersFromSkillGroupRequest : Tea.TeaModel {
    public var instanceId: String?

    public var skillGroupId: String?

    public var userIdList: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.skillGroupId != nil {
            map["SkillGroupId"] = self.skillGroupId!
        }
        if self.userIdList != nil {
            map["UserIdList"] = self.userIdList!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("SkillGroupId") {
            self.skillGroupId = dict["SkillGroupId"] as! String
        }
        if dict.keys.contains("UserIdList") {
            self.userIdList = dict["UserIdList"] as! String
        }
    }
}

public class RemoveUsersFromSkillGroupResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class RemoveUsersFromSkillGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RemoveUsersFromSkillGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RemoveUsersFromSkillGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ResetAgentStateRequest : Tea.TeaModel {
    public var deviceId: String?

    public var instanceId: String?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.deviceId != nil {
            map["DeviceId"] = self.deviceId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DeviceId") {
            self.deviceId = dict["DeviceId"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("UserId") {
            self.userId = dict["UserId"] as! String
        }
    }
}

public class ResetAgentStateResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var breakCode: String?

        public var deviceId: String?

        public var extension_: String?

        public var instanceId: String?

        public var jobId: String?

        public var outboundScenario: Bool?

        public var signedSkillGroupIdList: [String]?

        public var userId: String?

        public var userState: String?

        public var workMode: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.breakCode != nil {
                map["BreakCode"] = self.breakCode!
            }
            if self.deviceId != nil {
                map["DeviceId"] = self.deviceId!
            }
            if self.extension_ != nil {
                map["Extension"] = self.extension_!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            if self.outboundScenario != nil {
                map["OutboundScenario"] = self.outboundScenario!
            }
            if self.signedSkillGroupIdList != nil {
                map["SignedSkillGroupIdList"] = self.signedSkillGroupIdList!
            }
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            if self.userState != nil {
                map["UserState"] = self.userState!
            }
            if self.workMode != nil {
                map["WorkMode"] = self.workMode!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BreakCode") {
                self.breakCode = dict["BreakCode"] as! String
            }
            if dict.keys.contains("DeviceId") {
                self.deviceId = dict["DeviceId"] as! String
            }
            if dict.keys.contains("Extension") {
                self.extension_ = dict["Extension"] as! String
            }
            if dict.keys.contains("InstanceId") {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("JobId") {
                self.jobId = dict["JobId"] as! String
            }
            if dict.keys.contains("OutboundScenario") {
                self.outboundScenario = dict["OutboundScenario"] as! Bool
            }
            if dict.keys.contains("SignedSkillGroupIdList") {
                self.signedSkillGroupIdList = dict["SignedSkillGroupIdList"] as! [String]
            }
            if dict.keys.contains("UserId") {
                self.userId = dict["UserId"] as! String
            }
            if dict.keys.contains("UserState") {
                self.userState = dict["UserState"] as! String
            }
            if dict.keys.contains("WorkMode") {
                self.workMode = dict["WorkMode"] as! String
            }
        }
    }
    public var code: String?

    public var data: ResetAgentStateResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var params: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.params != nil {
            map["Params"] = self.params!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = ResetAgentStateResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Params") {
            self.params = dict["Params"] as! [String]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ResetAgentStateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ResetAgentStateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ResetAgentStateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ResetUserPasswordRequest : Tea.TeaModel {
    public var instanceId: String?

    public var password: String?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.password != nil {
            map["Password"] = self.password!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Password") {
            self.password = dict["Password"] as! String
        }
        if dict.keys.contains("UserId") {
            self.userId = dict["UserId"] as! String
        }
    }
}

public class ResetUserPasswordResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ResetUserPasswordResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ResetUserPasswordResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ResetUserPasswordResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RestoreArchivedRecordingsRequest : Tea.TeaModel {
    public var contactIds: String?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.contactIds != nil {
            map["ContactIds"] = self.contactIds!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ContactIds") {
            self.contactIds = dict["ContactIds"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
    }
}

public class RestoreArchivedRecordingsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var contactId: String?

        public var exists: String?

        public var status: String?

        public var storageType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.contactId != nil {
                map["ContactId"] = self.contactId!
            }
            if self.exists != nil {
                map["Exists"] = self.exists!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.storageType != nil {
                map["StorageType"] = self.storageType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ContactId") {
                self.contactId = dict["ContactId"] as! String
            }
            if dict.keys.contains("Exists") {
                self.exists = dict["Exists"] as! String
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("StorageType") {
                self.storageType = dict["StorageType"] as! String
            }
        }
    }
    public var code: String?

    public var data: [RestoreArchivedRecordingsResponseBody.Data]?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var tmp : [RestoreArchivedRecordingsResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = RestoreArchivedRecordingsResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class RestoreArchivedRecordingsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RestoreArchivedRecordingsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RestoreArchivedRecordingsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ResubmitTicketRequest : Tea.TeaModel {
    public var comment: String?

    public var instanceId: String?

    public var ticketId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.comment != nil {
            map["Comment"] = self.comment!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.ticketId != nil {
            map["TicketId"] = self.ticketId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Comment") {
            self.comment = dict["Comment"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("TicketId") {
            self.ticketId = dict["TicketId"] as! String
        }
    }
}

public class ResubmitTicketResponseBody : Tea.TeaModel {
    public var code: String?

    public var data: Any?

    public var httpStatusCode: Int32?

    public var message: String?

    public var params: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.params != nil {
            map["Params"] = self.params!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Any
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Params") {
            self.params = dict["Params"] as! [String]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ResubmitTicketResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ResubmitTicketResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ResubmitTicketResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ResumeCampaignRequest : Tea.TeaModel {
    public var campaignId: String?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.campaignId != nil {
            map["CampaignId"] = self.campaignId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CampaignId") {
            self.campaignId = dict["CampaignId"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
    }
}

public class ResumeCampaignResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpStatusCode: String?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ResumeCampaignResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ResumeCampaignResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ResumeCampaignResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RetrieveCallRequest : Tea.TeaModel {
    public var channelId: String?

    public var deviceId: String?

    public var instanceId: String?

    public var jobId: String?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.channelId != nil {
            map["ChannelId"] = self.channelId!
        }
        if self.deviceId != nil {
            map["DeviceId"] = self.deviceId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ChannelId") {
            self.channelId = dict["ChannelId"] as! String
        }
        if dict.keys.contains("DeviceId") {
            self.deviceId = dict["DeviceId"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("UserId") {
            self.userId = dict["UserId"] as! String
        }
    }
}

public class RetrieveCallResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class CallContext : Tea.TeaModel {
            public class ChannelContexts : Tea.TeaModel {
                public var callType: String?

                public var channelId: String?

                public var channelState: String?

                public var destination: String?

                public var jobId: String?

                public var originator: String?

                public var releaseInitiator: String?

                public var releaseReason: String?

                public var skillGroupId: String?

                public var timestamp: Int64?

                public var userExtension: String?

                public var userId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.callType != nil {
                        map["CallType"] = self.callType!
                    }
                    if self.channelId != nil {
                        map["ChannelId"] = self.channelId!
                    }
                    if self.channelState != nil {
                        map["ChannelState"] = self.channelState!
                    }
                    if self.destination != nil {
                        map["Destination"] = self.destination!
                    }
                    if self.jobId != nil {
                        map["JobId"] = self.jobId!
                    }
                    if self.originator != nil {
                        map["Originator"] = self.originator!
                    }
                    if self.releaseInitiator != nil {
                        map["ReleaseInitiator"] = self.releaseInitiator!
                    }
                    if self.releaseReason != nil {
                        map["ReleaseReason"] = self.releaseReason!
                    }
                    if self.skillGroupId != nil {
                        map["SkillGroupId"] = self.skillGroupId!
                    }
                    if self.timestamp != nil {
                        map["Timestamp"] = self.timestamp!
                    }
                    if self.userExtension != nil {
                        map["UserExtension"] = self.userExtension!
                    }
                    if self.userId != nil {
                        map["UserId"] = self.userId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("CallType") {
                        self.callType = dict["CallType"] as! String
                    }
                    if dict.keys.contains("ChannelId") {
                        self.channelId = dict["ChannelId"] as! String
                    }
                    if dict.keys.contains("ChannelState") {
                        self.channelState = dict["ChannelState"] as! String
                    }
                    if dict.keys.contains("Destination") {
                        self.destination = dict["Destination"] as! String
                    }
                    if dict.keys.contains("JobId") {
                        self.jobId = dict["JobId"] as! String
                    }
                    if dict.keys.contains("Originator") {
                        self.originator = dict["Originator"] as! String
                    }
                    if dict.keys.contains("ReleaseInitiator") {
                        self.releaseInitiator = dict["ReleaseInitiator"] as! String
                    }
                    if dict.keys.contains("ReleaseReason") {
                        self.releaseReason = dict["ReleaseReason"] as! String
                    }
                    if dict.keys.contains("SkillGroupId") {
                        self.skillGroupId = dict["SkillGroupId"] as! String
                    }
                    if dict.keys.contains("Timestamp") {
                        self.timestamp = dict["Timestamp"] as! Int64
                    }
                    if dict.keys.contains("UserExtension") {
                        self.userExtension = dict["UserExtension"] as! String
                    }
                    if dict.keys.contains("UserId") {
                        self.userId = dict["UserId"] as! String
                    }
                }
            }
            public var callType: String?

            public var channelContexts: [RetrieveCallResponseBody.Data.CallContext.ChannelContexts]?

            public var instanceId: String?

            public var jobId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.callType != nil {
                    map["CallType"] = self.callType!
                }
                if self.channelContexts != nil {
                    var tmp : [Any] = []
                    for k in self.channelContexts! {
                        tmp.append(k.toMap())
                    }
                    map["ChannelContexts"] = tmp
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.jobId != nil {
                    map["JobId"] = self.jobId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CallType") {
                    self.callType = dict["CallType"] as! String
                }
                if dict.keys.contains("ChannelContexts") {
                    var tmp : [RetrieveCallResponseBody.Data.CallContext.ChannelContexts] = []
                    for v in dict["ChannelContexts"] as! [Any] {
                        var model = RetrieveCallResponseBody.Data.CallContext.ChannelContexts()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.channelContexts = tmp
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("JobId") {
                    self.jobId = dict["JobId"] as! String
                }
            }
        }
        public class UserContext : Tea.TeaModel {
            public var breakCode: String?

            public var deviceId: String?

            public var extension_: String?

            public var heartbeat: Int64?

            public var instanceId: String?

            public var jobId: String?

            public var mobile: String?

            public var outboundScenario: Bool?

            public var reserved: Int64?

            public var signedSkillGroupIdList: [String]?

            public var userId: String?

            public var userState: String?

            public var workMode: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.breakCode != nil {
                    map["BreakCode"] = self.breakCode!
                }
                if self.deviceId != nil {
                    map["DeviceId"] = self.deviceId!
                }
                if self.extension_ != nil {
                    map["Extension"] = self.extension_!
                }
                if self.heartbeat != nil {
                    map["Heartbeat"] = self.heartbeat!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.jobId != nil {
                    map["JobId"] = self.jobId!
                }
                if self.mobile != nil {
                    map["Mobile"] = self.mobile!
                }
                if self.outboundScenario != nil {
                    map["OutboundScenario"] = self.outboundScenario!
                }
                if self.reserved != nil {
                    map["Reserved"] = self.reserved!
                }
                if self.signedSkillGroupIdList != nil {
                    map["SignedSkillGroupIdList"] = self.signedSkillGroupIdList!
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                if self.userState != nil {
                    map["UserState"] = self.userState!
                }
                if self.workMode != nil {
                    map["WorkMode"] = self.workMode!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BreakCode") {
                    self.breakCode = dict["BreakCode"] as! String
                }
                if dict.keys.contains("DeviceId") {
                    self.deviceId = dict["DeviceId"] as! String
                }
                if dict.keys.contains("Extension") {
                    self.extension_ = dict["Extension"] as! String
                }
                if dict.keys.contains("Heartbeat") {
                    self.heartbeat = dict["Heartbeat"] as! Int64
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("JobId") {
                    self.jobId = dict["JobId"] as! String
                }
                if dict.keys.contains("Mobile") {
                    self.mobile = dict["Mobile"] as! String
                }
                if dict.keys.contains("OutboundScenario") {
                    self.outboundScenario = dict["OutboundScenario"] as! Bool
                }
                if dict.keys.contains("Reserved") {
                    self.reserved = dict["Reserved"] as! Int64
                }
                if dict.keys.contains("SignedSkillGroupIdList") {
                    self.signedSkillGroupIdList = dict["SignedSkillGroupIdList"] as! [String]
                }
                if dict.keys.contains("UserId") {
                    self.userId = dict["UserId"] as! String
                }
                if dict.keys.contains("UserState") {
                    self.userState = dict["UserState"] as! String
                }
                if dict.keys.contains("WorkMode") {
                    self.workMode = dict["WorkMode"] as! String
                }
            }
        }
        public var callContext: RetrieveCallResponseBody.Data.CallContext?

        public var userContext: RetrieveCallResponseBody.Data.UserContext?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.callContext?.validate()
            try self.userContext?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.callContext != nil {
                map["CallContext"] = self.callContext?.toMap()
            }
            if self.userContext != nil {
                map["UserContext"] = self.userContext?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CallContext") {
                var model = RetrieveCallResponseBody.Data.CallContext()
                model.fromMap(dict["CallContext"] as! [String: Any])
                self.callContext = model
            }
            if dict.keys.contains("UserContext") {
                var model = RetrieveCallResponseBody.Data.UserContext()
                model.fromMap(dict["UserContext"] as! [String: Any])
                self.userContext = model
            }
        }
    }
    public var code: String?

    public var data: RetrieveCallResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var params: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.params != nil {
            map["Params"] = self.params!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = RetrieveCallResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Params") {
            self.params = dict["Params"] as! [String]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class RetrieveCallResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RetrieveCallResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RetrieveCallResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SaveDocumentRequest : Tea.TeaModel {
    public var documentId: String?

    public var documentJson: String?

    public var instanceId: String?

    public var requestId: String?

    public var schemaId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.documentId != nil {
            map["DocumentId"] = self.documentId!
        }
        if self.documentJson != nil {
            map["DocumentJson"] = self.documentJson!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.schemaId != nil {
            map["SchemaId"] = self.schemaId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DocumentId") {
            self.documentId = dict["DocumentId"] as! String
        }
        if dict.keys.contains("DocumentJson") {
            self.documentJson = dict["DocumentJson"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SchemaId") {
            self.schemaId = dict["SchemaId"] as! String
        }
    }
}

public class SaveDocumentResponseBody : Tea.TeaModel {
    public var code: String?

    public var data: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var params: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.params != nil {
            map["Params"] = self.params!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Params") {
            self.params = dict["Params"] as! [String]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SaveDocumentResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SaveDocumentResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SaveDocumentResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SaveRTCStatsV2Request : Tea.TeaModel {
    public var callId: String?

    public var generalInfo: String?

    public var googAddress: String?

    public var instanceId: String?

    public var receiverReport: String?

    public var senderReport: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.callId != nil {
            map["CallId"] = self.callId!
        }
        if self.generalInfo != nil {
            map["GeneralInfo"] = self.generalInfo!
        }
        if self.googAddress != nil {
            map["GoogAddress"] = self.googAddress!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.receiverReport != nil {
            map["ReceiverReport"] = self.receiverReport!
        }
        if self.senderReport != nil {
            map["SenderReport"] = self.senderReport!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CallId") {
            self.callId = dict["CallId"] as! String
        }
        if dict.keys.contains("GeneralInfo") {
            self.generalInfo = dict["GeneralInfo"] as! String
        }
        if dict.keys.contains("GoogAddress") {
            self.googAddress = dict["GoogAddress"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("ReceiverReport") {
            self.receiverReport = dict["ReceiverReport"] as! String
        }
        if dict.keys.contains("SenderReport") {
            self.senderReport = dict["SenderReport"] as! String
        }
    }
}

public class SaveRTCStatsV2ResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpStatusCode: Int64?

    public var message: String?

    public var requestId: String?

    public var rowCount: Int64?

    public var success: Bool?

    public var timeStamp: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.rowCount != nil {
            map["RowCount"] = self.rowCount!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.timeStamp != nil {
            map["TimeStamp"] = self.timeStamp!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int64
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("RowCount") {
            self.rowCount = dict["RowCount"] as! Int64
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TimeStamp") {
            self.timeStamp = dict["TimeStamp"] as! Int64
        }
    }
}

public class SaveRTCStatsV2Response : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SaveRTCStatsV2ResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SaveRTCStatsV2ResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SaveTerminalLogRequest : Tea.TeaModel {
    public var appName: String?

    public var callId: String?

    public var content: String?

    public var dataType: Int32?

    public var instanceId: String?

    public var jobId: String?

    public var methodName: String?

    public var status: String?

    public var uniqueRequestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.callId != nil {
            map["CallId"] = self.callId!
        }
        if self.content != nil {
            map["Content"] = self.content!
        }
        if self.dataType != nil {
            map["DataType"] = self.dataType!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.methodName != nil {
            map["MethodName"] = self.methodName!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.uniqueRequestId != nil {
            map["UniqueRequestId"] = self.uniqueRequestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppName") {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("CallId") {
            self.callId = dict["CallId"] as! String
        }
        if dict.keys.contains("Content") {
            self.content = dict["Content"] as! String
        }
        if dict.keys.contains("DataType") {
            self.dataType = dict["DataType"] as! Int32
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("MethodName") {
            self.methodName = dict["MethodName"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("UniqueRequestId") {
            self.uniqueRequestId = dict["UniqueRequestId"] as! String
        }
    }
}

public class SaveTerminalLogResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpStatusCode: Int64?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var timeStamp: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.timeStamp != nil {
            map["TimeStamp"] = self.timeStamp!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int64
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TimeStamp") {
            self.timeStamp = dict["TimeStamp"] as! Int64
        }
    }
}

public class SaveTerminalLogResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SaveTerminalLogResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SaveTerminalLogResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SaveWebRTCStatsRequest : Tea.TeaModel {
    public var callId: String?

    public var generalInfo: String?

    public var googAddress: String?

    public var instanceId: String?

    public var receiverReport: String?

    public var senderReport: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.callId != nil {
            map["CallId"] = self.callId!
        }
        if self.generalInfo != nil {
            map["GeneralInfo"] = self.generalInfo!
        }
        if self.googAddress != nil {
            map["GoogAddress"] = self.googAddress!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.receiverReport != nil {
            map["ReceiverReport"] = self.receiverReport!
        }
        if self.senderReport != nil {
            map["SenderReport"] = self.senderReport!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CallId") {
            self.callId = dict["CallId"] as! String
        }
        if dict.keys.contains("GeneralInfo") {
            self.generalInfo = dict["GeneralInfo"] as! String
        }
        if dict.keys.contains("GoogAddress") {
            self.googAddress = dict["GoogAddress"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("ReceiverReport") {
            self.receiverReport = dict["ReceiverReport"] as! String
        }
        if dict.keys.contains("SenderReport") {
            self.senderReport = dict["SenderReport"] as! String
        }
    }
}

public class SaveWebRTCStatsResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpStatusCode: Int64?

    public var message: String?

    public var requestId: String?

    public var rowCount: Int64?

    public var success: Bool?

    public var timeStamp: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.rowCount != nil {
            map["RowCount"] = self.rowCount!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.timeStamp != nil {
            map["TimeStamp"] = self.timeStamp!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int64
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("RowCount") {
            self.rowCount = dict["RowCount"] as! Int64
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TimeStamp") {
            self.timeStamp = dict["TimeStamp"] as! Int64
        }
    }
}

public class SaveWebRTCStatsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SaveWebRTCStatsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SaveWebRTCStatsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SaveWebRtcInfoRequest : Tea.TeaModel {
    public var callId: String?

    public var content: String?

    public var contentType: String?

    public var instanceId: String?

    public var jobId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.callId != nil {
            map["CallId"] = self.callId!
        }
        if self.content != nil {
            map["Content"] = self.content!
        }
        if self.contentType != nil {
            map["ContentType"] = self.contentType!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CallId") {
            self.callId = dict["CallId"] as! String
        }
        if dict.keys.contains("Content") {
            self.content = dict["Content"] as! String
        }
        if dict.keys.contains("ContentType") {
            self.contentType = dict["ContentType"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
    }
}

public class SaveWebRtcInfoResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpStatusCode: Int64?

    public var message: String?

    public var requestId: String?

    public var rowCount: Int64?

    public var success: Bool?

    public var timeStamp: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.rowCount != nil {
            map["RowCount"] = self.rowCount!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.timeStamp != nil {
            map["TimeStamp"] = self.timeStamp!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int64
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("RowCount") {
            self.rowCount = dict["RowCount"] as! Int64
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TimeStamp") {
            self.timeStamp = dict["TimeStamp"] as! Int64
        }
    }
}

public class SaveWebRtcInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SaveWebRtcInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SaveWebRtcInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SendDtmfSignalingRequest : Tea.TeaModel {
    public var channelId: String?

    public var deviceId: String?

    public var dtmf: String?

    public var instanceId: String?

    public var jobId: String?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.channelId != nil {
            map["ChannelId"] = self.channelId!
        }
        if self.deviceId != nil {
            map["DeviceId"] = self.deviceId!
        }
        if self.dtmf != nil {
            map["Dtmf"] = self.dtmf!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ChannelId") {
            self.channelId = dict["ChannelId"] as! String
        }
        if dict.keys.contains("DeviceId") {
            self.deviceId = dict["DeviceId"] as! String
        }
        if dict.keys.contains("Dtmf") {
            self.dtmf = dict["Dtmf"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("UserId") {
            self.userId = dict["UserId"] as! String
        }
    }
}

public class SendDtmfSignalingResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class CallContext : Tea.TeaModel {
            public class ChannelContexts : Tea.TeaModel {
                public var callType: String?

                public var channelFlags: String?

                public var channelId: String?

                public var channelState: String?

                public var destination: String?

                public var index: Int32?

                public var jobId: String?

                public var originator: String?

                public var releaseInitiator: String?

                public var releaseReason: String?

                public var skillGroupId: String?

                public var timestamp: Int64?

                public var userExtension: String?

                public var userId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.callType != nil {
                        map["CallType"] = self.callType!
                    }
                    if self.channelFlags != nil {
                        map["ChannelFlags"] = self.channelFlags!
                    }
                    if self.channelId != nil {
                        map["ChannelId"] = self.channelId!
                    }
                    if self.channelState != nil {
                        map["ChannelState"] = self.channelState!
                    }
                    if self.destination != nil {
                        map["Destination"] = self.destination!
                    }
                    if self.index != nil {
                        map["Index"] = self.index!
                    }
                    if self.jobId != nil {
                        map["JobId"] = self.jobId!
                    }
                    if self.originator != nil {
                        map["Originator"] = self.originator!
                    }
                    if self.releaseInitiator != nil {
                        map["ReleaseInitiator"] = self.releaseInitiator!
                    }
                    if self.releaseReason != nil {
                        map["ReleaseReason"] = self.releaseReason!
                    }
                    if self.skillGroupId != nil {
                        map["SkillGroupId"] = self.skillGroupId!
                    }
                    if self.timestamp != nil {
                        map["Timestamp"] = self.timestamp!
                    }
                    if self.userExtension != nil {
                        map["UserExtension"] = self.userExtension!
                    }
                    if self.userId != nil {
                        map["UserId"] = self.userId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("CallType") {
                        self.callType = dict["CallType"] as! String
                    }
                    if dict.keys.contains("ChannelFlags") {
                        self.channelFlags = dict["ChannelFlags"] as! String
                    }
                    if dict.keys.contains("ChannelId") {
                        self.channelId = dict["ChannelId"] as! String
                    }
                    if dict.keys.contains("ChannelState") {
                        self.channelState = dict["ChannelState"] as! String
                    }
                    if dict.keys.contains("Destination") {
                        self.destination = dict["Destination"] as! String
                    }
                    if dict.keys.contains("Index") {
                        self.index = dict["Index"] as! Int32
                    }
                    if dict.keys.contains("JobId") {
                        self.jobId = dict["JobId"] as! String
                    }
                    if dict.keys.contains("Originator") {
                        self.originator = dict["Originator"] as! String
                    }
                    if dict.keys.contains("ReleaseInitiator") {
                        self.releaseInitiator = dict["ReleaseInitiator"] as! String
                    }
                    if dict.keys.contains("ReleaseReason") {
                        self.releaseReason = dict["ReleaseReason"] as! String
                    }
                    if dict.keys.contains("SkillGroupId") {
                        self.skillGroupId = dict["SkillGroupId"] as! String
                    }
                    if dict.keys.contains("Timestamp") {
                        self.timestamp = dict["Timestamp"] as! Int64
                    }
                    if dict.keys.contains("UserExtension") {
                        self.userExtension = dict["UserExtension"] as! String
                    }
                    if dict.keys.contains("UserId") {
                        self.userId = dict["UserId"] as! String
                    }
                }
            }
            public var callType: String?

            public var channelContexts: [SendDtmfSignalingResponseBody.Data.CallContext.ChannelContexts]?

            public var instanceId: String?

            public var jobId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.callType != nil {
                    map["CallType"] = self.callType!
                }
                if self.channelContexts != nil {
                    var tmp : [Any] = []
                    for k in self.channelContexts! {
                        tmp.append(k.toMap())
                    }
                    map["ChannelContexts"] = tmp
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.jobId != nil {
                    map["JobId"] = self.jobId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CallType") {
                    self.callType = dict["CallType"] as! String
                }
                if dict.keys.contains("ChannelContexts") {
                    var tmp : [SendDtmfSignalingResponseBody.Data.CallContext.ChannelContexts] = []
                    for v in dict["ChannelContexts"] as! [Any] {
                        var model = SendDtmfSignalingResponseBody.Data.CallContext.ChannelContexts()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.channelContexts = tmp
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("JobId") {
                    self.jobId = dict["JobId"] as! String
                }
            }
        }
        public class UserContext : Tea.TeaModel {
            public var breakCode: String?

            public var deviceId: String?

            public var extension_: String?

            public var heartbeat: Int64?

            public var instanceId: String?

            public var jobId: String?

            public var mobile: String?

            public var outboundScenario: Bool?

            public var reserved: Int64?

            public var signedSkillGroupIdList: [String]?

            public var userId: String?

            public var userState: String?

            public var workMode: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.breakCode != nil {
                    map["BreakCode"] = self.breakCode!
                }
                if self.deviceId != nil {
                    map["DeviceId"] = self.deviceId!
                }
                if self.extension_ != nil {
                    map["Extension"] = self.extension_!
                }
                if self.heartbeat != nil {
                    map["Heartbeat"] = self.heartbeat!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.jobId != nil {
                    map["JobId"] = self.jobId!
                }
                if self.mobile != nil {
                    map["Mobile"] = self.mobile!
                }
                if self.outboundScenario != nil {
                    map["OutboundScenario"] = self.outboundScenario!
                }
                if self.reserved != nil {
                    map["Reserved"] = self.reserved!
                }
                if self.signedSkillGroupIdList != nil {
                    map["SignedSkillGroupIdList"] = self.signedSkillGroupIdList!
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                if self.userState != nil {
                    map["UserState"] = self.userState!
                }
                if self.workMode != nil {
                    map["WorkMode"] = self.workMode!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BreakCode") {
                    self.breakCode = dict["BreakCode"] as! String
                }
                if dict.keys.contains("DeviceId") {
                    self.deviceId = dict["DeviceId"] as! String
                }
                if dict.keys.contains("Extension") {
                    self.extension_ = dict["Extension"] as! String
                }
                if dict.keys.contains("Heartbeat") {
                    self.heartbeat = dict["Heartbeat"] as! Int64
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("JobId") {
                    self.jobId = dict["JobId"] as! String
                }
                if dict.keys.contains("Mobile") {
                    self.mobile = dict["Mobile"] as! String
                }
                if dict.keys.contains("OutboundScenario") {
                    self.outboundScenario = dict["OutboundScenario"] as! Bool
                }
                if dict.keys.contains("Reserved") {
                    self.reserved = dict["Reserved"] as! Int64
                }
                if dict.keys.contains("SignedSkillGroupIdList") {
                    self.signedSkillGroupIdList = dict["SignedSkillGroupIdList"] as! [String]
                }
                if dict.keys.contains("UserId") {
                    self.userId = dict["UserId"] as! String
                }
                if dict.keys.contains("UserState") {
                    self.userState = dict["UserState"] as! String
                }
                if dict.keys.contains("WorkMode") {
                    self.workMode = dict["WorkMode"] as! String
                }
            }
        }
        public var callContext: SendDtmfSignalingResponseBody.Data.CallContext?

        public var userContext: SendDtmfSignalingResponseBody.Data.UserContext?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.callContext?.validate()
            try self.userContext?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.callContext != nil {
                map["CallContext"] = self.callContext?.toMap()
            }
            if self.userContext != nil {
                map["UserContext"] = self.userContext?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CallContext") {
                var model = SendDtmfSignalingResponseBody.Data.CallContext()
                model.fromMap(dict["CallContext"] as! [String: Any])
                self.callContext = model
            }
            if dict.keys.contains("UserContext") {
                var model = SendDtmfSignalingResponseBody.Data.UserContext()
                model.fromMap(dict["UserContext"] as! [String: Any])
                self.userContext = model
            }
        }
    }
    public var code: String?

    public var data: SendDtmfSignalingResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var params: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.params != nil {
            map["Params"] = self.params!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = SendDtmfSignalingResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Params") {
            self.params = dict["Params"] as! [String]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SendDtmfSignalingResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SendDtmfSignalingResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SendDtmfSignalingResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SignInGroupRequest : Tea.TeaModel {
    public var additivity: Bool?

    public var chatDeviceId: String?

    public var deviceId: String?

    public var instanceId: String?

    public var signedSkillGroupIdList: String?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.additivity != nil {
            map["Additivity"] = self.additivity!
        }
        if self.chatDeviceId != nil {
            map["ChatDeviceId"] = self.chatDeviceId!
        }
        if self.deviceId != nil {
            map["DeviceId"] = self.deviceId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.signedSkillGroupIdList != nil {
            map["SignedSkillGroupIdList"] = self.signedSkillGroupIdList!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Additivity") {
            self.additivity = dict["Additivity"] as! Bool
        }
        if dict.keys.contains("ChatDeviceId") {
            self.chatDeviceId = dict["ChatDeviceId"] as! String
        }
        if dict.keys.contains("DeviceId") {
            self.deviceId = dict["DeviceId"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("SignedSkillGroupIdList") {
            self.signedSkillGroupIdList = dict["SignedSkillGroupIdList"] as! String
        }
        if dict.keys.contains("UserId") {
            self.userId = dict["UserId"] as! String
        }
    }
}

public class SignInGroupResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var breakCode: String?

        public var chatDeviceId: String?

        public var deviceId: String?

        public var extension_: String?

        public var instanceId: String?

        public var jobId: String?

        public var outboundScenario: Bool?

        public var signedSkillGroupIdList: [String]?

        public var userId: String?

        public var userState: String?

        public var workMode: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.breakCode != nil {
                map["BreakCode"] = self.breakCode!
            }
            if self.chatDeviceId != nil {
                map["ChatDeviceId"] = self.chatDeviceId!
            }
            if self.deviceId != nil {
                map["DeviceId"] = self.deviceId!
            }
            if self.extension_ != nil {
                map["Extension"] = self.extension_!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            if self.outboundScenario != nil {
                map["OutboundScenario"] = self.outboundScenario!
            }
            if self.signedSkillGroupIdList != nil {
                map["SignedSkillGroupIdList"] = self.signedSkillGroupIdList!
            }
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            if self.userState != nil {
                map["UserState"] = self.userState!
            }
            if self.workMode != nil {
                map["WorkMode"] = self.workMode!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BreakCode") {
                self.breakCode = dict["BreakCode"] as! String
            }
            if dict.keys.contains("ChatDeviceId") {
                self.chatDeviceId = dict["ChatDeviceId"] as! String
            }
            if dict.keys.contains("DeviceId") {
                self.deviceId = dict["DeviceId"] as! String
            }
            if dict.keys.contains("Extension") {
                self.extension_ = dict["Extension"] as! String
            }
            if dict.keys.contains("InstanceId") {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("JobId") {
                self.jobId = dict["JobId"] as! String
            }
            if dict.keys.contains("OutboundScenario") {
                self.outboundScenario = dict["OutboundScenario"] as! Bool
            }
            if dict.keys.contains("SignedSkillGroupIdList") {
                self.signedSkillGroupIdList = dict["SignedSkillGroupIdList"] as! [String]
            }
            if dict.keys.contains("UserId") {
                self.userId = dict["UserId"] as! String
            }
            if dict.keys.contains("UserState") {
                self.userState = dict["UserState"] as! String
            }
            if dict.keys.contains("WorkMode") {
                self.workMode = dict["WorkMode"] as! String
            }
        }
    }
    public var code: String?

    public var data: SignInGroupResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var params: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.params != nil {
            map["Params"] = self.params!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = SignInGroupResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Params") {
            self.params = dict["Params"] as! [String]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SignInGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SignInGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SignInGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SignOutGroupRequest : Tea.TeaModel {
    public var deviceId: String?

    public var instanceId: String?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.deviceId != nil {
            map["DeviceId"] = self.deviceId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DeviceId") {
            self.deviceId = dict["DeviceId"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("UserId") {
            self.userId = dict["UserId"] as! String
        }
    }
}

public class SignOutGroupResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var breakCode: String?

        public var deviceId: String?

        public var extension_: String?

        public var heartbeat: Int64?

        public var instanceId: String?

        public var jobId: String?

        public var mobile: String?

        public var outboundScenario: Bool?

        public var reserved: Int64?

        public var signedSkillGroupIdList: [String]?

        public var userId: String?

        public var userState: String?

        public var workMode: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.breakCode != nil {
                map["BreakCode"] = self.breakCode!
            }
            if self.deviceId != nil {
                map["DeviceId"] = self.deviceId!
            }
            if self.extension_ != nil {
                map["Extension"] = self.extension_!
            }
            if self.heartbeat != nil {
                map["Heartbeat"] = self.heartbeat!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            if self.mobile != nil {
                map["Mobile"] = self.mobile!
            }
            if self.outboundScenario != nil {
                map["OutboundScenario"] = self.outboundScenario!
            }
            if self.reserved != nil {
                map["Reserved"] = self.reserved!
            }
            if self.signedSkillGroupIdList != nil {
                map["SignedSkillGroupIdList"] = self.signedSkillGroupIdList!
            }
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            if self.userState != nil {
                map["UserState"] = self.userState!
            }
            if self.workMode != nil {
                map["WorkMode"] = self.workMode!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BreakCode") {
                self.breakCode = dict["BreakCode"] as! String
            }
            if dict.keys.contains("DeviceId") {
                self.deviceId = dict["DeviceId"] as! String
            }
            if dict.keys.contains("Extension") {
                self.extension_ = dict["Extension"] as! String
            }
            if dict.keys.contains("Heartbeat") {
                self.heartbeat = dict["Heartbeat"] as! Int64
            }
            if dict.keys.contains("InstanceId") {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("JobId") {
                self.jobId = dict["JobId"] as! String
            }
            if dict.keys.contains("Mobile") {
                self.mobile = dict["Mobile"] as! String
            }
            if dict.keys.contains("OutboundScenario") {
                self.outboundScenario = dict["OutboundScenario"] as! Bool
            }
            if dict.keys.contains("Reserved") {
                self.reserved = dict["Reserved"] as! Int64
            }
            if dict.keys.contains("SignedSkillGroupIdList") {
                self.signedSkillGroupIdList = dict["SignedSkillGroupIdList"] as! [String]
            }
            if dict.keys.contains("UserId") {
                self.userId = dict["UserId"] as! String
            }
            if dict.keys.contains("UserState") {
                self.userState = dict["UserState"] as! String
            }
            if dict.keys.contains("WorkMode") {
                self.workMode = dict["WorkMode"] as! String
            }
        }
    }
    public var code: String?

    public var data: SignOutGroupResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var params: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.params != nil {
            map["Params"] = self.params!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = SignOutGroupResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Params") {
            self.params = dict["Params"] as! [String]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SignOutGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SignOutGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SignOutGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class StartBack2BackCallRequest : Tea.TeaModel {
    public var additionalBroker: String?

    public var broker: String?

    public var callee: String?

    public var caller: String?

    public var instanceId: String?

    public var tags: String?

    public var timeoutSeconds: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.additionalBroker != nil {
            map["AdditionalBroker"] = self.additionalBroker!
        }
        if self.broker != nil {
            map["Broker"] = self.broker!
        }
        if self.callee != nil {
            map["Callee"] = self.callee!
        }
        if self.caller != nil {
            map["Caller"] = self.caller!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.tags != nil {
            map["Tags"] = self.tags!
        }
        if self.timeoutSeconds != nil {
            map["TimeoutSeconds"] = self.timeoutSeconds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AdditionalBroker") {
            self.additionalBroker = dict["AdditionalBroker"] as! String
        }
        if dict.keys.contains("Broker") {
            self.broker = dict["Broker"] as! String
        }
        if dict.keys.contains("Callee") {
            self.callee = dict["Callee"] as! String
        }
        if dict.keys.contains("Caller") {
            self.caller = dict["Caller"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Tags") {
            self.tags = dict["Tags"] as! String
        }
        if dict.keys.contains("TimeoutSeconds") {
            self.timeoutSeconds = dict["TimeoutSeconds"] as! Int32
        }
    }
}

public class StartBack2BackCallResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class CallContext : Tea.TeaModel {
            public class ChannelContexts : Tea.TeaModel {
                public var callType: String?

                public var channelFlags: String?

                public var channelId: String?

                public var channelState: String?

                public var destination: String?

                public var jobId: String?

                public var originator: String?

                public var releaseInitiator: String?

                public var releaseReason: String?

                public var timestamp: Int64?

                public var userExtension: String?

                public var userId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.callType != nil {
                        map["CallType"] = self.callType!
                    }
                    if self.channelFlags != nil {
                        map["ChannelFlags"] = self.channelFlags!
                    }
                    if self.channelId != nil {
                        map["ChannelId"] = self.channelId!
                    }
                    if self.channelState != nil {
                        map["ChannelState"] = self.channelState!
                    }
                    if self.destination != nil {
                        map["Destination"] = self.destination!
                    }
                    if self.jobId != nil {
                        map["JobId"] = self.jobId!
                    }
                    if self.originator != nil {
                        map["Originator"] = self.originator!
                    }
                    if self.releaseInitiator != nil {
                        map["ReleaseInitiator"] = self.releaseInitiator!
                    }
                    if self.releaseReason != nil {
                        map["ReleaseReason"] = self.releaseReason!
                    }
                    if self.timestamp != nil {
                        map["Timestamp"] = self.timestamp!
                    }
                    if self.userExtension != nil {
                        map["UserExtension"] = self.userExtension!
                    }
                    if self.userId != nil {
                        map["UserId"] = self.userId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("CallType") {
                        self.callType = dict["CallType"] as! String
                    }
                    if dict.keys.contains("ChannelFlags") {
                        self.channelFlags = dict["ChannelFlags"] as! String
                    }
                    if dict.keys.contains("ChannelId") {
                        self.channelId = dict["ChannelId"] as! String
                    }
                    if dict.keys.contains("ChannelState") {
                        self.channelState = dict["ChannelState"] as! String
                    }
                    if dict.keys.contains("Destination") {
                        self.destination = dict["Destination"] as! String
                    }
                    if dict.keys.contains("JobId") {
                        self.jobId = dict["JobId"] as! String
                    }
                    if dict.keys.contains("Originator") {
                        self.originator = dict["Originator"] as! String
                    }
                    if dict.keys.contains("ReleaseInitiator") {
                        self.releaseInitiator = dict["ReleaseInitiator"] as! String
                    }
                    if dict.keys.contains("ReleaseReason") {
                        self.releaseReason = dict["ReleaseReason"] as! String
                    }
                    if dict.keys.contains("Timestamp") {
                        self.timestamp = dict["Timestamp"] as! Int64
                    }
                    if dict.keys.contains("UserExtension") {
                        self.userExtension = dict["UserExtension"] as! String
                    }
                    if dict.keys.contains("UserId") {
                        self.userId = dict["UserId"] as! String
                    }
                }
            }
            public var callType: String?

            public var channelContexts: [StartBack2BackCallResponseBody.Data.CallContext.ChannelContexts]?

            public var instanceId: String?

            public var jobId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.callType != nil {
                    map["CallType"] = self.callType!
                }
                if self.channelContexts != nil {
                    var tmp : [Any] = []
                    for k in self.channelContexts! {
                        tmp.append(k.toMap())
                    }
                    map["ChannelContexts"] = tmp
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.jobId != nil {
                    map["JobId"] = self.jobId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CallType") {
                    self.callType = dict["CallType"] as! String
                }
                if dict.keys.contains("ChannelContexts") {
                    var tmp : [StartBack2BackCallResponseBody.Data.CallContext.ChannelContexts] = []
                    for v in dict["ChannelContexts"] as! [Any] {
                        var model = StartBack2BackCallResponseBody.Data.CallContext.ChannelContexts()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.channelContexts = tmp
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("JobId") {
                    self.jobId = dict["JobId"] as! String
                }
            }
        }
        public class UserContext : Tea.TeaModel {
            public var breakCode: String?

            public var deviceId: String?

            public var deviceState: String?

            public var extension_: String?

            public var heartbeat: Int64?

            public var instanceId: String?

            public var jobId: String?

            public var mobile: String?

            public var outboundScenario: Bool?

            public var reserved: Int64?

            public var signedSkillGroupIdList: [String]?

            public var userId: String?

            public var userState: String?

            public var workMode: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.breakCode != nil {
                    map["BreakCode"] = self.breakCode!
                }
                if self.deviceId != nil {
                    map["DeviceId"] = self.deviceId!
                }
                if self.deviceState != nil {
                    map["DeviceState"] = self.deviceState!
                }
                if self.extension_ != nil {
                    map["Extension"] = self.extension_!
                }
                if self.heartbeat != nil {
                    map["Heartbeat"] = self.heartbeat!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.jobId != nil {
                    map["JobId"] = self.jobId!
                }
                if self.mobile != nil {
                    map["Mobile"] = self.mobile!
                }
                if self.outboundScenario != nil {
                    map["OutboundScenario"] = self.outboundScenario!
                }
                if self.reserved != nil {
                    map["Reserved"] = self.reserved!
                }
                if self.signedSkillGroupIdList != nil {
                    map["SignedSkillGroupIdList"] = self.signedSkillGroupIdList!
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                if self.userState != nil {
                    map["UserState"] = self.userState!
                }
                if self.workMode != nil {
                    map["WorkMode"] = self.workMode!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BreakCode") {
                    self.breakCode = dict["BreakCode"] as! String
                }
                if dict.keys.contains("DeviceId") {
                    self.deviceId = dict["DeviceId"] as! String
                }
                if dict.keys.contains("DeviceState") {
                    self.deviceState = dict["DeviceState"] as! String
                }
                if dict.keys.contains("Extension") {
                    self.extension_ = dict["Extension"] as! String
                }
                if dict.keys.contains("Heartbeat") {
                    self.heartbeat = dict["Heartbeat"] as! Int64
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("JobId") {
                    self.jobId = dict["JobId"] as! String
                }
                if dict.keys.contains("Mobile") {
                    self.mobile = dict["Mobile"] as! String
                }
                if dict.keys.contains("OutboundScenario") {
                    self.outboundScenario = dict["OutboundScenario"] as! Bool
                }
                if dict.keys.contains("Reserved") {
                    self.reserved = dict["Reserved"] as! Int64
                }
                if dict.keys.contains("SignedSkillGroupIdList") {
                    self.signedSkillGroupIdList = dict["SignedSkillGroupIdList"] as! [String]
                }
                if dict.keys.contains("UserId") {
                    self.userId = dict["UserId"] as! String
                }
                if dict.keys.contains("UserState") {
                    self.userState = dict["UserState"] as! String
                }
                if dict.keys.contains("WorkMode") {
                    self.workMode = dict["WorkMode"] as! String
                }
            }
        }
        public var callContext: StartBack2BackCallResponseBody.Data.CallContext?

        public var userContext: StartBack2BackCallResponseBody.Data.UserContext?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.callContext?.validate()
            try self.userContext?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.callContext != nil {
                map["CallContext"] = self.callContext?.toMap()
            }
            if self.userContext != nil {
                map["UserContext"] = self.userContext?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CallContext") {
                var model = StartBack2BackCallResponseBody.Data.CallContext()
                model.fromMap(dict["CallContext"] as! [String: Any])
                self.callContext = model
            }
            if dict.keys.contains("UserContext") {
                var model = StartBack2BackCallResponseBody.Data.UserContext()
                model.fromMap(dict["UserContext"] as! [String: Any])
                self.userContext = model
            }
        }
    }
    public var code: String?

    public var data: StartBack2BackCallResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var params: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.params != nil {
            map["Params"] = self.params!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = StartBack2BackCallResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Params") {
            self.params = dict["Params"] as! [String]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class StartBack2BackCallResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StartBack2BackCallResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = StartBack2BackCallResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class StartChatRequest : Tea.TeaModel {
    public class UserList : Tea.TeaModel {
        public var avatarUrl: String?

        public var nickname: String?

        public var userId: String?

        public var userType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.avatarUrl != nil {
                map["AvatarUrl"] = self.avatarUrl!
            }
            if self.nickname != nil {
                map["Nickname"] = self.nickname!
            }
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            if self.userType != nil {
                map["UserType"] = self.userType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AvatarUrl") {
                self.avatarUrl = dict["AvatarUrl"] as! String
            }
            if dict.keys.contains("Nickname") {
                self.nickname = dict["Nickname"] as! String
            }
            if dict.keys.contains("UserId") {
                self.userId = dict["UserId"] as! String
            }
            if dict.keys.contains("UserType") {
                self.userType = dict["UserType"] as! String
            }
        }
    }
    public var accessChannelId: String?

    public var instanceId: String?

    public var token: String?

    public var userList: [StartChatRequest.UserList]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessChannelId != nil {
            map["AccessChannelId"] = self.accessChannelId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.token != nil {
            map["Token"] = self.token!
        }
        if self.userList != nil {
            var tmp : [Any] = []
            for k in self.userList! {
                tmp.append(k.toMap())
            }
            map["UserList"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AccessChannelId") {
            self.accessChannelId = dict["AccessChannelId"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Token") {
            self.token = dict["Token"] as! String
        }
        if dict.keys.contains("UserList") {
            var tmp : [StartChatRequest.UserList] = []
            for v in dict["UserList"] as! [Any] {
                var model = StartChatRequest.UserList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.userList = tmp
        }
    }
}

public class StartChatShrinkRequest : Tea.TeaModel {
    public var accessChannelId: String?

    public var instanceId: String?

    public var token: String?

    public var userListShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessChannelId != nil {
            map["AccessChannelId"] = self.accessChannelId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.token != nil {
            map["Token"] = self.token!
        }
        if self.userListShrink != nil {
            map["UserList"] = self.userListShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AccessChannelId") {
            self.accessChannelId = dict["AccessChannelId"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Token") {
            self.token = dict["Token"] as! String
        }
        if dict.keys.contains("UserList") {
            self.userListShrink = dict["UserList"] as! String
        }
    }
}

public class StartChatResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var chatConversationId: String?

        public var jobId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.chatConversationId != nil {
                map["ChatConversationId"] = self.chatConversationId!
            }
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ChatConversationId") {
                self.chatConversationId = dict["ChatConversationId"] as! String
            }
            if dict.keys.contains("JobId") {
                self.jobId = dict["JobId"] as! String
            }
        }
    }
    public var code: String?

    public var data: StartChatResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = StartChatResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class StartChatResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StartChatResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = StartChatResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class StartConferenceRequest : Tea.TeaModel {
    public var instanceId: String?

    public var participantListJson: String?

    public var tags: String?

    public var timeoutSeconds: Int32?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.participantListJson != nil {
            map["ParticipantListJson"] = self.participantListJson!
        }
        if self.tags != nil {
            map["Tags"] = self.tags!
        }
        if self.timeoutSeconds != nil {
            map["TimeoutSeconds"] = self.timeoutSeconds!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("ParticipantListJson") {
            self.participantListJson = dict["ParticipantListJson"] as! String
        }
        if dict.keys.contains("Tags") {
            self.tags = dict["Tags"] as! String
        }
        if dict.keys.contains("TimeoutSeconds") {
            self.timeoutSeconds = dict["TimeoutSeconds"] as! Int32
        }
        if dict.keys.contains("UserId") {
            self.userId = dict["UserId"] as! String
        }
    }
}

public class StartConferenceResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class CallContext : Tea.TeaModel {
            public class ChannelContexts : Tea.TeaModel {
                public var callType: String?

                public var channelFlags: String?

                public var channelId: String?

                public var channelState: String?

                public var destination: String?

                public var jobId: String?

                public var originator: String?

                public var releaseInitiator: String?

                public var releaseReason: String?

                public var timestamp: Int64?

                public var userExtension: String?

                public var userId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.callType != nil {
                        map["CallType"] = self.callType!
                    }
                    if self.channelFlags != nil {
                        map["ChannelFlags"] = self.channelFlags!
                    }
                    if self.channelId != nil {
                        map["ChannelId"] = self.channelId!
                    }
                    if self.channelState != nil {
                        map["ChannelState"] = self.channelState!
                    }
                    if self.destination != nil {
                        map["Destination"] = self.destination!
                    }
                    if self.jobId != nil {
                        map["JobId"] = self.jobId!
                    }
                    if self.originator != nil {
                        map["Originator"] = self.originator!
                    }
                    if self.releaseInitiator != nil {
                        map["ReleaseInitiator"] = self.releaseInitiator!
                    }
                    if self.releaseReason != nil {
                        map["ReleaseReason"] = self.releaseReason!
                    }
                    if self.timestamp != nil {
                        map["Timestamp"] = self.timestamp!
                    }
                    if self.userExtension != nil {
                        map["UserExtension"] = self.userExtension!
                    }
                    if self.userId != nil {
                        map["UserId"] = self.userId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("CallType") {
                        self.callType = dict["CallType"] as! String
                    }
                    if dict.keys.contains("ChannelFlags") {
                        self.channelFlags = dict["ChannelFlags"] as! String
                    }
                    if dict.keys.contains("ChannelId") {
                        self.channelId = dict["ChannelId"] as! String
                    }
                    if dict.keys.contains("ChannelState") {
                        self.channelState = dict["ChannelState"] as! String
                    }
                    if dict.keys.contains("Destination") {
                        self.destination = dict["Destination"] as! String
                    }
                    if dict.keys.contains("JobId") {
                        self.jobId = dict["JobId"] as! String
                    }
                    if dict.keys.contains("Originator") {
                        self.originator = dict["Originator"] as! String
                    }
                    if dict.keys.contains("ReleaseInitiator") {
                        self.releaseInitiator = dict["ReleaseInitiator"] as! String
                    }
                    if dict.keys.contains("ReleaseReason") {
                        self.releaseReason = dict["ReleaseReason"] as! String
                    }
                    if dict.keys.contains("Timestamp") {
                        self.timestamp = dict["Timestamp"] as! Int64
                    }
                    if dict.keys.contains("UserExtension") {
                        self.userExtension = dict["UserExtension"] as! String
                    }
                    if dict.keys.contains("UserId") {
                        self.userId = dict["UserId"] as! String
                    }
                }
            }
            public var callType: String?

            public var channelContexts: [StartConferenceResponseBody.Data.CallContext.ChannelContexts]?

            public var instanceId: String?

            public var jobId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.callType != nil {
                    map["CallType"] = self.callType!
                }
                if self.channelContexts != nil {
                    var tmp : [Any] = []
                    for k in self.channelContexts! {
                        tmp.append(k.toMap())
                    }
                    map["ChannelContexts"] = tmp
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.jobId != nil {
                    map["JobId"] = self.jobId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CallType") {
                    self.callType = dict["CallType"] as! String
                }
                if dict.keys.contains("ChannelContexts") {
                    var tmp : [StartConferenceResponseBody.Data.CallContext.ChannelContexts] = []
                    for v in dict["ChannelContexts"] as! [Any] {
                        var model = StartConferenceResponseBody.Data.CallContext.ChannelContexts()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.channelContexts = tmp
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("JobId") {
                    self.jobId = dict["JobId"] as! String
                }
            }
        }
        public class UserContext : Tea.TeaModel {
            public var breakCode: String?

            public var deviceId: String?

            public var deviceState: String?

            public var extension_: String?

            public var heartbeat: Int64?

            public var instanceId: String?

            public var jobId: String?

            public var mobile: String?

            public var outboundScenario: Bool?

            public var reserved: Int64?

            public var signedSkillGroupIdList: [String]?

            public var userId: String?

            public var userState: String?

            public var workMode: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.breakCode != nil {
                    map["BreakCode"] = self.breakCode!
                }
                if self.deviceId != nil {
                    map["DeviceId"] = self.deviceId!
                }
                if self.deviceState != nil {
                    map["DeviceState"] = self.deviceState!
                }
                if self.extension_ != nil {
                    map["Extension"] = self.extension_!
                }
                if self.heartbeat != nil {
                    map["Heartbeat"] = self.heartbeat!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.jobId != nil {
                    map["JobId"] = self.jobId!
                }
                if self.mobile != nil {
                    map["Mobile"] = self.mobile!
                }
                if self.outboundScenario != nil {
                    map["OutboundScenario"] = self.outboundScenario!
                }
                if self.reserved != nil {
                    map["Reserved"] = self.reserved!
                }
                if self.signedSkillGroupIdList != nil {
                    map["SignedSkillGroupIdList"] = self.signedSkillGroupIdList!
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                if self.userState != nil {
                    map["UserState"] = self.userState!
                }
                if self.workMode != nil {
                    map["WorkMode"] = self.workMode!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BreakCode") {
                    self.breakCode = dict["BreakCode"] as! String
                }
                if dict.keys.contains("DeviceId") {
                    self.deviceId = dict["DeviceId"] as! String
                }
                if dict.keys.contains("DeviceState") {
                    self.deviceState = dict["DeviceState"] as! String
                }
                if dict.keys.contains("Extension") {
                    self.extension_ = dict["Extension"] as! String
                }
                if dict.keys.contains("Heartbeat") {
                    self.heartbeat = dict["Heartbeat"] as! Int64
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("JobId") {
                    self.jobId = dict["JobId"] as! String
                }
                if dict.keys.contains("Mobile") {
                    self.mobile = dict["Mobile"] as! String
                }
                if dict.keys.contains("OutboundScenario") {
                    self.outboundScenario = dict["OutboundScenario"] as! Bool
                }
                if dict.keys.contains("Reserved") {
                    self.reserved = dict["Reserved"] as! Int64
                }
                if dict.keys.contains("SignedSkillGroupIdList") {
                    self.signedSkillGroupIdList = dict["SignedSkillGroupIdList"] as! [String]
                }
                if dict.keys.contains("UserId") {
                    self.userId = dict["UserId"] as! String
                }
                if dict.keys.contains("UserState") {
                    self.userState = dict["UserState"] as! String
                }
                if dict.keys.contains("WorkMode") {
                    self.workMode = dict["WorkMode"] as! String
                }
            }
        }
        public var callContext: StartConferenceResponseBody.Data.CallContext?

        public var userContext: StartConferenceResponseBody.Data.UserContext?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.callContext?.validate()
            try self.userContext?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.callContext != nil {
                map["CallContext"] = self.callContext?.toMap()
            }
            if self.userContext != nil {
                map["UserContext"] = self.userContext?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CallContext") {
                var model = StartConferenceResponseBody.Data.CallContext()
                model.fromMap(dict["CallContext"] as! [String: Any])
                self.callContext = model
            }
            if dict.keys.contains("UserContext") {
                var model = StartConferenceResponseBody.Data.UserContext()
                model.fromMap(dict["UserContext"] as! [String: Any])
                self.userContext = model
            }
        }
    }
    public var code: String?

    public var data: StartConferenceResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var params: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.params != nil {
            map["Params"] = self.params!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = StartConferenceResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Params") {
            self.params = dict["Params"] as! [String]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class StartConferenceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StartConferenceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = StartConferenceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class StartEditContactFlowRequest : Tea.TeaModel {
    public var contactFlowId: String?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.contactFlowId != nil {
            map["ContactFlowId"] = self.contactFlowId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ContactFlowId") {
            self.contactFlowId = dict["ContactFlowId"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
    }
}

public class StartEditContactFlowResponseBody : Tea.TeaModel {
    public var code: String?

    public var data: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class StartEditContactFlowResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StartEditContactFlowResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = StartEditContactFlowResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class StartPredictiveCallRequest : Tea.TeaModel {
    public var callee: String?

    public var caller: String?

    public var contactFlowId: String?

    public var contactFlowVariables: String?

    public var instanceId: String?

    public var maskedCallee: String?

    public var skillGroupId: String?

    public var tags: String?

    public var timeoutSeconds: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.callee != nil {
            map["Callee"] = self.callee!
        }
        if self.caller != nil {
            map["Caller"] = self.caller!
        }
        if self.contactFlowId != nil {
            map["ContactFlowId"] = self.contactFlowId!
        }
        if self.contactFlowVariables != nil {
            map["ContactFlowVariables"] = self.contactFlowVariables!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.maskedCallee != nil {
            map["MaskedCallee"] = self.maskedCallee!
        }
        if self.skillGroupId != nil {
            map["SkillGroupId"] = self.skillGroupId!
        }
        if self.tags != nil {
            map["Tags"] = self.tags!
        }
        if self.timeoutSeconds != nil {
            map["TimeoutSeconds"] = self.timeoutSeconds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Callee") {
            self.callee = dict["Callee"] as! String
        }
        if dict.keys.contains("Caller") {
            self.caller = dict["Caller"] as! String
        }
        if dict.keys.contains("ContactFlowId") {
            self.contactFlowId = dict["ContactFlowId"] as! String
        }
        if dict.keys.contains("ContactFlowVariables") {
            self.contactFlowVariables = dict["ContactFlowVariables"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("MaskedCallee") {
            self.maskedCallee = dict["MaskedCallee"] as! String
        }
        if dict.keys.contains("SkillGroupId") {
            self.skillGroupId = dict["SkillGroupId"] as! String
        }
        if dict.keys.contains("Tags") {
            self.tags = dict["Tags"] as! String
        }
        if dict.keys.contains("TimeoutSeconds") {
            self.timeoutSeconds = dict["TimeoutSeconds"] as! Int32
        }
    }
}

public class StartPredictiveCallResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class CallContext : Tea.TeaModel {
            public class ChannelContexts : Tea.TeaModel {
                public var callType: String?

                public var channelFlags: String?

                public var channelId: String?

                public var channelState: String?

                public var destination: String?

                public var jobId: String?

                public var originator: String?

                public var releaseInitiator: String?

                public var releaseReason: String?

                public var timestamp: Int64?

                public var userExtension: String?

                public var userId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.callType != nil {
                        map["CallType"] = self.callType!
                    }
                    if self.channelFlags != nil {
                        map["ChannelFlags"] = self.channelFlags!
                    }
                    if self.channelId != nil {
                        map["ChannelId"] = self.channelId!
                    }
                    if self.channelState != nil {
                        map["ChannelState"] = self.channelState!
                    }
                    if self.destination != nil {
                        map["Destination"] = self.destination!
                    }
                    if self.jobId != nil {
                        map["JobId"] = self.jobId!
                    }
                    if self.originator != nil {
                        map["Originator"] = self.originator!
                    }
                    if self.releaseInitiator != nil {
                        map["ReleaseInitiator"] = self.releaseInitiator!
                    }
                    if self.releaseReason != nil {
                        map["ReleaseReason"] = self.releaseReason!
                    }
                    if self.timestamp != nil {
                        map["Timestamp"] = self.timestamp!
                    }
                    if self.userExtension != nil {
                        map["UserExtension"] = self.userExtension!
                    }
                    if self.userId != nil {
                        map["UserId"] = self.userId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("CallType") {
                        self.callType = dict["CallType"] as! String
                    }
                    if dict.keys.contains("ChannelFlags") {
                        self.channelFlags = dict["ChannelFlags"] as! String
                    }
                    if dict.keys.contains("ChannelId") {
                        self.channelId = dict["ChannelId"] as! String
                    }
                    if dict.keys.contains("ChannelState") {
                        self.channelState = dict["ChannelState"] as! String
                    }
                    if dict.keys.contains("Destination") {
                        self.destination = dict["Destination"] as! String
                    }
                    if dict.keys.contains("JobId") {
                        self.jobId = dict["JobId"] as! String
                    }
                    if dict.keys.contains("Originator") {
                        self.originator = dict["Originator"] as! String
                    }
                    if dict.keys.contains("ReleaseInitiator") {
                        self.releaseInitiator = dict["ReleaseInitiator"] as! String
                    }
                    if dict.keys.contains("ReleaseReason") {
                        self.releaseReason = dict["ReleaseReason"] as! String
                    }
                    if dict.keys.contains("Timestamp") {
                        self.timestamp = dict["Timestamp"] as! Int64
                    }
                    if dict.keys.contains("UserExtension") {
                        self.userExtension = dict["UserExtension"] as! String
                    }
                    if dict.keys.contains("UserId") {
                        self.userId = dict["UserId"] as! String
                    }
                }
            }
            public var callType: String?

            public var channelContexts: [StartPredictiveCallResponseBody.Data.CallContext.ChannelContexts]?

            public var instanceId: String?

            public var jobId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.callType != nil {
                    map["CallType"] = self.callType!
                }
                if self.channelContexts != nil {
                    var tmp : [Any] = []
                    for k in self.channelContexts! {
                        tmp.append(k.toMap())
                    }
                    map["ChannelContexts"] = tmp
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.jobId != nil {
                    map["JobId"] = self.jobId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CallType") {
                    self.callType = dict["CallType"] as! String
                }
                if dict.keys.contains("ChannelContexts") {
                    var tmp : [StartPredictiveCallResponseBody.Data.CallContext.ChannelContexts] = []
                    for v in dict["ChannelContexts"] as! [Any] {
                        var model = StartPredictiveCallResponseBody.Data.CallContext.ChannelContexts()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.channelContexts = tmp
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("JobId") {
                    self.jobId = dict["JobId"] as! String
                }
            }
        }
        public class UserContext : Tea.TeaModel {
            public var breakCode: String?

            public var deviceId: String?

            public var deviceState: String?

            public var extension_: String?

            public var heartbeat: Int64?

            public var instanceId: String?

            public var jobId: String?

            public var mobile: String?

            public var outboundScenario: Bool?

            public var reserved: Int64?

            public var signedSkillGroupIdList: [String]?

            public var userId: String?

            public var userState: String?

            public var workMode: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.breakCode != nil {
                    map["BreakCode"] = self.breakCode!
                }
                if self.deviceId != nil {
                    map["DeviceId"] = self.deviceId!
                }
                if self.deviceState != nil {
                    map["DeviceState"] = self.deviceState!
                }
                if self.extension_ != nil {
                    map["Extension"] = self.extension_!
                }
                if self.heartbeat != nil {
                    map["Heartbeat"] = self.heartbeat!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.jobId != nil {
                    map["JobId"] = self.jobId!
                }
                if self.mobile != nil {
                    map["Mobile"] = self.mobile!
                }
                if self.outboundScenario != nil {
                    map["OutboundScenario"] = self.outboundScenario!
                }
                if self.reserved != nil {
                    map["Reserved"] = self.reserved!
                }
                if self.signedSkillGroupIdList != nil {
                    map["SignedSkillGroupIdList"] = self.signedSkillGroupIdList!
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                if self.userState != nil {
                    map["UserState"] = self.userState!
                }
                if self.workMode != nil {
                    map["WorkMode"] = self.workMode!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BreakCode") {
                    self.breakCode = dict["BreakCode"] as! String
                }
                if dict.keys.contains("DeviceId") {
                    self.deviceId = dict["DeviceId"] as! String
                }
                if dict.keys.contains("DeviceState") {
                    self.deviceState = dict["DeviceState"] as! String
                }
                if dict.keys.contains("Extension") {
                    self.extension_ = dict["Extension"] as! String
                }
                if dict.keys.contains("Heartbeat") {
                    self.heartbeat = dict["Heartbeat"] as! Int64
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("JobId") {
                    self.jobId = dict["JobId"] as! String
                }
                if dict.keys.contains("Mobile") {
                    self.mobile = dict["Mobile"] as! String
                }
                if dict.keys.contains("OutboundScenario") {
                    self.outboundScenario = dict["OutboundScenario"] as! Bool
                }
                if dict.keys.contains("Reserved") {
                    self.reserved = dict["Reserved"] as! Int64
                }
                if dict.keys.contains("SignedSkillGroupIdList") {
                    self.signedSkillGroupIdList = dict["SignedSkillGroupIdList"] as! [String]
                }
                if dict.keys.contains("UserId") {
                    self.userId = dict["UserId"] as! String
                }
                if dict.keys.contains("UserState") {
                    self.userState = dict["UserState"] as! String
                }
                if dict.keys.contains("WorkMode") {
                    self.workMode = dict["WorkMode"] as! String
                }
            }
        }
        public var callContext: StartPredictiveCallResponseBody.Data.CallContext?

        public var userContext: StartPredictiveCallResponseBody.Data.UserContext?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.callContext?.validate()
            try self.userContext?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.callContext != nil {
                map["CallContext"] = self.callContext?.toMap()
            }
            if self.userContext != nil {
                map["UserContext"] = self.userContext?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CallContext") {
                var model = StartPredictiveCallResponseBody.Data.CallContext()
                model.fromMap(dict["CallContext"] as! [String: Any])
                self.callContext = model
            }
            if dict.keys.contains("UserContext") {
                var model = StartPredictiveCallResponseBody.Data.UserContext()
                model.fromMap(dict["UserContext"] as! [String: Any])
                self.userContext = model
            }
        }
    }
    public var code: String?

    public var data: StartPredictiveCallResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var params: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.params != nil {
            map["Params"] = self.params!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = StartPredictiveCallResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Params") {
            self.params = dict["Params"] as! [String]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class StartPredictiveCallResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StartPredictiveCallResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = StartPredictiveCallResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class StartPrivacyCallRequest : Tea.TeaModel {
    public var appId: String?

    public var callee: String?

    public var caller: String?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.callee != nil {
            map["Callee"] = self.callee!
        }
        if self.caller != nil {
            map["Caller"] = self.caller!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("Callee") {
            self.callee = dict["Callee"] as! String
        }
        if dict.keys.contains("Caller") {
            self.caller = dict["Caller"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
    }
}

public class StartPrivacyCallResponseBody : Tea.TeaModel {
    public var code: String?

    public var data: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var params: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.params != nil {
            map["Params"] = self.params!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Params") {
            self.params = dict["Params"] as! [String]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class StartPrivacyCallResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StartPrivacyCallResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = StartPrivacyCallResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SubmitCampaignRequest : Tea.TeaModel {
    public var campaignId: String?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.campaignId != nil {
            map["CampaignId"] = self.campaignId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CampaignId") {
            self.campaignId = dict["CampaignId"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
    }
}

public class SubmitCampaignResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpStatusCode: String?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SubmitCampaignResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SubmitCampaignResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SubmitCampaignResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SwitchToConferenceRequest : Tea.TeaModel {
    public var deviceId: String?

    public var instanceId: String?

    public var jobId: String?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.deviceId != nil {
            map["DeviceId"] = self.deviceId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DeviceId") {
            self.deviceId = dict["DeviceId"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("UserId") {
            self.userId = dict["UserId"] as! String
        }
    }
}

public class SwitchToConferenceResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class CallContext : Tea.TeaModel {
            public class ChannelContexts : Tea.TeaModel {
                public var callType: String?

                public var channelFlags: String?

                public var channelId: String?

                public var channelState: String?

                public var destination: String?

                public var index: Int32?

                public var jobId: String?

                public var originator: String?

                public var releaseInitiator: String?

                public var releaseReason: String?

                public var skillGroupId: String?

                public var timestamp: Int64?

                public var userExtension: String?

                public var userId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.callType != nil {
                        map["CallType"] = self.callType!
                    }
                    if self.channelFlags != nil {
                        map["ChannelFlags"] = self.channelFlags!
                    }
                    if self.channelId != nil {
                        map["ChannelId"] = self.channelId!
                    }
                    if self.channelState != nil {
                        map["ChannelState"] = self.channelState!
                    }
                    if self.destination != nil {
                        map["Destination"] = self.destination!
                    }
                    if self.index != nil {
                        map["Index"] = self.index!
                    }
                    if self.jobId != nil {
                        map["JobId"] = self.jobId!
                    }
                    if self.originator != nil {
                        map["Originator"] = self.originator!
                    }
                    if self.releaseInitiator != nil {
                        map["ReleaseInitiator"] = self.releaseInitiator!
                    }
                    if self.releaseReason != nil {
                        map["ReleaseReason"] = self.releaseReason!
                    }
                    if self.skillGroupId != nil {
                        map["SkillGroupId"] = self.skillGroupId!
                    }
                    if self.timestamp != nil {
                        map["Timestamp"] = self.timestamp!
                    }
                    if self.userExtension != nil {
                        map["UserExtension"] = self.userExtension!
                    }
                    if self.userId != nil {
                        map["UserId"] = self.userId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("CallType") {
                        self.callType = dict["CallType"] as! String
                    }
                    if dict.keys.contains("ChannelFlags") {
                        self.channelFlags = dict["ChannelFlags"] as! String
                    }
                    if dict.keys.contains("ChannelId") {
                        self.channelId = dict["ChannelId"] as! String
                    }
                    if dict.keys.contains("ChannelState") {
                        self.channelState = dict["ChannelState"] as! String
                    }
                    if dict.keys.contains("Destination") {
                        self.destination = dict["Destination"] as! String
                    }
                    if dict.keys.contains("Index") {
                        self.index = dict["Index"] as! Int32
                    }
                    if dict.keys.contains("JobId") {
                        self.jobId = dict["JobId"] as! String
                    }
                    if dict.keys.contains("Originator") {
                        self.originator = dict["Originator"] as! String
                    }
                    if dict.keys.contains("ReleaseInitiator") {
                        self.releaseInitiator = dict["ReleaseInitiator"] as! String
                    }
                    if dict.keys.contains("ReleaseReason") {
                        self.releaseReason = dict["ReleaseReason"] as! String
                    }
                    if dict.keys.contains("SkillGroupId") {
                        self.skillGroupId = dict["SkillGroupId"] as! String
                    }
                    if dict.keys.contains("Timestamp") {
                        self.timestamp = dict["Timestamp"] as! Int64
                    }
                    if dict.keys.contains("UserExtension") {
                        self.userExtension = dict["UserExtension"] as! String
                    }
                    if dict.keys.contains("UserId") {
                        self.userId = dict["UserId"] as! String
                    }
                }
            }
            public var callType: String?

            public var channelContexts: [SwitchToConferenceResponseBody.Data.CallContext.ChannelContexts]?

            public var instanceId: String?

            public var jobId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.callType != nil {
                    map["CallType"] = self.callType!
                }
                if self.channelContexts != nil {
                    var tmp : [Any] = []
                    for k in self.channelContexts! {
                        tmp.append(k.toMap())
                    }
                    map["ChannelContexts"] = tmp
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.jobId != nil {
                    map["JobId"] = self.jobId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CallType") {
                    self.callType = dict["CallType"] as! String
                }
                if dict.keys.contains("ChannelContexts") {
                    var tmp : [SwitchToConferenceResponseBody.Data.CallContext.ChannelContexts] = []
                    for v in dict["ChannelContexts"] as! [Any] {
                        var model = SwitchToConferenceResponseBody.Data.CallContext.ChannelContexts()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.channelContexts = tmp
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("JobId") {
                    self.jobId = dict["JobId"] as! String
                }
            }
        }
        public class UserContext : Tea.TeaModel {
            public var breakCode: String?

            public var deviceId: String?

            public var deviceState: String?

            public var extension_: String?

            public var heartbeat: Int64?

            public var instanceId: String?

            public var jobId: String?

            public var mobile: String?

            public var outboundScenario: Bool?

            public var signedSkillGroupIdList: [String]?

            public var userId: String?

            public var userState: String?

            public var workMode: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.breakCode != nil {
                    map["BreakCode"] = self.breakCode!
                }
                if self.deviceId != nil {
                    map["DeviceId"] = self.deviceId!
                }
                if self.deviceState != nil {
                    map["DeviceState"] = self.deviceState!
                }
                if self.extension_ != nil {
                    map["Extension"] = self.extension_!
                }
                if self.heartbeat != nil {
                    map["Heartbeat"] = self.heartbeat!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.jobId != nil {
                    map["JobId"] = self.jobId!
                }
                if self.mobile != nil {
                    map["Mobile"] = self.mobile!
                }
                if self.outboundScenario != nil {
                    map["OutboundScenario"] = self.outboundScenario!
                }
                if self.signedSkillGroupIdList != nil {
                    map["SignedSkillGroupIdList"] = self.signedSkillGroupIdList!
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                if self.userState != nil {
                    map["UserState"] = self.userState!
                }
                if self.workMode != nil {
                    map["WorkMode"] = self.workMode!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BreakCode") {
                    self.breakCode = dict["BreakCode"] as! String
                }
                if dict.keys.contains("DeviceId") {
                    self.deviceId = dict["DeviceId"] as! String
                }
                if dict.keys.contains("DeviceState") {
                    self.deviceState = dict["DeviceState"] as! String
                }
                if dict.keys.contains("Extension") {
                    self.extension_ = dict["Extension"] as! String
                }
                if dict.keys.contains("Heartbeat") {
                    self.heartbeat = dict["Heartbeat"] as! Int64
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("JobId") {
                    self.jobId = dict["JobId"] as! String
                }
                if dict.keys.contains("Mobile") {
                    self.mobile = dict["Mobile"] as! String
                }
                if dict.keys.contains("OutboundScenario") {
                    self.outboundScenario = dict["OutboundScenario"] as! Bool
                }
                if dict.keys.contains("SignedSkillGroupIdList") {
                    self.signedSkillGroupIdList = dict["SignedSkillGroupIdList"] as! [String]
                }
                if dict.keys.contains("UserId") {
                    self.userId = dict["UserId"] as! String
                }
                if dict.keys.contains("UserState") {
                    self.userState = dict["UserState"] as! String
                }
                if dict.keys.contains("WorkMode") {
                    self.workMode = dict["WorkMode"] as! String
                }
            }
        }
        public var callContext: SwitchToConferenceResponseBody.Data.CallContext?

        public var userContext: SwitchToConferenceResponseBody.Data.UserContext?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.callContext?.validate()
            try self.userContext?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.callContext != nil {
                map["CallContext"] = self.callContext?.toMap()
            }
            if self.userContext != nil {
                map["UserContext"] = self.userContext?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CallContext") {
                var model = SwitchToConferenceResponseBody.Data.CallContext()
                model.fromMap(dict["CallContext"] as! [String: Any])
                self.callContext = model
            }
            if dict.keys.contains("UserContext") {
                var model = SwitchToConferenceResponseBody.Data.UserContext()
                model.fromMap(dict["UserContext"] as! [String: Any])
                self.userContext = model
            }
        }
    }
    public var code: String?

    public var data: SwitchToConferenceResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var params: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.params != nil {
            map["Params"] = self.params!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = SwitchToConferenceResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Params") {
            self.params = dict["Params"] as! [String]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SwitchToConferenceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SwitchToConferenceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SwitchToConferenceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class TakeBreakRequest : Tea.TeaModel {
    public var code: String?

    public var deviceId: String?

    public var instanceId: String?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.deviceId != nil {
            map["DeviceId"] = self.deviceId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("DeviceId") {
            self.deviceId = dict["DeviceId"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("UserId") {
            self.userId = dict["UserId"] as! String
        }
    }
}

public class TakeBreakResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var breakCode: String?

        public var deviceId: String?

        public var extension_: String?

        public var heartbeat: Int64?

        public var instanceId: String?

        public var jobId: String?

        public var mobile: String?

        public var outboundScenario: Bool?

        public var reserved: Int64?

        public var signedSkillGroupIdList: [String]?

        public var userId: String?

        public var userState: String?

        public var workMode: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.breakCode != nil {
                map["BreakCode"] = self.breakCode!
            }
            if self.deviceId != nil {
                map["DeviceId"] = self.deviceId!
            }
            if self.extension_ != nil {
                map["Extension"] = self.extension_!
            }
            if self.heartbeat != nil {
                map["Heartbeat"] = self.heartbeat!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            if self.mobile != nil {
                map["Mobile"] = self.mobile!
            }
            if self.outboundScenario != nil {
                map["OutboundScenario"] = self.outboundScenario!
            }
            if self.reserved != nil {
                map["Reserved"] = self.reserved!
            }
            if self.signedSkillGroupIdList != nil {
                map["SignedSkillGroupIdList"] = self.signedSkillGroupIdList!
            }
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            if self.userState != nil {
                map["UserState"] = self.userState!
            }
            if self.workMode != nil {
                map["WorkMode"] = self.workMode!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BreakCode") {
                self.breakCode = dict["BreakCode"] as! String
            }
            if dict.keys.contains("DeviceId") {
                self.deviceId = dict["DeviceId"] as! String
            }
            if dict.keys.contains("Extension") {
                self.extension_ = dict["Extension"] as! String
            }
            if dict.keys.contains("Heartbeat") {
                self.heartbeat = dict["Heartbeat"] as! Int64
            }
            if dict.keys.contains("InstanceId") {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("JobId") {
                self.jobId = dict["JobId"] as! String
            }
            if dict.keys.contains("Mobile") {
                self.mobile = dict["Mobile"] as! String
            }
            if dict.keys.contains("OutboundScenario") {
                self.outboundScenario = dict["OutboundScenario"] as! Bool
            }
            if dict.keys.contains("Reserved") {
                self.reserved = dict["Reserved"] as! Int64
            }
            if dict.keys.contains("SignedSkillGroupIdList") {
                self.signedSkillGroupIdList = dict["SignedSkillGroupIdList"] as! [String]
            }
            if dict.keys.contains("UserId") {
                self.userId = dict["UserId"] as! String
            }
            if dict.keys.contains("UserState") {
                self.userState = dict["UserState"] as! String
            }
            if dict.keys.contains("WorkMode") {
                self.workMode = dict["WorkMode"] as! String
            }
        }
    }
    public var code: String?

    public var data: TakeBreakResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var params: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.params != nil {
            map["Params"] = self.params!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = TakeBreakResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Params") {
            self.params = dict["Params"] as! [String]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class TakeBreakResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: TakeBreakResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = TakeBreakResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class TerminateTicketRequest : Tea.TeaModel {
    public var comment: String?

    public var instanceId: String?

    public var ticketId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.comment != nil {
            map["Comment"] = self.comment!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.ticketId != nil {
            map["TicketId"] = self.ticketId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Comment") {
            self.comment = dict["Comment"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("TicketId") {
            self.ticketId = dict["TicketId"] as! String
        }
    }
}

public class TerminateTicketResponseBody : Tea.TeaModel {
    public var code: String?

    public var data: Any?

    public var httpStatusCode: Int32?

    public var message: String?

    public var params: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.params != nil {
            map["Params"] = self.params!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Any
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Params") {
            self.params = dict["Params"] as! [String]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class TerminateTicketResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: TerminateTicketResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = TerminateTicketResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class TransferTicketTaskRequest : Tea.TeaModel {
    public var assignee: String?

    public var comment: String?

    public var instanceId: String?

    public var taskId: String?

    public var ticketId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.assignee != nil {
            map["Assignee"] = self.assignee!
        }
        if self.comment != nil {
            map["Comment"] = self.comment!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        if self.ticketId != nil {
            map["TicketId"] = self.ticketId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Assignee") {
            self.assignee = dict["Assignee"] as! String
        }
        if dict.keys.contains("Comment") {
            self.comment = dict["Comment"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("TaskId") {
            self.taskId = dict["TaskId"] as! String
        }
        if dict.keys.contains("TicketId") {
            self.ticketId = dict["TicketId"] as! String
        }
    }
}

public class TransferTicketTaskResponseBody : Tea.TeaModel {
    public var code: String?

    public var data: Any?

    public var httpStatusCode: Int32?

    public var message: String?

    public var params: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.params != nil {
            map["Params"] = self.params!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Any
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Params") {
            self.params = dict["Params"] as! [String]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class TransferTicketTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: TransferTicketTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = TransferTicketTaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UnmuteCallRequest : Tea.TeaModel {
    public var channelId: String?

    public var deviceId: String?

    public var instanceId: String?

    public var jobId: String?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.channelId != nil {
            map["ChannelId"] = self.channelId!
        }
        if self.deviceId != nil {
            map["DeviceId"] = self.deviceId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ChannelId") {
            self.channelId = dict["ChannelId"] as! String
        }
        if dict.keys.contains("DeviceId") {
            self.deviceId = dict["DeviceId"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("JobId") {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("UserId") {
            self.userId = dict["UserId"] as! String
        }
    }
}

public class UnmuteCallResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class CallContext : Tea.TeaModel {
            public class ChannelContexts : Tea.TeaModel {
                public var callType: String?

                public var channelFlags: String?

                public var channelId: String?

                public var channelState: String?

                public var destination: String?

                public var index: Int32?

                public var jobId: String?

                public var originator: String?

                public var releaseInitiator: String?

                public var releaseReason: String?

                public var skillGroupId: String?

                public var timestamp: Int64?

                public var userExtension: String?

                public var userId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.callType != nil {
                        map["CallType"] = self.callType!
                    }
                    if self.channelFlags != nil {
                        map["ChannelFlags"] = self.channelFlags!
                    }
                    if self.channelId != nil {
                        map["ChannelId"] = self.channelId!
                    }
                    if self.channelState != nil {
                        map["ChannelState"] = self.channelState!
                    }
                    if self.destination != nil {
                        map["Destination"] = self.destination!
                    }
                    if self.index != nil {
                        map["Index"] = self.index!
                    }
                    if self.jobId != nil {
                        map["JobId"] = self.jobId!
                    }
                    if self.originator != nil {
                        map["Originator"] = self.originator!
                    }
                    if self.releaseInitiator != nil {
                        map["ReleaseInitiator"] = self.releaseInitiator!
                    }
                    if self.releaseReason != nil {
                        map["ReleaseReason"] = self.releaseReason!
                    }
                    if self.skillGroupId != nil {
                        map["SkillGroupId"] = self.skillGroupId!
                    }
                    if self.timestamp != nil {
                        map["Timestamp"] = self.timestamp!
                    }
                    if self.userExtension != nil {
                        map["UserExtension"] = self.userExtension!
                    }
                    if self.userId != nil {
                        map["UserId"] = self.userId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("CallType") {
                        self.callType = dict["CallType"] as! String
                    }
                    if dict.keys.contains("ChannelFlags") {
                        self.channelFlags = dict["ChannelFlags"] as! String
                    }
                    if dict.keys.contains("ChannelId") {
                        self.channelId = dict["ChannelId"] as! String
                    }
                    if dict.keys.contains("ChannelState") {
                        self.channelState = dict["ChannelState"] as! String
                    }
                    if dict.keys.contains("Destination") {
                        self.destination = dict["Destination"] as! String
                    }
                    if dict.keys.contains("Index") {
                        self.index = dict["Index"] as! Int32
                    }
                    if dict.keys.contains("JobId") {
                        self.jobId = dict["JobId"] as! String
                    }
                    if dict.keys.contains("Originator") {
                        self.originator = dict["Originator"] as! String
                    }
                    if dict.keys.contains("ReleaseInitiator") {
                        self.releaseInitiator = dict["ReleaseInitiator"] as! String
                    }
                    if dict.keys.contains("ReleaseReason") {
                        self.releaseReason = dict["ReleaseReason"] as! String
                    }
                    if dict.keys.contains("SkillGroupId") {
                        self.skillGroupId = dict["SkillGroupId"] as! String
                    }
                    if dict.keys.contains("Timestamp") {
                        self.timestamp = dict["Timestamp"] as! Int64
                    }
                    if dict.keys.contains("UserExtension") {
                        self.userExtension = dict["UserExtension"] as! String
                    }
                    if dict.keys.contains("UserId") {
                        self.userId = dict["UserId"] as! String
                    }
                }
            }
            public var callType: String?

            public var channelContexts: [UnmuteCallResponseBody.Data.CallContext.ChannelContexts]?

            public var instanceId: String?

            public var jobId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.callType != nil {
                    map["CallType"] = self.callType!
                }
                if self.channelContexts != nil {
                    var tmp : [Any] = []
                    for k in self.channelContexts! {
                        tmp.append(k.toMap())
                    }
                    map["ChannelContexts"] = tmp
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.jobId != nil {
                    map["JobId"] = self.jobId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CallType") {
                    self.callType = dict["CallType"] as! String
                }
                if dict.keys.contains("ChannelContexts") {
                    var tmp : [UnmuteCallResponseBody.Data.CallContext.ChannelContexts] = []
                    for v in dict["ChannelContexts"] as! [Any] {
                        var model = UnmuteCallResponseBody.Data.CallContext.ChannelContexts()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.channelContexts = tmp
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("JobId") {
                    self.jobId = dict["JobId"] as! String
                }
            }
        }
        public class UserContext : Tea.TeaModel {
            public var breakCode: String?

            public var deviceId: String?

            public var extension_: String?

            public var heartbeat: Int64?

            public var instanceId: String?

            public var jobId: String?

            public var mobile: String?

            public var outboundScenario: Bool?

            public var signedSkillGroupIdList: [String]?

            public var userId: String?

            public var userState: String?

            public var workMode: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.breakCode != nil {
                    map["BreakCode"] = self.breakCode!
                }
                if self.deviceId != nil {
                    map["DeviceId"] = self.deviceId!
                }
                if self.extension_ != nil {
                    map["Extension"] = self.extension_!
                }
                if self.heartbeat != nil {
                    map["Heartbeat"] = self.heartbeat!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.jobId != nil {
                    map["JobId"] = self.jobId!
                }
                if self.mobile != nil {
                    map["Mobile"] = self.mobile!
                }
                if self.outboundScenario != nil {
                    map["OutboundScenario"] = self.outboundScenario!
                }
                if self.signedSkillGroupIdList != nil {
                    map["SignedSkillGroupIdList"] = self.signedSkillGroupIdList!
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                if self.userState != nil {
                    map["UserState"] = self.userState!
                }
                if self.workMode != nil {
                    map["WorkMode"] = self.workMode!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BreakCode") {
                    self.breakCode = dict["BreakCode"] as! String
                }
                if dict.keys.contains("DeviceId") {
                    self.deviceId = dict["DeviceId"] as! String
                }
                if dict.keys.contains("Extension") {
                    self.extension_ = dict["Extension"] as! String
                }
                if dict.keys.contains("Heartbeat") {
                    self.heartbeat = dict["Heartbeat"] as! Int64
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("JobId") {
                    self.jobId = dict["JobId"] as! String
                }
                if dict.keys.contains("Mobile") {
                    self.mobile = dict["Mobile"] as! String
                }
                if dict.keys.contains("OutboundScenario") {
                    self.outboundScenario = dict["OutboundScenario"] as! Bool
                }
                if dict.keys.contains("SignedSkillGroupIdList") {
                    self.signedSkillGroupIdList = dict["SignedSkillGroupIdList"] as! [String]
                }
                if dict.keys.contains("UserId") {
                    self.userId = dict["UserId"] as! String
                }
                if dict.keys.contains("UserState") {
                    self.userState = dict["UserState"] as! String
                }
                if dict.keys.contains("WorkMode") {
                    self.workMode = dict["WorkMode"] as! String
                }
            }
        }
        public var callContext: UnmuteCallResponseBody.Data.CallContext?

        public var userContext: UnmuteCallResponseBody.Data.UserContext?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.callContext?.validate()
            try self.userContext?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.callContext != nil {
                map["CallContext"] = self.callContext?.toMap()
            }
            if self.userContext != nil {
                map["UserContext"] = self.userContext?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CallContext") {
                var model = UnmuteCallResponseBody.Data.CallContext()
                model.fromMap(dict["CallContext"] as! [String: Any])
                self.callContext = model
            }
            if dict.keys.contains("UserContext") {
                var model = UnmuteCallResponseBody.Data.UserContext()
                model.fromMap(dict["UserContext"] as! [String: Any])
                self.userContext = model
            }
        }
    }
    public var code: String?

    public var data: UnmuteCallResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var params: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.params != nil {
            map["Params"] = self.params!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            var model = UnmuteCallResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Params") {
            self.params = dict["Params"] as! [String]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UnmuteCallResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UnmuteCallResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UnmuteCallResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UnregisterDeviceRequest : Tea.TeaModel {
    public var instanceId: String?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("UserId") {
            self.userId = dict["UserId"] as! String
        }
    }
}

public class UnregisterDeviceResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UnregisterDeviceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UnregisterDeviceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UnregisterDeviceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateCampaignRequest : Tea.TeaModel {
    public var callableTime: String?

    public var campaignId: String?

    public var contactFlowId: String?

    public var endTime: String?

    public var instanceId: String?

    public var name: String?

    public var startTime: String?

    public var strategyParameters: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.callableTime != nil {
            map["CallableTime"] = self.callableTime!
        }
        if self.campaignId != nil {
            map["CampaignId"] = self.campaignId!
        }
        if self.contactFlowId != nil {
            map["ContactFlowId"] = self.contactFlowId!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.strategyParameters != nil {
            map["StrategyParameters"] = self.strategyParameters!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CallableTime") {
            self.callableTime = dict["CallableTime"] as! String
        }
        if dict.keys.contains("CampaignId") {
            self.campaignId = dict["CampaignId"] as! String
        }
        if dict.keys.contains("ContactFlowId") {
            self.contactFlowId = dict["ContactFlowId"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
        if dict.keys.contains("StrategyParameters") {
            self.strategyParameters = dict["StrategyParameters"] as! String
        }
    }
}

public class UpdateCampaignResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpStatusCode: Int64?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int64
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateCampaignResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateCampaignResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateCampaignResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateConfigItemsRequest : Tea.TeaModel {
    public var configItems: String?

    public var instanceId: String?

    public var objectId: String?

    public var objectType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.configItems != nil {
            map["ConfigItems"] = self.configItems!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.objectId != nil {
            map["ObjectId"] = self.objectId!
        }
        if self.objectType != nil {
            map["ObjectType"] = self.objectType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ConfigItems") {
            self.configItems = dict["ConfigItems"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("ObjectId") {
            self.objectId = dict["ObjectId"] as! String
        }
        if dict.keys.contains("ObjectType") {
            self.objectType = dict["ObjectType"] as! String
        }
    }
}

public class UpdateConfigItemsResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var params: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.params != nil {
            map["Params"] = self.params!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Params") {
            self.params = dict["Params"] as! [String]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateConfigItemsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateConfigItemsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateConfigItemsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateSchemaPropertyRequest : Tea.TeaModel {
    public class Property : Tea.TeaModel {
        public var array: Bool?

        public var attributes: String?

        public var dataType: String?

        public var description_: String?

        public var disabled: Bool?

        public var displayName: String?

        public var displayOrder: Int32?

        public var editorType: String?

        public var maxLength: Int32?

        public var maximum: Double?

        public var minLength: Int32?

        public var minimum: Double?

        public var name: String?

        public var pattern: String?

        public var patternErrorMessage: String?

        public var readOnly: Bool?

        public var required_: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.array != nil {
                map["Array"] = self.array!
            }
            if self.attributes != nil {
                map["Attributes"] = self.attributes!
            }
            if self.dataType != nil {
                map["DataType"] = self.dataType!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.disabled != nil {
                map["Disabled"] = self.disabled!
            }
            if self.displayName != nil {
                map["DisplayName"] = self.displayName!
            }
            if self.displayOrder != nil {
                map["DisplayOrder"] = self.displayOrder!
            }
            if self.editorType != nil {
                map["EditorType"] = self.editorType!
            }
            if self.maxLength != nil {
                map["MaxLength"] = self.maxLength!
            }
            if self.maximum != nil {
                map["Maximum"] = self.maximum!
            }
            if self.minLength != nil {
                map["MinLength"] = self.minLength!
            }
            if self.minimum != nil {
                map["Minimum"] = self.minimum!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.pattern != nil {
                map["Pattern"] = self.pattern!
            }
            if self.patternErrorMessage != nil {
                map["PatternErrorMessage"] = self.patternErrorMessage!
            }
            if self.readOnly != nil {
                map["ReadOnly"] = self.readOnly!
            }
            if self.required_ != nil {
                map["Required"] = self.required_!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Array") {
                self.array = dict["Array"] as! Bool
            }
            if dict.keys.contains("Attributes") {
                self.attributes = dict["Attributes"] as! String
            }
            if dict.keys.contains("DataType") {
                self.dataType = dict["DataType"] as! String
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("Disabled") {
                self.disabled = dict["Disabled"] as! Bool
            }
            if dict.keys.contains("DisplayName") {
                self.displayName = dict["DisplayName"] as! String
            }
            if dict.keys.contains("DisplayOrder") {
                self.displayOrder = dict["DisplayOrder"] as! Int32
            }
            if dict.keys.contains("EditorType") {
                self.editorType = dict["EditorType"] as! String
            }
            if dict.keys.contains("MaxLength") {
                self.maxLength = dict["MaxLength"] as! Int32
            }
            if dict.keys.contains("Maximum") {
                self.maximum = dict["Maximum"] as! Double
            }
            if dict.keys.contains("MinLength") {
                self.minLength = dict["MinLength"] as! Int32
            }
            if dict.keys.contains("Minimum") {
                self.minimum = dict["Minimum"] as! Double
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Pattern") {
                self.pattern = dict["Pattern"] as! String
            }
            if dict.keys.contains("PatternErrorMessage") {
                self.patternErrorMessage = dict["PatternErrorMessage"] as! String
            }
            if dict.keys.contains("ReadOnly") {
                self.readOnly = dict["ReadOnly"] as! Bool
            }
            if dict.keys.contains("Required") {
                self.required_ = dict["Required"] as! Bool
            }
        }
    }
    public var instanceId: String?

    public var property: UpdateSchemaPropertyRequest.Property?

    public var requestId: String?

    public var schemaId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.property?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.property != nil {
            map["Property"] = self.property?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.schemaId != nil {
            map["SchemaId"] = self.schemaId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Property") {
            var model = UpdateSchemaPropertyRequest.Property()
            model.fromMap(dict["Property"] as! [String: Any])
            self.property = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SchemaId") {
            self.schemaId = dict["SchemaId"] as! String
        }
    }
}

public class UpdateSchemaPropertyShrinkRequest : Tea.TeaModel {
    public var instanceId: String?

    public var propertyShrink: String?

    public var requestId: String?

    public var schemaId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.propertyShrink != nil {
            map["Property"] = self.propertyShrink!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.schemaId != nil {
            map["SchemaId"] = self.schemaId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Property") {
            self.propertyShrink = dict["Property"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SchemaId") {
            self.schemaId = dict["SchemaId"] as! String
        }
    }
}

public class UpdateSchemaPropertyResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var params: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.params != nil {
            map["Params"] = self.params!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Params") {
            self.params = dict["Params"] as! [String]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateSchemaPropertyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateSchemaPropertyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateSchemaPropertyResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateTicketRequest : Tea.TeaModel {
    public var context: String?

    public var customerId: String?

    public var instanceId: String?

    public var ticketId: String?

    public var title: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.context != nil {
            map["Context"] = self.context!
        }
        if self.customerId != nil {
            map["CustomerId"] = self.customerId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.ticketId != nil {
            map["TicketId"] = self.ticketId!
        }
        if self.title != nil {
            map["Title"] = self.title!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Context") {
            self.context = dict["Context"] as! String
        }
        if dict.keys.contains("CustomerId") {
            self.customerId = dict["CustomerId"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("TicketId") {
            self.ticketId = dict["TicketId"] as! String
        }
        if dict.keys.contains("Title") {
            self.title = dict["Title"] as! String
        }
    }
}

public class UpdateTicketResponseBody : Tea.TeaModel {
    public var code: String?

    public var data: Any?

    public var httpStatusCode: Int32?

    public var message: String?

    public var params: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.params != nil {
            map["Params"] = self.params!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Any
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Params") {
            self.params = dict["Params"] as! [String]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateTicketResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateTicketResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateTicketResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class WithdrawTicketRequest : Tea.TeaModel {
    public var comment: String?

    public var instanceId: String?

    public var ticketId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.comment != nil {
            map["Comment"] = self.comment!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.ticketId != nil {
            map["TicketId"] = self.ticketId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Comment") {
            self.comment = dict["Comment"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("TicketId") {
            self.ticketId = dict["TicketId"] as! String
        }
    }
}

public class WithdrawTicketResponseBody : Tea.TeaModel {
    public var code: String?

    public var data: Any?

    public var httpStatusCode: Int32?

    public var message: String?

    public var params: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.params != nil {
            map["Params"] = self.params!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") {
            self.data = dict["Data"] as! Any
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Params") {
            self.params = dict["Params"] as! [String]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class WithdrawTicketResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: WithdrawTicketResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = WithdrawTicketResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}
