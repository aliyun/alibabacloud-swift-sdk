import Foundation
import Tea
import TeaUtils
import AlibabacloudOpenApi
import AlibabaCloudOpenApiUtil
import AlibabacloudEndpointUtil

public class AbortCampaignRequest : Tea.TeaModel {
    public var campaignId: String?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.campaignId != nil {
            map["CampaignId"] = self.campaignId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CampaignId") && dict["CampaignId"] != nil {
            self.campaignId = dict["CampaignId"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
    }
}

public class AbortCampaignResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpStatusCode: String?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AbortCampaignResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AbortCampaignResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = AbortCampaignResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddCasesRequest : Tea.TeaModel {
    public class CaseList : Tea.TeaModel {
        public var caller: String?

        public var customVariables: String?

        public var maskedCallee: String?

        public var phoneNumber: String?

        public var referenceId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.caller != nil {
                map["Caller"] = self.caller!
            }
            if self.customVariables != nil {
                map["CustomVariables"] = self.customVariables!
            }
            if self.maskedCallee != nil {
                map["MaskedCallee"] = self.maskedCallee!
            }
            if self.phoneNumber != nil {
                map["PhoneNumber"] = self.phoneNumber!
            }
            if self.referenceId != nil {
                map["ReferenceId"] = self.referenceId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Caller") && dict["Caller"] != nil {
                self.caller = dict["Caller"] as! String
            }
            if dict.keys.contains("CustomVariables") && dict["CustomVariables"] != nil {
                self.customVariables = dict["CustomVariables"] as! String
            }
            if dict.keys.contains("MaskedCallee") && dict["MaskedCallee"] != nil {
                self.maskedCallee = dict["MaskedCallee"] as! String
            }
            if dict.keys.contains("PhoneNumber") && dict["PhoneNumber"] != nil {
                self.phoneNumber = dict["PhoneNumber"] as! String
            }
            if dict.keys.contains("ReferenceId") && dict["ReferenceId"] != nil {
                self.referenceId = dict["ReferenceId"] as! String
            }
        }
    }
    public var campaignId: String?

    public var caseList: [AddCasesRequest.CaseList]?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.campaignId != nil {
            map["CampaignId"] = self.campaignId!
        }
        if self.caseList != nil {
            var tmp : [Any] = []
            for k in self.caseList! {
                tmp.append(k.toMap())
            }
            map["CaseList"] = tmp
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CampaignId") && dict["CampaignId"] != nil {
            self.campaignId = dict["CampaignId"] as! String
        }
        if dict.keys.contains("CaseList") && dict["CaseList"] != nil {
            var tmp : [AddCasesRequest.CaseList] = []
            for v in dict["CaseList"] as! [Any] {
                var model = AddCasesRequest.CaseList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.caseList = tmp
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
    }
}

public class AddCasesShrinkRequest : Tea.TeaModel {
    public var campaignId: String?

    public var caseListShrink: String?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.campaignId != nil {
            map["CampaignId"] = self.campaignId!
        }
        if self.caseListShrink != nil {
            map["CaseList"] = self.caseListShrink!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CampaignId") && dict["CampaignId"] != nil {
            self.campaignId = dict["CampaignId"] as! String
        }
        if dict.keys.contains("CaseList") && dict["CaseList"] != nil {
            self.caseListShrink = dict["CaseList"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
    }
}

public class AddCasesResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpStatusCode: String?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AddCasesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddCasesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = AddCasesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddNumbersToSkillGroupRequest : Tea.TeaModel {
    public var instanceId: String?

    public var numberList: String?

    public var skillGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.numberList != nil {
            map["NumberList"] = self.numberList!
        }
        if self.skillGroupId != nil {
            map["SkillGroupId"] = self.skillGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("NumberList") && dict["NumberList"] != nil {
            self.numberList = dict["NumberList"] as! String
        }
        if dict.keys.contains("SkillGroupId") && dict["SkillGroupId"] != nil {
            self.skillGroupId = dict["SkillGroupId"] as! String
        }
    }
}

public class AddNumbersToSkillGroupResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AddNumbersToSkillGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddNumbersToSkillGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = AddNumbersToSkillGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddPersonalNumbersToUserRequest : Tea.TeaModel {
    public var instanceId: String?

    public var numberList: String?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.numberList != nil {
            map["NumberList"] = self.numberList!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("NumberList") && dict["NumberList"] != nil {
            self.numberList = dict["NumberList"] as! String
        }
        if dict.keys.contains("UserId") && dict["UserId"] != nil {
            self.userId = dict["UserId"] as! String
        }
    }
}

public class AddPersonalNumbersToUserResponseBody : Tea.TeaModel {
    public var code: String?

    public var data: [String]?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! [String]
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AddPersonalNumbersToUserResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddPersonalNumbersToUserResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = AddPersonalNumbersToUserResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddPhoneNumberToSkillGroupsRequest : Tea.TeaModel {
    public var instanceId: String?

    public var number: String?

    public var skillGroupIdList: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.number != nil {
            map["Number"] = self.number!
        }
        if self.skillGroupIdList != nil {
            map["SkillGroupIdList"] = self.skillGroupIdList!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Number") && dict["Number"] != nil {
            self.number = dict["Number"] as! String
        }
        if dict.keys.contains("SkillGroupIdList") && dict["SkillGroupIdList"] != nil {
            self.skillGroupIdList = dict["SkillGroupIdList"] as! String
        }
    }
}

public class AddPhoneNumberToSkillGroupsResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AddPhoneNumberToSkillGroupsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddPhoneNumberToSkillGroupsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = AddPhoneNumberToSkillGroupsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddPhoneNumbersRequest : Tea.TeaModel {
    public var contactFlowId: String?

    public var instanceId: String?

    public var numberGroupId: String?

    public var numberList: String?

    public var usage: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.contactFlowId != nil {
            map["ContactFlowId"] = self.contactFlowId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.numberGroupId != nil {
            map["NumberGroupId"] = self.numberGroupId!
        }
        if self.numberList != nil {
            map["NumberList"] = self.numberList!
        }
        if self.usage != nil {
            map["Usage"] = self.usage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ContactFlowId") && dict["ContactFlowId"] != nil {
            self.contactFlowId = dict["ContactFlowId"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("NumberGroupId") && dict["NumberGroupId"] != nil {
            self.numberGroupId = dict["NumberGroupId"] as! String
        }
        if dict.keys.contains("NumberList") && dict["NumberList"] != nil {
            self.numberList = dict["NumberList"] as! String
        }
        if dict.keys.contains("Usage") && dict["Usage"] != nil {
            self.usage = dict["Usage"] as! String
        }
    }
}

public class AddPhoneNumbersResponseBody : Tea.TeaModel {
    public var code: String?

    public var data: [String]?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! [String]
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AddPhoneNumbersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddPhoneNumbersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = AddPhoneNumbersResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddSkillGroupsToUserRequest : Tea.TeaModel {
    public var instanceId: String?

    public var skillLevelList: String?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.skillLevelList != nil {
            map["SkillLevelList"] = self.skillLevelList!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("SkillLevelList") && dict["SkillLevelList"] != nil {
            self.skillLevelList = dict["SkillLevelList"] as! String
        }
        if dict.keys.contains("UserId") && dict["UserId"] != nil {
            self.userId = dict["UserId"] as! String
        }
    }
}

public class AddSkillGroupsToUserResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AddSkillGroupsToUserResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddSkillGroupsToUserResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = AddSkillGroupsToUserResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddUsersToSkillGroupRequest : Tea.TeaModel {
    public var instanceId: String?

    public var skillGroupId: String?

    public var userSkillLevelList: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.skillGroupId != nil {
            map["SkillGroupId"] = self.skillGroupId!
        }
        if self.userSkillLevelList != nil {
            map["UserSkillLevelList"] = self.userSkillLevelList!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("SkillGroupId") && dict["SkillGroupId"] != nil {
            self.skillGroupId = dict["SkillGroupId"] as! String
        }
        if dict.keys.contains("UserSkillLevelList") && dict["UserSkillLevelList"] != nil {
            self.userSkillLevelList = dict["UserSkillLevelList"] as! String
        }
    }
}

public class AddUsersToSkillGroupResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AddUsersToSkillGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddUsersToSkillGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = AddUsersToSkillGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AnswerCallRequest : Tea.TeaModel {
    public var deviceId: String?

    public var instanceId: String?

    public var jobId: String?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.deviceId != nil {
            map["DeviceId"] = self.deviceId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DeviceId") && dict["DeviceId"] != nil {
            self.deviceId = dict["DeviceId"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("JobId") && dict["JobId"] != nil {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("UserId") && dict["UserId"] != nil {
            self.userId = dict["UserId"] as! String
        }
    }
}

public class AnswerCallResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class CallContext : Tea.TeaModel {
            public class ChannelContexts : Tea.TeaModel {
                public var callType: String?

                public var channelId: String?

                public var channelState: String?

                public var destination: String?

                public var jobId: String?

                public var originator: String?

                public var releaseInitiator: String?

                public var releaseReason: String?

                public var skillGroupId: String?

                public var timestamp: Int64?

                public var userExtension: String?

                public var userId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.callType != nil {
                        map["CallType"] = self.callType!
                    }
                    if self.channelId != nil {
                        map["ChannelId"] = self.channelId!
                    }
                    if self.channelState != nil {
                        map["ChannelState"] = self.channelState!
                    }
                    if self.destination != nil {
                        map["Destination"] = self.destination!
                    }
                    if self.jobId != nil {
                        map["JobId"] = self.jobId!
                    }
                    if self.originator != nil {
                        map["Originator"] = self.originator!
                    }
                    if self.releaseInitiator != nil {
                        map["ReleaseInitiator"] = self.releaseInitiator!
                    }
                    if self.releaseReason != nil {
                        map["ReleaseReason"] = self.releaseReason!
                    }
                    if self.skillGroupId != nil {
                        map["SkillGroupId"] = self.skillGroupId!
                    }
                    if self.timestamp != nil {
                        map["Timestamp"] = self.timestamp!
                    }
                    if self.userExtension != nil {
                        map["UserExtension"] = self.userExtension!
                    }
                    if self.userId != nil {
                        map["UserId"] = self.userId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("CallType") && dict["CallType"] != nil {
                        self.callType = dict["CallType"] as! String
                    }
                    if dict.keys.contains("ChannelId") && dict["ChannelId"] != nil {
                        self.channelId = dict["ChannelId"] as! String
                    }
                    if dict.keys.contains("ChannelState") && dict["ChannelState"] != nil {
                        self.channelState = dict["ChannelState"] as! String
                    }
                    if dict.keys.contains("Destination") && dict["Destination"] != nil {
                        self.destination = dict["Destination"] as! String
                    }
                    if dict.keys.contains("JobId") && dict["JobId"] != nil {
                        self.jobId = dict["JobId"] as! String
                    }
                    if dict.keys.contains("Originator") && dict["Originator"] != nil {
                        self.originator = dict["Originator"] as! String
                    }
                    if dict.keys.contains("ReleaseInitiator") && dict["ReleaseInitiator"] != nil {
                        self.releaseInitiator = dict["ReleaseInitiator"] as! String
                    }
                    if dict.keys.contains("ReleaseReason") && dict["ReleaseReason"] != nil {
                        self.releaseReason = dict["ReleaseReason"] as! String
                    }
                    if dict.keys.contains("SkillGroupId") && dict["SkillGroupId"] != nil {
                        self.skillGroupId = dict["SkillGroupId"] as! String
                    }
                    if dict.keys.contains("Timestamp") && dict["Timestamp"] != nil {
                        self.timestamp = dict["Timestamp"] as! Int64
                    }
                    if dict.keys.contains("UserExtension") && dict["UserExtension"] != nil {
                        self.userExtension = dict["UserExtension"] as! String
                    }
                    if dict.keys.contains("UserId") && dict["UserId"] != nil {
                        self.userId = dict["UserId"] as! String
                    }
                }
            }
            public var callType: String?

            public var channelContexts: [AnswerCallResponseBody.Data.CallContext.ChannelContexts]?

            public var instanceId: String?

            public var jobId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.callType != nil {
                    map["CallType"] = self.callType!
                }
                if self.channelContexts != nil {
                    var tmp : [Any] = []
                    for k in self.channelContexts! {
                        tmp.append(k.toMap())
                    }
                    map["ChannelContexts"] = tmp
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.jobId != nil {
                    map["JobId"] = self.jobId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CallType") && dict["CallType"] != nil {
                    self.callType = dict["CallType"] as! String
                }
                if dict.keys.contains("ChannelContexts") && dict["ChannelContexts"] != nil {
                    var tmp : [AnswerCallResponseBody.Data.CallContext.ChannelContexts] = []
                    for v in dict["ChannelContexts"] as! [Any] {
                        var model = AnswerCallResponseBody.Data.CallContext.ChannelContexts()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.channelContexts = tmp
                }
                if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("JobId") && dict["JobId"] != nil {
                    self.jobId = dict["JobId"] as! String
                }
            }
        }
        public class UserContext : Tea.TeaModel {
            public var breakCode: String?

            public var deviceId: String?

            public var extension_: String?

            public var heartbeat: Int64?

            public var instanceId: String?

            public var jobId: String?

            public var mobile: String?

            public var outboundScenario: Bool?

            public var reserved: Int64?

            public var signedSkillGroupIdList: [String]?

            public var userId: String?

            public var userState: String?

            public var workMode: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.breakCode != nil {
                    map["BreakCode"] = self.breakCode!
                }
                if self.deviceId != nil {
                    map["DeviceId"] = self.deviceId!
                }
                if self.extension_ != nil {
                    map["Extension"] = self.extension_!
                }
                if self.heartbeat != nil {
                    map["Heartbeat"] = self.heartbeat!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.jobId != nil {
                    map["JobId"] = self.jobId!
                }
                if self.mobile != nil {
                    map["Mobile"] = self.mobile!
                }
                if self.outboundScenario != nil {
                    map["OutboundScenario"] = self.outboundScenario!
                }
                if self.reserved != nil {
                    map["Reserved"] = self.reserved!
                }
                if self.signedSkillGroupIdList != nil {
                    map["SignedSkillGroupIdList"] = self.signedSkillGroupIdList!
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                if self.userState != nil {
                    map["UserState"] = self.userState!
                }
                if self.workMode != nil {
                    map["WorkMode"] = self.workMode!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BreakCode") && dict["BreakCode"] != nil {
                    self.breakCode = dict["BreakCode"] as! String
                }
                if dict.keys.contains("DeviceId") && dict["DeviceId"] != nil {
                    self.deviceId = dict["DeviceId"] as! String
                }
                if dict.keys.contains("Extension") && dict["Extension"] != nil {
                    self.extension_ = dict["Extension"] as! String
                }
                if dict.keys.contains("Heartbeat") && dict["Heartbeat"] != nil {
                    self.heartbeat = dict["Heartbeat"] as! Int64
                }
                if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("JobId") && dict["JobId"] != nil {
                    self.jobId = dict["JobId"] as! String
                }
                if dict.keys.contains("Mobile") && dict["Mobile"] != nil {
                    self.mobile = dict["Mobile"] as! String
                }
                if dict.keys.contains("OutboundScenario") && dict["OutboundScenario"] != nil {
                    self.outboundScenario = dict["OutboundScenario"] as! Bool
                }
                if dict.keys.contains("Reserved") && dict["Reserved"] != nil {
                    self.reserved = dict["Reserved"] as! Int64
                }
                if dict.keys.contains("SignedSkillGroupIdList") && dict["SignedSkillGroupIdList"] != nil {
                    self.signedSkillGroupIdList = dict["SignedSkillGroupIdList"] as! [String]
                }
                if dict.keys.contains("UserId") && dict["UserId"] != nil {
                    self.userId = dict["UserId"] as! String
                }
                if dict.keys.contains("UserState") && dict["UserState"] != nil {
                    self.userState = dict["UserState"] as! String
                }
                if dict.keys.contains("WorkMode") && dict["WorkMode"] != nil {
                    self.workMode = dict["WorkMode"] as! String
                }
            }
        }
        public var callContext: AnswerCallResponseBody.Data.CallContext?

        public var contextId: Int64?

        public var userContext: AnswerCallResponseBody.Data.UserContext?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.callContext?.validate()
            try self.userContext?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.callContext != nil {
                map["CallContext"] = self.callContext?.toMap()
            }
            if self.contextId != nil {
                map["ContextId"] = self.contextId!
            }
            if self.userContext != nil {
                map["UserContext"] = self.userContext?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CallContext") && dict["CallContext"] != nil {
                var model = AnswerCallResponseBody.Data.CallContext()
                model.fromMap(dict["CallContext"] as! [String: Any])
                self.callContext = model
            }
            if dict.keys.contains("ContextId") && dict["ContextId"] != nil {
                self.contextId = dict["ContextId"] as! Int64
            }
            if dict.keys.contains("UserContext") && dict["UserContext"] != nil {
                var model = AnswerCallResponseBody.Data.UserContext()
                model.fromMap(dict["UserContext"] as! [String: Any])
                self.userContext = model
            }
        }
    }
    public var code: String?

    public var data: AnswerCallResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var params: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.params != nil {
            map["Params"] = self.params!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = AnswerCallResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Params") && dict["Params"] != nil {
            self.params = dict["Params"] as! [String]
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AnswerCallResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AnswerCallResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = AnswerCallResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AppendCasesRequest : Tea.TeaModel {
    public class Body : Tea.TeaModel {
        public var agentId: String?

        public var caller: String?

        public var customVariables: String?

        public var maskedCallee: String?

        public var phoneNumber: String?

        public var referenceId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.agentId != nil {
                map["AgentId"] = self.agentId!
            }
            if self.caller != nil {
                map["Caller"] = self.caller!
            }
            if self.customVariables != nil {
                map["CustomVariables"] = self.customVariables!
            }
            if self.maskedCallee != nil {
                map["MaskedCallee"] = self.maskedCallee!
            }
            if self.phoneNumber != nil {
                map["PhoneNumber"] = self.phoneNumber!
            }
            if self.referenceId != nil {
                map["ReferenceId"] = self.referenceId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AgentId") && dict["AgentId"] != nil {
                self.agentId = dict["AgentId"] as! String
            }
            if dict.keys.contains("Caller") && dict["Caller"] != nil {
                self.caller = dict["Caller"] as! String
            }
            if dict.keys.contains("CustomVariables") && dict["CustomVariables"] != nil {
                self.customVariables = dict["CustomVariables"] as! String
            }
            if dict.keys.contains("MaskedCallee") && dict["MaskedCallee"] != nil {
                self.maskedCallee = dict["MaskedCallee"] as! String
            }
            if dict.keys.contains("PhoneNumber") && dict["PhoneNumber"] != nil {
                self.phoneNumber = dict["PhoneNumber"] as! String
            }
            if dict.keys.contains("ReferenceId") && dict["ReferenceId"] != nil {
                self.referenceId = dict["ReferenceId"] as! String
            }
        }
    }
    public var campaignId: String?

    public var instanceId: String?

    public var body: [AppendCasesRequest.Body]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.campaignId != nil {
            map["CampaignId"] = self.campaignId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.body != nil {
            var tmp : [Any] = []
            for k in self.body! {
                tmp.append(k.toMap())
            }
            map["body"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CampaignId") && dict["CampaignId"] != nil {
            self.campaignId = dict["CampaignId"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var tmp : [AppendCasesRequest.Body] = []
            for v in dict["body"] as! [Any] {
                var model = AppendCasesRequest.Body()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.body = tmp
        }
    }
}

public class AppendCasesShrinkRequest : Tea.TeaModel {
    public var campaignId: String?

    public var instanceId: String?

    public var bodyShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.campaignId != nil {
            map["CampaignId"] = self.campaignId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.bodyShrink != nil {
            map["body"] = self.bodyShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CampaignId") && dict["CampaignId"] != nil {
            self.campaignId = dict["CampaignId"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            self.bodyShrink = dict["body"] as! String
        }
    }
}

public class AppendCasesResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpStatusCode: String?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AppendCasesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AppendCasesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = AppendCasesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AssignUsersRequest : Tea.TeaModel {
    public var instanceId: String?

    public var ramIdList: String?

    public var roleId: String?

    public var skillLevelList: String?

    public var workMode: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.ramIdList != nil {
            map["RamIdList"] = self.ramIdList!
        }
        if self.roleId != nil {
            map["RoleId"] = self.roleId!
        }
        if self.skillLevelList != nil {
            map["SkillLevelList"] = self.skillLevelList!
        }
        if self.workMode != nil {
            map["WorkMode"] = self.workMode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("RamIdList") && dict["RamIdList"] != nil {
            self.ramIdList = dict["RamIdList"] as! String
        }
        if dict.keys.contains("RoleId") && dict["RoleId"] != nil {
            self.roleId = dict["RoleId"] as! String
        }
        if dict.keys.contains("SkillLevelList") && dict["SkillLevelList"] != nil {
            self.skillLevelList = dict["SkillLevelList"] as! String
        }
        if dict.keys.contains("WorkMode") && dict["WorkMode"] != nil {
            self.workMode = dict["WorkMode"] as! String
        }
    }
}

public class AssignUsersResponseBody : Tea.TeaModel {
    public var code: String?

    public var data: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var workflowId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.workflowId != nil {
            map["WorkflowId"] = self.workflowId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("WorkflowId") && dict["WorkflowId"] != nil {
            self.workflowId = dict["WorkflowId"] as! String
        }
    }
}

public class AssignUsersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AssignUsersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = AssignUsersResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class BargeInCallRequest : Tea.TeaModel {
    public var bargedUserId: String?

    public var deviceId: String?

    public var instanceId: String?

    public var jobId: String?

    public var timeoutSeconds: Int32?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bargedUserId != nil {
            map["BargedUserId"] = self.bargedUserId!
        }
        if self.deviceId != nil {
            map["DeviceId"] = self.deviceId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.timeoutSeconds != nil {
            map["TimeoutSeconds"] = self.timeoutSeconds!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BargedUserId") && dict["BargedUserId"] != nil {
            self.bargedUserId = dict["BargedUserId"] as! String
        }
        if dict.keys.contains("DeviceId") && dict["DeviceId"] != nil {
            self.deviceId = dict["DeviceId"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("JobId") && dict["JobId"] != nil {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("TimeoutSeconds") && dict["TimeoutSeconds"] != nil {
            self.timeoutSeconds = dict["TimeoutSeconds"] as! Int32
        }
        if dict.keys.contains("UserId") && dict["UserId"] != nil {
            self.userId = dict["UserId"] as! String
        }
    }
}

public class BargeInCallResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class CallContext : Tea.TeaModel {
            public class ChannelContexts : Tea.TeaModel {
                public var callType: String?

                public var channelFlags: String?

                public var channelId: String?

                public var channelState: String?

                public var destination: String?

                public var index: Int32?

                public var jobId: String?

                public var originator: String?

                public var releaseInitiator: String?

                public var releaseReason: String?

                public var skillGroupId: String?

                public var timestamp: Int64?

                public var userExtension: String?

                public var userId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.callType != nil {
                        map["CallType"] = self.callType!
                    }
                    if self.channelFlags != nil {
                        map["ChannelFlags"] = self.channelFlags!
                    }
                    if self.channelId != nil {
                        map["ChannelId"] = self.channelId!
                    }
                    if self.channelState != nil {
                        map["ChannelState"] = self.channelState!
                    }
                    if self.destination != nil {
                        map["Destination"] = self.destination!
                    }
                    if self.index != nil {
                        map["Index"] = self.index!
                    }
                    if self.jobId != nil {
                        map["JobId"] = self.jobId!
                    }
                    if self.originator != nil {
                        map["Originator"] = self.originator!
                    }
                    if self.releaseInitiator != nil {
                        map["ReleaseInitiator"] = self.releaseInitiator!
                    }
                    if self.releaseReason != nil {
                        map["ReleaseReason"] = self.releaseReason!
                    }
                    if self.skillGroupId != nil {
                        map["SkillGroupId"] = self.skillGroupId!
                    }
                    if self.timestamp != nil {
                        map["Timestamp"] = self.timestamp!
                    }
                    if self.userExtension != nil {
                        map["UserExtension"] = self.userExtension!
                    }
                    if self.userId != nil {
                        map["UserId"] = self.userId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("CallType") && dict["CallType"] != nil {
                        self.callType = dict["CallType"] as! String
                    }
                    if dict.keys.contains("ChannelFlags") && dict["ChannelFlags"] != nil {
                        self.channelFlags = dict["ChannelFlags"] as! String
                    }
                    if dict.keys.contains("ChannelId") && dict["ChannelId"] != nil {
                        self.channelId = dict["ChannelId"] as! String
                    }
                    if dict.keys.contains("ChannelState") && dict["ChannelState"] != nil {
                        self.channelState = dict["ChannelState"] as! String
                    }
                    if dict.keys.contains("Destination") && dict["Destination"] != nil {
                        self.destination = dict["Destination"] as! String
                    }
                    if dict.keys.contains("Index") && dict["Index"] != nil {
                        self.index = dict["Index"] as! Int32
                    }
                    if dict.keys.contains("JobId") && dict["JobId"] != nil {
                        self.jobId = dict["JobId"] as! String
                    }
                    if dict.keys.contains("Originator") && dict["Originator"] != nil {
                        self.originator = dict["Originator"] as! String
                    }
                    if dict.keys.contains("ReleaseInitiator") && dict["ReleaseInitiator"] != nil {
                        self.releaseInitiator = dict["ReleaseInitiator"] as! String
                    }
                    if dict.keys.contains("ReleaseReason") && dict["ReleaseReason"] != nil {
                        self.releaseReason = dict["ReleaseReason"] as! String
                    }
                    if dict.keys.contains("SkillGroupId") && dict["SkillGroupId"] != nil {
                        self.skillGroupId = dict["SkillGroupId"] as! String
                    }
                    if dict.keys.contains("Timestamp") && dict["Timestamp"] != nil {
                        self.timestamp = dict["Timestamp"] as! Int64
                    }
                    if dict.keys.contains("UserExtension") && dict["UserExtension"] != nil {
                        self.userExtension = dict["UserExtension"] as! String
                    }
                    if dict.keys.contains("UserId") && dict["UserId"] != nil {
                        self.userId = dict["UserId"] as! String
                    }
                }
            }
            public var callType: String?

            public var channelContexts: [BargeInCallResponseBody.Data.CallContext.ChannelContexts]?

            public var instanceId: String?

            public var jobId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.callType != nil {
                    map["CallType"] = self.callType!
                }
                if self.channelContexts != nil {
                    var tmp : [Any] = []
                    for k in self.channelContexts! {
                        tmp.append(k.toMap())
                    }
                    map["ChannelContexts"] = tmp
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.jobId != nil {
                    map["JobId"] = self.jobId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CallType") && dict["CallType"] != nil {
                    self.callType = dict["CallType"] as! String
                }
                if dict.keys.contains("ChannelContexts") && dict["ChannelContexts"] != nil {
                    var tmp : [BargeInCallResponseBody.Data.CallContext.ChannelContexts] = []
                    for v in dict["ChannelContexts"] as! [Any] {
                        var model = BargeInCallResponseBody.Data.CallContext.ChannelContexts()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.channelContexts = tmp
                }
                if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("JobId") && dict["JobId"] != nil {
                    self.jobId = dict["JobId"] as! String
                }
            }
        }
        public class UserContext : Tea.TeaModel {
            public var breakCode: String?

            public var deviceId: String?

            public var extension_: String?

            public var heartbeat: Int64?

            public var instanceId: String?

            public var jobId: String?

            public var mobile: String?

            public var outboundScenario: Bool?

            public var reserved: Int64?

            public var signedSkillGroupIdList: [String]?

            public var userId: String?

            public var userState: String?

            public var workMode: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.breakCode != nil {
                    map["BreakCode"] = self.breakCode!
                }
                if self.deviceId != nil {
                    map["DeviceId"] = self.deviceId!
                }
                if self.extension_ != nil {
                    map["Extension"] = self.extension_!
                }
                if self.heartbeat != nil {
                    map["Heartbeat"] = self.heartbeat!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.jobId != nil {
                    map["JobId"] = self.jobId!
                }
                if self.mobile != nil {
                    map["Mobile"] = self.mobile!
                }
                if self.outboundScenario != nil {
                    map["OutboundScenario"] = self.outboundScenario!
                }
                if self.reserved != nil {
                    map["Reserved"] = self.reserved!
                }
                if self.signedSkillGroupIdList != nil {
                    map["SignedSkillGroupIdList"] = self.signedSkillGroupIdList!
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                if self.userState != nil {
                    map["UserState"] = self.userState!
                }
                if self.workMode != nil {
                    map["WorkMode"] = self.workMode!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BreakCode") && dict["BreakCode"] != nil {
                    self.breakCode = dict["BreakCode"] as! String
                }
                if dict.keys.contains("DeviceId") && dict["DeviceId"] != nil {
                    self.deviceId = dict["DeviceId"] as! String
                }
                if dict.keys.contains("Extension") && dict["Extension"] != nil {
                    self.extension_ = dict["Extension"] as! String
                }
                if dict.keys.contains("Heartbeat") && dict["Heartbeat"] != nil {
                    self.heartbeat = dict["Heartbeat"] as! Int64
                }
                if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("JobId") && dict["JobId"] != nil {
                    self.jobId = dict["JobId"] as! String
                }
                if dict.keys.contains("Mobile") && dict["Mobile"] != nil {
                    self.mobile = dict["Mobile"] as! String
                }
                if dict.keys.contains("OutboundScenario") && dict["OutboundScenario"] != nil {
                    self.outboundScenario = dict["OutboundScenario"] as! Bool
                }
                if dict.keys.contains("Reserved") && dict["Reserved"] != nil {
                    self.reserved = dict["Reserved"] as! Int64
                }
                if dict.keys.contains("SignedSkillGroupIdList") && dict["SignedSkillGroupIdList"] != nil {
                    self.signedSkillGroupIdList = dict["SignedSkillGroupIdList"] as! [String]
                }
                if dict.keys.contains("UserId") && dict["UserId"] != nil {
                    self.userId = dict["UserId"] as! String
                }
                if dict.keys.contains("UserState") && dict["UserState"] != nil {
                    self.userState = dict["UserState"] as! String
                }
                if dict.keys.contains("WorkMode") && dict["WorkMode"] != nil {
                    self.workMode = dict["WorkMode"] as! String
                }
            }
        }
        public var callContext: BargeInCallResponseBody.Data.CallContext?

        public var userContext: BargeInCallResponseBody.Data.UserContext?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.callContext?.validate()
            try self.userContext?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.callContext != nil {
                map["CallContext"] = self.callContext?.toMap()
            }
            if self.userContext != nil {
                map["UserContext"] = self.userContext?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CallContext") && dict["CallContext"] != nil {
                var model = BargeInCallResponseBody.Data.CallContext()
                model.fromMap(dict["CallContext"] as! [String: Any])
                self.callContext = model
            }
            if dict.keys.contains("UserContext") && dict["UserContext"] != nil {
                var model = BargeInCallResponseBody.Data.UserContext()
                model.fromMap(dict["UserContext"] as! [String: Any])
                self.userContext = model
            }
        }
    }
    public var code: String?

    public var data: BargeInCallResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var params: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.params != nil {
            map["Params"] = self.params!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = BargeInCallResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Params") && dict["Params"] != nil {
            self.params = dict["Params"] as! [String]
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class BargeInCallResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: BargeInCallResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = BargeInCallResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class BlindTransferRequest : Tea.TeaModel {
    public var callPriority: Int32?

    public var deviceId: String?

    public var instanceId: String?

    public var jobId: String?

    public var strategyName: String?

    public var strategyParams: String?

    public var timeoutSeconds: Int32?

    public var transferee: String?

    public var transferor: String?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.callPriority != nil {
            map["CallPriority"] = self.callPriority!
        }
        if self.deviceId != nil {
            map["DeviceId"] = self.deviceId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.strategyName != nil {
            map["StrategyName"] = self.strategyName!
        }
        if self.strategyParams != nil {
            map["StrategyParams"] = self.strategyParams!
        }
        if self.timeoutSeconds != nil {
            map["TimeoutSeconds"] = self.timeoutSeconds!
        }
        if self.transferee != nil {
            map["Transferee"] = self.transferee!
        }
        if self.transferor != nil {
            map["Transferor"] = self.transferor!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CallPriority") && dict["CallPriority"] != nil {
            self.callPriority = dict["CallPriority"] as! Int32
        }
        if dict.keys.contains("DeviceId") && dict["DeviceId"] != nil {
            self.deviceId = dict["DeviceId"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("JobId") && dict["JobId"] != nil {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("StrategyName") && dict["StrategyName"] != nil {
            self.strategyName = dict["StrategyName"] as! String
        }
        if dict.keys.contains("StrategyParams") && dict["StrategyParams"] != nil {
            self.strategyParams = dict["StrategyParams"] as! String
        }
        if dict.keys.contains("TimeoutSeconds") && dict["TimeoutSeconds"] != nil {
            self.timeoutSeconds = dict["TimeoutSeconds"] as! Int32
        }
        if dict.keys.contains("Transferee") && dict["Transferee"] != nil {
            self.transferee = dict["Transferee"] as! String
        }
        if dict.keys.contains("Transferor") && dict["Transferor"] != nil {
            self.transferor = dict["Transferor"] as! String
        }
        if dict.keys.contains("UserId") && dict["UserId"] != nil {
            self.userId = dict["UserId"] as! String
        }
    }
}

public class BlindTransferResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class CallContext : Tea.TeaModel {
            public class ChannelContexts : Tea.TeaModel {
                public var callType: String?

                public var channelFlags: String?

                public var channelId: String?

                public var channelState: String?

                public var destination: String?

                public var jobId: String?

                public var originator: String?

                public var releaseInitiator: String?

                public var releaseReason: String?

                public var timestamp: Int64?

                public var userExtension: String?

                public var userId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.callType != nil {
                        map["CallType"] = self.callType!
                    }
                    if self.channelFlags != nil {
                        map["ChannelFlags"] = self.channelFlags!
                    }
                    if self.channelId != nil {
                        map["ChannelId"] = self.channelId!
                    }
                    if self.channelState != nil {
                        map["ChannelState"] = self.channelState!
                    }
                    if self.destination != nil {
                        map["Destination"] = self.destination!
                    }
                    if self.jobId != nil {
                        map["JobId"] = self.jobId!
                    }
                    if self.originator != nil {
                        map["Originator"] = self.originator!
                    }
                    if self.releaseInitiator != nil {
                        map["ReleaseInitiator"] = self.releaseInitiator!
                    }
                    if self.releaseReason != nil {
                        map["ReleaseReason"] = self.releaseReason!
                    }
                    if self.timestamp != nil {
                        map["Timestamp"] = self.timestamp!
                    }
                    if self.userExtension != nil {
                        map["UserExtension"] = self.userExtension!
                    }
                    if self.userId != nil {
                        map["UserId"] = self.userId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("CallType") && dict["CallType"] != nil {
                        self.callType = dict["CallType"] as! String
                    }
                    if dict.keys.contains("ChannelFlags") && dict["ChannelFlags"] != nil {
                        self.channelFlags = dict["ChannelFlags"] as! String
                    }
                    if dict.keys.contains("ChannelId") && dict["ChannelId"] != nil {
                        self.channelId = dict["ChannelId"] as! String
                    }
                    if dict.keys.contains("ChannelState") && dict["ChannelState"] != nil {
                        self.channelState = dict["ChannelState"] as! String
                    }
                    if dict.keys.contains("Destination") && dict["Destination"] != nil {
                        self.destination = dict["Destination"] as! String
                    }
                    if dict.keys.contains("JobId") && dict["JobId"] != nil {
                        self.jobId = dict["JobId"] as! String
                    }
                    if dict.keys.contains("Originator") && dict["Originator"] != nil {
                        self.originator = dict["Originator"] as! String
                    }
                    if dict.keys.contains("ReleaseInitiator") && dict["ReleaseInitiator"] != nil {
                        self.releaseInitiator = dict["ReleaseInitiator"] as! String
                    }
                    if dict.keys.contains("ReleaseReason") && dict["ReleaseReason"] != nil {
                        self.releaseReason = dict["ReleaseReason"] as! String
                    }
                    if dict.keys.contains("Timestamp") && dict["Timestamp"] != nil {
                        self.timestamp = dict["Timestamp"] as! Int64
                    }
                    if dict.keys.contains("UserExtension") && dict["UserExtension"] != nil {
                        self.userExtension = dict["UserExtension"] as! String
                    }
                    if dict.keys.contains("UserId") && dict["UserId"] != nil {
                        self.userId = dict["UserId"] as! String
                    }
                }
            }
            public var callType: String?

            public var channelContexts: [BlindTransferResponseBody.Data.CallContext.ChannelContexts]?

            public var instanceId: String?

            public var jobId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.callType != nil {
                    map["CallType"] = self.callType!
                }
                if self.channelContexts != nil {
                    var tmp : [Any] = []
                    for k in self.channelContexts! {
                        tmp.append(k.toMap())
                    }
                    map["ChannelContexts"] = tmp
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.jobId != nil {
                    map["JobId"] = self.jobId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CallType") && dict["CallType"] != nil {
                    self.callType = dict["CallType"] as! String
                }
                if dict.keys.contains("ChannelContexts") && dict["ChannelContexts"] != nil {
                    var tmp : [BlindTransferResponseBody.Data.CallContext.ChannelContexts] = []
                    for v in dict["ChannelContexts"] as! [Any] {
                        var model = BlindTransferResponseBody.Data.CallContext.ChannelContexts()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.channelContexts = tmp
                }
                if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("JobId") && dict["JobId"] != nil {
                    self.jobId = dict["JobId"] as! String
                }
            }
        }
        public class UserContext : Tea.TeaModel {
            public var breakCode: String?

            public var deviceId: String?

            public var extension_: String?

            public var heartbeat: Int64?

            public var instanceId: String?

            public var jobId: String?

            public var mobile: String?

            public var outboundScenario: Bool?

            public var reserved: Int64?

            public var signedSkillGroupIdList: [String]?

            public var userId: String?

            public var userState: String?

            public var workMode: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.breakCode != nil {
                    map["BreakCode"] = self.breakCode!
                }
                if self.deviceId != nil {
                    map["DeviceId"] = self.deviceId!
                }
                if self.extension_ != nil {
                    map["Extension"] = self.extension_!
                }
                if self.heartbeat != nil {
                    map["Heartbeat"] = self.heartbeat!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.jobId != nil {
                    map["JobId"] = self.jobId!
                }
                if self.mobile != nil {
                    map["Mobile"] = self.mobile!
                }
                if self.outboundScenario != nil {
                    map["OutboundScenario"] = self.outboundScenario!
                }
                if self.reserved != nil {
                    map["Reserved"] = self.reserved!
                }
                if self.signedSkillGroupIdList != nil {
                    map["SignedSkillGroupIdList"] = self.signedSkillGroupIdList!
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                if self.userState != nil {
                    map["UserState"] = self.userState!
                }
                if self.workMode != nil {
                    map["WorkMode"] = self.workMode!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BreakCode") && dict["BreakCode"] != nil {
                    self.breakCode = dict["BreakCode"] as! String
                }
                if dict.keys.contains("DeviceId") && dict["DeviceId"] != nil {
                    self.deviceId = dict["DeviceId"] as! String
                }
                if dict.keys.contains("Extension") && dict["Extension"] != nil {
                    self.extension_ = dict["Extension"] as! String
                }
                if dict.keys.contains("Heartbeat") && dict["Heartbeat"] != nil {
                    self.heartbeat = dict["Heartbeat"] as! Int64
                }
                if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("JobId") && dict["JobId"] != nil {
                    self.jobId = dict["JobId"] as! String
                }
                if dict.keys.contains("Mobile") && dict["Mobile"] != nil {
                    self.mobile = dict["Mobile"] as! String
                }
                if dict.keys.contains("OutboundScenario") && dict["OutboundScenario"] != nil {
                    self.outboundScenario = dict["OutboundScenario"] as! Bool
                }
                if dict.keys.contains("Reserved") && dict["Reserved"] != nil {
                    self.reserved = dict["Reserved"] as! Int64
                }
                if dict.keys.contains("SignedSkillGroupIdList") && dict["SignedSkillGroupIdList"] != nil {
                    self.signedSkillGroupIdList = dict["SignedSkillGroupIdList"] as! [String]
                }
                if dict.keys.contains("UserId") && dict["UserId"] != nil {
                    self.userId = dict["UserId"] as! String
                }
                if dict.keys.contains("UserState") && dict["UserState"] != nil {
                    self.userState = dict["UserState"] as! String
                }
                if dict.keys.contains("WorkMode") && dict["WorkMode"] != nil {
                    self.workMode = dict["WorkMode"] as! String
                }
            }
        }
        public var callContext: BlindTransferResponseBody.Data.CallContext?

        public var contextId: Int64?

        public var userContext: BlindTransferResponseBody.Data.UserContext?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.callContext?.validate()
            try self.userContext?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.callContext != nil {
                map["CallContext"] = self.callContext?.toMap()
            }
            if self.contextId != nil {
                map["ContextId"] = self.contextId!
            }
            if self.userContext != nil {
                map["UserContext"] = self.userContext?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CallContext") && dict["CallContext"] != nil {
                var model = BlindTransferResponseBody.Data.CallContext()
                model.fromMap(dict["CallContext"] as! [String: Any])
                self.callContext = model
            }
            if dict.keys.contains("ContextId") && dict["ContextId"] != nil {
                self.contextId = dict["ContextId"] as! Int64
            }
            if dict.keys.contains("UserContext") && dict["UserContext"] != nil {
                var model = BlindTransferResponseBody.Data.UserContext()
                model.fromMap(dict["UserContext"] as! [String: Any])
                self.userContext = model
            }
        }
    }
    public var code: String?

    public var data: BlindTransferResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var params: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.params != nil {
            map["Params"] = self.params!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = BlindTransferResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Params") && dict["Params"] != nil {
            self.params = dict["Params"] as! [String]
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class BlindTransferResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: BlindTransferResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = BlindTransferResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class BridgeRtcCallRequest : Tea.TeaModel {
    public var callee: String?

    public var caller: String?

    public var deviceId: String?

    public var instanceId: String?

    public var serviceProvider: String?

    public var tags: String?

    public var timeoutSeconds: Int32?

    public var userId: String?

    public var videoEnabled: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.callee != nil {
            map["Callee"] = self.callee!
        }
        if self.caller != nil {
            map["Caller"] = self.caller!
        }
        if self.deviceId != nil {
            map["DeviceId"] = self.deviceId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.serviceProvider != nil {
            map["ServiceProvider"] = self.serviceProvider!
        }
        if self.tags != nil {
            map["Tags"] = self.tags!
        }
        if self.timeoutSeconds != nil {
            map["TimeoutSeconds"] = self.timeoutSeconds!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        if self.videoEnabled != nil {
            map["VideoEnabled"] = self.videoEnabled!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Callee") && dict["Callee"] != nil {
            self.callee = dict["Callee"] as! String
        }
        if dict.keys.contains("Caller") && dict["Caller"] != nil {
            self.caller = dict["Caller"] as! String
        }
        if dict.keys.contains("DeviceId") && dict["DeviceId"] != nil {
            self.deviceId = dict["DeviceId"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("ServiceProvider") && dict["ServiceProvider"] != nil {
            self.serviceProvider = dict["ServiceProvider"] as! String
        }
        if dict.keys.contains("Tags") && dict["Tags"] != nil {
            self.tags = dict["Tags"] as! String
        }
        if dict.keys.contains("TimeoutSeconds") && dict["TimeoutSeconds"] != nil {
            self.timeoutSeconds = dict["TimeoutSeconds"] as! Int32
        }
        if dict.keys.contains("UserId") && dict["UserId"] != nil {
            self.userId = dict["UserId"] as! String
        }
        if dict.keys.contains("VideoEnabled") && dict["VideoEnabled"] != nil {
            self.videoEnabled = dict["VideoEnabled"] as! Bool
        }
    }
}

public class BridgeRtcCallResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var instanceId: String?

        public var jobId: String?

        public var tokenInfo: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            if self.tokenInfo != nil {
                map["TokenInfo"] = self.tokenInfo!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("JobId") && dict["JobId"] != nil {
                self.jobId = dict["JobId"] as! String
            }
            if dict.keys.contains("TokenInfo") && dict["TokenInfo"] != nil {
                self.tokenInfo = dict["TokenInfo"] as! String
            }
        }
    }
    public var code: String?

    public var data: BridgeRtcCallResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var params: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.params != nil {
            map["Params"] = self.params!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = BridgeRtcCallResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Params") && dict["Params"] != nil {
            self.params = dict["Params"] as! [String]
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class BridgeRtcCallResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: BridgeRtcCallResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = BridgeRtcCallResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CancelAttendedTransferRequest : Tea.TeaModel {
    public var deviceId: String?

    public var instanceId: String?

    public var jobId: String?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.deviceId != nil {
            map["DeviceId"] = self.deviceId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DeviceId") && dict["DeviceId"] != nil {
            self.deviceId = dict["DeviceId"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("JobId") && dict["JobId"] != nil {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("UserId") && dict["UserId"] != nil {
            self.userId = dict["UserId"] as! String
        }
    }
}

public class CancelAttendedTransferResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class CallContext : Tea.TeaModel {
            public class ChannelContexts : Tea.TeaModel {
                public var callType: String?

                public var channelFlags: String?

                public var channelId: String?

                public var channelState: String?

                public var destination: String?

                public var index: Int32?

                public var jobId: String?

                public var originator: String?

                public var releaseInitiator: String?

                public var releaseReason: String?

                public var timestamp: Int64?

                public var userExtension: String?

                public var userId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.callType != nil {
                        map["CallType"] = self.callType!
                    }
                    if self.channelFlags != nil {
                        map["ChannelFlags"] = self.channelFlags!
                    }
                    if self.channelId != nil {
                        map["ChannelId"] = self.channelId!
                    }
                    if self.channelState != nil {
                        map["ChannelState"] = self.channelState!
                    }
                    if self.destination != nil {
                        map["Destination"] = self.destination!
                    }
                    if self.index != nil {
                        map["Index"] = self.index!
                    }
                    if self.jobId != nil {
                        map["JobId"] = self.jobId!
                    }
                    if self.originator != nil {
                        map["Originator"] = self.originator!
                    }
                    if self.releaseInitiator != nil {
                        map["ReleaseInitiator"] = self.releaseInitiator!
                    }
                    if self.releaseReason != nil {
                        map["ReleaseReason"] = self.releaseReason!
                    }
                    if self.timestamp != nil {
                        map["Timestamp"] = self.timestamp!
                    }
                    if self.userExtension != nil {
                        map["UserExtension"] = self.userExtension!
                    }
                    if self.userId != nil {
                        map["UserId"] = self.userId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("CallType") && dict["CallType"] != nil {
                        self.callType = dict["CallType"] as! String
                    }
                    if dict.keys.contains("ChannelFlags") && dict["ChannelFlags"] != nil {
                        self.channelFlags = dict["ChannelFlags"] as! String
                    }
                    if dict.keys.contains("ChannelId") && dict["ChannelId"] != nil {
                        self.channelId = dict["ChannelId"] as! String
                    }
                    if dict.keys.contains("ChannelState") && dict["ChannelState"] != nil {
                        self.channelState = dict["ChannelState"] as! String
                    }
                    if dict.keys.contains("Destination") && dict["Destination"] != nil {
                        self.destination = dict["Destination"] as! String
                    }
                    if dict.keys.contains("Index") && dict["Index"] != nil {
                        self.index = dict["Index"] as! Int32
                    }
                    if dict.keys.contains("JobId") && dict["JobId"] != nil {
                        self.jobId = dict["JobId"] as! String
                    }
                    if dict.keys.contains("Originator") && dict["Originator"] != nil {
                        self.originator = dict["Originator"] as! String
                    }
                    if dict.keys.contains("ReleaseInitiator") && dict["ReleaseInitiator"] != nil {
                        self.releaseInitiator = dict["ReleaseInitiator"] as! String
                    }
                    if dict.keys.contains("ReleaseReason") && dict["ReleaseReason"] != nil {
                        self.releaseReason = dict["ReleaseReason"] as! String
                    }
                    if dict.keys.contains("Timestamp") && dict["Timestamp"] != nil {
                        self.timestamp = dict["Timestamp"] as! Int64
                    }
                    if dict.keys.contains("UserExtension") && dict["UserExtension"] != nil {
                        self.userExtension = dict["UserExtension"] as! String
                    }
                    if dict.keys.contains("UserId") && dict["UserId"] != nil {
                        self.userId = dict["UserId"] as! String
                    }
                }
            }
            public var callType: String?

            public var channelContexts: [CancelAttendedTransferResponseBody.Data.CallContext.ChannelContexts]?

            public var instanceId: String?

            public var jobId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.callType != nil {
                    map["CallType"] = self.callType!
                }
                if self.channelContexts != nil {
                    var tmp : [Any] = []
                    for k in self.channelContexts! {
                        tmp.append(k.toMap())
                    }
                    map["ChannelContexts"] = tmp
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.jobId != nil {
                    map["JobId"] = self.jobId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CallType") && dict["CallType"] != nil {
                    self.callType = dict["CallType"] as! String
                }
                if dict.keys.contains("ChannelContexts") && dict["ChannelContexts"] != nil {
                    var tmp : [CancelAttendedTransferResponseBody.Data.CallContext.ChannelContexts] = []
                    for v in dict["ChannelContexts"] as! [Any] {
                        var model = CancelAttendedTransferResponseBody.Data.CallContext.ChannelContexts()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.channelContexts = tmp
                }
                if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("JobId") && dict["JobId"] != nil {
                    self.jobId = dict["JobId"] as! String
                }
            }
        }
        public class UserContext : Tea.TeaModel {
            public var breakCode: String?

            public var deviceId: String?

            public var extension_: String?

            public var heartbeat: Int64?

            public var instanceId: String?

            public var jobId: String?

            public var mobile: String?

            public var outboundScenario: Bool?

            public var reserved: Int64?

            public var signedSkillGroupIdList: [String]?

            public var userId: String?

            public var userState: String?

            public var workMode: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.breakCode != nil {
                    map["BreakCode"] = self.breakCode!
                }
                if self.deviceId != nil {
                    map["DeviceId"] = self.deviceId!
                }
                if self.extension_ != nil {
                    map["Extension"] = self.extension_!
                }
                if self.heartbeat != nil {
                    map["Heartbeat"] = self.heartbeat!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.jobId != nil {
                    map["JobId"] = self.jobId!
                }
                if self.mobile != nil {
                    map["Mobile"] = self.mobile!
                }
                if self.outboundScenario != nil {
                    map["OutboundScenario"] = self.outboundScenario!
                }
                if self.reserved != nil {
                    map["Reserved"] = self.reserved!
                }
                if self.signedSkillGroupIdList != nil {
                    map["SignedSkillGroupIdList"] = self.signedSkillGroupIdList!
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                if self.userState != nil {
                    map["UserState"] = self.userState!
                }
                if self.workMode != nil {
                    map["WorkMode"] = self.workMode!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BreakCode") && dict["BreakCode"] != nil {
                    self.breakCode = dict["BreakCode"] as! String
                }
                if dict.keys.contains("DeviceId") && dict["DeviceId"] != nil {
                    self.deviceId = dict["DeviceId"] as! String
                }
                if dict.keys.contains("Extension") && dict["Extension"] != nil {
                    self.extension_ = dict["Extension"] as! String
                }
                if dict.keys.contains("Heartbeat") && dict["Heartbeat"] != nil {
                    self.heartbeat = dict["Heartbeat"] as! Int64
                }
                if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("JobId") && dict["JobId"] != nil {
                    self.jobId = dict["JobId"] as! String
                }
                if dict.keys.contains("Mobile") && dict["Mobile"] != nil {
                    self.mobile = dict["Mobile"] as! String
                }
                if dict.keys.contains("OutboundScenario") && dict["OutboundScenario"] != nil {
                    self.outboundScenario = dict["OutboundScenario"] as! Bool
                }
                if dict.keys.contains("Reserved") && dict["Reserved"] != nil {
                    self.reserved = dict["Reserved"] as! Int64
                }
                if dict.keys.contains("SignedSkillGroupIdList") && dict["SignedSkillGroupIdList"] != nil {
                    self.signedSkillGroupIdList = dict["SignedSkillGroupIdList"] as! [String]
                }
                if dict.keys.contains("UserId") && dict["UserId"] != nil {
                    self.userId = dict["UserId"] as! String
                }
                if dict.keys.contains("UserState") && dict["UserState"] != nil {
                    self.userState = dict["UserState"] as! String
                }
                if dict.keys.contains("WorkMode") && dict["WorkMode"] != nil {
                    self.workMode = dict["WorkMode"] as! String
                }
            }
        }
        public var callContext: CancelAttendedTransferResponseBody.Data.CallContext?

        public var contextId: Int64?

        public var userContext: CancelAttendedTransferResponseBody.Data.UserContext?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.callContext?.validate()
            try self.userContext?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.callContext != nil {
                map["CallContext"] = self.callContext?.toMap()
            }
            if self.contextId != nil {
                map["ContextId"] = self.contextId!
            }
            if self.userContext != nil {
                map["UserContext"] = self.userContext?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CallContext") && dict["CallContext"] != nil {
                var model = CancelAttendedTransferResponseBody.Data.CallContext()
                model.fromMap(dict["CallContext"] as! [String: Any])
                self.callContext = model
            }
            if dict.keys.contains("ContextId") && dict["ContextId"] != nil {
                self.contextId = dict["ContextId"] as! Int64
            }
            if dict.keys.contains("UserContext") && dict["UserContext"] != nil {
                var model = CancelAttendedTransferResponseBody.Data.UserContext()
                model.fromMap(dict["UserContext"] as! [String: Any])
                self.userContext = model
            }
        }
    }
    public var code: String?

    public var data: CancelAttendedTransferResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var params: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.params != nil {
            map["Params"] = self.params!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = CancelAttendedTransferResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Params") && dict["Params"] != nil {
            self.params = dict["Params"] as! [String]
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CancelAttendedTransferResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CancelAttendedTransferResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CancelAttendedTransferResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ChangeWorkModeRequest : Tea.TeaModel {
    public var deviceId: String?

    public var instanceId: String?

    public var mobile: String?

    public var signedSkillGroupIdList: String?

    public var userId: String?

    public var workMode: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.deviceId != nil {
            map["DeviceId"] = self.deviceId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.mobile != nil {
            map["Mobile"] = self.mobile!
        }
        if self.signedSkillGroupIdList != nil {
            map["SignedSkillGroupIdList"] = self.signedSkillGroupIdList!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        if self.workMode != nil {
            map["WorkMode"] = self.workMode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DeviceId") && dict["DeviceId"] != nil {
            self.deviceId = dict["DeviceId"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Mobile") && dict["Mobile"] != nil {
            self.mobile = dict["Mobile"] as! String
        }
        if dict.keys.contains("SignedSkillGroupIdList") && dict["SignedSkillGroupIdList"] != nil {
            self.signedSkillGroupIdList = dict["SignedSkillGroupIdList"] as! String
        }
        if dict.keys.contains("UserId") && dict["UserId"] != nil {
            self.userId = dict["UserId"] as! String
        }
        if dict.keys.contains("WorkMode") && dict["WorkMode"] != nil {
            self.workMode = dict["WorkMode"] as! String
        }
    }
}

public class ChangeWorkModeResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var breakCode: String?

        public var deviceId: String?

        public var extension_: String?

        public var instanceId: String?

        public var jobId: String?

        public var outboundScenario: Bool?

        public var signedSkillGroupIdList: [String]?

        public var userId: String?

        public var userState: String?

        public var workMode: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.breakCode != nil {
                map["BreakCode"] = self.breakCode!
            }
            if self.deviceId != nil {
                map["DeviceId"] = self.deviceId!
            }
            if self.extension_ != nil {
                map["Extension"] = self.extension_!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            if self.outboundScenario != nil {
                map["OutboundScenario"] = self.outboundScenario!
            }
            if self.signedSkillGroupIdList != nil {
                map["SignedSkillGroupIdList"] = self.signedSkillGroupIdList!
            }
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            if self.userState != nil {
                map["UserState"] = self.userState!
            }
            if self.workMode != nil {
                map["WorkMode"] = self.workMode!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BreakCode") && dict["BreakCode"] != nil {
                self.breakCode = dict["BreakCode"] as! String
            }
            if dict.keys.contains("DeviceId") && dict["DeviceId"] != nil {
                self.deviceId = dict["DeviceId"] as! String
            }
            if dict.keys.contains("Extension") && dict["Extension"] != nil {
                self.extension_ = dict["Extension"] as! String
            }
            if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("JobId") && dict["JobId"] != nil {
                self.jobId = dict["JobId"] as! String
            }
            if dict.keys.contains("OutboundScenario") && dict["OutboundScenario"] != nil {
                self.outboundScenario = dict["OutboundScenario"] as! Bool
            }
            if dict.keys.contains("SignedSkillGroupIdList") && dict["SignedSkillGroupIdList"] != nil {
                self.signedSkillGroupIdList = dict["SignedSkillGroupIdList"] as! [String]
            }
            if dict.keys.contains("UserId") && dict["UserId"] != nil {
                self.userId = dict["UserId"] as! String
            }
            if dict.keys.contains("UserState") && dict["UserState"] != nil {
                self.userState = dict["UserState"] as! String
            }
            if dict.keys.contains("WorkMode") && dict["WorkMode"] != nil {
                self.workMode = dict["WorkMode"] as! String
            }
        }
    }
    public var code: String?

    public var data: ChangeWorkModeResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var params: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.params != nil {
            map["Params"] = self.params!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = ChangeWorkModeResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Params") && dict["Params"] != nil {
            self.params = dict["Params"] as! [String]
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ChangeWorkModeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ChangeWorkModeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ChangeWorkModeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CoachCallRequest : Tea.TeaModel {
    public var coachedUserId: String?

    public var deviceId: String?

    public var instanceId: String?

    public var jobId: String?

    public var timeoutSeconds: Int32?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.coachedUserId != nil {
            map["CoachedUserId"] = self.coachedUserId!
        }
        if self.deviceId != nil {
            map["DeviceId"] = self.deviceId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.timeoutSeconds != nil {
            map["TimeoutSeconds"] = self.timeoutSeconds!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CoachedUserId") && dict["CoachedUserId"] != nil {
            self.coachedUserId = dict["CoachedUserId"] as! String
        }
        if dict.keys.contains("DeviceId") && dict["DeviceId"] != nil {
            self.deviceId = dict["DeviceId"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("JobId") && dict["JobId"] != nil {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("TimeoutSeconds") && dict["TimeoutSeconds"] != nil {
            self.timeoutSeconds = dict["TimeoutSeconds"] as! Int32
        }
        if dict.keys.contains("UserId") && dict["UserId"] != nil {
            self.userId = dict["UserId"] as! String
        }
    }
}

public class CoachCallResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class CallContext : Tea.TeaModel {
            public class ChannelContexts : Tea.TeaModel {
                public var callType: String?

                public var channelFlags: String?

                public var channelId: String?

                public var channelState: String?

                public var destination: String?

                public var index: Int32?

                public var jobId: String?

                public var originator: String?

                public var releaseInitiator: String?

                public var releaseReason: String?

                public var skillGroupId: String?

                public var timestamp: Int64?

                public var userExtension: String?

                public var userId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.callType != nil {
                        map["CallType"] = self.callType!
                    }
                    if self.channelFlags != nil {
                        map["ChannelFlags"] = self.channelFlags!
                    }
                    if self.channelId != nil {
                        map["ChannelId"] = self.channelId!
                    }
                    if self.channelState != nil {
                        map["ChannelState"] = self.channelState!
                    }
                    if self.destination != nil {
                        map["Destination"] = self.destination!
                    }
                    if self.index != nil {
                        map["Index"] = self.index!
                    }
                    if self.jobId != nil {
                        map["JobId"] = self.jobId!
                    }
                    if self.originator != nil {
                        map["Originator"] = self.originator!
                    }
                    if self.releaseInitiator != nil {
                        map["ReleaseInitiator"] = self.releaseInitiator!
                    }
                    if self.releaseReason != nil {
                        map["ReleaseReason"] = self.releaseReason!
                    }
                    if self.skillGroupId != nil {
                        map["SkillGroupId"] = self.skillGroupId!
                    }
                    if self.timestamp != nil {
                        map["Timestamp"] = self.timestamp!
                    }
                    if self.userExtension != nil {
                        map["UserExtension"] = self.userExtension!
                    }
                    if self.userId != nil {
                        map["UserId"] = self.userId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("CallType") && dict["CallType"] != nil {
                        self.callType = dict["CallType"] as! String
                    }
                    if dict.keys.contains("ChannelFlags") && dict["ChannelFlags"] != nil {
                        self.channelFlags = dict["ChannelFlags"] as! String
                    }
                    if dict.keys.contains("ChannelId") && dict["ChannelId"] != nil {
                        self.channelId = dict["ChannelId"] as! String
                    }
                    if dict.keys.contains("ChannelState") && dict["ChannelState"] != nil {
                        self.channelState = dict["ChannelState"] as! String
                    }
                    if dict.keys.contains("Destination") && dict["Destination"] != nil {
                        self.destination = dict["Destination"] as! String
                    }
                    if dict.keys.contains("Index") && dict["Index"] != nil {
                        self.index = dict["Index"] as! Int32
                    }
                    if dict.keys.contains("JobId") && dict["JobId"] != nil {
                        self.jobId = dict["JobId"] as! String
                    }
                    if dict.keys.contains("Originator") && dict["Originator"] != nil {
                        self.originator = dict["Originator"] as! String
                    }
                    if dict.keys.contains("ReleaseInitiator") && dict["ReleaseInitiator"] != nil {
                        self.releaseInitiator = dict["ReleaseInitiator"] as! String
                    }
                    if dict.keys.contains("ReleaseReason") && dict["ReleaseReason"] != nil {
                        self.releaseReason = dict["ReleaseReason"] as! String
                    }
                    if dict.keys.contains("SkillGroupId") && dict["SkillGroupId"] != nil {
                        self.skillGroupId = dict["SkillGroupId"] as! String
                    }
                    if dict.keys.contains("Timestamp") && dict["Timestamp"] != nil {
                        self.timestamp = dict["Timestamp"] as! Int64
                    }
                    if dict.keys.contains("UserExtension") && dict["UserExtension"] != nil {
                        self.userExtension = dict["UserExtension"] as! String
                    }
                    if dict.keys.contains("UserId") && dict["UserId"] != nil {
                        self.userId = dict["UserId"] as! String
                    }
                }
            }
            public var callType: String?

            public var channelContexts: [CoachCallResponseBody.Data.CallContext.ChannelContexts]?

            public var instanceId: String?

            public var jobId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.callType != nil {
                    map["CallType"] = self.callType!
                }
                if self.channelContexts != nil {
                    var tmp : [Any] = []
                    for k in self.channelContexts! {
                        tmp.append(k.toMap())
                    }
                    map["ChannelContexts"] = tmp
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.jobId != nil {
                    map["JobId"] = self.jobId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CallType") && dict["CallType"] != nil {
                    self.callType = dict["CallType"] as! String
                }
                if dict.keys.contains("ChannelContexts") && dict["ChannelContexts"] != nil {
                    var tmp : [CoachCallResponseBody.Data.CallContext.ChannelContexts] = []
                    for v in dict["ChannelContexts"] as! [Any] {
                        var model = CoachCallResponseBody.Data.CallContext.ChannelContexts()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.channelContexts = tmp
                }
                if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("JobId") && dict["JobId"] != nil {
                    self.jobId = dict["JobId"] as! String
                }
            }
        }
        public class UserContext : Tea.TeaModel {
            public var breakCode: String?

            public var deviceId: String?

            public var deviceState: String?

            public var extension_: String?

            public var heartbeat: Int64?

            public var instanceId: String?

            public var jobId: String?

            public var mobile: String?

            public var outboundScenario: Bool?

            public var reserved: Int64?

            public var signedSkillGroupIdList: [String]?

            public var uri: String?

            public var userId: String?

            public var userState: String?

            public var workMode: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.breakCode != nil {
                    map["BreakCode"] = self.breakCode!
                }
                if self.deviceId != nil {
                    map["DeviceId"] = self.deviceId!
                }
                if self.deviceState != nil {
                    map["DeviceState"] = self.deviceState!
                }
                if self.extension_ != nil {
                    map["Extension"] = self.extension_!
                }
                if self.heartbeat != nil {
                    map["Heartbeat"] = self.heartbeat!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.jobId != nil {
                    map["JobId"] = self.jobId!
                }
                if self.mobile != nil {
                    map["Mobile"] = self.mobile!
                }
                if self.outboundScenario != nil {
                    map["OutboundScenario"] = self.outboundScenario!
                }
                if self.reserved != nil {
                    map["Reserved"] = self.reserved!
                }
                if self.signedSkillGroupIdList != nil {
                    map["SignedSkillGroupIdList"] = self.signedSkillGroupIdList!
                }
                if self.uri != nil {
                    map["Uri"] = self.uri!
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                if self.userState != nil {
                    map["UserState"] = self.userState!
                }
                if self.workMode != nil {
                    map["WorkMode"] = self.workMode!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BreakCode") && dict["BreakCode"] != nil {
                    self.breakCode = dict["BreakCode"] as! String
                }
                if dict.keys.contains("DeviceId") && dict["DeviceId"] != nil {
                    self.deviceId = dict["DeviceId"] as! String
                }
                if dict.keys.contains("DeviceState") && dict["DeviceState"] != nil {
                    self.deviceState = dict["DeviceState"] as! String
                }
                if dict.keys.contains("Extension") && dict["Extension"] != nil {
                    self.extension_ = dict["Extension"] as! String
                }
                if dict.keys.contains("Heartbeat") && dict["Heartbeat"] != nil {
                    self.heartbeat = dict["Heartbeat"] as! Int64
                }
                if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("JobId") && dict["JobId"] != nil {
                    self.jobId = dict["JobId"] as! String
                }
                if dict.keys.contains("Mobile") && dict["Mobile"] != nil {
                    self.mobile = dict["Mobile"] as! String
                }
                if dict.keys.contains("OutboundScenario") && dict["OutboundScenario"] != nil {
                    self.outboundScenario = dict["OutboundScenario"] as! Bool
                }
                if dict.keys.contains("Reserved") && dict["Reserved"] != nil {
                    self.reserved = dict["Reserved"] as! Int64
                }
                if dict.keys.contains("SignedSkillGroupIdList") && dict["SignedSkillGroupIdList"] != nil {
                    self.signedSkillGroupIdList = dict["SignedSkillGroupIdList"] as! [String]
                }
                if dict.keys.contains("Uri") && dict["Uri"] != nil {
                    self.uri = dict["Uri"] as! String
                }
                if dict.keys.contains("UserId") && dict["UserId"] != nil {
                    self.userId = dict["UserId"] as! String
                }
                if dict.keys.contains("UserState") && dict["UserState"] != nil {
                    self.userState = dict["UserState"] as! String
                }
                if dict.keys.contains("WorkMode") && dict["WorkMode"] != nil {
                    self.workMode = dict["WorkMode"] as! String
                }
            }
        }
        public var callContext: CoachCallResponseBody.Data.CallContext?

        public var userContext: CoachCallResponseBody.Data.UserContext?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.callContext?.validate()
            try self.userContext?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.callContext != nil {
                map["CallContext"] = self.callContext?.toMap()
            }
            if self.userContext != nil {
                map["UserContext"] = self.userContext?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CallContext") && dict["CallContext"] != nil {
                var model = CoachCallResponseBody.Data.CallContext()
                model.fromMap(dict["CallContext"] as! [String: Any])
                self.callContext = model
            }
            if dict.keys.contains("UserContext") && dict["UserContext"] != nil {
                var model = CoachCallResponseBody.Data.UserContext()
                model.fromMap(dict["UserContext"] as! [String: Any])
                self.userContext = model
            }
        }
    }
    public var code: String?

    public var data: CoachCallResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var params: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.params != nil {
            map["Params"] = self.params!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = CoachCallResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Params") && dict["Params"] != nil {
            self.params = dict["Params"] as! [String]
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CoachCallResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CoachCallResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CoachCallResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CommitContactFlowRequest : Tea.TeaModel {
    public var contactFlowId: String?

    public var definition: String?

    public var description_: String?

    public var draftId: String?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.contactFlowId != nil {
            map["ContactFlowId"] = self.contactFlowId!
        }
        if self.definition != nil {
            map["Definition"] = self.definition!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.draftId != nil {
            map["DraftId"] = self.draftId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ContactFlowId") && dict["ContactFlowId"] != nil {
            self.contactFlowId = dict["ContactFlowId"] as! String
        }
        if dict.keys.contains("Definition") && dict["Definition"] != nil {
            self.definition = dict["Definition"] as! String
        }
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("DraftId") && dict["DraftId"] != nil {
            self.draftId = dict["DraftId"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
    }
}

public class CommitContactFlowResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CommitContactFlowResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CommitContactFlowResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CommitContactFlowResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CompleteAttendedTransferRequest : Tea.TeaModel {
    public var deviceId: String?

    public var instanceId: String?

    public var jobId: String?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.deviceId != nil {
            map["DeviceId"] = self.deviceId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DeviceId") && dict["DeviceId"] != nil {
            self.deviceId = dict["DeviceId"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("JobId") && dict["JobId"] != nil {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("UserId") && dict["UserId"] != nil {
            self.userId = dict["UserId"] as! String
        }
    }
}

public class CompleteAttendedTransferResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class CallContext : Tea.TeaModel {
            public class ChannelContexts : Tea.TeaModel {
                public var callType: String?

                public var channelFlags: String?

                public var channelId: String?

                public var channelState: String?

                public var destination: String?

                public var index: Int32?

                public var jobId: String?

                public var originator: String?

                public var releaseInitiator: String?

                public var releaseReason: String?

                public var skillGroupId: String?

                public var timestamp: Int64?

                public var userExtension: String?

                public var userId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.callType != nil {
                        map["CallType"] = self.callType!
                    }
                    if self.channelFlags != nil {
                        map["ChannelFlags"] = self.channelFlags!
                    }
                    if self.channelId != nil {
                        map["ChannelId"] = self.channelId!
                    }
                    if self.channelState != nil {
                        map["ChannelState"] = self.channelState!
                    }
                    if self.destination != nil {
                        map["Destination"] = self.destination!
                    }
                    if self.index != nil {
                        map["Index"] = self.index!
                    }
                    if self.jobId != nil {
                        map["JobId"] = self.jobId!
                    }
                    if self.originator != nil {
                        map["Originator"] = self.originator!
                    }
                    if self.releaseInitiator != nil {
                        map["ReleaseInitiator"] = self.releaseInitiator!
                    }
                    if self.releaseReason != nil {
                        map["ReleaseReason"] = self.releaseReason!
                    }
                    if self.skillGroupId != nil {
                        map["SkillGroupId"] = self.skillGroupId!
                    }
                    if self.timestamp != nil {
                        map["Timestamp"] = self.timestamp!
                    }
                    if self.userExtension != nil {
                        map["UserExtension"] = self.userExtension!
                    }
                    if self.userId != nil {
                        map["UserId"] = self.userId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("CallType") && dict["CallType"] != nil {
                        self.callType = dict["CallType"] as! String
                    }
                    if dict.keys.contains("ChannelFlags") && dict["ChannelFlags"] != nil {
                        self.channelFlags = dict["ChannelFlags"] as! String
                    }
                    if dict.keys.contains("ChannelId") && dict["ChannelId"] != nil {
                        self.channelId = dict["ChannelId"] as! String
                    }
                    if dict.keys.contains("ChannelState") && dict["ChannelState"] != nil {
                        self.channelState = dict["ChannelState"] as! String
                    }
                    if dict.keys.contains("Destination") && dict["Destination"] != nil {
                        self.destination = dict["Destination"] as! String
                    }
                    if dict.keys.contains("Index") && dict["Index"] != nil {
                        self.index = dict["Index"] as! Int32
                    }
                    if dict.keys.contains("JobId") && dict["JobId"] != nil {
                        self.jobId = dict["JobId"] as! String
                    }
                    if dict.keys.contains("Originator") && dict["Originator"] != nil {
                        self.originator = dict["Originator"] as! String
                    }
                    if dict.keys.contains("ReleaseInitiator") && dict["ReleaseInitiator"] != nil {
                        self.releaseInitiator = dict["ReleaseInitiator"] as! String
                    }
                    if dict.keys.contains("ReleaseReason") && dict["ReleaseReason"] != nil {
                        self.releaseReason = dict["ReleaseReason"] as! String
                    }
                    if dict.keys.contains("SkillGroupId") && dict["SkillGroupId"] != nil {
                        self.skillGroupId = dict["SkillGroupId"] as! String
                    }
                    if dict.keys.contains("Timestamp") && dict["Timestamp"] != nil {
                        self.timestamp = dict["Timestamp"] as! Int64
                    }
                    if dict.keys.contains("UserExtension") && dict["UserExtension"] != nil {
                        self.userExtension = dict["UserExtension"] as! String
                    }
                    if dict.keys.contains("UserId") && dict["UserId"] != nil {
                        self.userId = dict["UserId"] as! String
                    }
                }
            }
            public var callType: String?

            public var channelContexts: [CompleteAttendedTransferResponseBody.Data.CallContext.ChannelContexts]?

            public var instanceId: String?

            public var jobId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.callType != nil {
                    map["CallType"] = self.callType!
                }
                if self.channelContexts != nil {
                    var tmp : [Any] = []
                    for k in self.channelContexts! {
                        tmp.append(k.toMap())
                    }
                    map["ChannelContexts"] = tmp
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.jobId != nil {
                    map["JobId"] = self.jobId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CallType") && dict["CallType"] != nil {
                    self.callType = dict["CallType"] as! String
                }
                if dict.keys.contains("ChannelContexts") && dict["ChannelContexts"] != nil {
                    var tmp : [CompleteAttendedTransferResponseBody.Data.CallContext.ChannelContexts] = []
                    for v in dict["ChannelContexts"] as! [Any] {
                        var model = CompleteAttendedTransferResponseBody.Data.CallContext.ChannelContexts()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.channelContexts = tmp
                }
                if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("JobId") && dict["JobId"] != nil {
                    self.jobId = dict["JobId"] as! String
                }
            }
        }
        public class UserContext : Tea.TeaModel {
            public var breakCode: String?

            public var deviceId: String?

            public var extension_: String?

            public var heartbeat: Int64?

            public var instanceId: String?

            public var jobId: String?

            public var mobile: String?

            public var outboundScenario: Bool?

            public var reserved: Int64?

            public var signedSkillGroupIdList: [String]?

            public var userId: String?

            public var userState: String?

            public var workMode: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.breakCode != nil {
                    map["BreakCode"] = self.breakCode!
                }
                if self.deviceId != nil {
                    map["DeviceId"] = self.deviceId!
                }
                if self.extension_ != nil {
                    map["Extension"] = self.extension_!
                }
                if self.heartbeat != nil {
                    map["Heartbeat"] = self.heartbeat!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.jobId != nil {
                    map["JobId"] = self.jobId!
                }
                if self.mobile != nil {
                    map["Mobile"] = self.mobile!
                }
                if self.outboundScenario != nil {
                    map["OutboundScenario"] = self.outboundScenario!
                }
                if self.reserved != nil {
                    map["Reserved"] = self.reserved!
                }
                if self.signedSkillGroupIdList != nil {
                    map["SignedSkillGroupIdList"] = self.signedSkillGroupIdList!
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                if self.userState != nil {
                    map["UserState"] = self.userState!
                }
                if self.workMode != nil {
                    map["WorkMode"] = self.workMode!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BreakCode") && dict["BreakCode"] != nil {
                    self.breakCode = dict["BreakCode"] as! String
                }
                if dict.keys.contains("DeviceId") && dict["DeviceId"] != nil {
                    self.deviceId = dict["DeviceId"] as! String
                }
                if dict.keys.contains("Extension") && dict["Extension"] != nil {
                    self.extension_ = dict["Extension"] as! String
                }
                if dict.keys.contains("Heartbeat") && dict["Heartbeat"] != nil {
                    self.heartbeat = dict["Heartbeat"] as! Int64
                }
                if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("JobId") && dict["JobId"] != nil {
                    self.jobId = dict["JobId"] as! String
                }
                if dict.keys.contains("Mobile") && dict["Mobile"] != nil {
                    self.mobile = dict["Mobile"] as! String
                }
                if dict.keys.contains("OutboundScenario") && dict["OutboundScenario"] != nil {
                    self.outboundScenario = dict["OutboundScenario"] as! Bool
                }
                if dict.keys.contains("Reserved") && dict["Reserved"] != nil {
                    self.reserved = dict["Reserved"] as! Int64
                }
                if dict.keys.contains("SignedSkillGroupIdList") && dict["SignedSkillGroupIdList"] != nil {
                    self.signedSkillGroupIdList = dict["SignedSkillGroupIdList"] as! [String]
                }
                if dict.keys.contains("UserId") && dict["UserId"] != nil {
                    self.userId = dict["UserId"] as! String
                }
                if dict.keys.contains("UserState") && dict["UserState"] != nil {
                    self.userState = dict["UserState"] as! String
                }
                if dict.keys.contains("WorkMode") && dict["WorkMode"] != nil {
                    self.workMode = dict["WorkMode"] as! String
                }
            }
        }
        public var callContext: CompleteAttendedTransferResponseBody.Data.CallContext?

        public var contextId: Int64?

        public var userContext: CompleteAttendedTransferResponseBody.Data.UserContext?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.callContext?.validate()
            try self.userContext?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.callContext != nil {
                map["CallContext"] = self.callContext?.toMap()
            }
            if self.contextId != nil {
                map["ContextId"] = self.contextId!
            }
            if self.userContext != nil {
                map["UserContext"] = self.userContext?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CallContext") && dict["CallContext"] != nil {
                var model = CompleteAttendedTransferResponseBody.Data.CallContext()
                model.fromMap(dict["CallContext"] as! [String: Any])
                self.callContext = model
            }
            if dict.keys.contains("ContextId") && dict["ContextId"] != nil {
                self.contextId = dict["ContextId"] as! Int64
            }
            if dict.keys.contains("UserContext") && dict["UserContext"] != nil {
                var model = CompleteAttendedTransferResponseBody.Data.UserContext()
                model.fromMap(dict["UserContext"] as! [String: Any])
                self.userContext = model
            }
        }
    }
    public var code: String?

    public var data: CompleteAttendedTransferResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var params: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.params != nil {
            map["Params"] = self.params!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = CompleteAttendedTransferResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Params") && dict["Params"] != nil {
            self.params = dict["Params"] as! [String]
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CompleteAttendedTransferResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CompleteAttendedTransferResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CompleteAttendedTransferResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateAudioFileRequest : Tea.TeaModel {
    public var audioFileName: String?

    public var instanceId: String?

    public var name: String?

    public var ossFileKey: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.audioFileName != nil {
            map["AudioFileName"] = self.audioFileName!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.ossFileKey != nil {
            map["OssFileKey"] = self.ossFileKey!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AudioFileName") && dict["AudioFileName"] != nil {
            self.audioFileName = dict["AudioFileName"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("OssFileKey") && dict["OssFileKey"] != nil {
            self.ossFileKey = dict["OssFileKey"] as! String
        }
    }
}

public class CreateAudioFileResponseBody : Tea.TeaModel {
    public var code: String?

    public var data: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateAudioFileResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateAudioFileResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateAudioFileResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateCallTagsRequest : Tea.TeaModel {
    public var callTagNameList: String?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.callTagNameList != nil {
            map["CallTagNameList"] = self.callTagNameList!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CallTagNameList") && dict["CallTagNameList"] != nil {
            self.callTagNameList = dict["CallTagNameList"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
    }
}

public class CreateCallTagsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var item: String?

        public var reason: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.item != nil {
                map["Item"] = self.item!
            }
            if self.reason != nil {
                map["Reason"] = self.reason!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Item") && dict["Item"] != nil {
                self.item = dict["Item"] as! String
            }
            if dict.keys.contains("Reason") && dict["Reason"] != nil {
                self.reason = dict["Reason"] as! String
            }
        }
    }
    public var code: String?

    public var data: [CreateCallTagsResponseBody.Data]?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var tmp : [CreateCallTagsResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = CreateCallTagsResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateCallTagsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateCallTagsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateCallTagsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateCampaignRequest : Tea.TeaModel {
    public class CaseList : Tea.TeaModel {
        public var customVariables: String?

        public var phoneNumber: String?

        public var referenceId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.customVariables != nil {
                map["CustomVariables"] = self.customVariables!
            }
            if self.phoneNumber != nil {
                map["PhoneNumber"] = self.phoneNumber!
            }
            if self.referenceId != nil {
                map["ReferenceId"] = self.referenceId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CustomVariables") && dict["CustomVariables"] != nil {
                self.customVariables = dict["CustomVariables"] as! String
            }
            if dict.keys.contains("PhoneNumber") && dict["PhoneNumber"] != nil {
                self.phoneNumber = dict["PhoneNumber"] as! String
            }
            if dict.keys.contains("ReferenceId") && dict["ReferenceId"] != nil {
                self.referenceId = dict["ReferenceId"] as! String
            }
        }
    }
    public var callableTime: String?

    public var caseFileKey: String?

    public var caseList: [CreateCampaignRequest.CaseList]?

    public var contactFlowId: String?

    public var endTime: String?

    public var executingUntilTimeout: Bool?

    public var instanceId: String?

    public var maxAttemptCount: Int64?

    public var minAttemptInterval: Int64?

    public var name: String?

    public var queueId: String?

    public var simulation: Bool?

    public var simulationParameters: String?

    public var startTime: String?

    public var strategyParameters: String?

    public var strategyType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.callableTime != nil {
            map["CallableTime"] = self.callableTime!
        }
        if self.caseFileKey != nil {
            map["CaseFileKey"] = self.caseFileKey!
        }
        if self.caseList != nil {
            var tmp : [Any] = []
            for k in self.caseList! {
                tmp.append(k.toMap())
            }
            map["CaseList"] = tmp
        }
        if self.contactFlowId != nil {
            map["ContactFlowId"] = self.contactFlowId!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.executingUntilTimeout != nil {
            map["ExecutingUntilTimeout"] = self.executingUntilTimeout!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.maxAttemptCount != nil {
            map["MaxAttemptCount"] = self.maxAttemptCount!
        }
        if self.minAttemptInterval != nil {
            map["MinAttemptInterval"] = self.minAttemptInterval!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.queueId != nil {
            map["QueueId"] = self.queueId!
        }
        if self.simulation != nil {
            map["Simulation"] = self.simulation!
        }
        if self.simulationParameters != nil {
            map["SimulationParameters"] = self.simulationParameters!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.strategyParameters != nil {
            map["StrategyParameters"] = self.strategyParameters!
        }
        if self.strategyType != nil {
            map["StrategyType"] = self.strategyType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CallableTime") && dict["CallableTime"] != nil {
            self.callableTime = dict["CallableTime"] as! String
        }
        if dict.keys.contains("CaseFileKey") && dict["CaseFileKey"] != nil {
            self.caseFileKey = dict["CaseFileKey"] as! String
        }
        if dict.keys.contains("CaseList") && dict["CaseList"] != nil {
            var tmp : [CreateCampaignRequest.CaseList] = []
            for v in dict["CaseList"] as! [Any] {
                var model = CreateCampaignRequest.CaseList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.caseList = tmp
        }
        if dict.keys.contains("ContactFlowId") && dict["ContactFlowId"] != nil {
            self.contactFlowId = dict["ContactFlowId"] as! String
        }
        if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("ExecutingUntilTimeout") && dict["ExecutingUntilTimeout"] != nil {
            self.executingUntilTimeout = dict["ExecutingUntilTimeout"] as! Bool
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("MaxAttemptCount") && dict["MaxAttemptCount"] != nil {
            self.maxAttemptCount = dict["MaxAttemptCount"] as! Int64
        }
        if dict.keys.contains("MinAttemptInterval") && dict["MinAttemptInterval"] != nil {
            self.minAttemptInterval = dict["MinAttemptInterval"] as! Int64
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("QueueId") && dict["QueueId"] != nil {
            self.queueId = dict["QueueId"] as! String
        }
        if dict.keys.contains("Simulation") && dict["Simulation"] != nil {
            self.simulation = dict["Simulation"] as! Bool
        }
        if dict.keys.contains("SimulationParameters") && dict["SimulationParameters"] != nil {
            self.simulationParameters = dict["SimulationParameters"] as! String
        }
        if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
            self.startTime = dict["StartTime"] as! String
        }
        if dict.keys.contains("StrategyParameters") && dict["StrategyParameters"] != nil {
            self.strategyParameters = dict["StrategyParameters"] as! String
        }
        if dict.keys.contains("StrategyType") && dict["StrategyType"] != nil {
            self.strategyType = dict["StrategyType"] as! String
        }
    }
}

public class CreateCampaignShrinkRequest : Tea.TeaModel {
    public var callableTime: String?

    public var caseFileKey: String?

    public var caseListShrink: String?

    public var contactFlowId: String?

    public var endTime: String?

    public var executingUntilTimeout: Bool?

    public var instanceId: String?

    public var maxAttemptCount: Int64?

    public var minAttemptInterval: Int64?

    public var name: String?

    public var queueId: String?

    public var simulation: Bool?

    public var simulationParameters: String?

    public var startTime: String?

    public var strategyParameters: String?

    public var strategyType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.callableTime != nil {
            map["CallableTime"] = self.callableTime!
        }
        if self.caseFileKey != nil {
            map["CaseFileKey"] = self.caseFileKey!
        }
        if self.caseListShrink != nil {
            map["CaseList"] = self.caseListShrink!
        }
        if self.contactFlowId != nil {
            map["ContactFlowId"] = self.contactFlowId!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.executingUntilTimeout != nil {
            map["ExecutingUntilTimeout"] = self.executingUntilTimeout!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.maxAttemptCount != nil {
            map["MaxAttemptCount"] = self.maxAttemptCount!
        }
        if self.minAttemptInterval != nil {
            map["MinAttemptInterval"] = self.minAttemptInterval!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.queueId != nil {
            map["QueueId"] = self.queueId!
        }
        if self.simulation != nil {
            map["Simulation"] = self.simulation!
        }
        if self.simulationParameters != nil {
            map["SimulationParameters"] = self.simulationParameters!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.strategyParameters != nil {
            map["StrategyParameters"] = self.strategyParameters!
        }
        if self.strategyType != nil {
            map["StrategyType"] = self.strategyType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CallableTime") && dict["CallableTime"] != nil {
            self.callableTime = dict["CallableTime"] as! String
        }
        if dict.keys.contains("CaseFileKey") && dict["CaseFileKey"] != nil {
            self.caseFileKey = dict["CaseFileKey"] as! String
        }
        if dict.keys.contains("CaseList") && dict["CaseList"] != nil {
            self.caseListShrink = dict["CaseList"] as! String
        }
        if dict.keys.contains("ContactFlowId") && dict["ContactFlowId"] != nil {
            self.contactFlowId = dict["ContactFlowId"] as! String
        }
        if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("ExecutingUntilTimeout") && dict["ExecutingUntilTimeout"] != nil {
            self.executingUntilTimeout = dict["ExecutingUntilTimeout"] as! Bool
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("MaxAttemptCount") && dict["MaxAttemptCount"] != nil {
            self.maxAttemptCount = dict["MaxAttemptCount"] as! Int64
        }
        if dict.keys.contains("MinAttemptInterval") && dict["MinAttemptInterval"] != nil {
            self.minAttemptInterval = dict["MinAttemptInterval"] as! Int64
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("QueueId") && dict["QueueId"] != nil {
            self.queueId = dict["QueueId"] as! String
        }
        if dict.keys.contains("Simulation") && dict["Simulation"] != nil {
            self.simulation = dict["Simulation"] as! Bool
        }
        if dict.keys.contains("SimulationParameters") && dict["SimulationParameters"] != nil {
            self.simulationParameters = dict["SimulationParameters"] as! String
        }
        if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
            self.startTime = dict["StartTime"] as! String
        }
        if dict.keys.contains("StrategyParameters") && dict["StrategyParameters"] != nil {
            self.strategyParameters = dict["StrategyParameters"] as! String
        }
        if dict.keys.contains("StrategyType") && dict["StrategyType"] != nil {
            self.strategyType = dict["StrategyType"] as! String
        }
    }
}

public class CreateCampaignResponseBody : Tea.TeaModel {
    public var code: String?

    public var data: String?

    public var httpStatusCode: Int64?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int64
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateCampaignResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateCampaignResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateCampaignResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateContactFlowRequest : Tea.TeaModel {
    public var definition: String?

    public var description_: String?

    public var instanceId: String?

    public var name: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.definition != nil {
            map["Definition"] = self.definition!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Definition") && dict["Definition"] != nil {
            self.definition = dict["Definition"] as! String
        }
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! String
        }
    }
}

public class CreateContactFlowResponseBody : Tea.TeaModel {
    public var code: String?

    public var data: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateContactFlowResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateContactFlowResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateContactFlowResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateCustomCallTaggingRequest : Tea.TeaModel {
    public var customNumberList: String?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.customNumberList != nil {
            map["CustomNumberList"] = self.customNumberList!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CustomNumberList") && dict["CustomNumberList"] != nil {
            self.customNumberList = dict["CustomNumberList"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
    }
}

public class CreateCustomCallTaggingResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var item: String?

        public var reason: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.item != nil {
                map["Item"] = self.item!
            }
            if self.reason != nil {
                map["Reason"] = self.reason!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Item") && dict["Item"] != nil {
                self.item = dict["Item"] as! String
            }
            if dict.keys.contains("Reason") && dict["Reason"] != nil {
                self.reason = dict["Reason"] as! String
            }
        }
    }
    public var code: String?

    public var data: [CreateCustomCallTaggingResponseBody.Data]?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var tmp : [CreateCustomCallTaggingResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = CreateCustomCallTaggingResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateCustomCallTaggingResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateCustomCallTaggingResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateCustomCallTaggingResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateInstanceRequest : Tea.TeaModel {
    public var adminRamIdList: String?

    public var description_: String?

    public var domainName: String?

    public var name: String?

    public var numberList: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.adminRamIdList != nil {
            map["AdminRamIdList"] = self.adminRamIdList!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.domainName != nil {
            map["DomainName"] = self.domainName!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.numberList != nil {
            map["NumberList"] = self.numberList!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AdminRamIdList") && dict["AdminRamIdList"] != nil {
            self.adminRamIdList = dict["AdminRamIdList"] as! String
        }
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("DomainName") && dict["DomainName"] != nil {
            self.domainName = dict["DomainName"] as! String
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("NumberList") && dict["NumberList"] != nil {
            self.numberList = dict["NumberList"] as! String
        }
    }
}

public class CreateInstanceResponseBody : Tea.TeaModel {
    public var code: String?

    public var data: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateSkillGroupRequest : Tea.TeaModel {
    public var description_: String?

    public var displayName: String?

    public var instanceId: String?

    public var name: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.displayName != nil {
            map["DisplayName"] = self.displayName!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("DisplayName") && dict["DisplayName"] != nil {
            self.displayName = dict["DisplayName"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
    }
}

public class CreateSkillGroupResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var description_: String?

        public var instanceId: String?

        public var name: String?

        public var skillGroupId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.skillGroupId != nil {
                map["SkillGroupId"] = self.skillGroupId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Description") && dict["Description"] != nil {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("SkillGroupId") && dict["SkillGroupId"] != nil {
                self.skillGroupId = dict["SkillGroupId"] as! String
            }
        }
    }
    public var code: String?

    public var data: CreateSkillGroupResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = CreateSkillGroupResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateSkillGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateSkillGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateSkillGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateUserRequest : Tea.TeaModel {
    public var displayId: String?

    public var displayName: String?

    public var email: String?

    public var instanceId: String?

    public var loginName: String?

    public var mobile: String?

    public var resetPassword: Bool?

    public var roleId: String?

    public var skillLevelList: String?

    public var workMode: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.displayId != nil {
            map["DisplayId"] = self.displayId!
        }
        if self.displayName != nil {
            map["DisplayName"] = self.displayName!
        }
        if self.email != nil {
            map["Email"] = self.email!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.loginName != nil {
            map["LoginName"] = self.loginName!
        }
        if self.mobile != nil {
            map["Mobile"] = self.mobile!
        }
        if self.resetPassword != nil {
            map["ResetPassword"] = self.resetPassword!
        }
        if self.roleId != nil {
            map["RoleId"] = self.roleId!
        }
        if self.skillLevelList != nil {
            map["SkillLevelList"] = self.skillLevelList!
        }
        if self.workMode != nil {
            map["WorkMode"] = self.workMode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DisplayId") && dict["DisplayId"] != nil {
            self.displayId = dict["DisplayId"] as! String
        }
        if dict.keys.contains("DisplayName") && dict["DisplayName"] != nil {
            self.displayName = dict["DisplayName"] as! String
        }
        if dict.keys.contains("Email") && dict["Email"] != nil {
            self.email = dict["Email"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("LoginName") && dict["LoginName"] != nil {
            self.loginName = dict["LoginName"] as! String
        }
        if dict.keys.contains("Mobile") && dict["Mobile"] != nil {
            self.mobile = dict["Mobile"] as! String
        }
        if dict.keys.contains("ResetPassword") && dict["ResetPassword"] != nil {
            self.resetPassword = dict["ResetPassword"] as! Bool
        }
        if dict.keys.contains("RoleId") && dict["RoleId"] != nil {
            self.roleId = dict["RoleId"] as! String
        }
        if dict.keys.contains("SkillLevelList") && dict["SkillLevelList"] != nil {
            self.skillLevelList = dict["SkillLevelList"] as! String
        }
        if dict.keys.contains("WorkMode") && dict["WorkMode"] != nil {
            self.workMode = dict["WorkMode"] as! String
        }
    }
}

public class CreateUserResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var displayName: String?

        public var email: String?

        public var extension_: String?

        public var loginName: String?

        public var mobile: String?

        public var userId: String?

        public var workMode: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.displayName != nil {
                map["DisplayName"] = self.displayName!
            }
            if self.email != nil {
                map["Email"] = self.email!
            }
            if self.extension_ != nil {
                map["Extension"] = self.extension_!
            }
            if self.loginName != nil {
                map["LoginName"] = self.loginName!
            }
            if self.mobile != nil {
                map["Mobile"] = self.mobile!
            }
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            if self.workMode != nil {
                map["WorkMode"] = self.workMode!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DisplayName") && dict["DisplayName"] != nil {
                self.displayName = dict["DisplayName"] as! String
            }
            if dict.keys.contains("Email") && dict["Email"] != nil {
                self.email = dict["Email"] as! String
            }
            if dict.keys.contains("Extension") && dict["Extension"] != nil {
                self.extension_ = dict["Extension"] as! String
            }
            if dict.keys.contains("LoginName") && dict["LoginName"] != nil {
                self.loginName = dict["LoginName"] as! String
            }
            if dict.keys.contains("Mobile") && dict["Mobile"] != nil {
                self.mobile = dict["Mobile"] as! String
            }
            if dict.keys.contains("UserId") && dict["UserId"] != nil {
                self.userId = dict["UserId"] as! String
            }
            if dict.keys.contains("WorkMode") && dict["WorkMode"] != nil {
                self.workMode = dict["WorkMode"] as! String
            }
        }
    }
    public var code: String?

    public var data: CreateUserResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = CreateUserResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateUserResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateUserResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateUserResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteAudioFileRequest : Tea.TeaModel {
    public var audioResourceId: String?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.audioResourceId != nil {
            map["AudioResourceId"] = self.audioResourceId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AudioResourceId") && dict["AudioResourceId"] != nil {
            self.audioResourceId = dict["AudioResourceId"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
    }
}

public class DeleteAudioFileResponseBody : Tea.TeaModel {
    public var code: String?

    public var data: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteAudioFileResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteAudioFileResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteAudioFileResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteCallTagRequest : Tea.TeaModel {
    public var instanceId: String?

    public var tagName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.tagName != nil {
            map["TagName"] = self.tagName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("TagName") && dict["TagName"] != nil {
            self.tagName = dict["TagName"] as! String
        }
    }
}

public class DeleteCallTagResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteCallTagResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteCallTagResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteCallTagResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteContactFlowRequest : Tea.TeaModel {
    public var contactFlowId: String?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.contactFlowId != nil {
            map["ContactFlowId"] = self.contactFlowId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ContactFlowId") && dict["ContactFlowId"] != nil {
            self.contactFlowId = dict["ContactFlowId"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
    }
}

public class DeleteContactFlowResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteContactFlowResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteContactFlowResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteContactFlowResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteCustomCallTaggingRequest : Tea.TeaModel {
    public var instanceId: String?

    public var number: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.number != nil {
            map["Number"] = self.number!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Number") && dict["Number"] != nil {
            self.number = dict["Number"] as! String
        }
    }
}

public class DeleteCustomCallTaggingResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteCustomCallTaggingResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteCustomCallTaggingResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteCustomCallTaggingResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteSkillGroupRequest : Tea.TeaModel {
    public var force: Bool?

    public var instanceId: String?

    public var skillGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.force != nil {
            map["Force"] = self.force!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.skillGroupId != nil {
            map["SkillGroupId"] = self.skillGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Force") && dict["Force"] != nil {
            self.force = dict["Force"] as! Bool
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("SkillGroupId") && dict["SkillGroupId"] != nil {
            self.skillGroupId = dict["SkillGroupId"] as! String
        }
    }
}

public class DeleteSkillGroupResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteSkillGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteSkillGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteSkillGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DiscardEditingContactFlowRequest : Tea.TeaModel {
    public var contactFlowId: String?

    public var draftId: String?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.contactFlowId != nil {
            map["ContactFlowId"] = self.contactFlowId!
        }
        if self.draftId != nil {
            map["DraftId"] = self.draftId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ContactFlowId") && dict["ContactFlowId"] != nil {
            self.contactFlowId = dict["ContactFlowId"] as! String
        }
        if dict.keys.contains("DraftId") && dict["DraftId"] != nil {
            self.draftId = dict["DraftId"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
    }
}

public class DiscardEditingContactFlowResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DiscardEditingContactFlowResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DiscardEditingContactFlowResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DiscardEditingContactFlowResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class EndConferenceRequest : Tea.TeaModel {
    public var instanceId: String?

    public var jobId: String?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("JobId") && dict["JobId"] != nil {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("UserId") && dict["UserId"] != nil {
            self.userId = dict["UserId"] as! String
        }
    }
}

public class EndConferenceResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class CallContext : Tea.TeaModel {
            public class ChannelContexts : Tea.TeaModel {
                public var callType: String?

                public var channelId: String?

                public var channelState: String?

                public var destination: String?

                public var jobId: String?

                public var originator: String?

                public var releaseInitiator: String?

                public var releaseReason: String?

                public var timestamp: Int64?

                public var userExtension: String?

                public var userId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.callType != nil {
                        map["CallType"] = self.callType!
                    }
                    if self.channelId != nil {
                        map["ChannelId"] = self.channelId!
                    }
                    if self.channelState != nil {
                        map["ChannelState"] = self.channelState!
                    }
                    if self.destination != nil {
                        map["Destination"] = self.destination!
                    }
                    if self.jobId != nil {
                        map["JobId"] = self.jobId!
                    }
                    if self.originator != nil {
                        map["Originator"] = self.originator!
                    }
                    if self.releaseInitiator != nil {
                        map["ReleaseInitiator"] = self.releaseInitiator!
                    }
                    if self.releaseReason != nil {
                        map["ReleaseReason"] = self.releaseReason!
                    }
                    if self.timestamp != nil {
                        map["Timestamp"] = self.timestamp!
                    }
                    if self.userExtension != nil {
                        map["UserExtension"] = self.userExtension!
                    }
                    if self.userId != nil {
                        map["UserId"] = self.userId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("CallType") && dict["CallType"] != nil {
                        self.callType = dict["CallType"] as! String
                    }
                    if dict.keys.contains("ChannelId") && dict["ChannelId"] != nil {
                        self.channelId = dict["ChannelId"] as! String
                    }
                    if dict.keys.contains("ChannelState") && dict["ChannelState"] != nil {
                        self.channelState = dict["ChannelState"] as! String
                    }
                    if dict.keys.contains("Destination") && dict["Destination"] != nil {
                        self.destination = dict["Destination"] as! String
                    }
                    if dict.keys.contains("JobId") && dict["JobId"] != nil {
                        self.jobId = dict["JobId"] as! String
                    }
                    if dict.keys.contains("Originator") && dict["Originator"] != nil {
                        self.originator = dict["Originator"] as! String
                    }
                    if dict.keys.contains("ReleaseInitiator") && dict["ReleaseInitiator"] != nil {
                        self.releaseInitiator = dict["ReleaseInitiator"] as! String
                    }
                    if dict.keys.contains("ReleaseReason") && dict["ReleaseReason"] != nil {
                        self.releaseReason = dict["ReleaseReason"] as! String
                    }
                    if dict.keys.contains("Timestamp") && dict["Timestamp"] != nil {
                        self.timestamp = dict["Timestamp"] as! Int64
                    }
                    if dict.keys.contains("UserExtension") && dict["UserExtension"] != nil {
                        self.userExtension = dict["UserExtension"] as! String
                    }
                    if dict.keys.contains("UserId") && dict["UserId"] != nil {
                        self.userId = dict["UserId"] as! String
                    }
                }
            }
            public var channelContexts: [EndConferenceResponseBody.Data.CallContext.ChannelContexts]?

            public var instanceId: String?

            public var jobId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.channelContexts != nil {
                    var tmp : [Any] = []
                    for k in self.channelContexts! {
                        tmp.append(k.toMap())
                    }
                    map["ChannelContexts"] = tmp
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.jobId != nil {
                    map["JobId"] = self.jobId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ChannelContexts") && dict["ChannelContexts"] != nil {
                    var tmp : [EndConferenceResponseBody.Data.CallContext.ChannelContexts] = []
                    for v in dict["ChannelContexts"] as! [Any] {
                        var model = EndConferenceResponseBody.Data.CallContext.ChannelContexts()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.channelContexts = tmp
                }
                if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("JobId") && dict["JobId"] != nil {
                    self.jobId = dict["JobId"] as! String
                }
            }
        }
        public class UserContext : Tea.TeaModel {
            public var breakCode: String?

            public var deviceId: String?

            public var deviceState: String?

            public var extension_: String?

            public var instanceId: String?

            public var jobId: String?

            public var outboundScenario: Bool?

            public var signedSkillGroupIdList: [String]?

            public var userId: String?

            public var userState: String?

            public var workMode: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.breakCode != nil {
                    map["BreakCode"] = self.breakCode!
                }
                if self.deviceId != nil {
                    map["DeviceId"] = self.deviceId!
                }
                if self.deviceState != nil {
                    map["DeviceState"] = self.deviceState!
                }
                if self.extension_ != nil {
                    map["Extension"] = self.extension_!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.jobId != nil {
                    map["JobId"] = self.jobId!
                }
                if self.outboundScenario != nil {
                    map["OutboundScenario"] = self.outboundScenario!
                }
                if self.signedSkillGroupIdList != nil {
                    map["SignedSkillGroupIdList"] = self.signedSkillGroupIdList!
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                if self.userState != nil {
                    map["UserState"] = self.userState!
                }
                if self.workMode != nil {
                    map["WorkMode"] = self.workMode!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BreakCode") && dict["BreakCode"] != nil {
                    self.breakCode = dict["BreakCode"] as! String
                }
                if dict.keys.contains("DeviceId") && dict["DeviceId"] != nil {
                    self.deviceId = dict["DeviceId"] as! String
                }
                if dict.keys.contains("DeviceState") && dict["DeviceState"] != nil {
                    self.deviceState = dict["DeviceState"] as! String
                }
                if dict.keys.contains("Extension") && dict["Extension"] != nil {
                    self.extension_ = dict["Extension"] as! String
                }
                if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("JobId") && dict["JobId"] != nil {
                    self.jobId = dict["JobId"] as! String
                }
                if dict.keys.contains("OutboundScenario") && dict["OutboundScenario"] != nil {
                    self.outboundScenario = dict["OutboundScenario"] as! Bool
                }
                if dict.keys.contains("SignedSkillGroupIdList") && dict["SignedSkillGroupIdList"] != nil {
                    self.signedSkillGroupIdList = dict["SignedSkillGroupIdList"] as! [String]
                }
                if dict.keys.contains("UserId") && dict["UserId"] != nil {
                    self.userId = dict["UserId"] as! String
                }
                if dict.keys.contains("UserState") && dict["UserState"] != nil {
                    self.userState = dict["UserState"] as! String
                }
                if dict.keys.contains("WorkMode") && dict["WorkMode"] != nil {
                    self.workMode = dict["WorkMode"] as! String
                }
            }
        }
        public var callContext: EndConferenceResponseBody.Data.CallContext?

        public var contextId: Int64?

        public var userContext: EndConferenceResponseBody.Data.UserContext?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.callContext?.validate()
            try self.userContext?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.callContext != nil {
                map["CallContext"] = self.callContext?.toMap()
            }
            if self.contextId != nil {
                map["ContextId"] = self.contextId!
            }
            if self.userContext != nil {
                map["UserContext"] = self.userContext?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CallContext") && dict["CallContext"] != nil {
                var model = EndConferenceResponseBody.Data.CallContext()
                model.fromMap(dict["CallContext"] as! [String: Any])
                self.callContext = model
            }
            if dict.keys.contains("ContextId") && dict["ContextId"] != nil {
                self.contextId = dict["ContextId"] as! Int64
            }
            if dict.keys.contains("UserContext") && dict["UserContext"] != nil {
                var model = EndConferenceResponseBody.Data.UserContext()
                model.fromMap(dict["UserContext"] as! [String: Any])
                self.userContext = model
            }
        }
    }
    public var code: String?

    public var data: EndConferenceResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var params: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.params != nil {
            map["Params"] = self.params!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = EndConferenceResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Params") && dict["Params"] != nil {
            self.params = dict["Params"] as! [String]
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class EndConferenceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: EndConferenceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = EndConferenceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ExportCustomCallTaggingRequest : Tea.TeaModel {
    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
    }
}

public class ExportCustomCallTaggingResponseBody : Tea.TeaModel {
    public var code: String?

    public var data: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ExportCustomCallTaggingResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ExportCustomCallTaggingResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ExportCustomCallTaggingResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ExportDoNotCallNumbersRequest : Tea.TeaModel {
    public var instanceId: String?

    public var scope: String?

    public var searchPattern: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.scope != nil {
            map["Scope"] = self.scope!
        }
        if self.searchPattern != nil {
            map["SearchPattern"] = self.searchPattern!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Scope") && dict["Scope"] != nil {
            self.scope = dict["Scope"] as! String
        }
        if dict.keys.contains("SearchPattern") && dict["SearchPattern"] != nil {
            self.searchPattern = dict["SearchPattern"] as! String
        }
    }
}

public class ExportDoNotCallNumbersResponseBody : Tea.TeaModel {
    public var code: String?

    public var data: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ExportDoNotCallNumbersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ExportDoNotCallNumbersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ExportDoNotCallNumbersResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetAudioFileRequest : Tea.TeaModel {
    public var audioResourceId: String?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.audioResourceId != nil {
            map["AudioResourceId"] = self.audioResourceId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AudioResourceId") && dict["AudioResourceId"] != nil {
            self.audioResourceId = dict["AudioResourceId"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
    }
}

public class GetAudioFileResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var audioFileName: String?

        public var audioResourceId: String?

        public var createdTime: String?

        public var instanceId: String?

        public var name: String?

        public var ossFileKey: String?

        public var updatedTime: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.audioFileName != nil {
                map["AudioFileName"] = self.audioFileName!
            }
            if self.audioResourceId != nil {
                map["AudioResourceId"] = self.audioResourceId!
            }
            if self.createdTime != nil {
                map["CreatedTime"] = self.createdTime!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.ossFileKey != nil {
                map["OssFileKey"] = self.ossFileKey!
            }
            if self.updatedTime != nil {
                map["UpdatedTime"] = self.updatedTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AudioFileName") && dict["AudioFileName"] != nil {
                self.audioFileName = dict["AudioFileName"] as! String
            }
            if dict.keys.contains("AudioResourceId") && dict["AudioResourceId"] != nil {
                self.audioResourceId = dict["AudioResourceId"] as! String
            }
            if dict.keys.contains("CreatedTime") && dict["CreatedTime"] != nil {
                self.createdTime = dict["CreatedTime"] as! String
            }
            if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("OssFileKey") && dict["OssFileKey"] != nil {
                self.ossFileKey = dict["OssFileKey"] as! String
            }
            if dict.keys.contains("UpdatedTime") && dict["UpdatedTime"] != nil {
                self.updatedTime = dict["UpdatedTime"] as! String
            }
        }
    }
    public var code: String?

    public var data: GetAudioFileResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = GetAudioFileResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetAudioFileResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetAudioFileResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetAudioFileResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetAudioFileDownloadUrlRequest : Tea.TeaModel {
    public var audioResourceId: String?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.audioResourceId != nil {
            map["AudioResourceId"] = self.audioResourceId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AudioResourceId") && dict["AudioResourceId"] != nil {
            self.audioResourceId = dict["AudioResourceId"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
    }
}

public class GetAudioFileDownloadUrlResponseBody : Tea.TeaModel {
    public var code: String?

    public var data: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetAudioFileDownloadUrlResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetAudioFileDownloadUrlResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetAudioFileDownloadUrlResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetAudioFileUploadParametersRequest : Tea.TeaModel {
    public var audioFileName: String?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.audioFileName != nil {
            map["AudioFileName"] = self.audioFileName!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AudioFileName") && dict["AudioFileName"] != nil {
            self.audioFileName = dict["AudioFileName"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
    }
}

public class GetAudioFileUploadParametersResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var accessKeyId: String?

        public var expireTime: Int32?

        public var filePath: String?

        public var host: String?

        public var policy: String?

        public var signature: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accessKeyId != nil {
                map["AccessKeyId"] = self.accessKeyId!
            }
            if self.expireTime != nil {
                map["ExpireTime"] = self.expireTime!
            }
            if self.filePath != nil {
                map["FilePath"] = self.filePath!
            }
            if self.host != nil {
                map["Host"] = self.host!
            }
            if self.policy != nil {
                map["Policy"] = self.policy!
            }
            if self.signature != nil {
                map["Signature"] = self.signature!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AccessKeyId") && dict["AccessKeyId"] != nil {
                self.accessKeyId = dict["AccessKeyId"] as! String
            }
            if dict.keys.contains("ExpireTime") && dict["ExpireTime"] != nil {
                self.expireTime = dict["ExpireTime"] as! Int32
            }
            if dict.keys.contains("FilePath") && dict["FilePath"] != nil {
                self.filePath = dict["FilePath"] as! String
            }
            if dict.keys.contains("Host") && dict["Host"] != nil {
                self.host = dict["Host"] as! String
            }
            if dict.keys.contains("Policy") && dict["Policy"] != nil {
                self.policy = dict["Policy"] as! String
            }
            if dict.keys.contains("Signature") && dict["Signature"] != nil {
                self.signature = dict["Signature"] as! String
            }
        }
    }
    public var code: String?

    public var data: GetAudioFileUploadParametersResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = GetAudioFileUploadParametersResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetAudioFileUploadParametersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetAudioFileUploadParametersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetAudioFileUploadParametersResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetCallDetailRecordRequest : Tea.TeaModel {
    public var contactId: String?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.contactId != nil {
            map["ContactId"] = self.contactId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ContactId") && dict["ContactId"] != nil {
            self.contactId = dict["ContactId"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
    }
}

public class GetCallDetailRecordResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class AgentEvents : Tea.TeaModel {
            public class EventSequence : Tea.TeaModel {
                public var duration: Int64?

                public var event: String?

                public var eventTime: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.duration != nil {
                        map["Duration"] = self.duration!
                    }
                    if self.event != nil {
                        map["Event"] = self.event!
                    }
                    if self.eventTime != nil {
                        map["EventTime"] = self.eventTime!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Duration") && dict["Duration"] != nil {
                        self.duration = dict["Duration"] as! Int64
                    }
                    if dict.keys.contains("Event") && dict["Event"] != nil {
                        self.event = dict["Event"] as! String
                    }
                    if dict.keys.contains("EventTime") && dict["EventTime"] != nil {
                        self.eventTime = dict["EventTime"] as! Int64
                    }
                }
            }
            public var agentId: String?

            public var agentName: String?

            public var eventSequence: [GetCallDetailRecordResponseBody.Data.AgentEvents.EventSequence]?

            public var skillGroupId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.agentId != nil {
                    map["AgentId"] = self.agentId!
                }
                if self.agentName != nil {
                    map["AgentName"] = self.agentName!
                }
                if self.eventSequence != nil {
                    var tmp : [Any] = []
                    for k in self.eventSequence! {
                        tmp.append(k.toMap())
                    }
                    map["EventSequence"] = tmp
                }
                if self.skillGroupId != nil {
                    map["SkillGroupId"] = self.skillGroupId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AgentId") && dict["AgentId"] != nil {
                    self.agentId = dict["AgentId"] as! String
                }
                if dict.keys.contains("AgentName") && dict["AgentName"] != nil {
                    self.agentName = dict["AgentName"] as! String
                }
                if dict.keys.contains("EventSequence") && dict["EventSequence"] != nil {
                    var tmp : [GetCallDetailRecordResponseBody.Data.AgentEvents.EventSequence] = []
                    for v in dict["EventSequence"] as! [Any] {
                        var model = GetCallDetailRecordResponseBody.Data.AgentEvents.EventSequence()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.eventSequence = tmp
                }
                if dict.keys.contains("SkillGroupId") && dict["SkillGroupId"] != nil {
                    self.skillGroupId = dict["SkillGroupId"] as! String
                }
            }
        }
        public class CustomerEvents : Tea.TeaModel {
            public class EventSequence : Tea.TeaModel {
                public var event: String?

                public var eventTime: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.event != nil {
                        map["Event"] = self.event!
                    }
                    if self.eventTime != nil {
                        map["EventTime"] = self.eventTime!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Event") && dict["Event"] != nil {
                        self.event = dict["Event"] as! String
                    }
                    if dict.keys.contains("EventTime") && dict["EventTime"] != nil {
                        self.eventTime = dict["EventTime"] as! Int64
                    }
                }
            }
            public var customerId: String?

            public var eventSequence: [GetCallDetailRecordResponseBody.Data.CustomerEvents.EventSequence]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.customerId != nil {
                    map["CustomerId"] = self.customerId!
                }
                if self.eventSequence != nil {
                    var tmp : [Any] = []
                    for k in self.eventSequence! {
                        tmp.append(k.toMap())
                    }
                    map["EventSequence"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CustomerId") && dict["CustomerId"] != nil {
                    self.customerId = dict["CustomerId"] as! String
                }
                if dict.keys.contains("EventSequence") && dict["EventSequence"] != nil {
                    var tmp : [GetCallDetailRecordResponseBody.Data.CustomerEvents.EventSequence] = []
                    for v in dict["EventSequence"] as! [Any] {
                        var model = GetCallDetailRecordResponseBody.Data.CustomerEvents.EventSequence()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.eventSequence = tmp
                }
            }
        }
        public class IvrEvents : Tea.TeaModel {
            public class EventSequence : Tea.TeaModel {
                public var event: String?

                public var eventTime: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.event != nil {
                        map["Event"] = self.event!
                    }
                    if self.eventTime != nil {
                        map["EventTime"] = self.eventTime!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Event") && dict["Event"] != nil {
                        self.event = dict["Event"] as! String
                    }
                    if dict.keys.contains("EventTime") && dict["EventTime"] != nil {
                        self.eventTime = dict["EventTime"] as! Int64
                    }
                }
            }
            public var eventSequence: [GetCallDetailRecordResponseBody.Data.IvrEvents.EventSequence]?

            public var flowId: String?

            public var flowType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.eventSequence != nil {
                    var tmp : [Any] = []
                    for k in self.eventSequence! {
                        tmp.append(k.toMap())
                    }
                    map["EventSequence"] = tmp
                }
                if self.flowId != nil {
                    map["FlowId"] = self.flowId!
                }
                if self.flowType != nil {
                    map["FlowType"] = self.flowType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("EventSequence") && dict["EventSequence"] != nil {
                    var tmp : [GetCallDetailRecordResponseBody.Data.IvrEvents.EventSequence] = []
                    for v in dict["EventSequence"] as! [Any] {
                        var model = GetCallDetailRecordResponseBody.Data.IvrEvents.EventSequence()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.eventSequence = tmp
                }
                if dict.keys.contains("FlowId") && dict["FlowId"] != nil {
                    self.flowId = dict["FlowId"] as! String
                }
                if dict.keys.contains("FlowType") && dict["FlowType"] != nil {
                    self.flowType = dict["FlowType"] as! String
                }
            }
        }
        public class QueueEvents : Tea.TeaModel {
            public class EventSequence : Tea.TeaModel {
                public var event: String?

                public var eventTime: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.event != nil {
                        map["Event"] = self.event!
                    }
                    if self.eventTime != nil {
                        map["EventTime"] = self.eventTime!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Event") && dict["Event"] != nil {
                        self.event = dict["Event"] as! String
                    }
                    if dict.keys.contains("EventTime") && dict["EventTime"] != nil {
                        self.eventTime = dict["EventTime"] as! Int64
                    }
                }
            }
            public var eventSequence: [GetCallDetailRecordResponseBody.Data.QueueEvents.EventSequence]?

            public var flowId: String?

            public var queueId: String?

            public var queueName: String?

            public var queueType: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.eventSequence != nil {
                    var tmp : [Any] = []
                    for k in self.eventSequence! {
                        tmp.append(k.toMap())
                    }
                    map["EventSequence"] = tmp
                }
                if self.flowId != nil {
                    map["FlowId"] = self.flowId!
                }
                if self.queueId != nil {
                    map["QueueId"] = self.queueId!
                }
                if self.queueName != nil {
                    map["QueueName"] = self.queueName!
                }
                if self.queueType != nil {
                    map["QueueType"] = self.queueType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("EventSequence") && dict["EventSequence"] != nil {
                    var tmp : [GetCallDetailRecordResponseBody.Data.QueueEvents.EventSequence] = []
                    for v in dict["EventSequence"] as! [Any] {
                        var model = GetCallDetailRecordResponseBody.Data.QueueEvents.EventSequence()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.eventSequence = tmp
                }
                if dict.keys.contains("FlowId") && dict["FlowId"] != nil {
                    self.flowId = dict["FlowId"] as! String
                }
                if dict.keys.contains("QueueId") && dict["QueueId"] != nil {
                    self.queueId = dict["QueueId"] as! String
                }
                if dict.keys.contains("QueueName") && dict["QueueName"] != nil {
                    self.queueName = dict["QueueName"] as! String
                }
                if dict.keys.contains("QueueType") && dict["QueueType"] != nil {
                    self.queueType = dict["QueueType"] as! Int32
                }
            }
        }
        public var agentEvents: [GetCallDetailRecordResponseBody.Data.AgentEvents]?

        public var agentIds: String?

        public var agentNames: String?

        public var callDuration: Int64?

        public var calledNumber: String?

        public var calleeLocation: String?

        public var callerLocation: String?

        public var callingNumber: String?

        public var contactDisposition: String?

        public var contactId: String?

        public var contactType: String?

        public var customerEvents: [GetCallDetailRecordResponseBody.Data.CustomerEvents]?

        public var earlyMediaState: String?

        public var establishedTime: Int64?

        public var instanceId: String?

        public var ivrEvents: [GetCallDetailRecordResponseBody.Data.IvrEvents]?

        public var queueEvents: [GetCallDetailRecordResponseBody.Data.QueueEvents]?

        public var recordingReady: Bool?

        public var releaseInitiator: String?

        public var releaseReason: String?

        public var releaseTime: Int64?

        public var satisfaction: Int32?

        public var satisfactionSurveyChannel: String?

        public var satisfactionSurveyOffered: Bool?

        public var skillGroupIds: String?

        public var skillGroupNames: String?

        public var startTime: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.agentEvents != nil {
                var tmp : [Any] = []
                for k in self.agentEvents! {
                    tmp.append(k.toMap())
                }
                map["AgentEvents"] = tmp
            }
            if self.agentIds != nil {
                map["AgentIds"] = self.agentIds!
            }
            if self.agentNames != nil {
                map["AgentNames"] = self.agentNames!
            }
            if self.callDuration != nil {
                map["CallDuration"] = self.callDuration!
            }
            if self.calledNumber != nil {
                map["CalledNumber"] = self.calledNumber!
            }
            if self.calleeLocation != nil {
                map["CalleeLocation"] = self.calleeLocation!
            }
            if self.callerLocation != nil {
                map["CallerLocation"] = self.callerLocation!
            }
            if self.callingNumber != nil {
                map["CallingNumber"] = self.callingNumber!
            }
            if self.contactDisposition != nil {
                map["ContactDisposition"] = self.contactDisposition!
            }
            if self.contactId != nil {
                map["ContactId"] = self.contactId!
            }
            if self.contactType != nil {
                map["ContactType"] = self.contactType!
            }
            if self.customerEvents != nil {
                var tmp : [Any] = []
                for k in self.customerEvents! {
                    tmp.append(k.toMap())
                }
                map["CustomerEvents"] = tmp
            }
            if self.earlyMediaState != nil {
                map["EarlyMediaState"] = self.earlyMediaState!
            }
            if self.establishedTime != nil {
                map["EstablishedTime"] = self.establishedTime!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.ivrEvents != nil {
                var tmp : [Any] = []
                for k in self.ivrEvents! {
                    tmp.append(k.toMap())
                }
                map["IvrEvents"] = tmp
            }
            if self.queueEvents != nil {
                var tmp : [Any] = []
                for k in self.queueEvents! {
                    tmp.append(k.toMap())
                }
                map["QueueEvents"] = tmp
            }
            if self.recordingReady != nil {
                map["RecordingReady"] = self.recordingReady!
            }
            if self.releaseInitiator != nil {
                map["ReleaseInitiator"] = self.releaseInitiator!
            }
            if self.releaseReason != nil {
                map["ReleaseReason"] = self.releaseReason!
            }
            if self.releaseTime != nil {
                map["ReleaseTime"] = self.releaseTime!
            }
            if self.satisfaction != nil {
                map["Satisfaction"] = self.satisfaction!
            }
            if self.satisfactionSurveyChannel != nil {
                map["SatisfactionSurveyChannel"] = self.satisfactionSurveyChannel!
            }
            if self.satisfactionSurveyOffered != nil {
                map["SatisfactionSurveyOffered"] = self.satisfactionSurveyOffered!
            }
            if self.skillGroupIds != nil {
                map["SkillGroupIds"] = self.skillGroupIds!
            }
            if self.skillGroupNames != nil {
                map["SkillGroupNames"] = self.skillGroupNames!
            }
            if self.startTime != nil {
                map["StartTime"] = self.startTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AgentEvents") && dict["AgentEvents"] != nil {
                var tmp : [GetCallDetailRecordResponseBody.Data.AgentEvents] = []
                for v in dict["AgentEvents"] as! [Any] {
                    var model = GetCallDetailRecordResponseBody.Data.AgentEvents()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.agentEvents = tmp
            }
            if dict.keys.contains("AgentIds") && dict["AgentIds"] != nil {
                self.agentIds = dict["AgentIds"] as! String
            }
            if dict.keys.contains("AgentNames") && dict["AgentNames"] != nil {
                self.agentNames = dict["AgentNames"] as! String
            }
            if dict.keys.contains("CallDuration") && dict["CallDuration"] != nil {
                self.callDuration = dict["CallDuration"] as! Int64
            }
            if dict.keys.contains("CalledNumber") && dict["CalledNumber"] != nil {
                self.calledNumber = dict["CalledNumber"] as! String
            }
            if dict.keys.contains("CalleeLocation") && dict["CalleeLocation"] != nil {
                self.calleeLocation = dict["CalleeLocation"] as! String
            }
            if dict.keys.contains("CallerLocation") && dict["CallerLocation"] != nil {
                self.callerLocation = dict["CallerLocation"] as! String
            }
            if dict.keys.contains("CallingNumber") && dict["CallingNumber"] != nil {
                self.callingNumber = dict["CallingNumber"] as! String
            }
            if dict.keys.contains("ContactDisposition") && dict["ContactDisposition"] != nil {
                self.contactDisposition = dict["ContactDisposition"] as! String
            }
            if dict.keys.contains("ContactId") && dict["ContactId"] != nil {
                self.contactId = dict["ContactId"] as! String
            }
            if dict.keys.contains("ContactType") && dict["ContactType"] != nil {
                self.contactType = dict["ContactType"] as! String
            }
            if dict.keys.contains("CustomerEvents") && dict["CustomerEvents"] != nil {
                var tmp : [GetCallDetailRecordResponseBody.Data.CustomerEvents] = []
                for v in dict["CustomerEvents"] as! [Any] {
                    var model = GetCallDetailRecordResponseBody.Data.CustomerEvents()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.customerEvents = tmp
            }
            if dict.keys.contains("EarlyMediaState") && dict["EarlyMediaState"] != nil {
                self.earlyMediaState = dict["EarlyMediaState"] as! String
            }
            if dict.keys.contains("EstablishedTime") && dict["EstablishedTime"] != nil {
                self.establishedTime = dict["EstablishedTime"] as! Int64
            }
            if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("IvrEvents") && dict["IvrEvents"] != nil {
                var tmp : [GetCallDetailRecordResponseBody.Data.IvrEvents] = []
                for v in dict["IvrEvents"] as! [Any] {
                    var model = GetCallDetailRecordResponseBody.Data.IvrEvents()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.ivrEvents = tmp
            }
            if dict.keys.contains("QueueEvents") && dict["QueueEvents"] != nil {
                var tmp : [GetCallDetailRecordResponseBody.Data.QueueEvents] = []
                for v in dict["QueueEvents"] as! [Any] {
                    var model = GetCallDetailRecordResponseBody.Data.QueueEvents()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.queueEvents = tmp
            }
            if dict.keys.contains("RecordingReady") && dict["RecordingReady"] != nil {
                self.recordingReady = dict["RecordingReady"] as! Bool
            }
            if dict.keys.contains("ReleaseInitiator") && dict["ReleaseInitiator"] != nil {
                self.releaseInitiator = dict["ReleaseInitiator"] as! String
            }
            if dict.keys.contains("ReleaseReason") && dict["ReleaseReason"] != nil {
                self.releaseReason = dict["ReleaseReason"] as! String
            }
            if dict.keys.contains("ReleaseTime") && dict["ReleaseTime"] != nil {
                self.releaseTime = dict["ReleaseTime"] as! Int64
            }
            if dict.keys.contains("Satisfaction") && dict["Satisfaction"] != nil {
                self.satisfaction = dict["Satisfaction"] as! Int32
            }
            if dict.keys.contains("SatisfactionSurveyChannel") && dict["SatisfactionSurveyChannel"] != nil {
                self.satisfactionSurveyChannel = dict["SatisfactionSurveyChannel"] as! String
            }
            if dict.keys.contains("SatisfactionSurveyOffered") && dict["SatisfactionSurveyOffered"] != nil {
                self.satisfactionSurveyOffered = dict["SatisfactionSurveyOffered"] as! Bool
            }
            if dict.keys.contains("SkillGroupIds") && dict["SkillGroupIds"] != nil {
                self.skillGroupIds = dict["SkillGroupIds"] as! String
            }
            if dict.keys.contains("SkillGroupNames") && dict["SkillGroupNames"] != nil {
                self.skillGroupNames = dict["SkillGroupNames"] as! String
            }
            if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
                self.startTime = dict["StartTime"] as! Int64
            }
        }
    }
    public var code: String?

    public var data: GetCallDetailRecordResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = GetCallDetailRecordResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetCallDetailRecordResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetCallDetailRecordResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetCallDetailRecordResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetCampaignRequest : Tea.TeaModel {
    public var campaignId: String?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.campaignId != nil {
            map["CampaignId"] = self.campaignId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CampaignId") && dict["CampaignId"] != nil {
            self.campaignId = dict["CampaignId"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
    }
}

public class GetCampaignResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var actualEndTime: Int64?

        public var actualStartTime: Int64?

        public var campaignId: String?

        public var casesAborted: Int64?

        public var casesConnected: Int64?

        public var casesUncompleted: Int64?

        public var casesUncompletedAfterAttempted: Int64?

        public var maxAttemptCount: Int64?

        public var minAttemptInterval: Int64?

        public var name: String?

        public var planedEndTime: Int64?

        public var planedStartTime: Int64?

        public var queueId: String?

        public var queueName: String?

        public var simulation: Bool?

        public var simulationParameters: String?

        public var state: String?

        public var strategyParameters: String?

        public var strategyType: String?

        public var totalCases: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.actualEndTime != nil {
                map["ActualEndTime"] = self.actualEndTime!
            }
            if self.actualStartTime != nil {
                map["ActualStartTime"] = self.actualStartTime!
            }
            if self.campaignId != nil {
                map["CampaignId"] = self.campaignId!
            }
            if self.casesAborted != nil {
                map["CasesAborted"] = self.casesAborted!
            }
            if self.casesConnected != nil {
                map["CasesConnected"] = self.casesConnected!
            }
            if self.casesUncompleted != nil {
                map["CasesUncompleted"] = self.casesUncompleted!
            }
            if self.casesUncompletedAfterAttempted != nil {
                map["CasesUncompletedAfterAttempted"] = self.casesUncompletedAfterAttempted!
            }
            if self.maxAttemptCount != nil {
                map["MaxAttemptCount"] = self.maxAttemptCount!
            }
            if self.minAttemptInterval != nil {
                map["MinAttemptInterval"] = self.minAttemptInterval!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.planedEndTime != nil {
                map["PlanedEndTime"] = self.planedEndTime!
            }
            if self.planedStartTime != nil {
                map["PlanedStartTime"] = self.planedStartTime!
            }
            if self.queueId != nil {
                map["QueueId"] = self.queueId!
            }
            if self.queueName != nil {
                map["QueueName"] = self.queueName!
            }
            if self.simulation != nil {
                map["Simulation"] = self.simulation!
            }
            if self.simulationParameters != nil {
                map["SimulationParameters"] = self.simulationParameters!
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            if self.strategyParameters != nil {
                map["StrategyParameters"] = self.strategyParameters!
            }
            if self.strategyType != nil {
                map["StrategyType"] = self.strategyType!
            }
            if self.totalCases != nil {
                map["TotalCases"] = self.totalCases!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ActualEndTime") && dict["ActualEndTime"] != nil {
                self.actualEndTime = dict["ActualEndTime"] as! Int64
            }
            if dict.keys.contains("ActualStartTime") && dict["ActualStartTime"] != nil {
                self.actualStartTime = dict["ActualStartTime"] as! Int64
            }
            if dict.keys.contains("CampaignId") && dict["CampaignId"] != nil {
                self.campaignId = dict["CampaignId"] as! String
            }
            if dict.keys.contains("CasesAborted") && dict["CasesAborted"] != nil {
                self.casesAborted = dict["CasesAborted"] as! Int64
            }
            if dict.keys.contains("CasesConnected") && dict["CasesConnected"] != nil {
                self.casesConnected = dict["CasesConnected"] as! Int64
            }
            if dict.keys.contains("CasesUncompleted") && dict["CasesUncompleted"] != nil {
                self.casesUncompleted = dict["CasesUncompleted"] as! Int64
            }
            if dict.keys.contains("CasesUncompletedAfterAttempted") && dict["CasesUncompletedAfterAttempted"] != nil {
                self.casesUncompletedAfterAttempted = dict["CasesUncompletedAfterAttempted"] as! Int64
            }
            if dict.keys.contains("MaxAttemptCount") && dict["MaxAttemptCount"] != nil {
                self.maxAttemptCount = dict["MaxAttemptCount"] as! Int64
            }
            if dict.keys.contains("MinAttemptInterval") && dict["MinAttemptInterval"] != nil {
                self.minAttemptInterval = dict["MinAttemptInterval"] as! Int64
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("PlanedEndTime") && dict["PlanedEndTime"] != nil {
                self.planedEndTime = dict["PlanedEndTime"] as! Int64
            }
            if dict.keys.contains("PlanedStartTime") && dict["PlanedStartTime"] != nil {
                self.planedStartTime = dict["PlanedStartTime"] as! Int64
            }
            if dict.keys.contains("QueueId") && dict["QueueId"] != nil {
                self.queueId = dict["QueueId"] as! String
            }
            if dict.keys.contains("QueueName") && dict["QueueName"] != nil {
                self.queueName = dict["QueueName"] as! String
            }
            if dict.keys.contains("Simulation") && dict["Simulation"] != nil {
                self.simulation = dict["Simulation"] as! Bool
            }
            if dict.keys.contains("SimulationParameters") && dict["SimulationParameters"] != nil {
                self.simulationParameters = dict["SimulationParameters"] as! String
            }
            if dict.keys.contains("State") && dict["State"] != nil {
                self.state = dict["State"] as! String
            }
            if dict.keys.contains("StrategyParameters") && dict["StrategyParameters"] != nil {
                self.strategyParameters = dict["StrategyParameters"] as! String
            }
            if dict.keys.contains("StrategyType") && dict["StrategyType"] != nil {
                self.strategyType = dict["StrategyType"] as! String
            }
            if dict.keys.contains("TotalCases") && dict["TotalCases"] != nil {
                self.totalCases = dict["TotalCases"] as! Int64
            }
        }
    }
    public var code: String?

    public var data: GetCampaignResponseBody.Data?

    public var httpStatusCode: Int64?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = GetCampaignResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int64
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetCampaignResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetCampaignResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetCampaignResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetCaseFileUploadUrlRequest : Tea.TeaModel {
    public var fileName: String?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.fileName != nil {
            map["FileName"] = self.fileName!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FileName") && dict["FileName"] != nil {
            self.fileName = dict["FileName"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
    }
}

public class GetCaseFileUploadUrlResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var caseFileKey: String?

        public var url: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.caseFileKey != nil {
                map["CaseFileKey"] = self.caseFileKey!
            }
            if self.url != nil {
                map["Url"] = self.url!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CaseFileKey") && dict["CaseFileKey"] != nil {
                self.caseFileKey = dict["CaseFileKey"] as! String
            }
            if dict.keys.contains("Url") && dict["Url"] != nil {
                self.url = dict["Url"] as! String
            }
        }
    }
    public var code: String?

    public var data: GetCaseFileUploadUrlResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = GetCaseFileUploadUrlResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetCaseFileUploadUrlResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetCaseFileUploadUrlResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetCaseFileUploadUrlResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetContactFlowRequest : Tea.TeaModel {
    public var contactFlowId: String?

    public var draftId: String?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.contactFlowId != nil {
            map["ContactFlowId"] = self.contactFlowId!
        }
        if self.draftId != nil {
            map["DraftId"] = self.draftId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ContactFlowId") && dict["ContactFlowId"] != nil {
            self.contactFlowId = dict["ContactFlowId"] as! String
        }
        if dict.keys.contains("DraftId") && dict["DraftId"] != nil {
            self.draftId = dict["DraftId"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
    }
}

public class GetContactFlowResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var contactFlowId: String?

        public var createdTime: String?

        public var definition: String?

        public var description_: String?

        public var draftId: String?

        public var editor: String?

        public var instanceId: String?

        public var name: String?

        public var published: Bool?

        public var type: String?

        public var updatedTime: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.contactFlowId != nil {
                map["ContactFlowId"] = self.contactFlowId!
            }
            if self.createdTime != nil {
                map["CreatedTime"] = self.createdTime!
            }
            if self.definition != nil {
                map["Definition"] = self.definition!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.draftId != nil {
                map["DraftId"] = self.draftId!
            }
            if self.editor != nil {
                map["Editor"] = self.editor!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.published != nil {
                map["Published"] = self.published!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            if self.updatedTime != nil {
                map["UpdatedTime"] = self.updatedTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ContactFlowId") && dict["ContactFlowId"] != nil {
                self.contactFlowId = dict["ContactFlowId"] as! String
            }
            if dict.keys.contains("CreatedTime") && dict["CreatedTime"] != nil {
                self.createdTime = dict["CreatedTime"] as! String
            }
            if dict.keys.contains("Definition") && dict["Definition"] != nil {
                self.definition = dict["Definition"] as! String
            }
            if dict.keys.contains("Description") && dict["Description"] != nil {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("DraftId") && dict["DraftId"] != nil {
                self.draftId = dict["DraftId"] as! String
            }
            if dict.keys.contains("Editor") && dict["Editor"] != nil {
                self.editor = dict["Editor"] as! String
            }
            if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Published") && dict["Published"] != nil {
                self.published = dict["Published"] as! Bool
            }
            if dict.keys.contains("Type") && dict["Type"] != nil {
                self.type = dict["Type"] as! String
            }
            if dict.keys.contains("UpdatedTime") && dict["UpdatedTime"] != nil {
                self.updatedTime = dict["UpdatedTime"] as! String
            }
        }
    }
    public var code: String?

    public var data: GetContactFlowResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = GetContactFlowResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetContactFlowResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetContactFlowResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetContactFlowResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetConversationDetailRequest : Tea.TeaModel {
    public var contactId: String?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.contactId != nil {
            map["ContactId"] = self.contactId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ContactId") && dict["ContactId"] != nil {
            self.contactId = dict["ContactId"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
    }
}

public class GetConversationDetailResponseBody : Tea.TeaModel {
    public class Phrases : Tea.TeaModel {
        public var begin: Int32?

        public var end: Int32?

        public var identity: String?

        public var role: String?

        public var words: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.begin != nil {
                map["Begin"] = self.begin!
            }
            if self.end != nil {
                map["End"] = self.end!
            }
            if self.identity != nil {
                map["Identity"] = self.identity!
            }
            if self.role != nil {
                map["Role"] = self.role!
            }
            if self.words != nil {
                map["Words"] = self.words!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Begin") && dict["Begin"] != nil {
                self.begin = dict["Begin"] as! Int32
            }
            if dict.keys.contains("End") && dict["End"] != nil {
                self.end = dict["End"] as! Int32
            }
            if dict.keys.contains("Identity") && dict["Identity"] != nil {
                self.identity = dict["Identity"] as! String
            }
            if dict.keys.contains("Role") && dict["Role"] != nil {
                self.role = dict["Role"] as! String
            }
            if dict.keys.contains("Words") && dict["Words"] != nil {
                self.words = dict["Words"] as! String
            }
        }
    }
    public var code: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var phrases: [GetConversationDetailResponseBody.Phrases]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.phrases != nil {
            var tmp : [Any] = []
            for k in self.phrases! {
                tmp.append(k.toMap())
            }
            map["Phrases"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Phrases") && dict["Phrases"] != nil {
            var tmp : [GetConversationDetailResponseBody.Phrases] = []
            for v in dict["Phrases"] as! [Any] {
                var model = GetConversationDetailResponseBody.Phrases()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.phrases = tmp
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetConversationDetailResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetConversationDetailResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetConversationDetailResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetDataChannelCredentialsRequest : Tea.TeaModel {
    public var deviceId: String?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.deviceId != nil {
            map["DeviceId"] = self.deviceId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DeviceId") && dict["DeviceId"] != nil {
            self.deviceId = dict["DeviceId"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
    }
}

public class GetDataChannelCredentialsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var clientId: String?

        public var deviceId: String?

        public var endpoint: String?

        public var expiredTime: Int64?

        public var password: String?

        public var topic: String?

        public var userName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.clientId != nil {
                map["ClientId"] = self.clientId!
            }
            if self.deviceId != nil {
                map["DeviceId"] = self.deviceId!
            }
            if self.endpoint != nil {
                map["Endpoint"] = self.endpoint!
            }
            if self.expiredTime != nil {
                map["ExpiredTime"] = self.expiredTime!
            }
            if self.password != nil {
                map["Password"] = self.password!
            }
            if self.topic != nil {
                map["Topic"] = self.topic!
            }
            if self.userName != nil {
                map["UserName"] = self.userName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ClientId") && dict["ClientId"] != nil {
                self.clientId = dict["ClientId"] as! String
            }
            if dict.keys.contains("DeviceId") && dict["DeviceId"] != nil {
                self.deviceId = dict["DeviceId"] as! String
            }
            if dict.keys.contains("Endpoint") && dict["Endpoint"] != nil {
                self.endpoint = dict["Endpoint"] as! String
            }
            if dict.keys.contains("ExpiredTime") && dict["ExpiredTime"] != nil {
                self.expiredTime = dict["ExpiredTime"] as! Int64
            }
            if dict.keys.contains("Password") && dict["Password"] != nil {
                self.password = dict["Password"] as! String
            }
            if dict.keys.contains("Topic") && dict["Topic"] != nil {
                self.topic = dict["Topic"] as! String
            }
            if dict.keys.contains("UserName") && dict["UserName"] != nil {
                self.userName = dict["UserName"] as! String
            }
        }
    }
    public var code: String?

    public var data: GetDataChannelCredentialsResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var params: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.params != nil {
            map["Params"] = self.params!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = GetDataChannelCredentialsResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Params") && dict["Params"] != nil {
            self.params = dict["Params"] as! [String]
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetDataChannelCredentialsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetDataChannelCredentialsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetDataChannelCredentialsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetDoNotCallFileUploadParametersRequest : Tea.TeaModel {
    public var fileName: String?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.fileName != nil {
            map["FileName"] = self.fileName!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FileName") && dict["FileName"] != nil {
            self.fileName = dict["FileName"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
    }
}

public class GetDoNotCallFileUploadParametersResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var accessKeyId: String?

        public var expireTime: Int32?

        public var filePath: String?

        public var host: String?

        public var policy: String?

        public var signature: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accessKeyId != nil {
                map["AccessKeyId"] = self.accessKeyId!
            }
            if self.expireTime != nil {
                map["ExpireTime"] = self.expireTime!
            }
            if self.filePath != nil {
                map["FilePath"] = self.filePath!
            }
            if self.host != nil {
                map["Host"] = self.host!
            }
            if self.policy != nil {
                map["Policy"] = self.policy!
            }
            if self.signature != nil {
                map["Signature"] = self.signature!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AccessKeyId") && dict["AccessKeyId"] != nil {
                self.accessKeyId = dict["AccessKeyId"] as! String
            }
            if dict.keys.contains("ExpireTime") && dict["ExpireTime"] != nil {
                self.expireTime = dict["ExpireTime"] as! Int32
            }
            if dict.keys.contains("FilePath") && dict["FilePath"] != nil {
                self.filePath = dict["FilePath"] as! String
            }
            if dict.keys.contains("Host") && dict["Host"] != nil {
                self.host = dict["Host"] as! String
            }
            if dict.keys.contains("Policy") && dict["Policy"] != nil {
                self.policy = dict["Policy"] as! String
            }
            if dict.keys.contains("Signature") && dict["Signature"] != nil {
                self.signature = dict["Signature"] as! String
            }
        }
    }
    public var code: String?

    public var data: GetDoNotCallFileUploadParametersResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = GetDoNotCallFileUploadParametersResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetDoNotCallFileUploadParametersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetDoNotCallFileUploadParametersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetDoNotCallFileUploadParametersResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetEarlyMediaRecordingRequest : Tea.TeaModel {
    public var contactId: String?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.contactId != nil {
            map["ContactId"] = self.contactId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ContactId") && dict["ContactId"] != nil {
            self.contactId = dict["ContactId"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
    }
}

public class GetEarlyMediaRecordingResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var fileName: String?

        public var fileUrl: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.fileName != nil {
                map["FileName"] = self.fileName!
            }
            if self.fileUrl != nil {
                map["FileUrl"] = self.fileUrl!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("FileName") && dict["FileName"] != nil {
                self.fileName = dict["FileName"] as! String
            }
            if dict.keys.contains("FileUrl") && dict["FileUrl"] != nil {
                self.fileUrl = dict["FileUrl"] as! String
            }
        }
    }
    public var code: String?

    public var data: GetEarlyMediaRecordingResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = GetEarlyMediaRecordingResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetEarlyMediaRecordingResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetEarlyMediaRecordingResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetEarlyMediaRecordingResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetHistoricalCallerReportRequest : Tea.TeaModel {
    public var callingNumber: String?

    public var instanceId: String?

    public var startTime: Int64?

    public var stopTime: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.callingNumber != nil {
            map["CallingNumber"] = self.callingNumber!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.stopTime != nil {
            map["StopTime"] = self.stopTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CallingNumber") && dict["CallingNumber"] != nil {
            self.callingNumber = dict["CallingNumber"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
            self.startTime = dict["StartTime"] as! Int64
        }
        if dict.keys.contains("StopTime") && dict["StopTime"] != nil {
            self.stopTime = dict["StopTime"] as! Int64
        }
    }
}

public class GetHistoricalCallerReportResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var lastCallingTime: Int64?

        public var totalCalls: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.lastCallingTime != nil {
                map["LastCallingTime"] = self.lastCallingTime!
            }
            if self.totalCalls != nil {
                map["TotalCalls"] = self.totalCalls!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("LastCallingTime") && dict["LastCallingTime"] != nil {
                self.lastCallingTime = dict["LastCallingTime"] as! Int64
            }
            if dict.keys.contains("TotalCalls") && dict["TotalCalls"] != nil {
                self.totalCalls = dict["TotalCalls"] as! Int64
            }
        }
    }
    public var code: String?

    public var data: GetHistoricalCallerReportResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = GetHistoricalCallerReportResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetHistoricalCallerReportResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetHistoricalCallerReportResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetHistoricalCallerReportResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetHistoricalCampaignReportRequest : Tea.TeaModel {
    public var campaignId: String?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.campaignId != nil {
            map["CampaignId"] = self.campaignId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CampaignId") && dict["CampaignId"] != nil {
            self.campaignId = dict["CampaignId"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
    }
}

public class GetHistoricalCampaignReportResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var abandonedRate: Double?

        public var callsAbandoned: Int64?

        public var callsConnected: Int64?

        public var callsDialed: Int64?

        public var connectedRate: Double?

        public var occupancyRate: Double?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.abandonedRate != nil {
                map["AbandonedRate"] = self.abandonedRate!
            }
            if self.callsAbandoned != nil {
                map["CallsAbandoned"] = self.callsAbandoned!
            }
            if self.callsConnected != nil {
                map["CallsConnected"] = self.callsConnected!
            }
            if self.callsDialed != nil {
                map["CallsDialed"] = self.callsDialed!
            }
            if self.connectedRate != nil {
                map["ConnectedRate"] = self.connectedRate!
            }
            if self.occupancyRate != nil {
                map["OccupancyRate"] = self.occupancyRate!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AbandonedRate") && dict["AbandonedRate"] != nil {
                self.abandonedRate = dict["AbandonedRate"] as! Double
            }
            if dict.keys.contains("CallsAbandoned") && dict["CallsAbandoned"] != nil {
                self.callsAbandoned = dict["CallsAbandoned"] as! Int64
            }
            if dict.keys.contains("CallsConnected") && dict["CallsConnected"] != nil {
                self.callsConnected = dict["CallsConnected"] as! Int64
            }
            if dict.keys.contains("CallsDialed") && dict["CallsDialed"] != nil {
                self.callsDialed = dict["CallsDialed"] as! Int64
            }
            if dict.keys.contains("ConnectedRate") && dict["ConnectedRate"] != nil {
                self.connectedRate = dict["ConnectedRate"] as! Double
            }
            if dict.keys.contains("OccupancyRate") && dict["OccupancyRate"] != nil {
                self.occupancyRate = dict["OccupancyRate"] as! Double
            }
        }
    }
    public var code: String?

    public var data: GetHistoricalCampaignReportResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = GetHistoricalCampaignReportResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetHistoricalCampaignReportResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetHistoricalCampaignReportResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetHistoricalCampaignReportResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetHistoricalInstanceReportRequest : Tea.TeaModel {
    public var endTime: Int64?

    public var instanceId: String?

    public var startTime: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
            self.startTime = dict["StartTime"] as! Int64
        }
    }
}

public class GetHistoricalInstanceReportResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Inbound : Tea.TeaModel {
            public var abandonRate: Double?

            public var averageAbandonTime: Double?

            public var averageAbandonedInIVRTime: Double?

            public var averageAbandonedInQueueTime: Double?

            public var averageAbandonedInRingTime: Double?

            public var averageHoldTime: Double?

            public var averageRingTime: Double?

            public var averageTalkTime: Double?

            public var averageWaitTime: Double?

            public var averageWorkTime: Double?

            public var callsAbandoned: Int64?

            public var callsAbandonedInIVR: Int64?

            public var callsAbandonedInQueue: Int64?

            public var callsAbandonedInRing: Int64?

            public var callsAbandonedInVoiceNavigator: Int64?

            public var callsAttendedTransferred: Int64?

            public var callsBlindTransferred: Int64?

            public var callsForwardToOutsideNumber: Int64?

            public var callsHandled: Int64?

            public var callsHold: Int64?

            public var callsIVRException: Int64?

            public var callsOffered: Int64?

            public var callsQueued: Int64?

            public var callsQueuingFailed: Int64?

            public var callsQueuingOverflow: Int64?

            public var callsQueuingTimeout: Int64?

            public var callsRinged: Int64?

            public var callsVoicemail: Int64?

            public var handleRate: Double?

            public var maxAbandonTime: Int64?

            public var maxAbandonedInIVRTime: Int64?

            public var maxAbandonedInQueueTime: Int64?

            public var maxAbandonedInRingTime: Int64?

            public var maxHoldTime: Int64?

            public var maxRingTime: Int64?

            public var maxTalkTime: Int64?

            public var maxWaitTime: Int64?

            public var maxWorkTime: Int64?

            public var satisfactionIndex: Double?

            public var satisfactionRate: Double?

            public var satisfactionSurveysOffered: Int64?

            public var satisfactionSurveysResponded: Int64?

            public var serviceLevel20: Double?

            public var totalAbandonTime: Int64?

            public var totalAbandonedInIVRTime: Int64?

            public var totalAbandonedInQueueTime: Int64?

            public var totalAbandonedInRingTime: Int64?

            public var totalHoldTime: Int64?

            public var totalRingTime: Int64?

            public var totalTalkTime: Int64?

            public var totalWaitTime: Int64?

            public var totalWorkTime: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.abandonRate != nil {
                    map["AbandonRate"] = self.abandonRate!
                }
                if self.averageAbandonTime != nil {
                    map["AverageAbandonTime"] = self.averageAbandonTime!
                }
                if self.averageAbandonedInIVRTime != nil {
                    map["AverageAbandonedInIVRTime"] = self.averageAbandonedInIVRTime!
                }
                if self.averageAbandonedInQueueTime != nil {
                    map["AverageAbandonedInQueueTime"] = self.averageAbandonedInQueueTime!
                }
                if self.averageAbandonedInRingTime != nil {
                    map["AverageAbandonedInRingTime"] = self.averageAbandonedInRingTime!
                }
                if self.averageHoldTime != nil {
                    map["AverageHoldTime"] = self.averageHoldTime!
                }
                if self.averageRingTime != nil {
                    map["AverageRingTime"] = self.averageRingTime!
                }
                if self.averageTalkTime != nil {
                    map["AverageTalkTime"] = self.averageTalkTime!
                }
                if self.averageWaitTime != nil {
                    map["AverageWaitTime"] = self.averageWaitTime!
                }
                if self.averageWorkTime != nil {
                    map["AverageWorkTime"] = self.averageWorkTime!
                }
                if self.callsAbandoned != nil {
                    map["CallsAbandoned"] = self.callsAbandoned!
                }
                if self.callsAbandonedInIVR != nil {
                    map["CallsAbandonedInIVR"] = self.callsAbandonedInIVR!
                }
                if self.callsAbandonedInQueue != nil {
                    map["CallsAbandonedInQueue"] = self.callsAbandonedInQueue!
                }
                if self.callsAbandonedInRing != nil {
                    map["CallsAbandonedInRing"] = self.callsAbandonedInRing!
                }
                if self.callsAbandonedInVoiceNavigator != nil {
                    map["CallsAbandonedInVoiceNavigator"] = self.callsAbandonedInVoiceNavigator!
                }
                if self.callsAttendedTransferred != nil {
                    map["CallsAttendedTransferred"] = self.callsAttendedTransferred!
                }
                if self.callsBlindTransferred != nil {
                    map["CallsBlindTransferred"] = self.callsBlindTransferred!
                }
                if self.callsForwardToOutsideNumber != nil {
                    map["CallsForwardToOutsideNumber"] = self.callsForwardToOutsideNumber!
                }
                if self.callsHandled != nil {
                    map["CallsHandled"] = self.callsHandled!
                }
                if self.callsHold != nil {
                    map["CallsHold"] = self.callsHold!
                }
                if self.callsIVRException != nil {
                    map["CallsIVRException"] = self.callsIVRException!
                }
                if self.callsOffered != nil {
                    map["CallsOffered"] = self.callsOffered!
                }
                if self.callsQueued != nil {
                    map["CallsQueued"] = self.callsQueued!
                }
                if self.callsQueuingFailed != nil {
                    map["CallsQueuingFailed"] = self.callsQueuingFailed!
                }
                if self.callsQueuingOverflow != nil {
                    map["CallsQueuingOverflow"] = self.callsQueuingOverflow!
                }
                if self.callsQueuingTimeout != nil {
                    map["CallsQueuingTimeout"] = self.callsQueuingTimeout!
                }
                if self.callsRinged != nil {
                    map["CallsRinged"] = self.callsRinged!
                }
                if self.callsVoicemail != nil {
                    map["CallsVoicemail"] = self.callsVoicemail!
                }
                if self.handleRate != nil {
                    map["HandleRate"] = self.handleRate!
                }
                if self.maxAbandonTime != nil {
                    map["MaxAbandonTime"] = self.maxAbandonTime!
                }
                if self.maxAbandonedInIVRTime != nil {
                    map["MaxAbandonedInIVRTime"] = self.maxAbandonedInIVRTime!
                }
                if self.maxAbandonedInQueueTime != nil {
                    map["MaxAbandonedInQueueTime"] = self.maxAbandonedInQueueTime!
                }
                if self.maxAbandonedInRingTime != nil {
                    map["MaxAbandonedInRingTime"] = self.maxAbandonedInRingTime!
                }
                if self.maxHoldTime != nil {
                    map["MaxHoldTime"] = self.maxHoldTime!
                }
                if self.maxRingTime != nil {
                    map["MaxRingTime"] = self.maxRingTime!
                }
                if self.maxTalkTime != nil {
                    map["MaxTalkTime"] = self.maxTalkTime!
                }
                if self.maxWaitTime != nil {
                    map["MaxWaitTime"] = self.maxWaitTime!
                }
                if self.maxWorkTime != nil {
                    map["MaxWorkTime"] = self.maxWorkTime!
                }
                if self.satisfactionIndex != nil {
                    map["SatisfactionIndex"] = self.satisfactionIndex!
                }
                if self.satisfactionRate != nil {
                    map["SatisfactionRate"] = self.satisfactionRate!
                }
                if self.satisfactionSurveysOffered != nil {
                    map["SatisfactionSurveysOffered"] = self.satisfactionSurveysOffered!
                }
                if self.satisfactionSurveysResponded != nil {
                    map["SatisfactionSurveysResponded"] = self.satisfactionSurveysResponded!
                }
                if self.serviceLevel20 != nil {
                    map["ServiceLevel20"] = self.serviceLevel20!
                }
                if self.totalAbandonTime != nil {
                    map["TotalAbandonTime"] = self.totalAbandonTime!
                }
                if self.totalAbandonedInIVRTime != nil {
                    map["TotalAbandonedInIVRTime"] = self.totalAbandonedInIVRTime!
                }
                if self.totalAbandonedInQueueTime != nil {
                    map["TotalAbandonedInQueueTime"] = self.totalAbandonedInQueueTime!
                }
                if self.totalAbandonedInRingTime != nil {
                    map["TotalAbandonedInRingTime"] = self.totalAbandonedInRingTime!
                }
                if self.totalHoldTime != nil {
                    map["TotalHoldTime"] = self.totalHoldTime!
                }
                if self.totalRingTime != nil {
                    map["TotalRingTime"] = self.totalRingTime!
                }
                if self.totalTalkTime != nil {
                    map["TotalTalkTime"] = self.totalTalkTime!
                }
                if self.totalWaitTime != nil {
                    map["TotalWaitTime"] = self.totalWaitTime!
                }
                if self.totalWorkTime != nil {
                    map["TotalWorkTime"] = self.totalWorkTime!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AbandonRate") && dict["AbandonRate"] != nil {
                    self.abandonRate = dict["AbandonRate"] as! Double
                }
                if dict.keys.contains("AverageAbandonTime") && dict["AverageAbandonTime"] != nil {
                    self.averageAbandonTime = dict["AverageAbandonTime"] as! Double
                }
                if dict.keys.contains("AverageAbandonedInIVRTime") && dict["AverageAbandonedInIVRTime"] != nil {
                    self.averageAbandonedInIVRTime = dict["AverageAbandonedInIVRTime"] as! Double
                }
                if dict.keys.contains("AverageAbandonedInQueueTime") && dict["AverageAbandonedInQueueTime"] != nil {
                    self.averageAbandonedInQueueTime = dict["AverageAbandonedInQueueTime"] as! Double
                }
                if dict.keys.contains("AverageAbandonedInRingTime") && dict["AverageAbandonedInRingTime"] != nil {
                    self.averageAbandonedInRingTime = dict["AverageAbandonedInRingTime"] as! Double
                }
                if dict.keys.contains("AverageHoldTime") && dict["AverageHoldTime"] != nil {
                    self.averageHoldTime = dict["AverageHoldTime"] as! Double
                }
                if dict.keys.contains("AverageRingTime") && dict["AverageRingTime"] != nil {
                    self.averageRingTime = dict["AverageRingTime"] as! Double
                }
                if dict.keys.contains("AverageTalkTime") && dict["AverageTalkTime"] != nil {
                    self.averageTalkTime = dict["AverageTalkTime"] as! Double
                }
                if dict.keys.contains("AverageWaitTime") && dict["AverageWaitTime"] != nil {
                    self.averageWaitTime = dict["AverageWaitTime"] as! Double
                }
                if dict.keys.contains("AverageWorkTime") && dict["AverageWorkTime"] != nil {
                    self.averageWorkTime = dict["AverageWorkTime"] as! Double
                }
                if dict.keys.contains("CallsAbandoned") && dict["CallsAbandoned"] != nil {
                    self.callsAbandoned = dict["CallsAbandoned"] as! Int64
                }
                if dict.keys.contains("CallsAbandonedInIVR") && dict["CallsAbandonedInIVR"] != nil {
                    self.callsAbandonedInIVR = dict["CallsAbandonedInIVR"] as! Int64
                }
                if dict.keys.contains("CallsAbandonedInQueue") && dict["CallsAbandonedInQueue"] != nil {
                    self.callsAbandonedInQueue = dict["CallsAbandonedInQueue"] as! Int64
                }
                if dict.keys.contains("CallsAbandonedInRing") && dict["CallsAbandonedInRing"] != nil {
                    self.callsAbandonedInRing = dict["CallsAbandonedInRing"] as! Int64
                }
                if dict.keys.contains("CallsAbandonedInVoiceNavigator") && dict["CallsAbandonedInVoiceNavigator"] != nil {
                    self.callsAbandonedInVoiceNavigator = dict["CallsAbandonedInVoiceNavigator"] as! Int64
                }
                if dict.keys.contains("CallsAttendedTransferred") && dict["CallsAttendedTransferred"] != nil {
                    self.callsAttendedTransferred = dict["CallsAttendedTransferred"] as! Int64
                }
                if dict.keys.contains("CallsBlindTransferred") && dict["CallsBlindTransferred"] != nil {
                    self.callsBlindTransferred = dict["CallsBlindTransferred"] as! Int64
                }
                if dict.keys.contains("CallsForwardToOutsideNumber") && dict["CallsForwardToOutsideNumber"] != nil {
                    self.callsForwardToOutsideNumber = dict["CallsForwardToOutsideNumber"] as! Int64
                }
                if dict.keys.contains("CallsHandled") && dict["CallsHandled"] != nil {
                    self.callsHandled = dict["CallsHandled"] as! Int64
                }
                if dict.keys.contains("CallsHold") && dict["CallsHold"] != nil {
                    self.callsHold = dict["CallsHold"] as! Int64
                }
                if dict.keys.contains("CallsIVRException") && dict["CallsIVRException"] != nil {
                    self.callsIVRException = dict["CallsIVRException"] as! Int64
                }
                if dict.keys.contains("CallsOffered") && dict["CallsOffered"] != nil {
                    self.callsOffered = dict["CallsOffered"] as! Int64
                }
                if dict.keys.contains("CallsQueued") && dict["CallsQueued"] != nil {
                    self.callsQueued = dict["CallsQueued"] as! Int64
                }
                if dict.keys.contains("CallsQueuingFailed") && dict["CallsQueuingFailed"] != nil {
                    self.callsQueuingFailed = dict["CallsQueuingFailed"] as! Int64
                }
                if dict.keys.contains("CallsQueuingOverflow") && dict["CallsQueuingOverflow"] != nil {
                    self.callsQueuingOverflow = dict["CallsQueuingOverflow"] as! Int64
                }
                if dict.keys.contains("CallsQueuingTimeout") && dict["CallsQueuingTimeout"] != nil {
                    self.callsQueuingTimeout = dict["CallsQueuingTimeout"] as! Int64
                }
                if dict.keys.contains("CallsRinged") && dict["CallsRinged"] != nil {
                    self.callsRinged = dict["CallsRinged"] as! Int64
                }
                if dict.keys.contains("CallsVoicemail") && dict["CallsVoicemail"] != nil {
                    self.callsVoicemail = dict["CallsVoicemail"] as! Int64
                }
                if dict.keys.contains("HandleRate") && dict["HandleRate"] != nil {
                    self.handleRate = dict["HandleRate"] as! Double
                }
                if dict.keys.contains("MaxAbandonTime") && dict["MaxAbandonTime"] != nil {
                    self.maxAbandonTime = dict["MaxAbandonTime"] as! Int64
                }
                if dict.keys.contains("MaxAbandonedInIVRTime") && dict["MaxAbandonedInIVRTime"] != nil {
                    self.maxAbandonedInIVRTime = dict["MaxAbandonedInIVRTime"] as! Int64
                }
                if dict.keys.contains("MaxAbandonedInQueueTime") && dict["MaxAbandonedInQueueTime"] != nil {
                    self.maxAbandonedInQueueTime = dict["MaxAbandonedInQueueTime"] as! Int64
                }
                if dict.keys.contains("MaxAbandonedInRingTime") && dict["MaxAbandonedInRingTime"] != nil {
                    self.maxAbandonedInRingTime = dict["MaxAbandonedInRingTime"] as! Int64
                }
                if dict.keys.contains("MaxHoldTime") && dict["MaxHoldTime"] != nil {
                    self.maxHoldTime = dict["MaxHoldTime"] as! Int64
                }
                if dict.keys.contains("MaxRingTime") && dict["MaxRingTime"] != nil {
                    self.maxRingTime = dict["MaxRingTime"] as! Int64
                }
                if dict.keys.contains("MaxTalkTime") && dict["MaxTalkTime"] != nil {
                    self.maxTalkTime = dict["MaxTalkTime"] as! Int64
                }
                if dict.keys.contains("MaxWaitTime") && dict["MaxWaitTime"] != nil {
                    self.maxWaitTime = dict["MaxWaitTime"] as! Int64
                }
                if dict.keys.contains("MaxWorkTime") && dict["MaxWorkTime"] != nil {
                    self.maxWorkTime = dict["MaxWorkTime"] as! Int64
                }
                if dict.keys.contains("SatisfactionIndex") && dict["SatisfactionIndex"] != nil {
                    self.satisfactionIndex = dict["SatisfactionIndex"] as! Double
                }
                if dict.keys.contains("SatisfactionRate") && dict["SatisfactionRate"] != nil {
                    self.satisfactionRate = dict["SatisfactionRate"] as! Double
                }
                if dict.keys.contains("SatisfactionSurveysOffered") && dict["SatisfactionSurveysOffered"] != nil {
                    self.satisfactionSurveysOffered = dict["SatisfactionSurveysOffered"] as! Int64
                }
                if dict.keys.contains("SatisfactionSurveysResponded") && dict["SatisfactionSurveysResponded"] != nil {
                    self.satisfactionSurveysResponded = dict["SatisfactionSurveysResponded"] as! Int64
                }
                if dict.keys.contains("ServiceLevel20") && dict["ServiceLevel20"] != nil {
                    self.serviceLevel20 = dict["ServiceLevel20"] as! Double
                }
                if dict.keys.contains("TotalAbandonTime") && dict["TotalAbandonTime"] != nil {
                    self.totalAbandonTime = dict["TotalAbandonTime"] as! Int64
                }
                if dict.keys.contains("TotalAbandonedInIVRTime") && dict["TotalAbandonedInIVRTime"] != nil {
                    self.totalAbandonedInIVRTime = dict["TotalAbandonedInIVRTime"] as! Int64
                }
                if dict.keys.contains("TotalAbandonedInQueueTime") && dict["TotalAbandonedInQueueTime"] != nil {
                    self.totalAbandonedInQueueTime = dict["TotalAbandonedInQueueTime"] as! Int64
                }
                if dict.keys.contains("TotalAbandonedInRingTime") && dict["TotalAbandonedInRingTime"] != nil {
                    self.totalAbandonedInRingTime = dict["TotalAbandonedInRingTime"] as! Int64
                }
                if dict.keys.contains("TotalHoldTime") && dict["TotalHoldTime"] != nil {
                    self.totalHoldTime = dict["TotalHoldTime"] as! Int64
                }
                if dict.keys.contains("TotalRingTime") && dict["TotalRingTime"] != nil {
                    self.totalRingTime = dict["TotalRingTime"] as! Int64
                }
                if dict.keys.contains("TotalTalkTime") && dict["TotalTalkTime"] != nil {
                    self.totalTalkTime = dict["TotalTalkTime"] as! Int64
                }
                if dict.keys.contains("TotalWaitTime") && dict["TotalWaitTime"] != nil {
                    self.totalWaitTime = dict["TotalWaitTime"] as! Int64
                }
                if dict.keys.contains("TotalWorkTime") && dict["TotalWorkTime"] != nil {
                    self.totalWorkTime = dict["TotalWorkTime"] as! Int64
                }
            }
        }
        public class Outbound : Tea.TeaModel {
            public var answerRate: Double?

            public var averageDialingTime: Double?

            public var averageHoldTime: Double?

            public var averageRingTime: Double?

            public var averageTalkTime: Double?

            public var averageWorkTime: Double?

            public var callsAnswered: Int64?

            public var callsAttendedTransferred: Int64?

            public var callsBlindTransferred: Int64?

            public var callsDialed: Int64?

            public var callsHold: Int32?

            public var callsRinged: Int64?

            public var maxDialingTime: Int64?

            public var maxHoldTime: Int64?

            public var maxRingTime: Int64?

            public var maxTalkTime: Int64?

            public var maxWorkTime: Int64?

            public var satisfactionIndex: Double?

            public var satisfactionRate: Double?

            public var satisfactionSurveysOffered: Int64?

            public var satisfactionSurveysResponded: Int64?

            public var totalDialingTime: Int64?

            public var totalHoldTime: Int64?

            public var totalRingTime: Int64?

            public var totalTalkTime: Int64?

            public var totalWorkTime: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.answerRate != nil {
                    map["AnswerRate"] = self.answerRate!
                }
                if self.averageDialingTime != nil {
                    map["AverageDialingTime"] = self.averageDialingTime!
                }
                if self.averageHoldTime != nil {
                    map["AverageHoldTime"] = self.averageHoldTime!
                }
                if self.averageRingTime != nil {
                    map["AverageRingTime"] = self.averageRingTime!
                }
                if self.averageTalkTime != nil {
                    map["AverageTalkTime"] = self.averageTalkTime!
                }
                if self.averageWorkTime != nil {
                    map["AverageWorkTime"] = self.averageWorkTime!
                }
                if self.callsAnswered != nil {
                    map["CallsAnswered"] = self.callsAnswered!
                }
                if self.callsAttendedTransferred != nil {
                    map["CallsAttendedTransferred"] = self.callsAttendedTransferred!
                }
                if self.callsBlindTransferred != nil {
                    map["CallsBlindTransferred"] = self.callsBlindTransferred!
                }
                if self.callsDialed != nil {
                    map["CallsDialed"] = self.callsDialed!
                }
                if self.callsHold != nil {
                    map["CallsHold"] = self.callsHold!
                }
                if self.callsRinged != nil {
                    map["CallsRinged"] = self.callsRinged!
                }
                if self.maxDialingTime != nil {
                    map["MaxDialingTime"] = self.maxDialingTime!
                }
                if self.maxHoldTime != nil {
                    map["MaxHoldTime"] = self.maxHoldTime!
                }
                if self.maxRingTime != nil {
                    map["MaxRingTime"] = self.maxRingTime!
                }
                if self.maxTalkTime != nil {
                    map["MaxTalkTime"] = self.maxTalkTime!
                }
                if self.maxWorkTime != nil {
                    map["MaxWorkTime"] = self.maxWorkTime!
                }
                if self.satisfactionIndex != nil {
                    map["SatisfactionIndex"] = self.satisfactionIndex!
                }
                if self.satisfactionRate != nil {
                    map["SatisfactionRate"] = self.satisfactionRate!
                }
                if self.satisfactionSurveysOffered != nil {
                    map["SatisfactionSurveysOffered"] = self.satisfactionSurveysOffered!
                }
                if self.satisfactionSurveysResponded != nil {
                    map["SatisfactionSurveysResponded"] = self.satisfactionSurveysResponded!
                }
                if self.totalDialingTime != nil {
                    map["TotalDialingTime"] = self.totalDialingTime!
                }
                if self.totalHoldTime != nil {
                    map["TotalHoldTime"] = self.totalHoldTime!
                }
                if self.totalRingTime != nil {
                    map["TotalRingTime"] = self.totalRingTime!
                }
                if self.totalTalkTime != nil {
                    map["TotalTalkTime"] = self.totalTalkTime!
                }
                if self.totalWorkTime != nil {
                    map["TotalWorkTime"] = self.totalWorkTime!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AnswerRate") && dict["AnswerRate"] != nil {
                    self.answerRate = dict["AnswerRate"] as! Double
                }
                if dict.keys.contains("AverageDialingTime") && dict["AverageDialingTime"] != nil {
                    self.averageDialingTime = dict["AverageDialingTime"] as! Double
                }
                if dict.keys.contains("AverageHoldTime") && dict["AverageHoldTime"] != nil {
                    self.averageHoldTime = dict["AverageHoldTime"] as! Double
                }
                if dict.keys.contains("AverageRingTime") && dict["AverageRingTime"] != nil {
                    self.averageRingTime = dict["AverageRingTime"] as! Double
                }
                if dict.keys.contains("AverageTalkTime") && dict["AverageTalkTime"] != nil {
                    self.averageTalkTime = dict["AverageTalkTime"] as! Double
                }
                if dict.keys.contains("AverageWorkTime") && dict["AverageWorkTime"] != nil {
                    self.averageWorkTime = dict["AverageWorkTime"] as! Double
                }
                if dict.keys.contains("CallsAnswered") && dict["CallsAnswered"] != nil {
                    self.callsAnswered = dict["CallsAnswered"] as! Int64
                }
                if dict.keys.contains("CallsAttendedTransferred") && dict["CallsAttendedTransferred"] != nil {
                    self.callsAttendedTransferred = dict["CallsAttendedTransferred"] as! Int64
                }
                if dict.keys.contains("CallsBlindTransferred") && dict["CallsBlindTransferred"] != nil {
                    self.callsBlindTransferred = dict["CallsBlindTransferred"] as! Int64
                }
                if dict.keys.contains("CallsDialed") && dict["CallsDialed"] != nil {
                    self.callsDialed = dict["CallsDialed"] as! Int64
                }
                if dict.keys.contains("CallsHold") && dict["CallsHold"] != nil {
                    self.callsHold = dict["CallsHold"] as! Int32
                }
                if dict.keys.contains("CallsRinged") && dict["CallsRinged"] != nil {
                    self.callsRinged = dict["CallsRinged"] as! Int64
                }
                if dict.keys.contains("MaxDialingTime") && dict["MaxDialingTime"] != nil {
                    self.maxDialingTime = dict["MaxDialingTime"] as! Int64
                }
                if dict.keys.contains("MaxHoldTime") && dict["MaxHoldTime"] != nil {
                    self.maxHoldTime = dict["MaxHoldTime"] as! Int64
                }
                if dict.keys.contains("MaxRingTime") && dict["MaxRingTime"] != nil {
                    self.maxRingTime = dict["MaxRingTime"] as! Int64
                }
                if dict.keys.contains("MaxTalkTime") && dict["MaxTalkTime"] != nil {
                    self.maxTalkTime = dict["MaxTalkTime"] as! Int64
                }
                if dict.keys.contains("MaxWorkTime") && dict["MaxWorkTime"] != nil {
                    self.maxWorkTime = dict["MaxWorkTime"] as! Int64
                }
                if dict.keys.contains("SatisfactionIndex") && dict["SatisfactionIndex"] != nil {
                    self.satisfactionIndex = dict["SatisfactionIndex"] as! Double
                }
                if dict.keys.contains("SatisfactionRate") && dict["SatisfactionRate"] != nil {
                    self.satisfactionRate = dict["SatisfactionRate"] as! Double
                }
                if dict.keys.contains("SatisfactionSurveysOffered") && dict["SatisfactionSurveysOffered"] != nil {
                    self.satisfactionSurveysOffered = dict["SatisfactionSurveysOffered"] as! Int64
                }
                if dict.keys.contains("SatisfactionSurveysResponded") && dict["SatisfactionSurveysResponded"] != nil {
                    self.satisfactionSurveysResponded = dict["SatisfactionSurveysResponded"] as! Int64
                }
                if dict.keys.contains("TotalDialingTime") && dict["TotalDialingTime"] != nil {
                    self.totalDialingTime = dict["TotalDialingTime"] as! Int64
                }
                if dict.keys.contains("TotalHoldTime") && dict["TotalHoldTime"] != nil {
                    self.totalHoldTime = dict["TotalHoldTime"] as! Int64
                }
                if dict.keys.contains("TotalRingTime") && dict["TotalRingTime"] != nil {
                    self.totalRingTime = dict["TotalRingTime"] as! Int64
                }
                if dict.keys.contains("TotalTalkTime") && dict["TotalTalkTime"] != nil {
                    self.totalTalkTime = dict["TotalTalkTime"] as! Int64
                }
                if dict.keys.contains("TotalWorkTime") && dict["TotalWorkTime"] != nil {
                    self.totalWorkTime = dict["TotalWorkTime"] as! Int64
                }
            }
        }
        public class Overall : Tea.TeaModel {
            public var averageBreakTime: Double?

            public var averageHoldTime: Double?

            public var averageReadyTime: Double?

            public var averageTalkTime: Double?

            public var averageWorkTime: Double?

            public var maxBreakTime: Int64?

            public var maxHoldTime: Int64?

            public var maxReadyTime: Int64?

            public var maxTalkTime: Int64?

            public var maxWorkTime: Int64?

            public var occupancyRate: Double?

            public var satisfactionIndex: Double?

            public var satisfactionRate: Double?

            public var satisfactionSurveysOffered: Int64?

            public var satisfactionSurveysResponded: Int64?

            public var totalBreakTime: Int64?

            public var totalCalls: Int64?

            public var totalHoldTime: Int64?

            public var totalLoggedInTime: Int64?

            public var totalReadyTime: Int64?

            public var totalTalkTime: Int64?

            public var totalWorkTime: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.averageBreakTime != nil {
                    map["AverageBreakTime"] = self.averageBreakTime!
                }
                if self.averageHoldTime != nil {
                    map["AverageHoldTime"] = self.averageHoldTime!
                }
                if self.averageReadyTime != nil {
                    map["AverageReadyTime"] = self.averageReadyTime!
                }
                if self.averageTalkTime != nil {
                    map["AverageTalkTime"] = self.averageTalkTime!
                }
                if self.averageWorkTime != nil {
                    map["AverageWorkTime"] = self.averageWorkTime!
                }
                if self.maxBreakTime != nil {
                    map["MaxBreakTime"] = self.maxBreakTime!
                }
                if self.maxHoldTime != nil {
                    map["MaxHoldTime"] = self.maxHoldTime!
                }
                if self.maxReadyTime != nil {
                    map["MaxReadyTime"] = self.maxReadyTime!
                }
                if self.maxTalkTime != nil {
                    map["MaxTalkTime"] = self.maxTalkTime!
                }
                if self.maxWorkTime != nil {
                    map["MaxWorkTime"] = self.maxWorkTime!
                }
                if self.occupancyRate != nil {
                    map["OccupancyRate"] = self.occupancyRate!
                }
                if self.satisfactionIndex != nil {
                    map["SatisfactionIndex"] = self.satisfactionIndex!
                }
                if self.satisfactionRate != nil {
                    map["SatisfactionRate"] = self.satisfactionRate!
                }
                if self.satisfactionSurveysOffered != nil {
                    map["SatisfactionSurveysOffered"] = self.satisfactionSurveysOffered!
                }
                if self.satisfactionSurveysResponded != nil {
                    map["SatisfactionSurveysResponded"] = self.satisfactionSurveysResponded!
                }
                if self.totalBreakTime != nil {
                    map["TotalBreakTime"] = self.totalBreakTime!
                }
                if self.totalCalls != nil {
                    map["TotalCalls"] = self.totalCalls!
                }
                if self.totalHoldTime != nil {
                    map["TotalHoldTime"] = self.totalHoldTime!
                }
                if self.totalLoggedInTime != nil {
                    map["TotalLoggedInTime"] = self.totalLoggedInTime!
                }
                if self.totalReadyTime != nil {
                    map["TotalReadyTime"] = self.totalReadyTime!
                }
                if self.totalTalkTime != nil {
                    map["TotalTalkTime"] = self.totalTalkTime!
                }
                if self.totalWorkTime != nil {
                    map["TotalWorkTime"] = self.totalWorkTime!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AverageBreakTime") && dict["AverageBreakTime"] != nil {
                    self.averageBreakTime = dict["AverageBreakTime"] as! Double
                }
                if dict.keys.contains("AverageHoldTime") && dict["AverageHoldTime"] != nil {
                    self.averageHoldTime = dict["AverageHoldTime"] as! Double
                }
                if dict.keys.contains("AverageReadyTime") && dict["AverageReadyTime"] != nil {
                    self.averageReadyTime = dict["AverageReadyTime"] as! Double
                }
                if dict.keys.contains("AverageTalkTime") && dict["AverageTalkTime"] != nil {
                    self.averageTalkTime = dict["AverageTalkTime"] as! Double
                }
                if dict.keys.contains("AverageWorkTime") && dict["AverageWorkTime"] != nil {
                    self.averageWorkTime = dict["AverageWorkTime"] as! Double
                }
                if dict.keys.contains("MaxBreakTime") && dict["MaxBreakTime"] != nil {
                    self.maxBreakTime = dict["MaxBreakTime"] as! Int64
                }
                if dict.keys.contains("MaxHoldTime") && dict["MaxHoldTime"] != nil {
                    self.maxHoldTime = dict["MaxHoldTime"] as! Int64
                }
                if dict.keys.contains("MaxReadyTime") && dict["MaxReadyTime"] != nil {
                    self.maxReadyTime = dict["MaxReadyTime"] as! Int64
                }
                if dict.keys.contains("MaxTalkTime") && dict["MaxTalkTime"] != nil {
                    self.maxTalkTime = dict["MaxTalkTime"] as! Int64
                }
                if dict.keys.contains("MaxWorkTime") && dict["MaxWorkTime"] != nil {
                    self.maxWorkTime = dict["MaxWorkTime"] as! Int64
                }
                if dict.keys.contains("OccupancyRate") && dict["OccupancyRate"] != nil {
                    self.occupancyRate = dict["OccupancyRate"] as! Double
                }
                if dict.keys.contains("SatisfactionIndex") && dict["SatisfactionIndex"] != nil {
                    self.satisfactionIndex = dict["SatisfactionIndex"] as! Double
                }
                if dict.keys.contains("SatisfactionRate") && dict["SatisfactionRate"] != nil {
                    self.satisfactionRate = dict["SatisfactionRate"] as! Double
                }
                if dict.keys.contains("SatisfactionSurveysOffered") && dict["SatisfactionSurveysOffered"] != nil {
                    self.satisfactionSurveysOffered = dict["SatisfactionSurveysOffered"] as! Int64
                }
                if dict.keys.contains("SatisfactionSurveysResponded") && dict["SatisfactionSurveysResponded"] != nil {
                    self.satisfactionSurveysResponded = dict["SatisfactionSurveysResponded"] as! Int64
                }
                if dict.keys.contains("TotalBreakTime") && dict["TotalBreakTime"] != nil {
                    self.totalBreakTime = dict["TotalBreakTime"] as! Int64
                }
                if dict.keys.contains("TotalCalls") && dict["TotalCalls"] != nil {
                    self.totalCalls = dict["TotalCalls"] as! Int64
                }
                if dict.keys.contains("TotalHoldTime") && dict["TotalHoldTime"] != nil {
                    self.totalHoldTime = dict["TotalHoldTime"] as! Int64
                }
                if dict.keys.contains("TotalLoggedInTime") && dict["TotalLoggedInTime"] != nil {
                    self.totalLoggedInTime = dict["TotalLoggedInTime"] as! Int64
                }
                if dict.keys.contains("TotalReadyTime") && dict["TotalReadyTime"] != nil {
                    self.totalReadyTime = dict["TotalReadyTime"] as! Int64
                }
                if dict.keys.contains("TotalTalkTime") && dict["TotalTalkTime"] != nil {
                    self.totalTalkTime = dict["TotalTalkTime"] as! Int64
                }
                if dict.keys.contains("TotalWorkTime") && dict["TotalWorkTime"] != nil {
                    self.totalWorkTime = dict["TotalWorkTime"] as! Int64
                }
            }
        }
        public var inbound: GetHistoricalInstanceReportResponseBody.Data.Inbound?

        public var outbound: GetHistoricalInstanceReportResponseBody.Data.Outbound?

        public var overall: GetHistoricalInstanceReportResponseBody.Data.Overall?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.inbound?.validate()
            try self.outbound?.validate()
            try self.overall?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.inbound != nil {
                map["Inbound"] = self.inbound?.toMap()
            }
            if self.outbound != nil {
                map["Outbound"] = self.outbound?.toMap()
            }
            if self.overall != nil {
                map["Overall"] = self.overall?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Inbound") && dict["Inbound"] != nil {
                var model = GetHistoricalInstanceReportResponseBody.Data.Inbound()
                model.fromMap(dict["Inbound"] as! [String: Any])
                self.inbound = model
            }
            if dict.keys.contains("Outbound") && dict["Outbound"] != nil {
                var model = GetHistoricalInstanceReportResponseBody.Data.Outbound()
                model.fromMap(dict["Outbound"] as! [String: Any])
                self.outbound = model
            }
            if dict.keys.contains("Overall") && dict["Overall"] != nil {
                var model = GetHistoricalInstanceReportResponseBody.Data.Overall()
                model.fromMap(dict["Overall"] as! [String: Any])
                self.overall = model
            }
        }
    }
    public var code: String?

    public var data: GetHistoricalInstanceReportResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = GetHistoricalInstanceReportResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetHistoricalInstanceReportResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetHistoricalInstanceReportResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetHistoricalInstanceReportResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetInstanceRequest : Tea.TeaModel {
    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
    }
}

public class GetInstanceResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class AdminList : Tea.TeaModel {
            public var displayName: String?

            public var email: String?

            public var extension_: String?

            public var instanceId: String?

            public var loginName: String?

            public var mobile: String?

            public var roleId: String?

            public var roleName: String?

            public var userId: String?

            public var workMode: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.displayName != nil {
                    map["DisplayName"] = self.displayName!
                }
                if self.email != nil {
                    map["Email"] = self.email!
                }
                if self.extension_ != nil {
                    map["Extension"] = self.extension_!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.loginName != nil {
                    map["LoginName"] = self.loginName!
                }
                if self.mobile != nil {
                    map["Mobile"] = self.mobile!
                }
                if self.roleId != nil {
                    map["RoleId"] = self.roleId!
                }
                if self.roleName != nil {
                    map["RoleName"] = self.roleName!
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                if self.workMode != nil {
                    map["WorkMode"] = self.workMode!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DisplayName") && dict["DisplayName"] != nil {
                    self.displayName = dict["DisplayName"] as! String
                }
                if dict.keys.contains("Email") && dict["Email"] != nil {
                    self.email = dict["Email"] as! String
                }
                if dict.keys.contains("Extension") && dict["Extension"] != nil {
                    self.extension_ = dict["Extension"] as! String
                }
                if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("LoginName") && dict["LoginName"] != nil {
                    self.loginName = dict["LoginName"] as! String
                }
                if dict.keys.contains("Mobile") && dict["Mobile"] != nil {
                    self.mobile = dict["Mobile"] as! String
                }
                if dict.keys.contains("RoleId") && dict["RoleId"] != nil {
                    self.roleId = dict["RoleId"] as! String
                }
                if dict.keys.contains("RoleName") && dict["RoleName"] != nil {
                    self.roleName = dict["RoleName"] as! String
                }
                if dict.keys.contains("UserId") && dict["UserId"] != nil {
                    self.userId = dict["UserId"] as! String
                }
                if dict.keys.contains("WorkMode") && dict["WorkMode"] != nil {
                    self.workMode = dict["WorkMode"] as! String
                }
            }
        }
        public class NumberList : Tea.TeaModel {
            public class SkillGroups : Tea.TeaModel {
                public var description_: String?

                public var displayName: String?

                public var instanceId: String?

                public var name: String?

                public var phoneNumberCount: Int32?

                public var skillGroupId: String?

                public var userCount: Int32?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.displayName != nil {
                        map["DisplayName"] = self.displayName!
                    }
                    if self.instanceId != nil {
                        map["InstanceId"] = self.instanceId!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.phoneNumberCount != nil {
                        map["PhoneNumberCount"] = self.phoneNumberCount!
                    }
                    if self.skillGroupId != nil {
                        map["SkillGroupId"] = self.skillGroupId!
                    }
                    if self.userCount != nil {
                        map["UserCount"] = self.userCount!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") && dict["Description"] != nil {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("DisplayName") && dict["DisplayName"] != nil {
                        self.displayName = dict["DisplayName"] as! String
                    }
                    if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                        self.instanceId = dict["InstanceId"] as! String
                    }
                    if dict.keys.contains("Name") && dict["Name"] != nil {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("PhoneNumberCount") && dict["PhoneNumberCount"] != nil {
                        self.phoneNumberCount = dict["PhoneNumberCount"] as! Int32
                    }
                    if dict.keys.contains("SkillGroupId") && dict["SkillGroupId"] != nil {
                        self.skillGroupId = dict["SkillGroupId"] as! String
                    }
                    if dict.keys.contains("UserCount") && dict["UserCount"] != nil {
                        self.userCount = dict["UserCount"] as! Int32
                    }
                }
            }
            public var active: Bool?

            public var city: String?

            public var contactFlowId: String?

            public var instanceId: String?

            public var number: String?

            public var province: String?

            public var skillGroups: [GetInstanceResponseBody.Data.NumberList.SkillGroups]?

            public var usage: String?

            public var userId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.active != nil {
                    map["Active"] = self.active!
                }
                if self.city != nil {
                    map["City"] = self.city!
                }
                if self.contactFlowId != nil {
                    map["ContactFlowId"] = self.contactFlowId!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.number != nil {
                    map["Number"] = self.number!
                }
                if self.province != nil {
                    map["Province"] = self.province!
                }
                if self.skillGroups != nil {
                    var tmp : [Any] = []
                    for k in self.skillGroups! {
                        tmp.append(k.toMap())
                    }
                    map["SkillGroups"] = tmp
                }
                if self.usage != nil {
                    map["Usage"] = self.usage!
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Active") && dict["Active"] != nil {
                    self.active = dict["Active"] as! Bool
                }
                if dict.keys.contains("City") && dict["City"] != nil {
                    self.city = dict["City"] as! String
                }
                if dict.keys.contains("ContactFlowId") && dict["ContactFlowId"] != nil {
                    self.contactFlowId = dict["ContactFlowId"] as! String
                }
                if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("Number") && dict["Number"] != nil {
                    self.number = dict["Number"] as! String
                }
                if dict.keys.contains("Province") && dict["Province"] != nil {
                    self.province = dict["Province"] as! String
                }
                if dict.keys.contains("SkillGroups") && dict["SkillGroups"] != nil {
                    var tmp : [GetInstanceResponseBody.Data.NumberList.SkillGroups] = []
                    for v in dict["SkillGroups"] as! [Any] {
                        var model = GetInstanceResponseBody.Data.NumberList.SkillGroups()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.skillGroups = tmp
                }
                if dict.keys.contains("Usage") && dict["Usage"] != nil {
                    self.usage = dict["Usage"] as! String
                }
                if dict.keys.contains("UserId") && dict["UserId"] != nil {
                    self.userId = dict["UserId"] as! String
                }
            }
        }
        public var adminList: [GetInstanceResponseBody.Data.AdminList]?

        public var aliyunUid: String?

        public var consoleUrl: String?

        public var description_: String?

        public var domainName: String?

        public var id: String?

        public var name: String?

        public var numberList: [GetInstanceResponseBody.Data.NumberList]?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.adminList != nil {
                var tmp : [Any] = []
                for k in self.adminList! {
                    tmp.append(k.toMap())
                }
                map["AdminList"] = tmp
            }
            if self.aliyunUid != nil {
                map["AliyunUid"] = self.aliyunUid!
            }
            if self.consoleUrl != nil {
                map["ConsoleUrl"] = self.consoleUrl!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.domainName != nil {
                map["DomainName"] = self.domainName!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.numberList != nil {
                var tmp : [Any] = []
                for k in self.numberList! {
                    tmp.append(k.toMap())
                }
                map["NumberList"] = tmp
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AdminList") && dict["AdminList"] != nil {
                var tmp : [GetInstanceResponseBody.Data.AdminList] = []
                for v in dict["AdminList"] as! [Any] {
                    var model = GetInstanceResponseBody.Data.AdminList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.adminList = tmp
            }
            if dict.keys.contains("AliyunUid") && dict["AliyunUid"] != nil {
                self.aliyunUid = dict["AliyunUid"] as! String
            }
            if dict.keys.contains("ConsoleUrl") && dict["ConsoleUrl"] != nil {
                self.consoleUrl = dict["ConsoleUrl"] as! String
            }
            if dict.keys.contains("Description") && dict["Description"] != nil {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("DomainName") && dict["DomainName"] != nil {
                self.domainName = dict["DomainName"] as! String
            }
            if dict.keys.contains("Id") && dict["Id"] != nil {
                self.id = dict["Id"] as! String
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("NumberList") && dict["NumberList"] != nil {
                var tmp : [GetInstanceResponseBody.Data.NumberList] = []
                for v in dict["NumberList"] as! [Any] {
                    var model = GetInstanceResponseBody.Data.NumberList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.numberList = tmp
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! String
            }
        }
    }
    public var code: String?

    public var data: GetInstanceResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = GetInstanceResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetInstanceTrendingReportRequest : Tea.TeaModel {
    public var endTime: Int64?

    public var instanceId: String?

    public var startTime: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
            self.startTime = dict["StartTime"] as! Int64
        }
    }
}

public class GetInstanceTrendingReportResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Inbound : Tea.TeaModel {
            public var callsAbandonedInIVR: Int64?

            public var callsAbandonedInQueue: Int64?

            public var callsAbandonedInRing: Int64?

            public var callsHandled: Int64?

            public var callsQueued: Int64?

            public var statsTime: Int64?

            public var totalCalls: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.callsAbandonedInIVR != nil {
                    map["CallsAbandonedInIVR"] = self.callsAbandonedInIVR!
                }
                if self.callsAbandonedInQueue != nil {
                    map["CallsAbandonedInQueue"] = self.callsAbandonedInQueue!
                }
                if self.callsAbandonedInRing != nil {
                    map["CallsAbandonedInRing"] = self.callsAbandonedInRing!
                }
                if self.callsHandled != nil {
                    map["CallsHandled"] = self.callsHandled!
                }
                if self.callsQueued != nil {
                    map["CallsQueued"] = self.callsQueued!
                }
                if self.statsTime != nil {
                    map["StatsTime"] = self.statsTime!
                }
                if self.totalCalls != nil {
                    map["TotalCalls"] = self.totalCalls!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CallsAbandonedInIVR") && dict["CallsAbandonedInIVR"] != nil {
                    self.callsAbandonedInIVR = dict["CallsAbandonedInIVR"] as! Int64
                }
                if dict.keys.contains("CallsAbandonedInQueue") && dict["CallsAbandonedInQueue"] != nil {
                    self.callsAbandonedInQueue = dict["CallsAbandonedInQueue"] as! Int64
                }
                if dict.keys.contains("CallsAbandonedInRing") && dict["CallsAbandonedInRing"] != nil {
                    self.callsAbandonedInRing = dict["CallsAbandonedInRing"] as! Int64
                }
                if dict.keys.contains("CallsHandled") && dict["CallsHandled"] != nil {
                    self.callsHandled = dict["CallsHandled"] as! Int64
                }
                if dict.keys.contains("CallsQueued") && dict["CallsQueued"] != nil {
                    self.callsQueued = dict["CallsQueued"] as! Int64
                }
                if dict.keys.contains("StatsTime") && dict["StatsTime"] != nil {
                    self.statsTime = dict["StatsTime"] as! Int64
                }
                if dict.keys.contains("TotalCalls") && dict["TotalCalls"] != nil {
                    self.totalCalls = dict["TotalCalls"] as! Int64
                }
            }
        }
        public class Outbound : Tea.TeaModel {
            public var callsAnswered: Int64?

            public var statsTime: Int64?

            public var totalCalls: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.callsAnswered != nil {
                    map["CallsAnswered"] = self.callsAnswered!
                }
                if self.statsTime != nil {
                    map["StatsTime"] = self.statsTime!
                }
                if self.totalCalls != nil {
                    map["TotalCalls"] = self.totalCalls!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CallsAnswered") && dict["CallsAnswered"] != nil {
                    self.callsAnswered = dict["CallsAnswered"] as! Int64
                }
                if dict.keys.contains("StatsTime") && dict["StatsTime"] != nil {
                    self.statsTime = dict["StatsTime"] as! Int64
                }
                if dict.keys.contains("TotalCalls") && dict["TotalCalls"] != nil {
                    self.totalCalls = dict["TotalCalls"] as! Int64
                }
            }
        }
        public var inbound: [GetInstanceTrendingReportResponseBody.Data.Inbound]?

        public var outbound: [GetInstanceTrendingReportResponseBody.Data.Outbound]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.inbound != nil {
                var tmp : [Any] = []
                for k in self.inbound! {
                    tmp.append(k.toMap())
                }
                map["Inbound"] = tmp
            }
            if self.outbound != nil {
                var tmp : [Any] = []
                for k in self.outbound! {
                    tmp.append(k.toMap())
                }
                map["Outbound"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Inbound") && dict["Inbound"] != nil {
                var tmp : [GetInstanceTrendingReportResponseBody.Data.Inbound] = []
                for v in dict["Inbound"] as! [Any] {
                    var model = GetInstanceTrendingReportResponseBody.Data.Inbound()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.inbound = tmp
            }
            if dict.keys.contains("Outbound") && dict["Outbound"] != nil {
                var tmp : [GetInstanceTrendingReportResponseBody.Data.Outbound] = []
                for v in dict["Outbound"] as! [Any] {
                    var model = GetInstanceTrendingReportResponseBody.Data.Outbound()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.outbound = tmp
            }
        }
    }
    public var code: String?

    public var data: GetInstanceTrendingReportResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = GetInstanceTrendingReportResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetInstanceTrendingReportResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetInstanceTrendingReportResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetInstanceTrendingReportResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetLoginDetailsRequest : Tea.TeaModel {
    public var instanceId: String?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("UserId") && dict["UserId"] != nil {
            self.userId = dict["UserId"] as! String
        }
    }
}

public class GetLoginDetailsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var agentServerUrl: String?

        public var deviceExt: String?

        public var deviceId: String?

        public var deviceState: String?

        public var displayName: String?

        public var extension_: String?

        public var signature: String?

        public var signature2: String?

        public var sipServerUrl: String?

        public var userId: String?

        public var userKey: String?

        public var userKey2: String?

        public var workMode: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.agentServerUrl != nil {
                map["AgentServerUrl"] = self.agentServerUrl!
            }
            if self.deviceExt != nil {
                map["DeviceExt"] = self.deviceExt!
            }
            if self.deviceId != nil {
                map["DeviceId"] = self.deviceId!
            }
            if self.deviceState != nil {
                map["DeviceState"] = self.deviceState!
            }
            if self.displayName != nil {
                map["DisplayName"] = self.displayName!
            }
            if self.extension_ != nil {
                map["Extension"] = self.extension_!
            }
            if self.signature != nil {
                map["Signature"] = self.signature!
            }
            if self.signature2 != nil {
                map["Signature2"] = self.signature2!
            }
            if self.sipServerUrl != nil {
                map["SipServerUrl"] = self.sipServerUrl!
            }
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            if self.userKey != nil {
                map["UserKey"] = self.userKey!
            }
            if self.userKey2 != nil {
                map["UserKey2"] = self.userKey2!
            }
            if self.workMode != nil {
                map["WorkMode"] = self.workMode!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AgentServerUrl") && dict["AgentServerUrl"] != nil {
                self.agentServerUrl = dict["AgentServerUrl"] as! String
            }
            if dict.keys.contains("DeviceExt") && dict["DeviceExt"] != nil {
                self.deviceExt = dict["DeviceExt"] as! String
            }
            if dict.keys.contains("DeviceId") && dict["DeviceId"] != nil {
                self.deviceId = dict["DeviceId"] as! String
            }
            if dict.keys.contains("DeviceState") && dict["DeviceState"] != nil {
                self.deviceState = dict["DeviceState"] as! String
            }
            if dict.keys.contains("DisplayName") && dict["DisplayName"] != nil {
                self.displayName = dict["DisplayName"] as! String
            }
            if dict.keys.contains("Extension") && dict["Extension"] != nil {
                self.extension_ = dict["Extension"] as! String
            }
            if dict.keys.contains("Signature") && dict["Signature"] != nil {
                self.signature = dict["Signature"] as! String
            }
            if dict.keys.contains("Signature2") && dict["Signature2"] != nil {
                self.signature2 = dict["Signature2"] as! String
            }
            if dict.keys.contains("SipServerUrl") && dict["SipServerUrl"] != nil {
                self.sipServerUrl = dict["SipServerUrl"] as! String
            }
            if dict.keys.contains("UserId") && dict["UserId"] != nil {
                self.userId = dict["UserId"] as! String
            }
            if dict.keys.contains("UserKey") && dict["UserKey"] != nil {
                self.userKey = dict["UserKey"] as! String
            }
            if dict.keys.contains("UserKey2") && dict["UserKey2"] != nil {
                self.userKey2 = dict["UserKey2"] as! String
            }
            if dict.keys.contains("WorkMode") && dict["WorkMode"] != nil {
                self.workMode = dict["WorkMode"] as! String
            }
        }
    }
    public var code: String?

    public var data: GetLoginDetailsResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var params: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.params != nil {
            map["Params"] = self.params!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = GetLoginDetailsResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Params") && dict["Params"] != nil {
            self.params = dict["Params"] as! [String]
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetLoginDetailsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetLoginDetailsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetLoginDetailsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetMonoRecordingRequest : Tea.TeaModel {
    public var contactId: String?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.contactId != nil {
            map["ContactId"] = self.contactId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ContactId") && dict["ContactId"] != nil {
            self.contactId = dict["ContactId"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
    }
}

public class GetMonoRecordingResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var duration: Int64?

        public var fileName: String?

        public var fileUrl: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.duration != nil {
                map["Duration"] = self.duration!
            }
            if self.fileName != nil {
                map["FileName"] = self.fileName!
            }
            if self.fileUrl != nil {
                map["FileUrl"] = self.fileUrl!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Duration") && dict["Duration"] != nil {
                self.duration = dict["Duration"] as! Int64
            }
            if dict.keys.contains("FileName") && dict["FileName"] != nil {
                self.fileName = dict["FileName"] as! String
            }
            if dict.keys.contains("FileUrl") && dict["FileUrl"] != nil {
                self.fileUrl = dict["FileUrl"] as! String
            }
        }
    }
    public var code: String?

    public var data: GetMonoRecordingResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = GetMonoRecordingResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetMonoRecordingResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetMonoRecordingResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetMonoRecordingResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetMultiChannelRecordingRequest : Tea.TeaModel {
    public var contactId: String?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.contactId != nil {
            map["ContactId"] = self.contactId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ContactId") && dict["ContactId"] != nil {
            self.contactId = dict["ContactId"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
    }
}

public class GetMultiChannelRecordingResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var fileName: String?

        public var fileUrl: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.fileName != nil {
                map["FileName"] = self.fileName!
            }
            if self.fileUrl != nil {
                map["FileUrl"] = self.fileUrl!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("FileName") && dict["FileName"] != nil {
                self.fileName = dict["FileName"] as! String
            }
            if dict.keys.contains("FileUrl") && dict["FileUrl"] != nil {
                self.fileUrl = dict["FileUrl"] as! String
            }
        }
    }
    public var code: String?

    public var data: GetMultiChannelRecordingResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = GetMultiChannelRecordingResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetMultiChannelRecordingResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetMultiChannelRecordingResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetMultiChannelRecordingResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetNumberLocationRequest : Tea.TeaModel {
    public var instanceId: String?

    public var number: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.number != nil {
            map["Number"] = self.number!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Number") && dict["Number"] != nil {
            self.number = dict["Number"] as! String
        }
    }
}

public class GetNumberLocationResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var city: String?

        public var number: String?

        public var province: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.city != nil {
                map["City"] = self.city!
            }
            if self.number != nil {
                map["Number"] = self.number!
            }
            if self.province != nil {
                map["Province"] = self.province!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("City") && dict["City"] != nil {
                self.city = dict["City"] as! String
            }
            if dict.keys.contains("Number") && dict["Number"] != nil {
                self.number = dict["Number"] as! String
            }
            if dict.keys.contains("Province") && dict["Province"] != nil {
                self.province = dict["Province"] as! String
            }
        }
    }
    public var code: String?

    public var data: GetNumberLocationResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = GetNumberLocationResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetNumberLocationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetNumberLocationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetNumberLocationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetRealtimeCampaignStatsRequest : Tea.TeaModel {
    public var instanceId: String?

    public var queueId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.queueId != nil {
            map["QueueId"] = self.queueId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("QueueId") && dict["QueueId"] != nil {
            self.queueId = dict["QueueId"] as! String
        }
    }
}

public class GetRealtimeCampaignStatsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var breakingAgents: Int64?

        public var caps: Int64?

        public var loggedInAgents: Int64?

        public var readyAgents: Int64?

        public var talkingAgents: Int64?

        public var totalAgents: Int64?

        public var workingAgents: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.breakingAgents != nil {
                map["BreakingAgents"] = self.breakingAgents!
            }
            if self.caps != nil {
                map["Caps"] = self.caps!
            }
            if self.loggedInAgents != nil {
                map["LoggedInAgents"] = self.loggedInAgents!
            }
            if self.readyAgents != nil {
                map["ReadyAgents"] = self.readyAgents!
            }
            if self.talkingAgents != nil {
                map["TalkingAgents"] = self.talkingAgents!
            }
            if self.totalAgents != nil {
                map["TotalAgents"] = self.totalAgents!
            }
            if self.workingAgents != nil {
                map["WorkingAgents"] = self.workingAgents!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BreakingAgents") && dict["BreakingAgents"] != nil {
                self.breakingAgents = dict["BreakingAgents"] as! Int64
            }
            if dict.keys.contains("Caps") && dict["Caps"] != nil {
                self.caps = dict["Caps"] as! Int64
            }
            if dict.keys.contains("LoggedInAgents") && dict["LoggedInAgents"] != nil {
                self.loggedInAgents = dict["LoggedInAgents"] as! Int64
            }
            if dict.keys.contains("ReadyAgents") && dict["ReadyAgents"] != nil {
                self.readyAgents = dict["ReadyAgents"] as! Int64
            }
            if dict.keys.contains("TalkingAgents") && dict["TalkingAgents"] != nil {
                self.talkingAgents = dict["TalkingAgents"] as! Int64
            }
            if dict.keys.contains("TotalAgents") && dict["TotalAgents"] != nil {
                self.totalAgents = dict["TotalAgents"] as! Int64
            }
            if dict.keys.contains("WorkingAgents") && dict["WorkingAgents"] != nil {
                self.workingAgents = dict["WorkingAgents"] as! Int64
            }
        }
    }
    public var code: String?

    public var data: GetRealtimeCampaignStatsResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = GetRealtimeCampaignStatsResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetRealtimeCampaignStatsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetRealtimeCampaignStatsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetRealtimeCampaignStatsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetRealtimeInstanceStatesRequest : Tea.TeaModel {
    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
    }
}

public class GetRealtimeInstanceStatesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var breakingAgents: Int64?

        public var instanceId: String?

        public var interactiveCalls: Int64?

        public var loggedInAgents: Int64?

        public var longestWaitingTime: Int64?

        public var readyAgents: Int64?

        public var talkingAgents: Int64?

        public var totalAgents: Int64?

        public var waitingCalls: Int64?

        public var workingAgents: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.breakingAgents != nil {
                map["BreakingAgents"] = self.breakingAgents!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.interactiveCalls != nil {
                map["InteractiveCalls"] = self.interactiveCalls!
            }
            if self.loggedInAgents != nil {
                map["LoggedInAgents"] = self.loggedInAgents!
            }
            if self.longestWaitingTime != nil {
                map["LongestWaitingTime"] = self.longestWaitingTime!
            }
            if self.readyAgents != nil {
                map["ReadyAgents"] = self.readyAgents!
            }
            if self.talkingAgents != nil {
                map["TalkingAgents"] = self.talkingAgents!
            }
            if self.totalAgents != nil {
                map["TotalAgents"] = self.totalAgents!
            }
            if self.waitingCalls != nil {
                map["WaitingCalls"] = self.waitingCalls!
            }
            if self.workingAgents != nil {
                map["WorkingAgents"] = self.workingAgents!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BreakingAgents") && dict["BreakingAgents"] != nil {
                self.breakingAgents = dict["BreakingAgents"] as! Int64
            }
            if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("InteractiveCalls") && dict["InteractiveCalls"] != nil {
                self.interactiveCalls = dict["InteractiveCalls"] as! Int64
            }
            if dict.keys.contains("LoggedInAgents") && dict["LoggedInAgents"] != nil {
                self.loggedInAgents = dict["LoggedInAgents"] as! Int64
            }
            if dict.keys.contains("LongestWaitingTime") && dict["LongestWaitingTime"] != nil {
                self.longestWaitingTime = dict["LongestWaitingTime"] as! Int64
            }
            if dict.keys.contains("ReadyAgents") && dict["ReadyAgents"] != nil {
                self.readyAgents = dict["ReadyAgents"] as! Int64
            }
            if dict.keys.contains("TalkingAgents") && dict["TalkingAgents"] != nil {
                self.talkingAgents = dict["TalkingAgents"] as! Int64
            }
            if dict.keys.contains("TotalAgents") && dict["TotalAgents"] != nil {
                self.totalAgents = dict["TotalAgents"] as! Int64
            }
            if dict.keys.contains("WaitingCalls") && dict["WaitingCalls"] != nil {
                self.waitingCalls = dict["WaitingCalls"] as! Int64
            }
            if dict.keys.contains("WorkingAgents") && dict["WorkingAgents"] != nil {
                self.workingAgents = dict["WorkingAgents"] as! Int64
            }
        }
    }
    public var code: String?

    public var data: GetRealtimeInstanceStatesResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = GetRealtimeInstanceStatesResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetRealtimeInstanceStatesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetRealtimeInstanceStatesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetRealtimeInstanceStatesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetSkillGroupRequest : Tea.TeaModel {
    public var instanceId: String?

    public var skillGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.skillGroupId != nil {
            map["SkillGroupId"] = self.skillGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("SkillGroupId") && dict["SkillGroupId"] != nil {
            self.skillGroupId = dict["SkillGroupId"] as! String
        }
    }
}

public class GetSkillGroupResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var description_: String?

        public var displayName: String?

        public var instanceId: String?

        public var name: String?

        public var skillGroupId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.displayName != nil {
                map["DisplayName"] = self.displayName!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.skillGroupId != nil {
                map["SkillGroupId"] = self.skillGroupId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Description") && dict["Description"] != nil {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("DisplayName") && dict["DisplayName"] != nil {
                self.displayName = dict["DisplayName"] as! String
            }
            if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("SkillGroupId") && dict["SkillGroupId"] != nil {
                self.skillGroupId = dict["SkillGroupId"] as! String
            }
        }
    }
    public var code: String?

    public var data: GetSkillGroupResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = GetSkillGroupResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetSkillGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetSkillGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetSkillGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetTurnCredentialsRequest : Tea.TeaModel {
    public var instanceId: String?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("UserId") && dict["UserId"] != nil {
            self.userId = dict["UserId"] as! String
        }
    }
}

public class GetTurnCredentialsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var password: String?

        public var userName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.password != nil {
                map["Password"] = self.password!
            }
            if self.userName != nil {
                map["UserName"] = self.userName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Password") && dict["Password"] != nil {
                self.password = dict["Password"] as! String
            }
            if dict.keys.contains("UserName") && dict["UserName"] != nil {
                self.userName = dict["UserName"] as! String
            }
        }
    }
    public var code: String?

    public var data: GetTurnCredentialsResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = GetTurnCredentialsResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetTurnCredentialsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetTurnCredentialsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetTurnCredentialsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetTurnServerListRequest : Tea.TeaModel {
    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
    }
}

public class GetTurnServerListResponseBody : Tea.TeaModel {
    public var code: String?

    public var data: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetTurnServerListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetTurnServerListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetTurnServerListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetUploadAudioDataParamsRequest : Tea.TeaModel {
    public var contactId: String?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.contactId != nil {
            map["ContactId"] = self.contactId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ContactId") && dict["ContactId"] != nil {
            self.contactId = dict["ContactId"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
    }
}

public class GetUploadAudioDataParamsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var paramsStr: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.paramsStr != nil {
                map["ParamsStr"] = self.paramsStr!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ParamsStr") && dict["ParamsStr"] != nil {
                self.paramsStr = dict["ParamsStr"] as! String
            }
        }
    }
    public var code: String?

    public var data: GetUploadAudioDataParamsResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = GetUploadAudioDataParamsResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetUploadAudioDataParamsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetUploadAudioDataParamsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetUploadAudioDataParamsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetUserRequest : Tea.TeaModel {
    public var extension_: String?

    public var instanceId: String?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.extension_ != nil {
            map["Extension"] = self.extension_!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Extension") && dict["Extension"] != nil {
            self.extension_ = dict["Extension"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("UserId") && dict["UserId"] != nil {
            self.userId = dict["UserId"] as! String
        }
    }
}

public class GetUserResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var deviceExt: String?

        public var deviceId: String?

        public var deviceState: String?

        public var displayId: String?

        public var displayName: String?

        public var email: String?

        public var extension_: String?

        public var instanceId: String?

        public var loginName: String?

        public var mobile: String?

        public var roleId: String?

        public var roleName: String?

        public var userId: String?

        public var workMode: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.deviceExt != nil {
                map["DeviceExt"] = self.deviceExt!
            }
            if self.deviceId != nil {
                map["DeviceId"] = self.deviceId!
            }
            if self.deviceState != nil {
                map["DeviceState"] = self.deviceState!
            }
            if self.displayId != nil {
                map["DisplayId"] = self.displayId!
            }
            if self.displayName != nil {
                map["DisplayName"] = self.displayName!
            }
            if self.email != nil {
                map["Email"] = self.email!
            }
            if self.extension_ != nil {
                map["Extension"] = self.extension_!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.loginName != nil {
                map["LoginName"] = self.loginName!
            }
            if self.mobile != nil {
                map["Mobile"] = self.mobile!
            }
            if self.roleId != nil {
                map["RoleId"] = self.roleId!
            }
            if self.roleName != nil {
                map["RoleName"] = self.roleName!
            }
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            if self.workMode != nil {
                map["WorkMode"] = self.workMode!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DeviceExt") && dict["DeviceExt"] != nil {
                self.deviceExt = dict["DeviceExt"] as! String
            }
            if dict.keys.contains("DeviceId") && dict["DeviceId"] != nil {
                self.deviceId = dict["DeviceId"] as! String
            }
            if dict.keys.contains("DeviceState") && dict["DeviceState"] != nil {
                self.deviceState = dict["DeviceState"] as! String
            }
            if dict.keys.contains("DisplayId") && dict["DisplayId"] != nil {
                self.displayId = dict["DisplayId"] as! String
            }
            if dict.keys.contains("DisplayName") && dict["DisplayName"] != nil {
                self.displayName = dict["DisplayName"] as! String
            }
            if dict.keys.contains("Email") && dict["Email"] != nil {
                self.email = dict["Email"] as! String
            }
            if dict.keys.contains("Extension") && dict["Extension"] != nil {
                self.extension_ = dict["Extension"] as! String
            }
            if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("LoginName") && dict["LoginName"] != nil {
                self.loginName = dict["LoginName"] as! String
            }
            if dict.keys.contains("Mobile") && dict["Mobile"] != nil {
                self.mobile = dict["Mobile"] as! String
            }
            if dict.keys.contains("RoleId") && dict["RoleId"] != nil {
                self.roleId = dict["RoleId"] as! String
            }
            if dict.keys.contains("RoleName") && dict["RoleName"] != nil {
                self.roleName = dict["RoleName"] as! String
            }
            if dict.keys.contains("UserId") && dict["UserId"] != nil {
                self.userId = dict["UserId"] as! String
            }
            if dict.keys.contains("WorkMode") && dict["WorkMode"] != nil {
                self.workMode = dict["WorkMode"] as! String
            }
        }
    }
    public var code: String?

    public var data: GetUserResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = GetUserResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetUserResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetUserResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetUserResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetVoicemailRecordingRequest : Tea.TeaModel {
    public var contactId: String?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.contactId != nil {
            map["ContactId"] = self.contactId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ContactId") && dict["ContactId"] != nil {
            self.contactId = dict["ContactId"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
    }
}

public class GetVoicemailRecordingResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var fileName: String?

        public var fileUrl: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.fileName != nil {
                map["FileName"] = self.fileName!
            }
            if self.fileUrl != nil {
                map["FileUrl"] = self.fileUrl!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("FileName") && dict["FileName"] != nil {
                self.fileName = dict["FileName"] as! String
            }
            if dict.keys.contains("FileUrl") && dict["FileUrl"] != nil {
                self.fileUrl = dict["FileUrl"] as! String
            }
        }
    }
    public var code: String?

    public var data: GetVoicemailRecordingResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = GetVoicemailRecordingResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetVoicemailRecordingResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetVoicemailRecordingResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = GetVoicemailRecordingResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class HoldCallRequest : Tea.TeaModel {
    public var channelId: String?

    public var deviceId: String?

    public var instanceId: String?

    public var jobId: String?

    public var music: String?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.channelId != nil {
            map["ChannelId"] = self.channelId!
        }
        if self.deviceId != nil {
            map["DeviceId"] = self.deviceId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.music != nil {
            map["Music"] = self.music!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ChannelId") && dict["ChannelId"] != nil {
            self.channelId = dict["ChannelId"] as! String
        }
        if dict.keys.contains("DeviceId") && dict["DeviceId"] != nil {
            self.deviceId = dict["DeviceId"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("JobId") && dict["JobId"] != nil {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("Music") && dict["Music"] != nil {
            self.music = dict["Music"] as! String
        }
        if dict.keys.contains("UserId") && dict["UserId"] != nil {
            self.userId = dict["UserId"] as! String
        }
    }
}

public class HoldCallResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class CallContext : Tea.TeaModel {
            public class ChannelContexts : Tea.TeaModel {
                public var callType: String?

                public var channelId: String?

                public var channelState: String?

                public var destination: String?

                public var jobId: String?

                public var originator: String?

                public var releaseInitiator: String?

                public var releaseReason: String?

                public var skillGroupId: String?

                public var timestamp: Int64?

                public var userExtension: String?

                public var userId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.callType != nil {
                        map["CallType"] = self.callType!
                    }
                    if self.channelId != nil {
                        map["ChannelId"] = self.channelId!
                    }
                    if self.channelState != nil {
                        map["ChannelState"] = self.channelState!
                    }
                    if self.destination != nil {
                        map["Destination"] = self.destination!
                    }
                    if self.jobId != nil {
                        map["JobId"] = self.jobId!
                    }
                    if self.originator != nil {
                        map["Originator"] = self.originator!
                    }
                    if self.releaseInitiator != nil {
                        map["ReleaseInitiator"] = self.releaseInitiator!
                    }
                    if self.releaseReason != nil {
                        map["ReleaseReason"] = self.releaseReason!
                    }
                    if self.skillGroupId != nil {
                        map["SkillGroupId"] = self.skillGroupId!
                    }
                    if self.timestamp != nil {
                        map["Timestamp"] = self.timestamp!
                    }
                    if self.userExtension != nil {
                        map["UserExtension"] = self.userExtension!
                    }
                    if self.userId != nil {
                        map["UserId"] = self.userId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("CallType") && dict["CallType"] != nil {
                        self.callType = dict["CallType"] as! String
                    }
                    if dict.keys.contains("ChannelId") && dict["ChannelId"] != nil {
                        self.channelId = dict["ChannelId"] as! String
                    }
                    if dict.keys.contains("ChannelState") && dict["ChannelState"] != nil {
                        self.channelState = dict["ChannelState"] as! String
                    }
                    if dict.keys.contains("Destination") && dict["Destination"] != nil {
                        self.destination = dict["Destination"] as! String
                    }
                    if dict.keys.contains("JobId") && dict["JobId"] != nil {
                        self.jobId = dict["JobId"] as! String
                    }
                    if dict.keys.contains("Originator") && dict["Originator"] != nil {
                        self.originator = dict["Originator"] as! String
                    }
                    if dict.keys.contains("ReleaseInitiator") && dict["ReleaseInitiator"] != nil {
                        self.releaseInitiator = dict["ReleaseInitiator"] as! String
                    }
                    if dict.keys.contains("ReleaseReason") && dict["ReleaseReason"] != nil {
                        self.releaseReason = dict["ReleaseReason"] as! String
                    }
                    if dict.keys.contains("SkillGroupId") && dict["SkillGroupId"] != nil {
                        self.skillGroupId = dict["SkillGroupId"] as! String
                    }
                    if dict.keys.contains("Timestamp") && dict["Timestamp"] != nil {
                        self.timestamp = dict["Timestamp"] as! Int64
                    }
                    if dict.keys.contains("UserExtension") && dict["UserExtension"] != nil {
                        self.userExtension = dict["UserExtension"] as! String
                    }
                    if dict.keys.contains("UserId") && dict["UserId"] != nil {
                        self.userId = dict["UserId"] as! String
                    }
                }
            }
            public var callType: String?

            public var channelContexts: [HoldCallResponseBody.Data.CallContext.ChannelContexts]?

            public var instanceId: String?

            public var jobId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.callType != nil {
                    map["CallType"] = self.callType!
                }
                if self.channelContexts != nil {
                    var tmp : [Any] = []
                    for k in self.channelContexts! {
                        tmp.append(k.toMap())
                    }
                    map["ChannelContexts"] = tmp
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.jobId != nil {
                    map["JobId"] = self.jobId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CallType") && dict["CallType"] != nil {
                    self.callType = dict["CallType"] as! String
                }
                if dict.keys.contains("ChannelContexts") && dict["ChannelContexts"] != nil {
                    var tmp : [HoldCallResponseBody.Data.CallContext.ChannelContexts] = []
                    for v in dict["ChannelContexts"] as! [Any] {
                        var model = HoldCallResponseBody.Data.CallContext.ChannelContexts()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.channelContexts = tmp
                }
                if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("JobId") && dict["JobId"] != nil {
                    self.jobId = dict["JobId"] as! String
                }
            }
        }
        public class UserContext : Tea.TeaModel {
            public var breakCode: String?

            public var deviceId: String?

            public var extension_: String?

            public var heartbeat: Int64?

            public var instanceId: String?

            public var jobId: String?

            public var mobile: String?

            public var outboundScenario: Bool?

            public var reserved: Int64?

            public var signedSkillGroupIdList: [String]?

            public var userId: String?

            public var userState: String?

            public var workMode: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.breakCode != nil {
                    map["BreakCode"] = self.breakCode!
                }
                if self.deviceId != nil {
                    map["DeviceId"] = self.deviceId!
                }
                if self.extension_ != nil {
                    map["Extension"] = self.extension_!
                }
                if self.heartbeat != nil {
                    map["Heartbeat"] = self.heartbeat!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.jobId != nil {
                    map["JobId"] = self.jobId!
                }
                if self.mobile != nil {
                    map["Mobile"] = self.mobile!
                }
                if self.outboundScenario != nil {
                    map["OutboundScenario"] = self.outboundScenario!
                }
                if self.reserved != nil {
                    map["Reserved"] = self.reserved!
                }
                if self.signedSkillGroupIdList != nil {
                    map["SignedSkillGroupIdList"] = self.signedSkillGroupIdList!
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                if self.userState != nil {
                    map["UserState"] = self.userState!
                }
                if self.workMode != nil {
                    map["WorkMode"] = self.workMode!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BreakCode") && dict["BreakCode"] != nil {
                    self.breakCode = dict["BreakCode"] as! String
                }
                if dict.keys.contains("DeviceId") && dict["DeviceId"] != nil {
                    self.deviceId = dict["DeviceId"] as! String
                }
                if dict.keys.contains("Extension") && dict["Extension"] != nil {
                    self.extension_ = dict["Extension"] as! String
                }
                if dict.keys.contains("Heartbeat") && dict["Heartbeat"] != nil {
                    self.heartbeat = dict["Heartbeat"] as! Int64
                }
                if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("JobId") && dict["JobId"] != nil {
                    self.jobId = dict["JobId"] as! String
                }
                if dict.keys.contains("Mobile") && dict["Mobile"] != nil {
                    self.mobile = dict["Mobile"] as! String
                }
                if dict.keys.contains("OutboundScenario") && dict["OutboundScenario"] != nil {
                    self.outboundScenario = dict["OutboundScenario"] as! Bool
                }
                if dict.keys.contains("Reserved") && dict["Reserved"] != nil {
                    self.reserved = dict["Reserved"] as! Int64
                }
                if dict.keys.contains("SignedSkillGroupIdList") && dict["SignedSkillGroupIdList"] != nil {
                    self.signedSkillGroupIdList = dict["SignedSkillGroupIdList"] as! [String]
                }
                if dict.keys.contains("UserId") && dict["UserId"] != nil {
                    self.userId = dict["UserId"] as! String
                }
                if dict.keys.contains("UserState") && dict["UserState"] != nil {
                    self.userState = dict["UserState"] as! String
                }
                if dict.keys.contains("WorkMode") && dict["WorkMode"] != nil {
                    self.workMode = dict["WorkMode"] as! String
                }
            }
        }
        public var callContext: HoldCallResponseBody.Data.CallContext?

        public var userContext: HoldCallResponseBody.Data.UserContext?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.callContext?.validate()
            try self.userContext?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.callContext != nil {
                map["CallContext"] = self.callContext?.toMap()
            }
            if self.userContext != nil {
                map["UserContext"] = self.userContext?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CallContext") && dict["CallContext"] != nil {
                var model = HoldCallResponseBody.Data.CallContext()
                model.fromMap(dict["CallContext"] as! [String: Any])
                self.callContext = model
            }
            if dict.keys.contains("UserContext") && dict["UserContext"] != nil {
                var model = HoldCallResponseBody.Data.UserContext()
                model.fromMap(dict["UserContext"] as! [String: Any])
                self.userContext = model
            }
        }
    }
    public var code: String?

    public var data: HoldCallResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var params: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.params != nil {
            map["Params"] = self.params!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = HoldCallResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Params") && dict["Params"] != nil {
            self.params = dict["Params"] as! [String]
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class HoldCallResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: HoldCallResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = HoldCallResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ImportAdminsRequest : Tea.TeaModel {
    public var instanceId: String?

    public var ramIdList: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.ramIdList != nil {
            map["RamIdList"] = self.ramIdList!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("RamIdList") && dict["RamIdList"] != nil {
            self.ramIdList = dict["RamIdList"] as! String
        }
    }
}

public class ImportAdminsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var extension_: String?

        public var instanceId: String?

        public var ramId: String?

        public var roleId: String?

        public var userId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.extension_ != nil {
                map["Extension"] = self.extension_!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.ramId != nil {
                map["RamId"] = self.ramId!
            }
            if self.roleId != nil {
                map["RoleId"] = self.roleId!
            }
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Extension") && dict["Extension"] != nil {
                self.extension_ = dict["Extension"] as! String
            }
            if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("RamId") && dict["RamId"] != nil {
                self.ramId = dict["RamId"] as! String
            }
            if dict.keys.contains("RoleId") && dict["RoleId"] != nil {
                self.roleId = dict["RoleId"] as! String
            }
            if dict.keys.contains("UserId") && dict["UserId"] != nil {
                self.userId = dict["UserId"] as! String
            }
        }
    }
    public var code: String?

    public var data: [ImportAdminsResponseBody.Data]?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var tmp : [ImportAdminsResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = ImportAdminsResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ImportAdminsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ImportAdminsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ImportAdminsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ImportCustomCallTaggingRequest : Tea.TeaModel {
    public var filePath: String?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.filePath != nil {
            map["FilePath"] = self.filePath!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FilePath") && dict["FilePath"] != nil {
            self.filePath = dict["FilePath"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
    }
}

public class ImportCustomCallTaggingResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var item: String?

        public var reason: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.item != nil {
                map["Item"] = self.item!
            }
            if self.reason != nil {
                map["Reason"] = self.reason!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Item") && dict["Item"] != nil {
                self.item = dict["Item"] as! String
            }
            if dict.keys.contains("Reason") && dict["Reason"] != nil {
                self.reason = dict["Reason"] as! String
            }
        }
    }
    public var code: String?

    public var data: [ImportCustomCallTaggingResponseBody.Data]?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var tmp : [ImportCustomCallTaggingResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = ImportCustomCallTaggingResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ImportCustomCallTaggingResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ImportCustomCallTaggingResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ImportCustomCallTaggingResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ImportDoNotCallNumbersRequest : Tea.TeaModel {
    public var filePath: String?

    public var instanceId: String?

    public var numberList: String?

    public var remark: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.filePath != nil {
            map["FilePath"] = self.filePath!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.numberList != nil {
            map["NumberList"] = self.numberList!
        }
        if self.remark != nil {
            map["Remark"] = self.remark!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FilePath") && dict["FilePath"] != nil {
            self.filePath = dict["FilePath"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("NumberList") && dict["NumberList"] != nil {
            self.numberList = dict["NumberList"] as! String
        }
        if dict.keys.contains("Remark") && dict["Remark"] != nil {
            self.remark = dict["Remark"] as! String
        }
    }
}

public class ImportDoNotCallNumbersResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ImportDoNotCallNumbersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ImportDoNotCallNumbersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ImportDoNotCallNumbersResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class InitiateAttendedTransferRequest : Tea.TeaModel {
    public var callPriority: Int32?

    public var deviceId: String?

    public var instanceId: String?

    public var jobId: String?

    public var strategyName: String?

    public var strategyParams: String?

    public var timeoutSeconds: Int32?

    public var transferee: String?

    public var transferor: String?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.callPriority != nil {
            map["CallPriority"] = self.callPriority!
        }
        if self.deviceId != nil {
            map["DeviceId"] = self.deviceId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.strategyName != nil {
            map["StrategyName"] = self.strategyName!
        }
        if self.strategyParams != nil {
            map["StrategyParams"] = self.strategyParams!
        }
        if self.timeoutSeconds != nil {
            map["TimeoutSeconds"] = self.timeoutSeconds!
        }
        if self.transferee != nil {
            map["Transferee"] = self.transferee!
        }
        if self.transferor != nil {
            map["Transferor"] = self.transferor!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CallPriority") && dict["CallPriority"] != nil {
            self.callPriority = dict["CallPriority"] as! Int32
        }
        if dict.keys.contains("DeviceId") && dict["DeviceId"] != nil {
            self.deviceId = dict["DeviceId"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("JobId") && dict["JobId"] != nil {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("StrategyName") && dict["StrategyName"] != nil {
            self.strategyName = dict["StrategyName"] as! String
        }
        if dict.keys.contains("StrategyParams") && dict["StrategyParams"] != nil {
            self.strategyParams = dict["StrategyParams"] as! String
        }
        if dict.keys.contains("TimeoutSeconds") && dict["TimeoutSeconds"] != nil {
            self.timeoutSeconds = dict["TimeoutSeconds"] as! Int32
        }
        if dict.keys.contains("Transferee") && dict["Transferee"] != nil {
            self.transferee = dict["Transferee"] as! String
        }
        if dict.keys.contains("Transferor") && dict["Transferor"] != nil {
            self.transferor = dict["Transferor"] as! String
        }
        if dict.keys.contains("UserId") && dict["UserId"] != nil {
            self.userId = dict["UserId"] as! String
        }
    }
}

public class InitiateAttendedTransferResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class CallContext : Tea.TeaModel {
            public class ChannelContexts : Tea.TeaModel {
                public var callType: String?

                public var channelFlags: String?

                public var channelId: String?

                public var channelState: String?

                public var destination: String?

                public var index: Int32?

                public var jobId: String?

                public var originator: String?

                public var releaseInitiator: String?

                public var releaseReason: String?

                public var skillGroupId: String?

                public var timestamp: Int64?

                public var userExtension: String?

                public var userId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.callType != nil {
                        map["CallType"] = self.callType!
                    }
                    if self.channelFlags != nil {
                        map["ChannelFlags"] = self.channelFlags!
                    }
                    if self.channelId != nil {
                        map["ChannelId"] = self.channelId!
                    }
                    if self.channelState != nil {
                        map["ChannelState"] = self.channelState!
                    }
                    if self.destination != nil {
                        map["Destination"] = self.destination!
                    }
                    if self.index != nil {
                        map["Index"] = self.index!
                    }
                    if self.jobId != nil {
                        map["JobId"] = self.jobId!
                    }
                    if self.originator != nil {
                        map["Originator"] = self.originator!
                    }
                    if self.releaseInitiator != nil {
                        map["ReleaseInitiator"] = self.releaseInitiator!
                    }
                    if self.releaseReason != nil {
                        map["ReleaseReason"] = self.releaseReason!
                    }
                    if self.skillGroupId != nil {
                        map["SkillGroupId"] = self.skillGroupId!
                    }
                    if self.timestamp != nil {
                        map["Timestamp"] = self.timestamp!
                    }
                    if self.userExtension != nil {
                        map["UserExtension"] = self.userExtension!
                    }
                    if self.userId != nil {
                        map["UserId"] = self.userId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("CallType") && dict["CallType"] != nil {
                        self.callType = dict["CallType"] as! String
                    }
                    if dict.keys.contains("ChannelFlags") && dict["ChannelFlags"] != nil {
                        self.channelFlags = dict["ChannelFlags"] as! String
                    }
                    if dict.keys.contains("ChannelId") && dict["ChannelId"] != nil {
                        self.channelId = dict["ChannelId"] as! String
                    }
                    if dict.keys.contains("ChannelState") && dict["ChannelState"] != nil {
                        self.channelState = dict["ChannelState"] as! String
                    }
                    if dict.keys.contains("Destination") && dict["Destination"] != nil {
                        self.destination = dict["Destination"] as! String
                    }
                    if dict.keys.contains("Index") && dict["Index"] != nil {
                        self.index = dict["Index"] as! Int32
                    }
                    if dict.keys.contains("JobId") && dict["JobId"] != nil {
                        self.jobId = dict["JobId"] as! String
                    }
                    if dict.keys.contains("Originator") && dict["Originator"] != nil {
                        self.originator = dict["Originator"] as! String
                    }
                    if dict.keys.contains("ReleaseInitiator") && dict["ReleaseInitiator"] != nil {
                        self.releaseInitiator = dict["ReleaseInitiator"] as! String
                    }
                    if dict.keys.contains("ReleaseReason") && dict["ReleaseReason"] != nil {
                        self.releaseReason = dict["ReleaseReason"] as! String
                    }
                    if dict.keys.contains("SkillGroupId") && dict["SkillGroupId"] != nil {
                        self.skillGroupId = dict["SkillGroupId"] as! String
                    }
                    if dict.keys.contains("Timestamp") && dict["Timestamp"] != nil {
                        self.timestamp = dict["Timestamp"] as! Int64
                    }
                    if dict.keys.contains("UserExtension") && dict["UserExtension"] != nil {
                        self.userExtension = dict["UserExtension"] as! String
                    }
                    if dict.keys.contains("UserId") && dict["UserId"] != nil {
                        self.userId = dict["UserId"] as! String
                    }
                }
            }
            public var callType: String?

            public var channelContexts: [InitiateAttendedTransferResponseBody.Data.CallContext.ChannelContexts]?

            public var instanceId: String?

            public var jobId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.callType != nil {
                    map["CallType"] = self.callType!
                }
                if self.channelContexts != nil {
                    var tmp : [Any] = []
                    for k in self.channelContexts! {
                        tmp.append(k.toMap())
                    }
                    map["ChannelContexts"] = tmp
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.jobId != nil {
                    map["JobId"] = self.jobId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CallType") && dict["CallType"] != nil {
                    self.callType = dict["CallType"] as! String
                }
                if dict.keys.contains("ChannelContexts") && dict["ChannelContexts"] != nil {
                    var tmp : [InitiateAttendedTransferResponseBody.Data.CallContext.ChannelContexts] = []
                    for v in dict["ChannelContexts"] as! [Any] {
                        var model = InitiateAttendedTransferResponseBody.Data.CallContext.ChannelContexts()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.channelContexts = tmp
                }
                if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("JobId") && dict["JobId"] != nil {
                    self.jobId = dict["JobId"] as! String
                }
            }
        }
        public class UserContext : Tea.TeaModel {
            public var breakCode: String?

            public var deviceId: String?

            public var extension_: String?

            public var heartbeat: Int64?

            public var instanceId: String?

            public var jobId: String?

            public var mobile: String?

            public var outboundScenario: Bool?

            public var reserved: Int64?

            public var signedSkillGroupIdList: [String]?

            public var userId: String?

            public var userState: String?

            public var workMode: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.breakCode != nil {
                    map["BreakCode"] = self.breakCode!
                }
                if self.deviceId != nil {
                    map["DeviceId"] = self.deviceId!
                }
                if self.extension_ != nil {
                    map["Extension"] = self.extension_!
                }
                if self.heartbeat != nil {
                    map["Heartbeat"] = self.heartbeat!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.jobId != nil {
                    map["JobId"] = self.jobId!
                }
                if self.mobile != nil {
                    map["Mobile"] = self.mobile!
                }
                if self.outboundScenario != nil {
                    map["OutboundScenario"] = self.outboundScenario!
                }
                if self.reserved != nil {
                    map["Reserved"] = self.reserved!
                }
                if self.signedSkillGroupIdList != nil {
                    map["SignedSkillGroupIdList"] = self.signedSkillGroupIdList!
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                if self.userState != nil {
                    map["UserState"] = self.userState!
                }
                if self.workMode != nil {
                    map["WorkMode"] = self.workMode!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BreakCode") && dict["BreakCode"] != nil {
                    self.breakCode = dict["BreakCode"] as! String
                }
                if dict.keys.contains("DeviceId") && dict["DeviceId"] != nil {
                    self.deviceId = dict["DeviceId"] as! String
                }
                if dict.keys.contains("Extension") && dict["Extension"] != nil {
                    self.extension_ = dict["Extension"] as! String
                }
                if dict.keys.contains("Heartbeat") && dict["Heartbeat"] != nil {
                    self.heartbeat = dict["Heartbeat"] as! Int64
                }
                if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("JobId") && dict["JobId"] != nil {
                    self.jobId = dict["JobId"] as! String
                }
                if dict.keys.contains("Mobile") && dict["Mobile"] != nil {
                    self.mobile = dict["Mobile"] as! String
                }
                if dict.keys.contains("OutboundScenario") && dict["OutboundScenario"] != nil {
                    self.outboundScenario = dict["OutboundScenario"] as! Bool
                }
                if dict.keys.contains("Reserved") && dict["Reserved"] != nil {
                    self.reserved = dict["Reserved"] as! Int64
                }
                if dict.keys.contains("SignedSkillGroupIdList") && dict["SignedSkillGroupIdList"] != nil {
                    self.signedSkillGroupIdList = dict["SignedSkillGroupIdList"] as! [String]
                }
                if dict.keys.contains("UserId") && dict["UserId"] != nil {
                    self.userId = dict["UserId"] as! String
                }
                if dict.keys.contains("UserState") && dict["UserState"] != nil {
                    self.userState = dict["UserState"] as! String
                }
                if dict.keys.contains("WorkMode") && dict["WorkMode"] != nil {
                    self.workMode = dict["WorkMode"] as! String
                }
            }
        }
        public var callContext: InitiateAttendedTransferResponseBody.Data.CallContext?

        public var contextId: Int64?

        public var userContext: InitiateAttendedTransferResponseBody.Data.UserContext?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.callContext?.validate()
            try self.userContext?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.callContext != nil {
                map["CallContext"] = self.callContext?.toMap()
            }
            if self.contextId != nil {
                map["ContextId"] = self.contextId!
            }
            if self.userContext != nil {
                map["UserContext"] = self.userContext?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CallContext") && dict["CallContext"] != nil {
                var model = InitiateAttendedTransferResponseBody.Data.CallContext()
                model.fromMap(dict["CallContext"] as! [String: Any])
                self.callContext = model
            }
            if dict.keys.contains("ContextId") && dict["ContextId"] != nil {
                self.contextId = dict["ContextId"] as! Int64
            }
            if dict.keys.contains("UserContext") && dict["UserContext"] != nil {
                var model = InitiateAttendedTransferResponseBody.Data.UserContext()
                model.fromMap(dict["UserContext"] as! [String: Any])
                self.userContext = model
            }
        }
    }
    public var code: String?

    public var data: InitiateAttendedTransferResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var params: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.params != nil {
            map["Params"] = self.params!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = InitiateAttendedTransferResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Params") && dict["Params"] != nil {
            self.params = dict["Params"] as! [String]
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class InitiateAttendedTransferResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: InitiateAttendedTransferResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = InitiateAttendedTransferResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class InterceptCallRequest : Tea.TeaModel {
    public var deviceId: String?

    public var instanceId: String?

    public var interceptedUserId: String?

    public var jobId: String?

    public var timeoutSeconds: Int32?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.deviceId != nil {
            map["DeviceId"] = self.deviceId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.interceptedUserId != nil {
            map["InterceptedUserId"] = self.interceptedUserId!
        }
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.timeoutSeconds != nil {
            map["TimeoutSeconds"] = self.timeoutSeconds!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DeviceId") && dict["DeviceId"] != nil {
            self.deviceId = dict["DeviceId"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("InterceptedUserId") && dict["InterceptedUserId"] != nil {
            self.interceptedUserId = dict["InterceptedUserId"] as! String
        }
        if dict.keys.contains("JobId") && dict["JobId"] != nil {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("TimeoutSeconds") && dict["TimeoutSeconds"] != nil {
            self.timeoutSeconds = dict["TimeoutSeconds"] as! Int32
        }
        if dict.keys.contains("UserId") && dict["UserId"] != nil {
            self.userId = dict["UserId"] as! String
        }
    }
}

public class InterceptCallResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class CallContext : Tea.TeaModel {
            public class ChannelContexts : Tea.TeaModel {
                public var callType: String?

                public var channelFlags: String?

                public var channelId: String?

                public var channelState: String?

                public var destination: String?

                public var index: Int32?

                public var jobId: String?

                public var originator: String?

                public var releaseInitiator: String?

                public var releaseReason: String?

                public var skillGroupId: String?

                public var timestamp: Int64?

                public var userExtension: String?

                public var userId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.callType != nil {
                        map["CallType"] = self.callType!
                    }
                    if self.channelFlags != nil {
                        map["ChannelFlags"] = self.channelFlags!
                    }
                    if self.channelId != nil {
                        map["ChannelId"] = self.channelId!
                    }
                    if self.channelState != nil {
                        map["ChannelState"] = self.channelState!
                    }
                    if self.destination != nil {
                        map["Destination"] = self.destination!
                    }
                    if self.index != nil {
                        map["Index"] = self.index!
                    }
                    if self.jobId != nil {
                        map["JobId"] = self.jobId!
                    }
                    if self.originator != nil {
                        map["Originator"] = self.originator!
                    }
                    if self.releaseInitiator != nil {
                        map["ReleaseInitiator"] = self.releaseInitiator!
                    }
                    if self.releaseReason != nil {
                        map["ReleaseReason"] = self.releaseReason!
                    }
                    if self.skillGroupId != nil {
                        map["SkillGroupId"] = self.skillGroupId!
                    }
                    if self.timestamp != nil {
                        map["Timestamp"] = self.timestamp!
                    }
                    if self.userExtension != nil {
                        map["UserExtension"] = self.userExtension!
                    }
                    if self.userId != nil {
                        map["UserId"] = self.userId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("CallType") && dict["CallType"] != nil {
                        self.callType = dict["CallType"] as! String
                    }
                    if dict.keys.contains("ChannelFlags") && dict["ChannelFlags"] != nil {
                        self.channelFlags = dict["ChannelFlags"] as! String
                    }
                    if dict.keys.contains("ChannelId") && dict["ChannelId"] != nil {
                        self.channelId = dict["ChannelId"] as! String
                    }
                    if dict.keys.contains("ChannelState") && dict["ChannelState"] != nil {
                        self.channelState = dict["ChannelState"] as! String
                    }
                    if dict.keys.contains("Destination") && dict["Destination"] != nil {
                        self.destination = dict["Destination"] as! String
                    }
                    if dict.keys.contains("Index") && dict["Index"] != nil {
                        self.index = dict["Index"] as! Int32
                    }
                    if dict.keys.contains("JobId") && dict["JobId"] != nil {
                        self.jobId = dict["JobId"] as! String
                    }
                    if dict.keys.contains("Originator") && dict["Originator"] != nil {
                        self.originator = dict["Originator"] as! String
                    }
                    if dict.keys.contains("ReleaseInitiator") && dict["ReleaseInitiator"] != nil {
                        self.releaseInitiator = dict["ReleaseInitiator"] as! String
                    }
                    if dict.keys.contains("ReleaseReason") && dict["ReleaseReason"] != nil {
                        self.releaseReason = dict["ReleaseReason"] as! String
                    }
                    if dict.keys.contains("SkillGroupId") && dict["SkillGroupId"] != nil {
                        self.skillGroupId = dict["SkillGroupId"] as! String
                    }
                    if dict.keys.contains("Timestamp") && dict["Timestamp"] != nil {
                        self.timestamp = dict["Timestamp"] as! Int64
                    }
                    if dict.keys.contains("UserExtension") && dict["UserExtension"] != nil {
                        self.userExtension = dict["UserExtension"] as! String
                    }
                    if dict.keys.contains("UserId") && dict["UserId"] != nil {
                        self.userId = dict["UserId"] as! String
                    }
                }
            }
            public var callType: String?

            public var channelContexts: [InterceptCallResponseBody.Data.CallContext.ChannelContexts]?

            public var instanceId: String?

            public var jobId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.callType != nil {
                    map["CallType"] = self.callType!
                }
                if self.channelContexts != nil {
                    var tmp : [Any] = []
                    for k in self.channelContexts! {
                        tmp.append(k.toMap())
                    }
                    map["ChannelContexts"] = tmp
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.jobId != nil {
                    map["JobId"] = self.jobId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CallType") && dict["CallType"] != nil {
                    self.callType = dict["CallType"] as! String
                }
                if dict.keys.contains("ChannelContexts") && dict["ChannelContexts"] != nil {
                    var tmp : [InterceptCallResponseBody.Data.CallContext.ChannelContexts] = []
                    for v in dict["ChannelContexts"] as! [Any] {
                        var model = InterceptCallResponseBody.Data.CallContext.ChannelContexts()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.channelContexts = tmp
                }
                if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("JobId") && dict["JobId"] != nil {
                    self.jobId = dict["JobId"] as! String
                }
            }
        }
        public class UserContext : Tea.TeaModel {
            public var breakCode: String?

            public var deviceId: String?

            public var extension_: String?

            public var heartbeat: Int64?

            public var instanceId: String?

            public var jobId: String?

            public var mobile: String?

            public var outboundScenario: Bool?

            public var reserved: Int64?

            public var signedSkillGroupIdList: [String]?

            public var userId: String?

            public var userState: String?

            public var workMode: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.breakCode != nil {
                    map["BreakCode"] = self.breakCode!
                }
                if self.deviceId != nil {
                    map["DeviceId"] = self.deviceId!
                }
                if self.extension_ != nil {
                    map["Extension"] = self.extension_!
                }
                if self.heartbeat != nil {
                    map["Heartbeat"] = self.heartbeat!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.jobId != nil {
                    map["JobId"] = self.jobId!
                }
                if self.mobile != nil {
                    map["Mobile"] = self.mobile!
                }
                if self.outboundScenario != nil {
                    map["OutboundScenario"] = self.outboundScenario!
                }
                if self.reserved != nil {
                    map["Reserved"] = self.reserved!
                }
                if self.signedSkillGroupIdList != nil {
                    map["SignedSkillGroupIdList"] = self.signedSkillGroupIdList!
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                if self.userState != nil {
                    map["UserState"] = self.userState!
                }
                if self.workMode != nil {
                    map["WorkMode"] = self.workMode!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BreakCode") && dict["BreakCode"] != nil {
                    self.breakCode = dict["BreakCode"] as! String
                }
                if dict.keys.contains("DeviceId") && dict["DeviceId"] != nil {
                    self.deviceId = dict["DeviceId"] as! String
                }
                if dict.keys.contains("Extension") && dict["Extension"] != nil {
                    self.extension_ = dict["Extension"] as! String
                }
                if dict.keys.contains("Heartbeat") && dict["Heartbeat"] != nil {
                    self.heartbeat = dict["Heartbeat"] as! Int64
                }
                if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("JobId") && dict["JobId"] != nil {
                    self.jobId = dict["JobId"] as! String
                }
                if dict.keys.contains("Mobile") && dict["Mobile"] != nil {
                    self.mobile = dict["Mobile"] as! String
                }
                if dict.keys.contains("OutboundScenario") && dict["OutboundScenario"] != nil {
                    self.outboundScenario = dict["OutboundScenario"] as! Bool
                }
                if dict.keys.contains("Reserved") && dict["Reserved"] != nil {
                    self.reserved = dict["Reserved"] as! Int64
                }
                if dict.keys.contains("SignedSkillGroupIdList") && dict["SignedSkillGroupIdList"] != nil {
                    self.signedSkillGroupIdList = dict["SignedSkillGroupIdList"] as! [String]
                }
                if dict.keys.contains("UserId") && dict["UserId"] != nil {
                    self.userId = dict["UserId"] as! String
                }
                if dict.keys.contains("UserState") && dict["UserState"] != nil {
                    self.userState = dict["UserState"] as! String
                }
                if dict.keys.contains("WorkMode") && dict["WorkMode"] != nil {
                    self.workMode = dict["WorkMode"] as! String
                }
            }
        }
        public var callContext: InterceptCallResponseBody.Data.CallContext?

        public var userContext: InterceptCallResponseBody.Data.UserContext?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.callContext?.validate()
            try self.userContext?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.callContext != nil {
                map["CallContext"] = self.callContext?.toMap()
            }
            if self.userContext != nil {
                map["UserContext"] = self.userContext?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CallContext") && dict["CallContext"] != nil {
                var model = InterceptCallResponseBody.Data.CallContext()
                model.fromMap(dict["CallContext"] as! [String: Any])
                self.callContext = model
            }
            if dict.keys.contains("UserContext") && dict["UserContext"] != nil {
                var model = InterceptCallResponseBody.Data.UserContext()
                model.fromMap(dict["UserContext"] as! [String: Any])
                self.userContext = model
            }
        }
    }
    public var code: String?

    public var data: InterceptCallResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var params: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.params != nil {
            map["Params"] = self.params!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = InterceptCallResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Params") && dict["Params"] != nil {
            self.params = dict["Params"] as! [String]
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class InterceptCallResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: InterceptCallResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = InterceptCallResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class LaunchAuthenticationRequest : Tea.TeaModel {
    public var contactFlowId: String?

    public var contactFlowVariables: String?

    public var deviceId: String?

    public var instanceId: String?

    public var jobId: String?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.contactFlowId != nil {
            map["ContactFlowId"] = self.contactFlowId!
        }
        if self.contactFlowVariables != nil {
            map["ContactFlowVariables"] = self.contactFlowVariables!
        }
        if self.deviceId != nil {
            map["DeviceId"] = self.deviceId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ContactFlowId") && dict["ContactFlowId"] != nil {
            self.contactFlowId = dict["ContactFlowId"] as! String
        }
        if dict.keys.contains("ContactFlowVariables") && dict["ContactFlowVariables"] != nil {
            self.contactFlowVariables = dict["ContactFlowVariables"] as! String
        }
        if dict.keys.contains("DeviceId") && dict["DeviceId"] != nil {
            self.deviceId = dict["DeviceId"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("JobId") && dict["JobId"] != nil {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("UserId") && dict["UserId"] != nil {
            self.userId = dict["UserId"] as! String
        }
    }
}

public class LaunchAuthenticationResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class CallContext : Tea.TeaModel {
            public class ChannelContexts : Tea.TeaModel {
                public var callType: String?

                public var channelFlags: String?

                public var channelId: String?

                public var channelState: String?

                public var destination: String?

                public var index: Int32?

                public var jobId: String?

                public var originator: String?

                public var releaseInitiator: String?

                public var releaseReason: String?

                public var skillGroupId: String?

                public var timestamp: Int64?

                public var userExtension: String?

                public var userId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.callType != nil {
                        map["CallType"] = self.callType!
                    }
                    if self.channelFlags != nil {
                        map["ChannelFlags"] = self.channelFlags!
                    }
                    if self.channelId != nil {
                        map["ChannelId"] = self.channelId!
                    }
                    if self.channelState != nil {
                        map["ChannelState"] = self.channelState!
                    }
                    if self.destination != nil {
                        map["Destination"] = self.destination!
                    }
                    if self.index != nil {
                        map["Index"] = self.index!
                    }
                    if self.jobId != nil {
                        map["JobId"] = self.jobId!
                    }
                    if self.originator != nil {
                        map["Originator"] = self.originator!
                    }
                    if self.releaseInitiator != nil {
                        map["ReleaseInitiator"] = self.releaseInitiator!
                    }
                    if self.releaseReason != nil {
                        map["ReleaseReason"] = self.releaseReason!
                    }
                    if self.skillGroupId != nil {
                        map["SkillGroupId"] = self.skillGroupId!
                    }
                    if self.timestamp != nil {
                        map["Timestamp"] = self.timestamp!
                    }
                    if self.userExtension != nil {
                        map["UserExtension"] = self.userExtension!
                    }
                    if self.userId != nil {
                        map["UserId"] = self.userId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("CallType") && dict["CallType"] != nil {
                        self.callType = dict["CallType"] as! String
                    }
                    if dict.keys.contains("ChannelFlags") && dict["ChannelFlags"] != nil {
                        self.channelFlags = dict["ChannelFlags"] as! String
                    }
                    if dict.keys.contains("ChannelId") && dict["ChannelId"] != nil {
                        self.channelId = dict["ChannelId"] as! String
                    }
                    if dict.keys.contains("ChannelState") && dict["ChannelState"] != nil {
                        self.channelState = dict["ChannelState"] as! String
                    }
                    if dict.keys.contains("Destination") && dict["Destination"] != nil {
                        self.destination = dict["Destination"] as! String
                    }
                    if dict.keys.contains("Index") && dict["Index"] != nil {
                        self.index = dict["Index"] as! Int32
                    }
                    if dict.keys.contains("JobId") && dict["JobId"] != nil {
                        self.jobId = dict["JobId"] as! String
                    }
                    if dict.keys.contains("Originator") && dict["Originator"] != nil {
                        self.originator = dict["Originator"] as! String
                    }
                    if dict.keys.contains("ReleaseInitiator") && dict["ReleaseInitiator"] != nil {
                        self.releaseInitiator = dict["ReleaseInitiator"] as! String
                    }
                    if dict.keys.contains("ReleaseReason") && dict["ReleaseReason"] != nil {
                        self.releaseReason = dict["ReleaseReason"] as! String
                    }
                    if dict.keys.contains("SkillGroupId") && dict["SkillGroupId"] != nil {
                        self.skillGroupId = dict["SkillGroupId"] as! String
                    }
                    if dict.keys.contains("Timestamp") && dict["Timestamp"] != nil {
                        self.timestamp = dict["Timestamp"] as! Int64
                    }
                    if dict.keys.contains("UserExtension") && dict["UserExtension"] != nil {
                        self.userExtension = dict["UserExtension"] as! String
                    }
                    if dict.keys.contains("UserId") && dict["UserId"] != nil {
                        self.userId = dict["UserId"] as! String
                    }
                }
            }
            public var callType: String?

            public var channelContexts: [LaunchAuthenticationResponseBody.Data.CallContext.ChannelContexts]?

            public var instanceId: String?

            public var jobId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.callType != nil {
                    map["CallType"] = self.callType!
                }
                if self.channelContexts != nil {
                    var tmp : [Any] = []
                    for k in self.channelContexts! {
                        tmp.append(k.toMap())
                    }
                    map["ChannelContexts"] = tmp
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.jobId != nil {
                    map["JobId"] = self.jobId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CallType") && dict["CallType"] != nil {
                    self.callType = dict["CallType"] as! String
                }
                if dict.keys.contains("ChannelContexts") && dict["ChannelContexts"] != nil {
                    var tmp : [LaunchAuthenticationResponseBody.Data.CallContext.ChannelContexts] = []
                    for v in dict["ChannelContexts"] as! [Any] {
                        var model = LaunchAuthenticationResponseBody.Data.CallContext.ChannelContexts()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.channelContexts = tmp
                }
                if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("JobId") && dict["JobId"] != nil {
                    self.jobId = dict["JobId"] as! String
                }
            }
        }
        public class UserContext : Tea.TeaModel {
            public var breakCode: String?

            public var deviceId: String?

            public var extension_: String?

            public var heartbeat: Int64?

            public var instanceId: String?

            public var jobId: String?

            public var mobile: String?

            public var outboundScenario: Bool?

            public var reserved: Int64?

            public var signedSkillGroupIdList: [String]?

            public var userId: String?

            public var userState: String?

            public var workMode: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.breakCode != nil {
                    map["BreakCode"] = self.breakCode!
                }
                if self.deviceId != nil {
                    map["DeviceId"] = self.deviceId!
                }
                if self.extension_ != nil {
                    map["Extension"] = self.extension_!
                }
                if self.heartbeat != nil {
                    map["Heartbeat"] = self.heartbeat!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.jobId != nil {
                    map["JobId"] = self.jobId!
                }
                if self.mobile != nil {
                    map["Mobile"] = self.mobile!
                }
                if self.outboundScenario != nil {
                    map["OutboundScenario"] = self.outboundScenario!
                }
                if self.reserved != nil {
                    map["Reserved"] = self.reserved!
                }
                if self.signedSkillGroupIdList != nil {
                    map["SignedSkillGroupIdList"] = self.signedSkillGroupIdList!
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                if self.userState != nil {
                    map["UserState"] = self.userState!
                }
                if self.workMode != nil {
                    map["WorkMode"] = self.workMode!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BreakCode") && dict["BreakCode"] != nil {
                    self.breakCode = dict["BreakCode"] as! String
                }
                if dict.keys.contains("DeviceId") && dict["DeviceId"] != nil {
                    self.deviceId = dict["DeviceId"] as! String
                }
                if dict.keys.contains("Extension") && dict["Extension"] != nil {
                    self.extension_ = dict["Extension"] as! String
                }
                if dict.keys.contains("Heartbeat") && dict["Heartbeat"] != nil {
                    self.heartbeat = dict["Heartbeat"] as! Int64
                }
                if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("JobId") && dict["JobId"] != nil {
                    self.jobId = dict["JobId"] as! String
                }
                if dict.keys.contains("Mobile") && dict["Mobile"] != nil {
                    self.mobile = dict["Mobile"] as! String
                }
                if dict.keys.contains("OutboundScenario") && dict["OutboundScenario"] != nil {
                    self.outboundScenario = dict["OutboundScenario"] as! Bool
                }
                if dict.keys.contains("Reserved") && dict["Reserved"] != nil {
                    self.reserved = dict["Reserved"] as! Int64
                }
                if dict.keys.contains("SignedSkillGroupIdList") && dict["SignedSkillGroupIdList"] != nil {
                    self.signedSkillGroupIdList = dict["SignedSkillGroupIdList"] as! [String]
                }
                if dict.keys.contains("UserId") && dict["UserId"] != nil {
                    self.userId = dict["UserId"] as! String
                }
                if dict.keys.contains("UserState") && dict["UserState"] != nil {
                    self.userState = dict["UserState"] as! String
                }
                if dict.keys.contains("WorkMode") && dict["WorkMode"] != nil {
                    self.workMode = dict["WorkMode"] as! String
                }
            }
        }
        public var callContext: LaunchAuthenticationResponseBody.Data.CallContext?

        public var userContext: LaunchAuthenticationResponseBody.Data.UserContext?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.callContext?.validate()
            try self.userContext?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.callContext != nil {
                map["CallContext"] = self.callContext?.toMap()
            }
            if self.userContext != nil {
                map["UserContext"] = self.userContext?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CallContext") && dict["CallContext"] != nil {
                var model = LaunchAuthenticationResponseBody.Data.CallContext()
                model.fromMap(dict["CallContext"] as! [String: Any])
                self.callContext = model
            }
            if dict.keys.contains("UserContext") && dict["UserContext"] != nil {
                var model = LaunchAuthenticationResponseBody.Data.UserContext()
                model.fromMap(dict["UserContext"] as! [String: Any])
                self.userContext = model
            }
        }
    }
    public var code: String?

    public var data: LaunchAuthenticationResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var params: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.params != nil {
            map["Params"] = self.params!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = LaunchAuthenticationResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Params") && dict["Params"] != nil {
            self.params = dict["Params"] as! [String]
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class LaunchAuthenticationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: LaunchAuthenticationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = LaunchAuthenticationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class LaunchSurveyRequest : Tea.TeaModel {
    public var contactFlowId: String?

    public var contactFlowVariables: String?

    public var deviceId: String?

    public var instanceId: String?

    public var jobId: String?

    public var smsMetadataId: String?

    public var surveyChannel: String?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.contactFlowId != nil {
            map["ContactFlowId"] = self.contactFlowId!
        }
        if self.contactFlowVariables != nil {
            map["ContactFlowVariables"] = self.contactFlowVariables!
        }
        if self.deviceId != nil {
            map["DeviceId"] = self.deviceId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.smsMetadataId != nil {
            map["SmsMetadataId"] = self.smsMetadataId!
        }
        if self.surveyChannel != nil {
            map["SurveyChannel"] = self.surveyChannel!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ContactFlowId") && dict["ContactFlowId"] != nil {
            self.contactFlowId = dict["ContactFlowId"] as! String
        }
        if dict.keys.contains("ContactFlowVariables") && dict["ContactFlowVariables"] != nil {
            self.contactFlowVariables = dict["ContactFlowVariables"] as! String
        }
        if dict.keys.contains("DeviceId") && dict["DeviceId"] != nil {
            self.deviceId = dict["DeviceId"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("JobId") && dict["JobId"] != nil {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("SmsMetadataId") && dict["SmsMetadataId"] != nil {
            self.smsMetadataId = dict["SmsMetadataId"] as! String
        }
        if dict.keys.contains("SurveyChannel") && dict["SurveyChannel"] != nil {
            self.surveyChannel = dict["SurveyChannel"] as! String
        }
        if dict.keys.contains("UserId") && dict["UserId"] != nil {
            self.userId = dict["UserId"] as! String
        }
    }
}

public class LaunchSurveyResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class CallContext : Tea.TeaModel {
            public class ChannelContexts : Tea.TeaModel {
                public var callType: String?

                public var channelFlags: String?

                public var channelId: String?

                public var channelState: String?

                public var destination: String?

                public var index: Int32?

                public var jobId: String?

                public var originator: String?

                public var releaseInitiator: String?

                public var releaseReason: String?

                public var skillGroupId: String?

                public var timestamp: Int64?

                public var userExtension: String?

                public var userId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.callType != nil {
                        map["CallType"] = self.callType!
                    }
                    if self.channelFlags != nil {
                        map["ChannelFlags"] = self.channelFlags!
                    }
                    if self.channelId != nil {
                        map["ChannelId"] = self.channelId!
                    }
                    if self.channelState != nil {
                        map["ChannelState"] = self.channelState!
                    }
                    if self.destination != nil {
                        map["Destination"] = self.destination!
                    }
                    if self.index != nil {
                        map["Index"] = self.index!
                    }
                    if self.jobId != nil {
                        map["JobId"] = self.jobId!
                    }
                    if self.originator != nil {
                        map["Originator"] = self.originator!
                    }
                    if self.releaseInitiator != nil {
                        map["ReleaseInitiator"] = self.releaseInitiator!
                    }
                    if self.releaseReason != nil {
                        map["ReleaseReason"] = self.releaseReason!
                    }
                    if self.skillGroupId != nil {
                        map["SkillGroupId"] = self.skillGroupId!
                    }
                    if self.timestamp != nil {
                        map["Timestamp"] = self.timestamp!
                    }
                    if self.userExtension != nil {
                        map["UserExtension"] = self.userExtension!
                    }
                    if self.userId != nil {
                        map["UserId"] = self.userId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("CallType") && dict["CallType"] != nil {
                        self.callType = dict["CallType"] as! String
                    }
                    if dict.keys.contains("ChannelFlags") && dict["ChannelFlags"] != nil {
                        self.channelFlags = dict["ChannelFlags"] as! String
                    }
                    if dict.keys.contains("ChannelId") && dict["ChannelId"] != nil {
                        self.channelId = dict["ChannelId"] as! String
                    }
                    if dict.keys.contains("ChannelState") && dict["ChannelState"] != nil {
                        self.channelState = dict["ChannelState"] as! String
                    }
                    if dict.keys.contains("Destination") && dict["Destination"] != nil {
                        self.destination = dict["Destination"] as! String
                    }
                    if dict.keys.contains("Index") && dict["Index"] != nil {
                        self.index = dict["Index"] as! Int32
                    }
                    if dict.keys.contains("JobId") && dict["JobId"] != nil {
                        self.jobId = dict["JobId"] as! String
                    }
                    if dict.keys.contains("Originator") && dict["Originator"] != nil {
                        self.originator = dict["Originator"] as! String
                    }
                    if dict.keys.contains("ReleaseInitiator") && dict["ReleaseInitiator"] != nil {
                        self.releaseInitiator = dict["ReleaseInitiator"] as! String
                    }
                    if dict.keys.contains("ReleaseReason") && dict["ReleaseReason"] != nil {
                        self.releaseReason = dict["ReleaseReason"] as! String
                    }
                    if dict.keys.contains("SkillGroupId") && dict["SkillGroupId"] != nil {
                        self.skillGroupId = dict["SkillGroupId"] as! String
                    }
                    if dict.keys.contains("Timestamp") && dict["Timestamp"] != nil {
                        self.timestamp = dict["Timestamp"] as! Int64
                    }
                    if dict.keys.contains("UserExtension") && dict["UserExtension"] != nil {
                        self.userExtension = dict["UserExtension"] as! String
                    }
                    if dict.keys.contains("UserId") && dict["UserId"] != nil {
                        self.userId = dict["UserId"] as! String
                    }
                }
            }
            public var callType: String?

            public var channelContexts: [LaunchSurveyResponseBody.Data.CallContext.ChannelContexts]?

            public var instanceId: String?

            public var jobId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.callType != nil {
                    map["CallType"] = self.callType!
                }
                if self.channelContexts != nil {
                    var tmp : [Any] = []
                    for k in self.channelContexts! {
                        tmp.append(k.toMap())
                    }
                    map["ChannelContexts"] = tmp
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.jobId != nil {
                    map["JobId"] = self.jobId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CallType") && dict["CallType"] != nil {
                    self.callType = dict["CallType"] as! String
                }
                if dict.keys.contains("ChannelContexts") && dict["ChannelContexts"] != nil {
                    var tmp : [LaunchSurveyResponseBody.Data.CallContext.ChannelContexts] = []
                    for v in dict["ChannelContexts"] as! [Any] {
                        var model = LaunchSurveyResponseBody.Data.CallContext.ChannelContexts()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.channelContexts = tmp
                }
                if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("JobId") && dict["JobId"] != nil {
                    self.jobId = dict["JobId"] as! String
                }
            }
        }
        public class UserContext : Tea.TeaModel {
            public var breakCode: String?

            public var deviceId: String?

            public var extension_: String?

            public var heartbeat: Int64?

            public var instanceId: String?

            public var jobId: String?

            public var mobile: String?

            public var outboundScenario: Bool?

            public var reserved: Int64?

            public var signedSkillGroupIdList: [String]?

            public var userId: String?

            public var userState: String?

            public var workMode: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.breakCode != nil {
                    map["BreakCode"] = self.breakCode!
                }
                if self.deviceId != nil {
                    map["DeviceId"] = self.deviceId!
                }
                if self.extension_ != nil {
                    map["Extension"] = self.extension_!
                }
                if self.heartbeat != nil {
                    map["Heartbeat"] = self.heartbeat!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.jobId != nil {
                    map["JobId"] = self.jobId!
                }
                if self.mobile != nil {
                    map["Mobile"] = self.mobile!
                }
                if self.outboundScenario != nil {
                    map["OutboundScenario"] = self.outboundScenario!
                }
                if self.reserved != nil {
                    map["Reserved"] = self.reserved!
                }
                if self.signedSkillGroupIdList != nil {
                    map["SignedSkillGroupIdList"] = self.signedSkillGroupIdList!
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                if self.userState != nil {
                    map["UserState"] = self.userState!
                }
                if self.workMode != nil {
                    map["WorkMode"] = self.workMode!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BreakCode") && dict["BreakCode"] != nil {
                    self.breakCode = dict["BreakCode"] as! String
                }
                if dict.keys.contains("DeviceId") && dict["DeviceId"] != nil {
                    self.deviceId = dict["DeviceId"] as! String
                }
                if dict.keys.contains("Extension") && dict["Extension"] != nil {
                    self.extension_ = dict["Extension"] as! String
                }
                if dict.keys.contains("Heartbeat") && dict["Heartbeat"] != nil {
                    self.heartbeat = dict["Heartbeat"] as! Int64
                }
                if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("JobId") && dict["JobId"] != nil {
                    self.jobId = dict["JobId"] as! String
                }
                if dict.keys.contains("Mobile") && dict["Mobile"] != nil {
                    self.mobile = dict["Mobile"] as! String
                }
                if dict.keys.contains("OutboundScenario") && dict["OutboundScenario"] != nil {
                    self.outboundScenario = dict["OutboundScenario"] as! Bool
                }
                if dict.keys.contains("Reserved") && dict["Reserved"] != nil {
                    self.reserved = dict["Reserved"] as! Int64
                }
                if dict.keys.contains("SignedSkillGroupIdList") && dict["SignedSkillGroupIdList"] != nil {
                    self.signedSkillGroupIdList = dict["SignedSkillGroupIdList"] as! [String]
                }
                if dict.keys.contains("UserId") && dict["UserId"] != nil {
                    self.userId = dict["UserId"] as! String
                }
                if dict.keys.contains("UserState") && dict["UserState"] != nil {
                    self.userState = dict["UserState"] as! String
                }
                if dict.keys.contains("WorkMode") && dict["WorkMode"] != nil {
                    self.workMode = dict["WorkMode"] as! String
                }
            }
        }
        public var callContext: LaunchSurveyResponseBody.Data.CallContext?

        public var contextId: Int64?

        public var userContext: LaunchSurveyResponseBody.Data.UserContext?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.callContext?.validate()
            try self.userContext?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.callContext != nil {
                map["CallContext"] = self.callContext?.toMap()
            }
            if self.contextId != nil {
                map["ContextId"] = self.contextId!
            }
            if self.userContext != nil {
                map["UserContext"] = self.userContext?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CallContext") && dict["CallContext"] != nil {
                var model = LaunchSurveyResponseBody.Data.CallContext()
                model.fromMap(dict["CallContext"] as! [String: Any])
                self.callContext = model
            }
            if dict.keys.contains("ContextId") && dict["ContextId"] != nil {
                self.contextId = dict["ContextId"] as! Int64
            }
            if dict.keys.contains("UserContext") && dict["UserContext"] != nil {
                var model = LaunchSurveyResponseBody.Data.UserContext()
                model.fromMap(dict["UserContext"] as! [String: Any])
                self.userContext = model
            }
        }
    }
    public var code: String?

    public var data: LaunchSurveyResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var params: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.params != nil {
            map["Params"] = self.params!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = LaunchSurveyResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Params") && dict["Params"] != nil {
            self.params = dict["Params"] as! [String]
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class LaunchSurveyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: LaunchSurveyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = LaunchSurveyResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListAgentStateLogsRequest : Tea.TeaModel {
    public var agentId: String?

    public var endTime: Int64?

    public var instanceId: String?

    public var startTime: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.agentId != nil {
            map["AgentId"] = self.agentId!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AgentId") && dict["AgentId"] != nil {
            self.agentId = dict["AgentId"] as! String
        }
        if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
            self.startTime = dict["StartTime"] as! Int64
        }
    }
}

public class ListAgentStateLogsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var duration: Int64?

        public var outboundScenario: Bool?

        public var startTime: Int64?

        public var state: String?

        public var stateCode: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.duration != nil {
                map["Duration"] = self.duration!
            }
            if self.outboundScenario != nil {
                map["OutboundScenario"] = self.outboundScenario!
            }
            if self.startTime != nil {
                map["StartTime"] = self.startTime!
            }
            if self.state != nil {
                map["State"] = self.state!
            }
            if self.stateCode != nil {
                map["StateCode"] = self.stateCode!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Duration") && dict["Duration"] != nil {
                self.duration = dict["Duration"] as! Int64
            }
            if dict.keys.contains("OutboundScenario") && dict["OutboundScenario"] != nil {
                self.outboundScenario = dict["OutboundScenario"] as! Bool
            }
            if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
                self.startTime = dict["StartTime"] as! Int64
            }
            if dict.keys.contains("State") && dict["State"] != nil {
                self.state = dict["State"] as! String
            }
            if dict.keys.contains("StateCode") && dict["StateCode"] != nil {
                self.stateCode = dict["StateCode"] as! String
            }
        }
    }
    public var code: String?

    public var data: [ListAgentStateLogsResponseBody.Data]?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var tmp : [ListAgentStateLogsResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = ListAgentStateLogsResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListAgentStateLogsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListAgentStateLogsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListAgentStateLogsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListAgentStatesRequest : Tea.TeaModel {
    public var agentIds: String?

    public var excludeOfflineUsers: Bool?

    public var instanceId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var skillGroupId: String?

    public var state: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.agentIds != nil {
            map["AgentIds"] = self.agentIds!
        }
        if self.excludeOfflineUsers != nil {
            map["ExcludeOfflineUsers"] = self.excludeOfflineUsers!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.skillGroupId != nil {
            map["SkillGroupId"] = self.skillGroupId!
        }
        if self.state != nil {
            map["State"] = self.state!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AgentIds") && dict["AgentIds"] != nil {
            self.agentIds = dict["AgentIds"] as! String
        }
        if dict.keys.contains("ExcludeOfflineUsers") && dict["ExcludeOfflineUsers"] != nil {
            self.excludeOfflineUsers = dict["ExcludeOfflineUsers"] as! Bool
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SkillGroupId") && dict["SkillGroupId"] != nil {
            self.skillGroupId = dict["SkillGroupId"] as! String
        }
        if dict.keys.contains("State") && dict["State"] != nil {
            self.state = dict["State"] as! String
        }
    }
}

public class ListAgentStatesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class List : Tea.TeaModel {
            public var agentId: String?

            public var agentName: String?

            public var breakCode: String?

            public var dn: String?

            public var instanceId: String?

            public var loginName: String?

            public var outboundScenario: Bool?

            public var state: String?

            public var stateDuration: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.agentId != nil {
                    map["AgentId"] = self.agentId!
                }
                if self.agentName != nil {
                    map["AgentName"] = self.agentName!
                }
                if self.breakCode != nil {
                    map["BreakCode"] = self.breakCode!
                }
                if self.dn != nil {
                    map["Dn"] = self.dn!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.loginName != nil {
                    map["LoginName"] = self.loginName!
                }
                if self.outboundScenario != nil {
                    map["OutboundScenario"] = self.outboundScenario!
                }
                if self.state != nil {
                    map["State"] = self.state!
                }
                if self.stateDuration != nil {
                    map["StateDuration"] = self.stateDuration!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AgentId") && dict["AgentId"] != nil {
                    self.agentId = dict["AgentId"] as! String
                }
                if dict.keys.contains("AgentName") && dict["AgentName"] != nil {
                    self.agentName = dict["AgentName"] as! String
                }
                if dict.keys.contains("BreakCode") && dict["BreakCode"] != nil {
                    self.breakCode = dict["BreakCode"] as! String
                }
                if dict.keys.contains("Dn") && dict["Dn"] != nil {
                    self.dn = dict["Dn"] as! String
                }
                if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("LoginName") && dict["LoginName"] != nil {
                    self.loginName = dict["LoginName"] as! String
                }
                if dict.keys.contains("OutboundScenario") && dict["OutboundScenario"] != nil {
                    self.outboundScenario = dict["OutboundScenario"] as! Bool
                }
                if dict.keys.contains("State") && dict["State"] != nil {
                    self.state = dict["State"] as! String
                }
                if dict.keys.contains("StateDuration") && dict["StateDuration"] != nil {
                    self.stateDuration = dict["StateDuration"] as! String
                }
            }
        }
        public var list: [ListAgentStatesResponseBody.Data.List]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.list != nil {
                var tmp : [Any] = []
                for k in self.list! {
                    tmp.append(k.toMap())
                }
                map["List"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("List") && dict["List"] != nil {
                var tmp : [ListAgentStatesResponseBody.Data.List] = []
                for v in dict["List"] as! [Any] {
                    var model = ListAgentStatesResponseBody.Data.List()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.list = tmp
            }
            if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var code: String?

    public var data: ListAgentStatesResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = ListAgentStatesResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListAgentStatesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListAgentStatesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListAgentStatesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListAgentSummaryReportsSinceMidnightRequest : Tea.TeaModel {
    public var agentIds: String?

    public var instanceId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var skillGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.agentIds != nil {
            map["AgentIds"] = self.agentIds!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.skillGroupId != nil {
            map["SkillGroupId"] = self.skillGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AgentIds") && dict["AgentIds"] != nil {
            self.agentIds = dict["AgentIds"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SkillGroupId") && dict["SkillGroupId"] != nil {
            self.skillGroupId = dict["SkillGroupId"] as! String
        }
    }
}

public class ListAgentSummaryReportsSinceMidnightResponseBody : Tea.TeaModel {
    public class PagedAgentSummaryReport : Tea.TeaModel {
        public class List : Tea.TeaModel {
            public class Inbound : Tea.TeaModel {
                public var averageRingTime: Int64?

                public var averageTalkTime: Int64?

                public var averageWorkTime: Int64?

                public var callsHandled: Int64?

                public var callsOffered: Int64?

                public var handleRate: Double?

                public var maxRingTime: Int64?

                public var maxTalkTime: Int64?

                public var maxWorkTime: Int64?

                public var satisfactionIndex: Double?

                public var satisfactionSurveysOffered: Int64?

                public var satisfactionSurveysResponded: Int64?

                public var serviceLevel20: Double?

                public var totalRingTime: Int64?

                public var totalTalkTime: Int64?

                public var totalWorkTime: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.averageRingTime != nil {
                        map["AverageRingTime"] = self.averageRingTime!
                    }
                    if self.averageTalkTime != nil {
                        map["AverageTalkTime"] = self.averageTalkTime!
                    }
                    if self.averageWorkTime != nil {
                        map["AverageWorkTime"] = self.averageWorkTime!
                    }
                    if self.callsHandled != nil {
                        map["CallsHandled"] = self.callsHandled!
                    }
                    if self.callsOffered != nil {
                        map["CallsOffered"] = self.callsOffered!
                    }
                    if self.handleRate != nil {
                        map["HandleRate"] = self.handleRate!
                    }
                    if self.maxRingTime != nil {
                        map["MaxRingTime"] = self.maxRingTime!
                    }
                    if self.maxTalkTime != nil {
                        map["MaxTalkTime"] = self.maxTalkTime!
                    }
                    if self.maxWorkTime != nil {
                        map["MaxWorkTime"] = self.maxWorkTime!
                    }
                    if self.satisfactionIndex != nil {
                        map["SatisfactionIndex"] = self.satisfactionIndex!
                    }
                    if self.satisfactionSurveysOffered != nil {
                        map["SatisfactionSurveysOffered"] = self.satisfactionSurveysOffered!
                    }
                    if self.satisfactionSurveysResponded != nil {
                        map["SatisfactionSurveysResponded"] = self.satisfactionSurveysResponded!
                    }
                    if self.serviceLevel20 != nil {
                        map["ServiceLevel20"] = self.serviceLevel20!
                    }
                    if self.totalRingTime != nil {
                        map["TotalRingTime"] = self.totalRingTime!
                    }
                    if self.totalTalkTime != nil {
                        map["TotalTalkTime"] = self.totalTalkTime!
                    }
                    if self.totalWorkTime != nil {
                        map["TotalWorkTime"] = self.totalWorkTime!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AverageRingTime") && dict["AverageRingTime"] != nil {
                        self.averageRingTime = dict["AverageRingTime"] as! Int64
                    }
                    if dict.keys.contains("AverageTalkTime") && dict["AverageTalkTime"] != nil {
                        self.averageTalkTime = dict["AverageTalkTime"] as! Int64
                    }
                    if dict.keys.contains("AverageWorkTime") && dict["AverageWorkTime"] != nil {
                        self.averageWorkTime = dict["AverageWorkTime"] as! Int64
                    }
                    if dict.keys.contains("CallsHandled") && dict["CallsHandled"] != nil {
                        self.callsHandled = dict["CallsHandled"] as! Int64
                    }
                    if dict.keys.contains("CallsOffered") && dict["CallsOffered"] != nil {
                        self.callsOffered = dict["CallsOffered"] as! Int64
                    }
                    if dict.keys.contains("HandleRate") && dict["HandleRate"] != nil {
                        self.handleRate = dict["HandleRate"] as! Double
                    }
                    if dict.keys.contains("MaxRingTime") && dict["MaxRingTime"] != nil {
                        self.maxRingTime = dict["MaxRingTime"] as! Int64
                    }
                    if dict.keys.contains("MaxTalkTime") && dict["MaxTalkTime"] != nil {
                        self.maxTalkTime = dict["MaxTalkTime"] as! Int64
                    }
                    if dict.keys.contains("MaxWorkTime") && dict["MaxWorkTime"] != nil {
                        self.maxWorkTime = dict["MaxWorkTime"] as! Int64
                    }
                    if dict.keys.contains("SatisfactionIndex") && dict["SatisfactionIndex"] != nil {
                        self.satisfactionIndex = dict["SatisfactionIndex"] as! Double
                    }
                    if dict.keys.contains("SatisfactionSurveysOffered") && dict["SatisfactionSurveysOffered"] != nil {
                        self.satisfactionSurveysOffered = dict["SatisfactionSurveysOffered"] as! Int64
                    }
                    if dict.keys.contains("SatisfactionSurveysResponded") && dict["SatisfactionSurveysResponded"] != nil {
                        self.satisfactionSurveysResponded = dict["SatisfactionSurveysResponded"] as! Int64
                    }
                    if dict.keys.contains("ServiceLevel20") && dict["ServiceLevel20"] != nil {
                        self.serviceLevel20 = dict["ServiceLevel20"] as! Double
                    }
                    if dict.keys.contains("TotalRingTime") && dict["TotalRingTime"] != nil {
                        self.totalRingTime = dict["TotalRingTime"] as! Int64
                    }
                    if dict.keys.contains("TotalTalkTime") && dict["TotalTalkTime"] != nil {
                        self.totalTalkTime = dict["TotalTalkTime"] as! Int64
                    }
                    if dict.keys.contains("TotalWorkTime") && dict["TotalWorkTime"] != nil {
                        self.totalWorkTime = dict["TotalWorkTime"] as! Int64
                    }
                }
            }
            public class Outbound : Tea.TeaModel {
                public var answerRate: Double?

                public var averageDialingTime: Int64?

                public var averageTalkTime: Int64?

                public var averageWorkTime: Int64?

                public var callsAnswered: Int64?

                public var callsDialed: Int64?

                public var maxDialingTime: Int64?

                public var maxTalkTime: Int64?

                public var maxWorkTime: String?

                public var satisfactionIndex: Double?

                public var satisfactionSurveysOffered: Int64?

                public var satisfactionSurveysResponded: Int64?

                public var totalDialingTime: Int64?

                public var totalTalkTime: Int64?

                public var totalWorkTime: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.answerRate != nil {
                        map["AnswerRate"] = self.answerRate!
                    }
                    if self.averageDialingTime != nil {
                        map["AverageDialingTime"] = self.averageDialingTime!
                    }
                    if self.averageTalkTime != nil {
                        map["AverageTalkTime"] = self.averageTalkTime!
                    }
                    if self.averageWorkTime != nil {
                        map["AverageWorkTime"] = self.averageWorkTime!
                    }
                    if self.callsAnswered != nil {
                        map["CallsAnswered"] = self.callsAnswered!
                    }
                    if self.callsDialed != nil {
                        map["CallsDialed"] = self.callsDialed!
                    }
                    if self.maxDialingTime != nil {
                        map["MaxDialingTime"] = self.maxDialingTime!
                    }
                    if self.maxTalkTime != nil {
                        map["MaxTalkTime"] = self.maxTalkTime!
                    }
                    if self.maxWorkTime != nil {
                        map["MaxWorkTime"] = self.maxWorkTime!
                    }
                    if self.satisfactionIndex != nil {
                        map["SatisfactionIndex"] = self.satisfactionIndex!
                    }
                    if self.satisfactionSurveysOffered != nil {
                        map["SatisfactionSurveysOffered"] = self.satisfactionSurveysOffered!
                    }
                    if self.satisfactionSurveysResponded != nil {
                        map["SatisfactionSurveysResponded"] = self.satisfactionSurveysResponded!
                    }
                    if self.totalDialingTime != nil {
                        map["TotalDialingTime"] = self.totalDialingTime!
                    }
                    if self.totalTalkTime != nil {
                        map["TotalTalkTime"] = self.totalTalkTime!
                    }
                    if self.totalWorkTime != nil {
                        map["TotalWorkTime"] = self.totalWorkTime!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AnswerRate") && dict["AnswerRate"] != nil {
                        self.answerRate = dict["AnswerRate"] as! Double
                    }
                    if dict.keys.contains("AverageDialingTime") && dict["AverageDialingTime"] != nil {
                        self.averageDialingTime = dict["AverageDialingTime"] as! Int64
                    }
                    if dict.keys.contains("AverageTalkTime") && dict["AverageTalkTime"] != nil {
                        self.averageTalkTime = dict["AverageTalkTime"] as! Int64
                    }
                    if dict.keys.contains("AverageWorkTime") && dict["AverageWorkTime"] != nil {
                        self.averageWorkTime = dict["AverageWorkTime"] as! Int64
                    }
                    if dict.keys.contains("CallsAnswered") && dict["CallsAnswered"] != nil {
                        self.callsAnswered = dict["CallsAnswered"] as! Int64
                    }
                    if dict.keys.contains("CallsDialed") && dict["CallsDialed"] != nil {
                        self.callsDialed = dict["CallsDialed"] as! Int64
                    }
                    if dict.keys.contains("MaxDialingTime") && dict["MaxDialingTime"] != nil {
                        self.maxDialingTime = dict["MaxDialingTime"] as! Int64
                    }
                    if dict.keys.contains("MaxTalkTime") && dict["MaxTalkTime"] != nil {
                        self.maxTalkTime = dict["MaxTalkTime"] as! Int64
                    }
                    if dict.keys.contains("MaxWorkTime") && dict["MaxWorkTime"] != nil {
                        self.maxWorkTime = dict["MaxWorkTime"] as! String
                    }
                    if dict.keys.contains("SatisfactionIndex") && dict["SatisfactionIndex"] != nil {
                        self.satisfactionIndex = dict["SatisfactionIndex"] as! Double
                    }
                    if dict.keys.contains("SatisfactionSurveysOffered") && dict["SatisfactionSurveysOffered"] != nil {
                        self.satisfactionSurveysOffered = dict["SatisfactionSurveysOffered"] as! Int64
                    }
                    if dict.keys.contains("SatisfactionSurveysResponded") && dict["SatisfactionSurveysResponded"] != nil {
                        self.satisfactionSurveysResponded = dict["SatisfactionSurveysResponded"] as! Int64
                    }
                    if dict.keys.contains("TotalDialingTime") && dict["TotalDialingTime"] != nil {
                        self.totalDialingTime = dict["TotalDialingTime"] as! Int64
                    }
                    if dict.keys.contains("TotalTalkTime") && dict["TotalTalkTime"] != nil {
                        self.totalTalkTime = dict["TotalTalkTime"] as! Int64
                    }
                    if dict.keys.contains("TotalWorkTime") && dict["TotalWorkTime"] != nil {
                        self.totalWorkTime = dict["TotalWorkTime"] as! Int64
                    }
                }
            }
            public class Overall : Tea.TeaModel {
                public var averageReadyTime: Int64?

                public var averageTalkTime: Int64?

                public var averageWorkTime: Int64?

                public var maxReadyTime: Int64?

                public var maxTalkTime: Int64?

                public var maxWorkTime: Int64?

                public var occupancyRate: Double?

                public var oneTransferCalls: Int64?

                public var satisfactionIndex: Double?

                public var satisfactionSurveysOffered: Int64?

                public var satisfactionSurveysResponded: Int64?

                public var totalBreakTime: Int64?

                public var totalCalls: Int64?

                public var totalLoggedInTime: Int64?

                public var totalReadyTime: Int64?

                public var totalTalkTime: Int64?

                public var totalWorkTime: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.averageReadyTime != nil {
                        map["AverageReadyTime"] = self.averageReadyTime!
                    }
                    if self.averageTalkTime != nil {
                        map["AverageTalkTime"] = self.averageTalkTime!
                    }
                    if self.averageWorkTime != nil {
                        map["AverageWorkTime"] = self.averageWorkTime!
                    }
                    if self.maxReadyTime != nil {
                        map["MaxReadyTime"] = self.maxReadyTime!
                    }
                    if self.maxTalkTime != nil {
                        map["MaxTalkTime"] = self.maxTalkTime!
                    }
                    if self.maxWorkTime != nil {
                        map["MaxWorkTime"] = self.maxWorkTime!
                    }
                    if self.occupancyRate != nil {
                        map["OccupancyRate"] = self.occupancyRate!
                    }
                    if self.oneTransferCalls != nil {
                        map["OneTransferCalls"] = self.oneTransferCalls!
                    }
                    if self.satisfactionIndex != nil {
                        map["SatisfactionIndex"] = self.satisfactionIndex!
                    }
                    if self.satisfactionSurveysOffered != nil {
                        map["SatisfactionSurveysOffered"] = self.satisfactionSurveysOffered!
                    }
                    if self.satisfactionSurveysResponded != nil {
                        map["SatisfactionSurveysResponded"] = self.satisfactionSurveysResponded!
                    }
                    if self.totalBreakTime != nil {
                        map["TotalBreakTime"] = self.totalBreakTime!
                    }
                    if self.totalCalls != nil {
                        map["TotalCalls"] = self.totalCalls!
                    }
                    if self.totalLoggedInTime != nil {
                        map["TotalLoggedInTime"] = self.totalLoggedInTime!
                    }
                    if self.totalReadyTime != nil {
                        map["TotalReadyTime"] = self.totalReadyTime!
                    }
                    if self.totalTalkTime != nil {
                        map["TotalTalkTime"] = self.totalTalkTime!
                    }
                    if self.totalWorkTime != nil {
                        map["TotalWorkTime"] = self.totalWorkTime!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AverageReadyTime") && dict["AverageReadyTime"] != nil {
                        self.averageReadyTime = dict["AverageReadyTime"] as! Int64
                    }
                    if dict.keys.contains("AverageTalkTime") && dict["AverageTalkTime"] != nil {
                        self.averageTalkTime = dict["AverageTalkTime"] as! Int64
                    }
                    if dict.keys.contains("AverageWorkTime") && dict["AverageWorkTime"] != nil {
                        self.averageWorkTime = dict["AverageWorkTime"] as! Int64
                    }
                    if dict.keys.contains("MaxReadyTime") && dict["MaxReadyTime"] != nil {
                        self.maxReadyTime = dict["MaxReadyTime"] as! Int64
                    }
                    if dict.keys.contains("MaxTalkTime") && dict["MaxTalkTime"] != nil {
                        self.maxTalkTime = dict["MaxTalkTime"] as! Int64
                    }
                    if dict.keys.contains("MaxWorkTime") && dict["MaxWorkTime"] != nil {
                        self.maxWorkTime = dict["MaxWorkTime"] as! Int64
                    }
                    if dict.keys.contains("OccupancyRate") && dict["OccupancyRate"] != nil {
                        self.occupancyRate = dict["OccupancyRate"] as! Double
                    }
                    if dict.keys.contains("OneTransferCalls") && dict["OneTransferCalls"] != nil {
                        self.oneTransferCalls = dict["OneTransferCalls"] as! Int64
                    }
                    if dict.keys.contains("SatisfactionIndex") && dict["SatisfactionIndex"] != nil {
                        self.satisfactionIndex = dict["SatisfactionIndex"] as! Double
                    }
                    if dict.keys.contains("SatisfactionSurveysOffered") && dict["SatisfactionSurveysOffered"] != nil {
                        self.satisfactionSurveysOffered = dict["SatisfactionSurveysOffered"] as! Int64
                    }
                    if dict.keys.contains("SatisfactionSurveysResponded") && dict["SatisfactionSurveysResponded"] != nil {
                        self.satisfactionSurveysResponded = dict["SatisfactionSurveysResponded"] as! Int64
                    }
                    if dict.keys.contains("TotalBreakTime") && dict["TotalBreakTime"] != nil {
                        self.totalBreakTime = dict["TotalBreakTime"] as! Int64
                    }
                    if dict.keys.contains("TotalCalls") && dict["TotalCalls"] != nil {
                        self.totalCalls = dict["TotalCalls"] as! Int64
                    }
                    if dict.keys.contains("TotalLoggedInTime") && dict["TotalLoggedInTime"] != nil {
                        self.totalLoggedInTime = dict["TotalLoggedInTime"] as! Int64
                    }
                    if dict.keys.contains("TotalReadyTime") && dict["TotalReadyTime"] != nil {
                        self.totalReadyTime = dict["TotalReadyTime"] as! Int64
                    }
                    if dict.keys.contains("TotalTalkTime") && dict["TotalTalkTime"] != nil {
                        self.totalTalkTime = dict["TotalTalkTime"] as! Int64
                    }
                    if dict.keys.contains("TotalWorkTime") && dict["TotalWorkTime"] != nil {
                        self.totalWorkTime = dict["TotalWorkTime"] as! Int64
                    }
                }
            }
            public var agentId: String?

            public var agentName: String?

            public var inbound: ListAgentSummaryReportsSinceMidnightResponseBody.PagedAgentSummaryReport.List.Inbound?

            public var instanceId: String?

            public var loginName: String?

            public var outbound: ListAgentSummaryReportsSinceMidnightResponseBody.PagedAgentSummaryReport.List.Outbound?

            public var overall: ListAgentSummaryReportsSinceMidnightResponseBody.PagedAgentSummaryReport.List.Overall?

            public var skillGroupIds: String?

            public var skillGroupNames: String?

            public var timestamp: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.inbound?.validate()
                try self.outbound?.validate()
                try self.overall?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.agentId != nil {
                    map["AgentId"] = self.agentId!
                }
                if self.agentName != nil {
                    map["AgentName"] = self.agentName!
                }
                if self.inbound != nil {
                    map["Inbound"] = self.inbound?.toMap()
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.loginName != nil {
                    map["LoginName"] = self.loginName!
                }
                if self.outbound != nil {
                    map["Outbound"] = self.outbound?.toMap()
                }
                if self.overall != nil {
                    map["Overall"] = self.overall?.toMap()
                }
                if self.skillGroupIds != nil {
                    map["SkillGroupIds"] = self.skillGroupIds!
                }
                if self.skillGroupNames != nil {
                    map["SkillGroupNames"] = self.skillGroupNames!
                }
                if self.timestamp != nil {
                    map["Timestamp"] = self.timestamp!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AgentId") && dict["AgentId"] != nil {
                    self.agentId = dict["AgentId"] as! String
                }
                if dict.keys.contains("AgentName") && dict["AgentName"] != nil {
                    self.agentName = dict["AgentName"] as! String
                }
                if dict.keys.contains("Inbound") && dict["Inbound"] != nil {
                    var model = ListAgentSummaryReportsSinceMidnightResponseBody.PagedAgentSummaryReport.List.Inbound()
                    model.fromMap(dict["Inbound"] as! [String: Any])
                    self.inbound = model
                }
                if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("LoginName") && dict["LoginName"] != nil {
                    self.loginName = dict["LoginName"] as! String
                }
                if dict.keys.contains("Outbound") && dict["Outbound"] != nil {
                    var model = ListAgentSummaryReportsSinceMidnightResponseBody.PagedAgentSummaryReport.List.Outbound()
                    model.fromMap(dict["Outbound"] as! [String: Any])
                    self.outbound = model
                }
                if dict.keys.contains("Overall") && dict["Overall"] != nil {
                    var model = ListAgentSummaryReportsSinceMidnightResponseBody.PagedAgentSummaryReport.List.Overall()
                    model.fromMap(dict["Overall"] as! [String: Any])
                    self.overall = model
                }
                if dict.keys.contains("SkillGroupIds") && dict["SkillGroupIds"] != nil {
                    self.skillGroupIds = dict["SkillGroupIds"] as! String
                }
                if dict.keys.contains("SkillGroupNames") && dict["SkillGroupNames"] != nil {
                    self.skillGroupNames = dict["SkillGroupNames"] as! String
                }
                if dict.keys.contains("Timestamp") && dict["Timestamp"] != nil {
                    self.timestamp = dict["Timestamp"] as! String
                }
            }
        }
        public var list: [ListAgentSummaryReportsSinceMidnightResponseBody.PagedAgentSummaryReport.List]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.list != nil {
                var tmp : [Any] = []
                for k in self.list! {
                    tmp.append(k.toMap())
                }
                map["List"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("List") && dict["List"] != nil {
                var tmp : [ListAgentSummaryReportsSinceMidnightResponseBody.PagedAgentSummaryReport.List] = []
                for v in dict["List"] as! [Any] {
                    var model = ListAgentSummaryReportsSinceMidnightResponseBody.PagedAgentSummaryReport.List()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.list = tmp
            }
            if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var code: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var pagedAgentSummaryReport: ListAgentSummaryReportsSinceMidnightResponseBody.PagedAgentSummaryReport?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pagedAgentSummaryReport?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.pagedAgentSummaryReport != nil {
            map["PagedAgentSummaryReport"] = self.pagedAgentSummaryReport?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("PagedAgentSummaryReport") && dict["PagedAgentSummaryReport"] != nil {
            var model = ListAgentSummaryReportsSinceMidnightResponseBody.PagedAgentSummaryReport()
            model.fromMap(dict["PagedAgentSummaryReport"] as! [String: Any])
            self.pagedAgentSummaryReport = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListAgentSummaryReportsSinceMidnightResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListAgentSummaryReportsSinceMidnightResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListAgentSummaryReportsSinceMidnightResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListAttemptsRequest : Tea.TeaModel {
    public var agentId: String?

    public var attemptId: String?

    public var callee: String?

    public var caller: String?

    public var campaignId: String?

    public var caseId: String?

    public var contactId: String?

    public var criteria: String?

    public var endTime: Int64?

    public var instanceId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var queueId: String?

    public var startTime: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.agentId != nil {
            map["AgentId"] = self.agentId!
        }
        if self.attemptId != nil {
            map["AttemptId"] = self.attemptId!
        }
        if self.callee != nil {
            map["Callee"] = self.callee!
        }
        if self.caller != nil {
            map["Caller"] = self.caller!
        }
        if self.campaignId != nil {
            map["CampaignId"] = self.campaignId!
        }
        if self.caseId != nil {
            map["CaseId"] = self.caseId!
        }
        if self.contactId != nil {
            map["ContactId"] = self.contactId!
        }
        if self.criteria != nil {
            map["Criteria"] = self.criteria!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.queueId != nil {
            map["QueueId"] = self.queueId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AgentId") && dict["AgentId"] != nil {
            self.agentId = dict["AgentId"] as! String
        }
        if dict.keys.contains("AttemptId") && dict["AttemptId"] != nil {
            self.attemptId = dict["AttemptId"] as! String
        }
        if dict.keys.contains("Callee") && dict["Callee"] != nil {
            self.callee = dict["Callee"] as! String
        }
        if dict.keys.contains("Caller") && dict["Caller"] != nil {
            self.caller = dict["Caller"] as! String
        }
        if dict.keys.contains("CampaignId") && dict["CampaignId"] != nil {
            self.campaignId = dict["CampaignId"] as! String
        }
        if dict.keys.contains("CaseId") && dict["CaseId"] != nil {
            self.caseId = dict["CaseId"] as! String
        }
        if dict.keys.contains("ContactId") && dict["ContactId"] != nil {
            self.contactId = dict["ContactId"] as! String
        }
        if dict.keys.contains("Criteria") && dict["Criteria"] != nil {
            self.criteria = dict["Criteria"] as! String
        }
        if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("QueueId") && dict["QueueId"] != nil {
            self.queueId = dict["QueueId"] as! String
        }
        if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
            self.startTime = dict["StartTime"] as! Int64
        }
    }
}

public class ListAttemptsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class List : Tea.TeaModel {
            public var agentEstablishedTime: Int64?

            public var agentId: String?

            public var agentRingDuration: Int64?

            public var assignAgentTime: Int64?

            public var attemptId: String?

            public var callee: String?

            public var caller: String?

            public var campaignId: String?

            public var caseId: String?

            public var contactId: String?

            public var customerEstablishedTime: Int64?

            public var customerReleasedTime: Int64?

            public var dialDuration: Int64?

            public var dialTime: Int64?

            public var enqueueTime: Int64?

            public var enterIvrTime: Int64?

            public var instanceId: String?

            public var ivrDuration: Int64?

            public var queueDuration: Int64?

            public var queueId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.agentEstablishedTime != nil {
                    map["AgentEstablishedTime"] = self.agentEstablishedTime!
                }
                if self.agentId != nil {
                    map["AgentId"] = self.agentId!
                }
                if self.agentRingDuration != nil {
                    map["AgentRingDuration"] = self.agentRingDuration!
                }
                if self.assignAgentTime != nil {
                    map["AssignAgentTime"] = self.assignAgentTime!
                }
                if self.attemptId != nil {
                    map["AttemptId"] = self.attemptId!
                }
                if self.callee != nil {
                    map["Callee"] = self.callee!
                }
                if self.caller != nil {
                    map["Caller"] = self.caller!
                }
                if self.campaignId != nil {
                    map["CampaignId"] = self.campaignId!
                }
                if self.caseId != nil {
                    map["CaseId"] = self.caseId!
                }
                if self.contactId != nil {
                    map["ContactId"] = self.contactId!
                }
                if self.customerEstablishedTime != nil {
                    map["CustomerEstablishedTime"] = self.customerEstablishedTime!
                }
                if self.customerReleasedTime != nil {
                    map["CustomerReleasedTime"] = self.customerReleasedTime!
                }
                if self.dialDuration != nil {
                    map["DialDuration"] = self.dialDuration!
                }
                if self.dialTime != nil {
                    map["DialTime"] = self.dialTime!
                }
                if self.enqueueTime != nil {
                    map["EnqueueTime"] = self.enqueueTime!
                }
                if self.enterIvrTime != nil {
                    map["EnterIvrTime"] = self.enterIvrTime!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.ivrDuration != nil {
                    map["IvrDuration"] = self.ivrDuration!
                }
                if self.queueDuration != nil {
                    map["QueueDuration"] = self.queueDuration!
                }
                if self.queueId != nil {
                    map["QueueId"] = self.queueId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AgentEstablishedTime") && dict["AgentEstablishedTime"] != nil {
                    self.agentEstablishedTime = dict["AgentEstablishedTime"] as! Int64
                }
                if dict.keys.contains("AgentId") && dict["AgentId"] != nil {
                    self.agentId = dict["AgentId"] as! String
                }
                if dict.keys.contains("AgentRingDuration") && dict["AgentRingDuration"] != nil {
                    self.agentRingDuration = dict["AgentRingDuration"] as! Int64
                }
                if dict.keys.contains("AssignAgentTime") && dict["AssignAgentTime"] != nil {
                    self.assignAgentTime = dict["AssignAgentTime"] as! Int64
                }
                if dict.keys.contains("AttemptId") && dict["AttemptId"] != nil {
                    self.attemptId = dict["AttemptId"] as! String
                }
                if dict.keys.contains("Callee") && dict["Callee"] != nil {
                    self.callee = dict["Callee"] as! String
                }
                if dict.keys.contains("Caller") && dict["Caller"] != nil {
                    self.caller = dict["Caller"] as! String
                }
                if dict.keys.contains("CampaignId") && dict["CampaignId"] != nil {
                    self.campaignId = dict["CampaignId"] as! String
                }
                if dict.keys.contains("CaseId") && dict["CaseId"] != nil {
                    self.caseId = dict["CaseId"] as! String
                }
                if dict.keys.contains("ContactId") && dict["ContactId"] != nil {
                    self.contactId = dict["ContactId"] as! String
                }
                if dict.keys.contains("CustomerEstablishedTime") && dict["CustomerEstablishedTime"] != nil {
                    self.customerEstablishedTime = dict["CustomerEstablishedTime"] as! Int64
                }
                if dict.keys.contains("CustomerReleasedTime") && dict["CustomerReleasedTime"] != nil {
                    self.customerReleasedTime = dict["CustomerReleasedTime"] as! Int64
                }
                if dict.keys.contains("DialDuration") && dict["DialDuration"] != nil {
                    self.dialDuration = dict["DialDuration"] as! Int64
                }
                if dict.keys.contains("DialTime") && dict["DialTime"] != nil {
                    self.dialTime = dict["DialTime"] as! Int64
                }
                if dict.keys.contains("EnqueueTime") && dict["EnqueueTime"] != nil {
                    self.enqueueTime = dict["EnqueueTime"] as! Int64
                }
                if dict.keys.contains("EnterIvrTime") && dict["EnterIvrTime"] != nil {
                    self.enterIvrTime = dict["EnterIvrTime"] as! Int64
                }
                if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("IvrDuration") && dict["IvrDuration"] != nil {
                    self.ivrDuration = dict["IvrDuration"] as! Int64
                }
                if dict.keys.contains("QueueDuration") && dict["QueueDuration"] != nil {
                    self.queueDuration = dict["QueueDuration"] as! Int64
                }
                if dict.keys.contains("QueueId") && dict["QueueId"] != nil {
                    self.queueId = dict["QueueId"] as! String
                }
            }
        }
        public var list: [ListAttemptsResponseBody.Data.List]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.list != nil {
                var tmp : [Any] = []
                for k in self.list! {
                    tmp.append(k.toMap())
                }
                map["List"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("List") && dict["List"] != nil {
                var tmp : [ListAttemptsResponseBody.Data.List] = []
                for v in dict["List"] as! [Any] {
                    var model = ListAttemptsResponseBody.Data.List()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.list = tmp
            }
            if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var code: String?

    public var data: ListAttemptsResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = ListAttemptsResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListAttemptsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListAttemptsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListAttemptsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListAudioFilesRequest : Tea.TeaModel {
    public var instanceId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
    }
}

public class ListAudioFilesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class List : Tea.TeaModel {
            public var audioFileName: String?

            public var audioResourceId: String?

            public var createdTime: String?

            public var instanceId: String?

            public var name: String?

            public var ossFileKey: String?

            public var updatedTime: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.audioFileName != nil {
                    map["AudioFileName"] = self.audioFileName!
                }
                if self.audioResourceId != nil {
                    map["AudioResourceId"] = self.audioResourceId!
                }
                if self.createdTime != nil {
                    map["CreatedTime"] = self.createdTime!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.ossFileKey != nil {
                    map["OssFileKey"] = self.ossFileKey!
                }
                if self.updatedTime != nil {
                    map["UpdatedTime"] = self.updatedTime!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AudioFileName") && dict["AudioFileName"] != nil {
                    self.audioFileName = dict["AudioFileName"] as! String
                }
                if dict.keys.contains("AudioResourceId") && dict["AudioResourceId"] != nil {
                    self.audioResourceId = dict["AudioResourceId"] as! String
                }
                if dict.keys.contains("CreatedTime") && dict["CreatedTime"] != nil {
                    self.createdTime = dict["CreatedTime"] as! String
                }
                if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("Name") && dict["Name"] != nil {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("OssFileKey") && dict["OssFileKey"] != nil {
                    self.ossFileKey = dict["OssFileKey"] as! String
                }
                if dict.keys.contains("UpdatedTime") && dict["UpdatedTime"] != nil {
                    self.updatedTime = dict["UpdatedTime"] as! String
                }
            }
        }
        public var list: [ListAudioFilesResponseBody.Data.List]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.list != nil {
                var tmp : [Any] = []
                for k in self.list! {
                    tmp.append(k.toMap())
                }
                map["List"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("List") && dict["List"] != nil {
                var tmp : [ListAudioFilesResponseBody.Data.List] = []
                for v in dict["List"] as! [Any] {
                    var model = ListAudioFilesResponseBody.Data.List()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.list = tmp
            }
            if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var code: String?

    public var data: ListAudioFilesResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = ListAudioFilesResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListAudioFilesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListAudioFilesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListAudioFilesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListBriefSkillGroupsRequest : Tea.TeaModel {
    public var instanceId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var searchPattern: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.searchPattern != nil {
            map["SearchPattern"] = self.searchPattern!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SearchPattern") && dict["SearchPattern"] != nil {
            self.searchPattern = dict["SearchPattern"] as! String
        }
    }
}

public class ListBriefSkillGroupsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class List : Tea.TeaModel {
            public var description_: String?

            public var displayName: String?

            public var instanceId: String?

            public var phoneNumberCount: Int32?

            public var skillGroupId: String?

            public var skillGroupName: String?

            public var userCount: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.displayName != nil {
                    map["DisplayName"] = self.displayName!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.phoneNumberCount != nil {
                    map["PhoneNumberCount"] = self.phoneNumberCount!
                }
                if self.skillGroupId != nil {
                    map["SkillGroupId"] = self.skillGroupId!
                }
                if self.skillGroupName != nil {
                    map["SkillGroupName"] = self.skillGroupName!
                }
                if self.userCount != nil {
                    map["UserCount"] = self.userCount!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Description") && dict["Description"] != nil {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("DisplayName") && dict["DisplayName"] != nil {
                    self.displayName = dict["DisplayName"] as! String
                }
                if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("PhoneNumberCount") && dict["PhoneNumberCount"] != nil {
                    self.phoneNumberCount = dict["PhoneNumberCount"] as! Int32
                }
                if dict.keys.contains("SkillGroupId") && dict["SkillGroupId"] != nil {
                    self.skillGroupId = dict["SkillGroupId"] as! String
                }
                if dict.keys.contains("SkillGroupName") && dict["SkillGroupName"] != nil {
                    self.skillGroupName = dict["SkillGroupName"] as! String
                }
                if dict.keys.contains("UserCount") && dict["UserCount"] != nil {
                    self.userCount = dict["UserCount"] as! Int32
                }
            }
        }
        public var list: [ListBriefSkillGroupsResponseBody.Data.List]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.list != nil {
                var tmp : [Any] = []
                for k in self.list! {
                    tmp.append(k.toMap())
                }
                map["List"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("List") && dict["List"] != nil {
                var tmp : [ListBriefSkillGroupsResponseBody.Data.List] = []
                for v in dict["List"] as! [Any] {
                    var model = ListBriefSkillGroupsResponseBody.Data.List()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.list = tmp
            }
            if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var code: String?

    public var data: ListBriefSkillGroupsResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = ListBriefSkillGroupsResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListBriefSkillGroupsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListBriefSkillGroupsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListBriefSkillGroupsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListCallDetailRecordsRequest : Tea.TeaModel {
    public var agentId: String?

    public var calledNumber: String?

    public var callingNumber: String?

    public var contactDisposition: String?

    public var contactDispositionList: String?

    public var contactId: String?

    public var contactType: String?

    public var contactTypeList: String?

    public var criteria: String?

    public var earlyMediaStateList: String?

    public var endTime: Int64?

    public var instanceId: String?

    public var orderByField: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var satisfactionDescriptionList: String?

    public var satisfactionList: String?

    public var satisfactionSurveyChannel: String?

    public var skillGroupId: String?

    public var sortOrder: String?

    public var startTime: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.agentId != nil {
            map["AgentId"] = self.agentId!
        }
        if self.calledNumber != nil {
            map["CalledNumber"] = self.calledNumber!
        }
        if self.callingNumber != nil {
            map["CallingNumber"] = self.callingNumber!
        }
        if self.contactDisposition != nil {
            map["ContactDisposition"] = self.contactDisposition!
        }
        if self.contactDispositionList != nil {
            map["ContactDispositionList"] = self.contactDispositionList!
        }
        if self.contactId != nil {
            map["ContactId"] = self.contactId!
        }
        if self.contactType != nil {
            map["ContactType"] = self.contactType!
        }
        if self.contactTypeList != nil {
            map["ContactTypeList"] = self.contactTypeList!
        }
        if self.criteria != nil {
            map["Criteria"] = self.criteria!
        }
        if self.earlyMediaStateList != nil {
            map["EarlyMediaStateList"] = self.earlyMediaStateList!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.orderByField != nil {
            map["OrderByField"] = self.orderByField!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.satisfactionDescriptionList != nil {
            map["SatisfactionDescriptionList"] = self.satisfactionDescriptionList!
        }
        if self.satisfactionList != nil {
            map["SatisfactionList"] = self.satisfactionList!
        }
        if self.satisfactionSurveyChannel != nil {
            map["SatisfactionSurveyChannel"] = self.satisfactionSurveyChannel!
        }
        if self.skillGroupId != nil {
            map["SkillGroupId"] = self.skillGroupId!
        }
        if self.sortOrder != nil {
            map["SortOrder"] = self.sortOrder!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AgentId") && dict["AgentId"] != nil {
            self.agentId = dict["AgentId"] as! String
        }
        if dict.keys.contains("CalledNumber") && dict["CalledNumber"] != nil {
            self.calledNumber = dict["CalledNumber"] as! String
        }
        if dict.keys.contains("CallingNumber") && dict["CallingNumber"] != nil {
            self.callingNumber = dict["CallingNumber"] as! String
        }
        if dict.keys.contains("ContactDisposition") && dict["ContactDisposition"] != nil {
            self.contactDisposition = dict["ContactDisposition"] as! String
        }
        if dict.keys.contains("ContactDispositionList") && dict["ContactDispositionList"] != nil {
            self.contactDispositionList = dict["ContactDispositionList"] as! String
        }
        if dict.keys.contains("ContactId") && dict["ContactId"] != nil {
            self.contactId = dict["ContactId"] as! String
        }
        if dict.keys.contains("ContactType") && dict["ContactType"] != nil {
            self.contactType = dict["ContactType"] as! String
        }
        if dict.keys.contains("ContactTypeList") && dict["ContactTypeList"] != nil {
            self.contactTypeList = dict["ContactTypeList"] as! String
        }
        if dict.keys.contains("Criteria") && dict["Criteria"] != nil {
            self.criteria = dict["Criteria"] as! String
        }
        if dict.keys.contains("EarlyMediaStateList") && dict["EarlyMediaStateList"] != nil {
            self.earlyMediaStateList = dict["EarlyMediaStateList"] as! String
        }
        if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("OrderByField") && dict["OrderByField"] != nil {
            self.orderByField = dict["OrderByField"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SatisfactionDescriptionList") && dict["SatisfactionDescriptionList"] != nil {
            self.satisfactionDescriptionList = dict["SatisfactionDescriptionList"] as! String
        }
        if dict.keys.contains("SatisfactionList") && dict["SatisfactionList"] != nil {
            self.satisfactionList = dict["SatisfactionList"] as! String
        }
        if dict.keys.contains("SatisfactionSurveyChannel") && dict["SatisfactionSurveyChannel"] != nil {
            self.satisfactionSurveyChannel = dict["SatisfactionSurveyChannel"] as! String
        }
        if dict.keys.contains("SkillGroupId") && dict["SkillGroupId"] != nil {
            self.skillGroupId = dict["SkillGroupId"] as! String
        }
        if dict.keys.contains("SortOrder") && dict["SortOrder"] != nil {
            self.sortOrder = dict["SortOrder"] as! String
        }
        if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
            self.startTime = dict["StartTime"] as! Int64
        }
    }
}

public class ListCallDetailRecordsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class List : Tea.TeaModel {
            public var additionalBroker: String?

            public var agentIds: String?

            public var agentNames: String?

            public var broker: String?

            public var callDuration: String?

            public var calledNumber: String?

            public var calleeLocation: String?

            public var callerLocation: String?

            public var callingNumber: String?

            public var contactDisposition: String?

            public var contactId: String?

            public var contactType: String?

            public var dialingTime: Int64?

            public var earlyMediaState: String?

            public var establishedTime: Int64?

            public var instanceId: String?

            public var ivrTime: Int64?

            public var queueTime: Int64?

            public var recordingDuration: Int64?

            public var recordingReady: Bool?

            public var releaseInitiator: String?

            public var releaseReason: String?

            public var releaseTime: Int64?

            public var ringTime: Int64?

            public var satisfactionDescription: String?

            public var satisfactionIndex: Int32?

            public var satisfactionSurveyChannel: String?

            public var satisfactionSurveyOffered: Bool?

            public var skillGroupIds: String?

            public var skillGroupNames: String?

            public var startTime: Int64?

            public var talkTime: Int64?

            public var waitTime: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.additionalBroker != nil {
                    map["AdditionalBroker"] = self.additionalBroker!
                }
                if self.agentIds != nil {
                    map["AgentIds"] = self.agentIds!
                }
                if self.agentNames != nil {
                    map["AgentNames"] = self.agentNames!
                }
                if self.broker != nil {
                    map["Broker"] = self.broker!
                }
                if self.callDuration != nil {
                    map["CallDuration"] = self.callDuration!
                }
                if self.calledNumber != nil {
                    map["CalledNumber"] = self.calledNumber!
                }
                if self.calleeLocation != nil {
                    map["CalleeLocation"] = self.calleeLocation!
                }
                if self.callerLocation != nil {
                    map["CallerLocation"] = self.callerLocation!
                }
                if self.callingNumber != nil {
                    map["CallingNumber"] = self.callingNumber!
                }
                if self.contactDisposition != nil {
                    map["ContactDisposition"] = self.contactDisposition!
                }
                if self.contactId != nil {
                    map["ContactId"] = self.contactId!
                }
                if self.contactType != nil {
                    map["ContactType"] = self.contactType!
                }
                if self.dialingTime != nil {
                    map["DialingTime"] = self.dialingTime!
                }
                if self.earlyMediaState != nil {
                    map["EarlyMediaState"] = self.earlyMediaState!
                }
                if self.establishedTime != nil {
                    map["EstablishedTime"] = self.establishedTime!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.ivrTime != nil {
                    map["IvrTime"] = self.ivrTime!
                }
                if self.queueTime != nil {
                    map["QueueTime"] = self.queueTime!
                }
                if self.recordingDuration != nil {
                    map["RecordingDuration"] = self.recordingDuration!
                }
                if self.recordingReady != nil {
                    map["RecordingReady"] = self.recordingReady!
                }
                if self.releaseInitiator != nil {
                    map["ReleaseInitiator"] = self.releaseInitiator!
                }
                if self.releaseReason != nil {
                    map["ReleaseReason"] = self.releaseReason!
                }
                if self.releaseTime != nil {
                    map["ReleaseTime"] = self.releaseTime!
                }
                if self.ringTime != nil {
                    map["RingTime"] = self.ringTime!
                }
                if self.satisfactionDescription != nil {
                    map["SatisfactionDescription"] = self.satisfactionDescription!
                }
                if self.satisfactionIndex != nil {
                    map["SatisfactionIndex"] = self.satisfactionIndex!
                }
                if self.satisfactionSurveyChannel != nil {
                    map["SatisfactionSurveyChannel"] = self.satisfactionSurveyChannel!
                }
                if self.satisfactionSurveyOffered != nil {
                    map["SatisfactionSurveyOffered"] = self.satisfactionSurveyOffered!
                }
                if self.skillGroupIds != nil {
                    map["SkillGroupIds"] = self.skillGroupIds!
                }
                if self.skillGroupNames != nil {
                    map["SkillGroupNames"] = self.skillGroupNames!
                }
                if self.startTime != nil {
                    map["StartTime"] = self.startTime!
                }
                if self.talkTime != nil {
                    map["TalkTime"] = self.talkTime!
                }
                if self.waitTime != nil {
                    map["WaitTime"] = self.waitTime!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AdditionalBroker") && dict["AdditionalBroker"] != nil {
                    self.additionalBroker = dict["AdditionalBroker"] as! String
                }
                if dict.keys.contains("AgentIds") && dict["AgentIds"] != nil {
                    self.agentIds = dict["AgentIds"] as! String
                }
                if dict.keys.contains("AgentNames") && dict["AgentNames"] != nil {
                    self.agentNames = dict["AgentNames"] as! String
                }
                if dict.keys.contains("Broker") && dict["Broker"] != nil {
                    self.broker = dict["Broker"] as! String
                }
                if dict.keys.contains("CallDuration") && dict["CallDuration"] != nil {
                    self.callDuration = dict["CallDuration"] as! String
                }
                if dict.keys.contains("CalledNumber") && dict["CalledNumber"] != nil {
                    self.calledNumber = dict["CalledNumber"] as! String
                }
                if dict.keys.contains("CalleeLocation") && dict["CalleeLocation"] != nil {
                    self.calleeLocation = dict["CalleeLocation"] as! String
                }
                if dict.keys.contains("CallerLocation") && dict["CallerLocation"] != nil {
                    self.callerLocation = dict["CallerLocation"] as! String
                }
                if dict.keys.contains("CallingNumber") && dict["CallingNumber"] != nil {
                    self.callingNumber = dict["CallingNumber"] as! String
                }
                if dict.keys.contains("ContactDisposition") && dict["ContactDisposition"] != nil {
                    self.contactDisposition = dict["ContactDisposition"] as! String
                }
                if dict.keys.contains("ContactId") && dict["ContactId"] != nil {
                    self.contactId = dict["ContactId"] as! String
                }
                if dict.keys.contains("ContactType") && dict["ContactType"] != nil {
                    self.contactType = dict["ContactType"] as! String
                }
                if dict.keys.contains("DialingTime") && dict["DialingTime"] != nil {
                    self.dialingTime = dict["DialingTime"] as! Int64
                }
                if dict.keys.contains("EarlyMediaState") && dict["EarlyMediaState"] != nil {
                    self.earlyMediaState = dict["EarlyMediaState"] as! String
                }
                if dict.keys.contains("EstablishedTime") && dict["EstablishedTime"] != nil {
                    self.establishedTime = dict["EstablishedTime"] as! Int64
                }
                if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("IvrTime") && dict["IvrTime"] != nil {
                    self.ivrTime = dict["IvrTime"] as! Int64
                }
                if dict.keys.contains("QueueTime") && dict["QueueTime"] != nil {
                    self.queueTime = dict["QueueTime"] as! Int64
                }
                if dict.keys.contains("RecordingDuration") && dict["RecordingDuration"] != nil {
                    self.recordingDuration = dict["RecordingDuration"] as! Int64
                }
                if dict.keys.contains("RecordingReady") && dict["RecordingReady"] != nil {
                    self.recordingReady = dict["RecordingReady"] as! Bool
                }
                if dict.keys.contains("ReleaseInitiator") && dict["ReleaseInitiator"] != nil {
                    self.releaseInitiator = dict["ReleaseInitiator"] as! String
                }
                if dict.keys.contains("ReleaseReason") && dict["ReleaseReason"] != nil {
                    self.releaseReason = dict["ReleaseReason"] as! String
                }
                if dict.keys.contains("ReleaseTime") && dict["ReleaseTime"] != nil {
                    self.releaseTime = dict["ReleaseTime"] as! Int64
                }
                if dict.keys.contains("RingTime") && dict["RingTime"] != nil {
                    self.ringTime = dict["RingTime"] as! Int64
                }
                if dict.keys.contains("SatisfactionDescription") && dict["SatisfactionDescription"] != nil {
                    self.satisfactionDescription = dict["SatisfactionDescription"] as! String
                }
                if dict.keys.contains("SatisfactionIndex") && dict["SatisfactionIndex"] != nil {
                    self.satisfactionIndex = dict["SatisfactionIndex"] as! Int32
                }
                if dict.keys.contains("SatisfactionSurveyChannel") && dict["SatisfactionSurveyChannel"] != nil {
                    self.satisfactionSurveyChannel = dict["SatisfactionSurveyChannel"] as! String
                }
                if dict.keys.contains("SatisfactionSurveyOffered") && dict["SatisfactionSurveyOffered"] != nil {
                    self.satisfactionSurveyOffered = dict["SatisfactionSurveyOffered"] as! Bool
                }
                if dict.keys.contains("SkillGroupIds") && dict["SkillGroupIds"] != nil {
                    self.skillGroupIds = dict["SkillGroupIds"] as! String
                }
                if dict.keys.contains("SkillGroupNames") && dict["SkillGroupNames"] != nil {
                    self.skillGroupNames = dict["SkillGroupNames"] as! String
                }
                if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
                    self.startTime = dict["StartTime"] as! Int64
                }
                if dict.keys.contains("TalkTime") && dict["TalkTime"] != nil {
                    self.talkTime = dict["TalkTime"] as! Int64
                }
                if dict.keys.contains("WaitTime") && dict["WaitTime"] != nil {
                    self.waitTime = dict["WaitTime"] as! Int64
                }
            }
        }
        public var list: [ListCallDetailRecordsResponseBody.Data.List]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.list != nil {
                var tmp : [Any] = []
                for k in self.list! {
                    tmp.append(k.toMap())
                }
                map["List"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("List") && dict["List"] != nil {
                var tmp : [ListCallDetailRecordsResponseBody.Data.List] = []
                for v in dict["List"] as! [Any] {
                    var model = ListCallDetailRecordsResponseBody.Data.List()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.list = tmp
            }
            if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var code: String?

    public var data: ListCallDetailRecordsResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = ListCallDetailRecordsResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListCallDetailRecordsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListCallDetailRecordsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListCallDetailRecordsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListCallTagsRequest : Tea.TeaModel {
    public var instanceId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
    }
}

public class ListCallTagsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class List : Tea.TeaModel {
            public var instanceId: String?

            public var tagName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.tagName != nil {
                    map["TagName"] = self.tagName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("TagName") && dict["TagName"] != nil {
                    self.tagName = dict["TagName"] as! String
                }
            }
        }
        public var list: [ListCallTagsResponseBody.Data.List]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.list != nil {
                var tmp : [Any] = []
                for k in self.list! {
                    tmp.append(k.toMap())
                }
                map["List"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("List") && dict["List"] != nil {
                var tmp : [ListCallTagsResponseBody.Data.List] = []
                for v in dict["List"] as! [Any] {
                    var model = ListCallTagsResponseBody.Data.List()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.list = tmp
            }
            if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var code: String?

    public var data: ListCallTagsResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = ListCallTagsResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListCallTagsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListCallTagsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListCallTagsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListCampaignTrendingReportRequest : Tea.TeaModel {
    public var campaignId: String?

    public var endTime: Int64?

    public var instanceId: String?

    public var startTime: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.campaignId != nil {
            map["CampaignId"] = self.campaignId!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CampaignId") && dict["CampaignId"] != nil {
            self.campaignId = dict["CampaignId"] as! String
        }
        if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
            self.startTime = dict["StartTime"] as! Int64
        }
    }
}

public class ListCampaignTrendingReportResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var breakAgents: Int64?

        public var concurrency: Int64?

        public var datetime: Int64?

        public var loggedInAgents: Int64?

        public var readyAgents: Int64?

        public var talkAgents: Int64?

        public var workAgents: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.breakAgents != nil {
                map["BreakAgents"] = self.breakAgents!
            }
            if self.concurrency != nil {
                map["Concurrency"] = self.concurrency!
            }
            if self.datetime != nil {
                map["Datetime"] = self.datetime!
            }
            if self.loggedInAgents != nil {
                map["LoggedInAgents"] = self.loggedInAgents!
            }
            if self.readyAgents != nil {
                map["ReadyAgents"] = self.readyAgents!
            }
            if self.talkAgents != nil {
                map["TalkAgents"] = self.talkAgents!
            }
            if self.workAgents != nil {
                map["WorkAgents"] = self.workAgents!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BreakAgents") && dict["BreakAgents"] != nil {
                self.breakAgents = dict["BreakAgents"] as! Int64
            }
            if dict.keys.contains("Concurrency") && dict["Concurrency"] != nil {
                self.concurrency = dict["Concurrency"] as! Int64
            }
            if dict.keys.contains("Datetime") && dict["Datetime"] != nil {
                self.datetime = dict["Datetime"] as! Int64
            }
            if dict.keys.contains("LoggedInAgents") && dict["LoggedInAgents"] != nil {
                self.loggedInAgents = dict["LoggedInAgents"] as! Int64
            }
            if dict.keys.contains("ReadyAgents") && dict["ReadyAgents"] != nil {
                self.readyAgents = dict["ReadyAgents"] as! Int64
            }
            if dict.keys.contains("TalkAgents") && dict["TalkAgents"] != nil {
                self.talkAgents = dict["TalkAgents"] as! Int64
            }
            if dict.keys.contains("WorkAgents") && dict["WorkAgents"] != nil {
                self.workAgents = dict["WorkAgents"] as! Int64
            }
        }
    }
    public var code: String?

    public var data: [ListCampaignTrendingReportResponseBody.Data]?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var tmp : [ListCampaignTrendingReportResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = ListCampaignTrendingReportResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListCampaignTrendingReportResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListCampaignTrendingReportResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListCampaignTrendingReportResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListCampaignsRequest : Tea.TeaModel {
    public var actualStartTimeFrom: String?

    public var actualStartTimeTo: String?

    public var instanceId: String?

    public var name: String?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var planedStartTimeFrom: String?

    public var planedStartTimeTo: String?

    public var queueId: String?

    public var state: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.actualStartTimeFrom != nil {
            map["ActualStartTimeFrom"] = self.actualStartTimeFrom!
        }
        if self.actualStartTimeTo != nil {
            map["ActualStartTimeTo"] = self.actualStartTimeTo!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.planedStartTimeFrom != nil {
            map["PlanedStartTimeFrom"] = self.planedStartTimeFrom!
        }
        if self.planedStartTimeTo != nil {
            map["PlanedStartTimeTo"] = self.planedStartTimeTo!
        }
        if self.queueId != nil {
            map["QueueId"] = self.queueId!
        }
        if self.state != nil {
            map["State"] = self.state!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ActualStartTimeFrom") && dict["ActualStartTimeFrom"] != nil {
            self.actualStartTimeFrom = dict["ActualStartTimeFrom"] as! String
        }
        if dict.keys.contains("ActualStartTimeTo") && dict["ActualStartTimeTo"] != nil {
            self.actualStartTimeTo = dict["ActualStartTimeTo"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("PlanedStartTimeFrom") && dict["PlanedStartTimeFrom"] != nil {
            self.planedStartTimeFrom = dict["PlanedStartTimeFrom"] as! String
        }
        if dict.keys.contains("PlanedStartTimeTo") && dict["PlanedStartTimeTo"] != nil {
            self.planedStartTimeTo = dict["PlanedStartTimeTo"] as! String
        }
        if dict.keys.contains("QueueId") && dict["QueueId"] != nil {
            self.queueId = dict["QueueId"] as! String
        }
        if dict.keys.contains("State") && dict["State"] != nil {
            self.state = dict["State"] as! String
        }
    }
}

public class ListCampaignsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class List : Tea.TeaModel {
            public var actualEndTime: Int64?

            public var actualStartTime: Int64?

            public var campaignId: String?

            public var casesAborted: Int64?

            public var casesConnected: Int64?

            public var casesUncompleted: Int64?

            public var maxAttemptCount: Int64?

            public var minAttemptInterval: Int64?

            public var name: String?

            public var planedEndTime: Int64?

            public var planedStartTime: Int64?

            public var queueId: String?

            public var queueName: String?

            public var simulation: Bool?

            public var state: String?

            public var strategyParameters: String?

            public var strategyType: String?

            public var totalCases: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.actualEndTime != nil {
                    map["ActualEndTime"] = self.actualEndTime!
                }
                if self.actualStartTime != nil {
                    map["ActualStartTime"] = self.actualStartTime!
                }
                if self.campaignId != nil {
                    map["CampaignId"] = self.campaignId!
                }
                if self.casesAborted != nil {
                    map["CasesAborted"] = self.casesAborted!
                }
                if self.casesConnected != nil {
                    map["CasesConnected"] = self.casesConnected!
                }
                if self.casesUncompleted != nil {
                    map["CasesUncompleted"] = self.casesUncompleted!
                }
                if self.maxAttemptCount != nil {
                    map["MaxAttemptCount"] = self.maxAttemptCount!
                }
                if self.minAttemptInterval != nil {
                    map["MinAttemptInterval"] = self.minAttemptInterval!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.planedEndTime != nil {
                    map["PlanedEndTime"] = self.planedEndTime!
                }
                if self.planedStartTime != nil {
                    map["PlanedStartTime"] = self.planedStartTime!
                }
                if self.queueId != nil {
                    map["QueueId"] = self.queueId!
                }
                if self.queueName != nil {
                    map["QueueName"] = self.queueName!
                }
                if self.simulation != nil {
                    map["Simulation"] = self.simulation!
                }
                if self.state != nil {
                    map["State"] = self.state!
                }
                if self.strategyParameters != nil {
                    map["StrategyParameters"] = self.strategyParameters!
                }
                if self.strategyType != nil {
                    map["StrategyType"] = self.strategyType!
                }
                if self.totalCases != nil {
                    map["TotalCases"] = self.totalCases!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ActualEndTime") && dict["ActualEndTime"] != nil {
                    self.actualEndTime = dict["ActualEndTime"] as! Int64
                }
                if dict.keys.contains("ActualStartTime") && dict["ActualStartTime"] != nil {
                    self.actualStartTime = dict["ActualStartTime"] as! Int64
                }
                if dict.keys.contains("CampaignId") && dict["CampaignId"] != nil {
                    self.campaignId = dict["CampaignId"] as! String
                }
                if dict.keys.contains("CasesAborted") && dict["CasesAborted"] != nil {
                    self.casesAborted = dict["CasesAborted"] as! Int64
                }
                if dict.keys.contains("CasesConnected") && dict["CasesConnected"] != nil {
                    self.casesConnected = dict["CasesConnected"] as! Int64
                }
                if dict.keys.contains("CasesUncompleted") && dict["CasesUncompleted"] != nil {
                    self.casesUncompleted = dict["CasesUncompleted"] as! Int64
                }
                if dict.keys.contains("MaxAttemptCount") && dict["MaxAttemptCount"] != nil {
                    self.maxAttemptCount = dict["MaxAttemptCount"] as! Int64
                }
                if dict.keys.contains("MinAttemptInterval") && dict["MinAttemptInterval"] != nil {
                    self.minAttemptInterval = dict["MinAttemptInterval"] as! Int64
                }
                if dict.keys.contains("Name") && dict["Name"] != nil {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("PlanedEndTime") && dict["PlanedEndTime"] != nil {
                    self.planedEndTime = dict["PlanedEndTime"] as! Int64
                }
                if dict.keys.contains("PlanedStartTime") && dict["PlanedStartTime"] != nil {
                    self.planedStartTime = dict["PlanedStartTime"] as! Int64
                }
                if dict.keys.contains("QueueId") && dict["QueueId"] != nil {
                    self.queueId = dict["QueueId"] as! String
                }
                if dict.keys.contains("QueueName") && dict["QueueName"] != nil {
                    self.queueName = dict["QueueName"] as! String
                }
                if dict.keys.contains("Simulation") && dict["Simulation"] != nil {
                    self.simulation = dict["Simulation"] as! Bool
                }
                if dict.keys.contains("State") && dict["State"] != nil {
                    self.state = dict["State"] as! String
                }
                if dict.keys.contains("StrategyParameters") && dict["StrategyParameters"] != nil {
                    self.strategyParameters = dict["StrategyParameters"] as! String
                }
                if dict.keys.contains("StrategyType") && dict["StrategyType"] != nil {
                    self.strategyType = dict["StrategyType"] as! String
                }
                if dict.keys.contains("TotalCases") && dict["TotalCases"] != nil {
                    self.totalCases = dict["TotalCases"] as! Int64
                }
            }
        }
        public var list: [ListCampaignsResponseBody.Data.List]?

        public var pageNumber: Int64?

        public var pageSize: Int64?

        public var totalCount: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.list != nil {
                var tmp : [Any] = []
                for k in self.list! {
                    tmp.append(k.toMap())
                }
                map["List"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("List") && dict["List"] != nil {
                var tmp : [ListCampaignsResponseBody.Data.List] = []
                for v in dict["List"] as! [Any] {
                    var model = ListCampaignsResponseBody.Data.List()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.list = tmp
            }
            if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
                self.pageNumber = dict["PageNumber"] as! Int64
            }
            if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
                self.pageSize = dict["PageSize"] as! Int64
            }
            if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
                self.totalCount = dict["TotalCount"] as! Int64
            }
        }
    }
    public var code: String?

    public var data: ListCampaignsResponseBody.Data?

    public var httpStatusCode: Int64?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = ListCampaignsResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int64
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListCampaignsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListCampaignsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListCampaignsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListCasesRequest : Tea.TeaModel {
    public var campaignId: String?

    public var instanceId: String?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var phoneNumber: String?

    public var state: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.campaignId != nil {
            map["CampaignId"] = self.campaignId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.phoneNumber != nil {
            map["PhoneNumber"] = self.phoneNumber!
        }
        if self.state != nil {
            map["State"] = self.state!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CampaignId") && dict["CampaignId"] != nil {
            self.campaignId = dict["CampaignId"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("PhoneNumber") && dict["PhoneNumber"] != nil {
            self.phoneNumber = dict["PhoneNumber"] as! String
        }
        if dict.keys.contains("State") && dict["State"] != nil {
            self.state = dict["State"] as! String
        }
    }
}

public class ListCasesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class List : Tea.TeaModel {
            public var abandonType: String?

            public var attemptCount: Int64?

            public var caseId: String?

            public var customVariables: String?

            public var failureReason: String?

            public var phoneNumber: String?

            public var state: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.abandonType != nil {
                    map["AbandonType"] = self.abandonType!
                }
                if self.attemptCount != nil {
                    map["AttemptCount"] = self.attemptCount!
                }
                if self.caseId != nil {
                    map["CaseId"] = self.caseId!
                }
                if self.customVariables != nil {
                    map["CustomVariables"] = self.customVariables!
                }
                if self.failureReason != nil {
                    map["FailureReason"] = self.failureReason!
                }
                if self.phoneNumber != nil {
                    map["PhoneNumber"] = self.phoneNumber!
                }
                if self.state != nil {
                    map["State"] = self.state!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AbandonType") && dict["AbandonType"] != nil {
                    self.abandonType = dict["AbandonType"] as! String
                }
                if dict.keys.contains("AttemptCount") && dict["AttemptCount"] != nil {
                    self.attemptCount = dict["AttemptCount"] as! Int64
                }
                if dict.keys.contains("CaseId") && dict["CaseId"] != nil {
                    self.caseId = dict["CaseId"] as! String
                }
                if dict.keys.contains("CustomVariables") && dict["CustomVariables"] != nil {
                    self.customVariables = dict["CustomVariables"] as! String
                }
                if dict.keys.contains("FailureReason") && dict["FailureReason"] != nil {
                    self.failureReason = dict["FailureReason"] as! String
                }
                if dict.keys.contains("PhoneNumber") && dict["PhoneNumber"] != nil {
                    self.phoneNumber = dict["PhoneNumber"] as! String
                }
                if dict.keys.contains("State") && dict["State"] != nil {
                    self.state = dict["State"] as! String
                }
            }
        }
        public var list: [ListCasesResponseBody.Data.List]?

        public var pageNumber: Int64?

        public var pageSize: Int64?

        public var totalCount: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.list != nil {
                var tmp : [Any] = []
                for k in self.list! {
                    tmp.append(k.toMap())
                }
                map["List"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("List") && dict["List"] != nil {
                var tmp : [ListCasesResponseBody.Data.List] = []
                for v in dict["List"] as! [Any] {
                    var model = ListCasesResponseBody.Data.List()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.list = tmp
            }
            if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
                self.pageNumber = dict["PageNumber"] as! Int64
            }
            if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
                self.pageSize = dict["PageSize"] as! Int64
            }
            if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
                self.totalCount = dict["TotalCount"] as! Int64
            }
        }
    }
    public var code: String?

    public var data: ListCasesResponseBody.Data?

    public var httpStatusCode: Int64?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = ListCasesResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int64
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListCasesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListCasesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListCasesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListConfigItemsRequest : Tea.TeaModel {
    public var instanceId: String?

    public var objectId: String?

    public var objectType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.objectId != nil {
            map["ObjectId"] = self.objectId!
        }
        if self.objectType != nil {
            map["ObjectType"] = self.objectType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("ObjectId") && dict["ObjectId"] != nil {
            self.objectId = dict["ObjectId"] as! String
        }
        if dict.keys.contains("ObjectType") && dict["ObjectType"] != nil {
            self.objectType = dict["ObjectType"] as! String
        }
    }
}

public class ListConfigItemsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var instanceId: String?

        public var name: String?

        public var objectId: String?

        public var objectType: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.objectId != nil {
                map["ObjectId"] = self.objectId!
            }
            if self.objectType != nil {
                map["ObjectType"] = self.objectType!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("ObjectId") && dict["ObjectId"] != nil {
                self.objectId = dict["ObjectId"] as! String
            }
            if dict.keys.contains("ObjectType") && dict["ObjectType"] != nil {
                self.objectType = dict["ObjectType"] as! String
            }
            if dict.keys.contains("Value") && dict["Value"] != nil {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var code: String?

    public var data: [ListConfigItemsResponseBody.Data]?

    public var httpStatusCode: Int32?

    public var message: String?

    public var params: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.params != nil {
            map["Params"] = self.params!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var tmp : [ListConfigItemsResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = ListConfigItemsResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Params") && dict["Params"] != nil {
            self.params = dict["Params"] as! [String]
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListConfigItemsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListConfigItemsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListConfigItemsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListContactFlowsRequest : Tea.TeaModel {
    public var instanceId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! String
        }
    }
}

public class ListContactFlowsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class List : Tea.TeaModel {
            public var contactFlowId: String?

            public var createdTime: String?

            public var definition: String?

            public var description_: String?

            public var draftId: String?

            public var editor: String?

            public var instanceId: String?

            public var name: String?

            public var numberList: [String]?

            public var published: Bool?

            public var type: String?

            public var updatedTime: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.contactFlowId != nil {
                    map["ContactFlowId"] = self.contactFlowId!
                }
                if self.createdTime != nil {
                    map["CreatedTime"] = self.createdTime!
                }
                if self.definition != nil {
                    map["Definition"] = self.definition!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.draftId != nil {
                    map["DraftId"] = self.draftId!
                }
                if self.editor != nil {
                    map["Editor"] = self.editor!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.numberList != nil {
                    map["NumberList"] = self.numberList!
                }
                if self.published != nil {
                    map["Published"] = self.published!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.updatedTime != nil {
                    map["UpdatedTime"] = self.updatedTime!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ContactFlowId") && dict["ContactFlowId"] != nil {
                    self.contactFlowId = dict["ContactFlowId"] as! String
                }
                if dict.keys.contains("CreatedTime") && dict["CreatedTime"] != nil {
                    self.createdTime = dict["CreatedTime"] as! String
                }
                if dict.keys.contains("Definition") && dict["Definition"] != nil {
                    self.definition = dict["Definition"] as! String
                }
                if dict.keys.contains("Description") && dict["Description"] != nil {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("DraftId") && dict["DraftId"] != nil {
                    self.draftId = dict["DraftId"] as! String
                }
                if dict.keys.contains("Editor") && dict["Editor"] != nil {
                    self.editor = dict["Editor"] as! String
                }
                if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("Name") && dict["Name"] != nil {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("NumberList") && dict["NumberList"] != nil {
                    self.numberList = dict["NumberList"] as! [String]
                }
                if dict.keys.contains("Published") && dict["Published"] != nil {
                    self.published = dict["Published"] as! Bool
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("UpdatedTime") && dict["UpdatedTime"] != nil {
                    self.updatedTime = dict["UpdatedTime"] as! String
                }
            }
        }
        public var list: [ListContactFlowsResponseBody.Data.List]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.list != nil {
                var tmp : [Any] = []
                for k in self.list! {
                    tmp.append(k.toMap())
                }
                map["List"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("List") && dict["List"] != nil {
                var tmp : [ListContactFlowsResponseBody.Data.List] = []
                for v in dict["List"] as! [Any] {
                    var model = ListContactFlowsResponseBody.Data.List()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.list = tmp
            }
            if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var code: String?

    public var data: ListContactFlowsResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = ListContactFlowsResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListContactFlowsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListContactFlowsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListContactFlowsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListCustomCallTaggingRequest : Tea.TeaModel {
    public var callTagNameList: String?

    public var instanceId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var searchPattern: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.callTagNameList != nil {
            map["CallTagNameList"] = self.callTagNameList!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.searchPattern != nil {
            map["SearchPattern"] = self.searchPattern!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CallTagNameList") && dict["CallTagNameList"] != nil {
            self.callTagNameList = dict["CallTagNameList"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SearchPattern") && dict["SearchPattern"] != nil {
            self.searchPattern = dict["SearchPattern"] as! String
        }
    }
}

public class ListCustomCallTaggingResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class List : Tea.TeaModel {
            public class CallTagList : Tea.TeaModel {
                public var instanceId: String?

                public var tagName: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.instanceId != nil {
                        map["InstanceId"] = self.instanceId!
                    }
                    if self.tagName != nil {
                        map["TagName"] = self.tagName!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                        self.instanceId = dict["InstanceId"] as! String
                    }
                    if dict.keys.contains("TagName") && dict["TagName"] != nil {
                        self.tagName = dict["TagName"] as! String
                    }
                }
            }
            public var callTagList: [ListCustomCallTaggingResponseBody.Data.List.CallTagList]?

            public var creator: String?

            public var description_: String?

            public var instanceId: String?

            public var number: String?

            public var updateTime: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.callTagList != nil {
                    var tmp : [Any] = []
                    for k in self.callTagList! {
                        tmp.append(k.toMap())
                    }
                    map["CallTagList"] = tmp
                }
                if self.creator != nil {
                    map["Creator"] = self.creator!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.number != nil {
                    map["Number"] = self.number!
                }
                if self.updateTime != nil {
                    map["UpdateTime"] = self.updateTime!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CallTagList") && dict["CallTagList"] != nil {
                    var tmp : [ListCustomCallTaggingResponseBody.Data.List.CallTagList] = []
                    for v in dict["CallTagList"] as! [Any] {
                        var model = ListCustomCallTaggingResponseBody.Data.List.CallTagList()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.callTagList = tmp
                }
                if dict.keys.contains("Creator") && dict["Creator"] != nil {
                    self.creator = dict["Creator"] as! String
                }
                if dict.keys.contains("Description") && dict["Description"] != nil {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("Number") && dict["Number"] != nil {
                    self.number = dict["Number"] as! String
                }
                if dict.keys.contains("UpdateTime") && dict["UpdateTime"] != nil {
                    self.updateTime = dict["UpdateTime"] as! String
                }
            }
        }
        public var list: [ListCustomCallTaggingResponseBody.Data.List]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.list != nil {
                var tmp : [Any] = []
                for k in self.list! {
                    tmp.append(k.toMap())
                }
                map["List"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("List") && dict["List"] != nil {
                var tmp : [ListCustomCallTaggingResponseBody.Data.List] = []
                for v in dict["List"] as! [Any] {
                    var model = ListCustomCallTaggingResponseBody.Data.List()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.list = tmp
            }
            if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var code: String?

    public var data: ListCustomCallTaggingResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = ListCustomCallTaggingResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListCustomCallTaggingResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListCustomCallTaggingResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListCustomCallTaggingResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListDevicesRequest : Tea.TeaModel {
    public var instanceId: String?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("UserId") && dict["UserId"] != nil {
            self.userId = dict["UserId"] as! String
        }
    }
}

public class ListDevicesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var callId: String?

        public var contact: String?

        public var deviceId: String?

        public var expires: Int64?

        public var extension_: String?

        public var instanceId: String?

        public var userId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.callId != nil {
                map["CallId"] = self.callId!
            }
            if self.contact != nil {
                map["Contact"] = self.contact!
            }
            if self.deviceId != nil {
                map["DeviceId"] = self.deviceId!
            }
            if self.expires != nil {
                map["Expires"] = self.expires!
            }
            if self.extension_ != nil {
                map["Extension"] = self.extension_!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CallId") && dict["CallId"] != nil {
                self.callId = dict["CallId"] as! String
            }
            if dict.keys.contains("Contact") && dict["Contact"] != nil {
                self.contact = dict["Contact"] as! String
            }
            if dict.keys.contains("DeviceId") && dict["DeviceId"] != nil {
                self.deviceId = dict["DeviceId"] as! String
            }
            if dict.keys.contains("Expires") && dict["Expires"] != nil {
                self.expires = dict["Expires"] as! Int64
            }
            if dict.keys.contains("Extension") && dict["Extension"] != nil {
                self.extension_ = dict["Extension"] as! String
            }
            if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("UserId") && dict["UserId"] != nil {
                self.userId = dict["UserId"] as! String
            }
        }
    }
    public var code: String?

    public var data: [ListDevicesResponseBody.Data]?

    public var httpStatusCode: Int32?

    public var message: String?

    public var params: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.params != nil {
            map["Params"] = self.params!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var tmp : [ListDevicesResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = ListDevicesResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Params") && dict["Params"] != nil {
            self.params = dict["Params"] as! [String]
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListDevicesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListDevicesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListDevicesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListDoNotCallNumbersRequest : Tea.TeaModel {
    public var instanceId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var scope: String?

    public var searchPattern: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.scope != nil {
            map["Scope"] = self.scope!
        }
        if self.searchPattern != nil {
            map["SearchPattern"] = self.searchPattern!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("Scope") && dict["Scope"] != nil {
            self.scope = dict["Scope"] as! String
        }
        if dict.keys.contains("SearchPattern") && dict["SearchPattern"] != nil {
            self.searchPattern = dict["SearchPattern"] as! String
        }
    }
}

public class ListDoNotCallNumbersResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class List : Tea.TeaModel {
            public var createTime: Int64?

            public var creator: String?

            public var number: String?

            public var remark: String?

            public var scope: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.creator != nil {
                    map["Creator"] = self.creator!
                }
                if self.number != nil {
                    map["Number"] = self.number!
                }
                if self.remark != nil {
                    map["Remark"] = self.remark!
                }
                if self.scope != nil {
                    map["Scope"] = self.scope!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                    self.createTime = dict["CreateTime"] as! Int64
                }
                if dict.keys.contains("Creator") && dict["Creator"] != nil {
                    self.creator = dict["Creator"] as! String
                }
                if dict.keys.contains("Number") && dict["Number"] != nil {
                    self.number = dict["Number"] as! String
                }
                if dict.keys.contains("Remark") && dict["Remark"] != nil {
                    self.remark = dict["Remark"] as! String
                }
                if dict.keys.contains("Scope") && dict["Scope"] != nil {
                    self.scope = dict["Scope"] as! String
                }
            }
        }
        public var list: [ListDoNotCallNumbersResponseBody.Data.List]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.list != nil {
                var tmp : [Any] = []
                for k in self.list! {
                    tmp.append(k.toMap())
                }
                map["List"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("List") && dict["List"] != nil {
                var tmp : [ListDoNotCallNumbersResponseBody.Data.List] = []
                for v in dict["List"] as! [Any] {
                    var model = ListDoNotCallNumbersResponseBody.Data.List()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.list = tmp
            }
            if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var code: String?

    public var data: ListDoNotCallNumbersResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = ListDoNotCallNumbersResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListDoNotCallNumbersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListDoNotCallNumbersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListDoNotCallNumbersResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListHistoricalAgentReportRequest : Tea.TeaModel {
    public var agentIdList: String?

    public var instanceId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var startTime: Int64?

    public var stopTime: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.agentIdList != nil {
            map["AgentIdList"] = self.agentIdList!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.stopTime != nil {
            map["StopTime"] = self.stopTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AgentIdList") && dict["AgentIdList"] != nil {
            self.agentIdList = dict["AgentIdList"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
            self.startTime = dict["StartTime"] as! Int64
        }
        if dict.keys.contains("StopTime") && dict["StopTime"] != nil {
            self.stopTime = dict["StopTime"] as! Int64
        }
    }
}

public class ListHistoricalAgentReportResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class List : Tea.TeaModel {
            public class Inbound : Tea.TeaModel {
                public var averageHoldTime: Double?

                public var averageRingTime: Double?

                public var averageTalkTime: Double?

                public var averageWorkTime: Double?

                public var callsAttendedTransferIn: Int64?

                public var callsAttendedTransferOut: Int64?

                public var callsBlindTransferIn: Int64?

                public var callsBlindTransferOut: Int64?

                public var callsHandled: Int64?

                public var callsHold: Int64?

                public var callsOffered: Int64?

                public var callsRinged: Int64?

                public var handleRate: Double?

                public var maxHoldTime: Int64?

                public var maxRingTime: Int64?

                public var maxTalkTime: Int64?

                public var maxWorkTime: Int64?

                public var satisfactionIndex: Double?

                public var satisfactionRate: Double?

                public var satisfactionSurveysOffered: Int64?

                public var satisfactionSurveysResponded: Int64?

                public var totalHoldTime: Int64?

                public var totalRingTime: Int64?

                public var totalTalkTime: Int64?

                public var totalWorkTime: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.averageHoldTime != nil {
                        map["AverageHoldTime"] = self.averageHoldTime!
                    }
                    if self.averageRingTime != nil {
                        map["AverageRingTime"] = self.averageRingTime!
                    }
                    if self.averageTalkTime != nil {
                        map["AverageTalkTime"] = self.averageTalkTime!
                    }
                    if self.averageWorkTime != nil {
                        map["AverageWorkTime"] = self.averageWorkTime!
                    }
                    if self.callsAttendedTransferIn != nil {
                        map["CallsAttendedTransferIn"] = self.callsAttendedTransferIn!
                    }
                    if self.callsAttendedTransferOut != nil {
                        map["CallsAttendedTransferOut"] = self.callsAttendedTransferOut!
                    }
                    if self.callsBlindTransferIn != nil {
                        map["CallsBlindTransferIn"] = self.callsBlindTransferIn!
                    }
                    if self.callsBlindTransferOut != nil {
                        map["CallsBlindTransferOut"] = self.callsBlindTransferOut!
                    }
                    if self.callsHandled != nil {
                        map["CallsHandled"] = self.callsHandled!
                    }
                    if self.callsHold != nil {
                        map["CallsHold"] = self.callsHold!
                    }
                    if self.callsOffered != nil {
                        map["CallsOffered"] = self.callsOffered!
                    }
                    if self.callsRinged != nil {
                        map["CallsRinged"] = self.callsRinged!
                    }
                    if self.handleRate != nil {
                        map["HandleRate"] = self.handleRate!
                    }
                    if self.maxHoldTime != nil {
                        map["MaxHoldTime"] = self.maxHoldTime!
                    }
                    if self.maxRingTime != nil {
                        map["MaxRingTime"] = self.maxRingTime!
                    }
                    if self.maxTalkTime != nil {
                        map["MaxTalkTime"] = self.maxTalkTime!
                    }
                    if self.maxWorkTime != nil {
                        map["MaxWorkTime"] = self.maxWorkTime!
                    }
                    if self.satisfactionIndex != nil {
                        map["SatisfactionIndex"] = self.satisfactionIndex!
                    }
                    if self.satisfactionRate != nil {
                        map["SatisfactionRate"] = self.satisfactionRate!
                    }
                    if self.satisfactionSurveysOffered != nil {
                        map["SatisfactionSurveysOffered"] = self.satisfactionSurveysOffered!
                    }
                    if self.satisfactionSurveysResponded != nil {
                        map["SatisfactionSurveysResponded"] = self.satisfactionSurveysResponded!
                    }
                    if self.totalHoldTime != nil {
                        map["TotalHoldTime"] = self.totalHoldTime!
                    }
                    if self.totalRingTime != nil {
                        map["TotalRingTime"] = self.totalRingTime!
                    }
                    if self.totalTalkTime != nil {
                        map["TotalTalkTime"] = self.totalTalkTime!
                    }
                    if self.totalWorkTime != nil {
                        map["TotalWorkTime"] = self.totalWorkTime!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AverageHoldTime") && dict["AverageHoldTime"] != nil {
                        self.averageHoldTime = dict["AverageHoldTime"] as! Double
                    }
                    if dict.keys.contains("AverageRingTime") && dict["AverageRingTime"] != nil {
                        self.averageRingTime = dict["AverageRingTime"] as! Double
                    }
                    if dict.keys.contains("AverageTalkTime") && dict["AverageTalkTime"] != nil {
                        self.averageTalkTime = dict["AverageTalkTime"] as! Double
                    }
                    if dict.keys.contains("AverageWorkTime") && dict["AverageWorkTime"] != nil {
                        self.averageWorkTime = dict["AverageWorkTime"] as! Double
                    }
                    if dict.keys.contains("CallsAttendedTransferIn") && dict["CallsAttendedTransferIn"] != nil {
                        self.callsAttendedTransferIn = dict["CallsAttendedTransferIn"] as! Int64
                    }
                    if dict.keys.contains("CallsAttendedTransferOut") && dict["CallsAttendedTransferOut"] != nil {
                        self.callsAttendedTransferOut = dict["CallsAttendedTransferOut"] as! Int64
                    }
                    if dict.keys.contains("CallsBlindTransferIn") && dict["CallsBlindTransferIn"] != nil {
                        self.callsBlindTransferIn = dict["CallsBlindTransferIn"] as! Int64
                    }
                    if dict.keys.contains("CallsBlindTransferOut") && dict["CallsBlindTransferOut"] != nil {
                        self.callsBlindTransferOut = dict["CallsBlindTransferOut"] as! Int64
                    }
                    if dict.keys.contains("CallsHandled") && dict["CallsHandled"] != nil {
                        self.callsHandled = dict["CallsHandled"] as! Int64
                    }
                    if dict.keys.contains("CallsHold") && dict["CallsHold"] != nil {
                        self.callsHold = dict["CallsHold"] as! Int64
                    }
                    if dict.keys.contains("CallsOffered") && dict["CallsOffered"] != nil {
                        self.callsOffered = dict["CallsOffered"] as! Int64
                    }
                    if dict.keys.contains("CallsRinged") && dict["CallsRinged"] != nil {
                        self.callsRinged = dict["CallsRinged"] as! Int64
                    }
                    if dict.keys.contains("HandleRate") && dict["HandleRate"] != nil {
                        self.handleRate = dict["HandleRate"] as! Double
                    }
                    if dict.keys.contains("MaxHoldTime") && dict["MaxHoldTime"] != nil {
                        self.maxHoldTime = dict["MaxHoldTime"] as! Int64
                    }
                    if dict.keys.contains("MaxRingTime") && dict["MaxRingTime"] != nil {
                        self.maxRingTime = dict["MaxRingTime"] as! Int64
                    }
                    if dict.keys.contains("MaxTalkTime") && dict["MaxTalkTime"] != nil {
                        self.maxTalkTime = dict["MaxTalkTime"] as! Int64
                    }
                    if dict.keys.contains("MaxWorkTime") && dict["MaxWorkTime"] != nil {
                        self.maxWorkTime = dict["MaxWorkTime"] as! Int64
                    }
                    if dict.keys.contains("SatisfactionIndex") && dict["SatisfactionIndex"] != nil {
                        self.satisfactionIndex = dict["SatisfactionIndex"] as! Double
                    }
                    if dict.keys.contains("SatisfactionRate") && dict["SatisfactionRate"] != nil {
                        self.satisfactionRate = dict["SatisfactionRate"] as! Double
                    }
                    if dict.keys.contains("SatisfactionSurveysOffered") && dict["SatisfactionSurveysOffered"] != nil {
                        self.satisfactionSurveysOffered = dict["SatisfactionSurveysOffered"] as! Int64
                    }
                    if dict.keys.contains("SatisfactionSurveysResponded") && dict["SatisfactionSurveysResponded"] != nil {
                        self.satisfactionSurveysResponded = dict["SatisfactionSurveysResponded"] as! Int64
                    }
                    if dict.keys.contains("TotalHoldTime") && dict["TotalHoldTime"] != nil {
                        self.totalHoldTime = dict["TotalHoldTime"] as! Int64
                    }
                    if dict.keys.contains("TotalRingTime") && dict["TotalRingTime"] != nil {
                        self.totalRingTime = dict["TotalRingTime"] as! Int64
                    }
                    if dict.keys.contains("TotalTalkTime") && dict["TotalTalkTime"] != nil {
                        self.totalTalkTime = dict["TotalTalkTime"] as! Int64
                    }
                    if dict.keys.contains("TotalWorkTime") && dict["TotalWorkTime"] != nil {
                        self.totalWorkTime = dict["TotalWorkTime"] as! Int64
                    }
                }
            }
            public class Outbound : Tea.TeaModel {
                public var answerRate: Double?

                public var averageDialingTime: Double?

                public var averageHoldTime: Double?

                public var averageRingTime: Double?

                public var averageTalkTime: Double?

                public var averageWorkTime: Double?

                public var callsAnswered: Int64?

                public var callsAttendedTransferIn: Int64?

                public var callsAttendedTransferOut: Int64?

                public var callsBlindTransferIn: Int64?

                public var callsBlindTransferOut: Int64?

                public var callsDialed: Int64?

                public var callsHold: Int64?

                public var callsRinged: Int64?

                public var maxDialingTime: Int64?

                public var maxHoldTime: Int64?

                public var maxRingTime: Int64?

                public var maxTalkTime: Int64?

                public var maxWorkTime: Int64?

                public var satisfactionIndex: Double?

                public var satisfactionRate: Double?

                public var satisfactionSurveysOffered: Int64?

                public var satisfactionSurveysResponded: Int64?

                public var totalDialingTime: Int64?

                public var totalHoldTime: Int64?

                public var totalRingTime: Int64?

                public var totalTalkTime: Int64?

                public var totalWorkTime: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.answerRate != nil {
                        map["AnswerRate"] = self.answerRate!
                    }
                    if self.averageDialingTime != nil {
                        map["AverageDialingTime"] = self.averageDialingTime!
                    }
                    if self.averageHoldTime != nil {
                        map["AverageHoldTime"] = self.averageHoldTime!
                    }
                    if self.averageRingTime != nil {
                        map["AverageRingTime"] = self.averageRingTime!
                    }
                    if self.averageTalkTime != nil {
                        map["AverageTalkTime"] = self.averageTalkTime!
                    }
                    if self.averageWorkTime != nil {
                        map["AverageWorkTime"] = self.averageWorkTime!
                    }
                    if self.callsAnswered != nil {
                        map["CallsAnswered"] = self.callsAnswered!
                    }
                    if self.callsAttendedTransferIn != nil {
                        map["CallsAttendedTransferIn"] = self.callsAttendedTransferIn!
                    }
                    if self.callsAttendedTransferOut != nil {
                        map["CallsAttendedTransferOut"] = self.callsAttendedTransferOut!
                    }
                    if self.callsBlindTransferIn != nil {
                        map["CallsBlindTransferIn"] = self.callsBlindTransferIn!
                    }
                    if self.callsBlindTransferOut != nil {
                        map["CallsBlindTransferOut"] = self.callsBlindTransferOut!
                    }
                    if self.callsDialed != nil {
                        map["CallsDialed"] = self.callsDialed!
                    }
                    if self.callsHold != nil {
                        map["CallsHold"] = self.callsHold!
                    }
                    if self.callsRinged != nil {
                        map["CallsRinged"] = self.callsRinged!
                    }
                    if self.maxDialingTime != nil {
                        map["MaxDialingTime"] = self.maxDialingTime!
                    }
                    if self.maxHoldTime != nil {
                        map["MaxHoldTime"] = self.maxHoldTime!
                    }
                    if self.maxRingTime != nil {
                        map["MaxRingTime"] = self.maxRingTime!
                    }
                    if self.maxTalkTime != nil {
                        map["MaxTalkTime"] = self.maxTalkTime!
                    }
                    if self.maxWorkTime != nil {
                        map["MaxWorkTime"] = self.maxWorkTime!
                    }
                    if self.satisfactionIndex != nil {
                        map["SatisfactionIndex"] = self.satisfactionIndex!
                    }
                    if self.satisfactionRate != nil {
                        map["SatisfactionRate"] = self.satisfactionRate!
                    }
                    if self.satisfactionSurveysOffered != nil {
                        map["SatisfactionSurveysOffered"] = self.satisfactionSurveysOffered!
                    }
                    if self.satisfactionSurveysResponded != nil {
                        map["SatisfactionSurveysResponded"] = self.satisfactionSurveysResponded!
                    }
                    if self.totalDialingTime != nil {
                        map["TotalDialingTime"] = self.totalDialingTime!
                    }
                    if self.totalHoldTime != nil {
                        map["TotalHoldTime"] = self.totalHoldTime!
                    }
                    if self.totalRingTime != nil {
                        map["TotalRingTime"] = self.totalRingTime!
                    }
                    if self.totalTalkTime != nil {
                        map["TotalTalkTime"] = self.totalTalkTime!
                    }
                    if self.totalWorkTime != nil {
                        map["TotalWorkTime"] = self.totalWorkTime!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AnswerRate") && dict["AnswerRate"] != nil {
                        self.answerRate = dict["AnswerRate"] as! Double
                    }
                    if dict.keys.contains("AverageDialingTime") && dict["AverageDialingTime"] != nil {
                        self.averageDialingTime = dict["AverageDialingTime"] as! Double
                    }
                    if dict.keys.contains("AverageHoldTime") && dict["AverageHoldTime"] != nil {
                        self.averageHoldTime = dict["AverageHoldTime"] as! Double
                    }
                    if dict.keys.contains("AverageRingTime") && dict["AverageRingTime"] != nil {
                        self.averageRingTime = dict["AverageRingTime"] as! Double
                    }
                    if dict.keys.contains("AverageTalkTime") && dict["AverageTalkTime"] != nil {
                        self.averageTalkTime = dict["AverageTalkTime"] as! Double
                    }
                    if dict.keys.contains("AverageWorkTime") && dict["AverageWorkTime"] != nil {
                        self.averageWorkTime = dict["AverageWorkTime"] as! Double
                    }
                    if dict.keys.contains("CallsAnswered") && dict["CallsAnswered"] != nil {
                        self.callsAnswered = dict["CallsAnswered"] as! Int64
                    }
                    if dict.keys.contains("CallsAttendedTransferIn") && dict["CallsAttendedTransferIn"] != nil {
                        self.callsAttendedTransferIn = dict["CallsAttendedTransferIn"] as! Int64
                    }
                    if dict.keys.contains("CallsAttendedTransferOut") && dict["CallsAttendedTransferOut"] != nil {
                        self.callsAttendedTransferOut = dict["CallsAttendedTransferOut"] as! Int64
                    }
                    if dict.keys.contains("CallsBlindTransferIn") && dict["CallsBlindTransferIn"] != nil {
                        self.callsBlindTransferIn = dict["CallsBlindTransferIn"] as! Int64
                    }
                    if dict.keys.contains("CallsBlindTransferOut") && dict["CallsBlindTransferOut"] != nil {
                        self.callsBlindTransferOut = dict["CallsBlindTransferOut"] as! Int64
                    }
                    if dict.keys.contains("CallsDialed") && dict["CallsDialed"] != nil {
                        self.callsDialed = dict["CallsDialed"] as! Int64
                    }
                    if dict.keys.contains("CallsHold") && dict["CallsHold"] != nil {
                        self.callsHold = dict["CallsHold"] as! Int64
                    }
                    if dict.keys.contains("CallsRinged") && dict["CallsRinged"] != nil {
                        self.callsRinged = dict["CallsRinged"] as! Int64
                    }
                    if dict.keys.contains("MaxDialingTime") && dict["MaxDialingTime"] != nil {
                        self.maxDialingTime = dict["MaxDialingTime"] as! Int64
                    }
                    if dict.keys.contains("MaxHoldTime") && dict["MaxHoldTime"] != nil {
                        self.maxHoldTime = dict["MaxHoldTime"] as! Int64
                    }
                    if dict.keys.contains("MaxRingTime") && dict["MaxRingTime"] != nil {
                        self.maxRingTime = dict["MaxRingTime"] as! Int64
                    }
                    if dict.keys.contains("MaxTalkTime") && dict["MaxTalkTime"] != nil {
                        self.maxTalkTime = dict["MaxTalkTime"] as! Int64
                    }
                    if dict.keys.contains("MaxWorkTime") && dict["MaxWorkTime"] != nil {
                        self.maxWorkTime = dict["MaxWorkTime"] as! Int64
                    }
                    if dict.keys.contains("SatisfactionIndex") && dict["SatisfactionIndex"] != nil {
                        self.satisfactionIndex = dict["SatisfactionIndex"] as! Double
                    }
                    if dict.keys.contains("SatisfactionRate") && dict["SatisfactionRate"] != nil {
                        self.satisfactionRate = dict["SatisfactionRate"] as! Double
                    }
                    if dict.keys.contains("SatisfactionSurveysOffered") && dict["SatisfactionSurveysOffered"] != nil {
                        self.satisfactionSurveysOffered = dict["SatisfactionSurveysOffered"] as! Int64
                    }
                    if dict.keys.contains("SatisfactionSurveysResponded") && dict["SatisfactionSurveysResponded"] != nil {
                        self.satisfactionSurveysResponded = dict["SatisfactionSurveysResponded"] as! Int64
                    }
                    if dict.keys.contains("TotalDialingTime") && dict["TotalDialingTime"] != nil {
                        self.totalDialingTime = dict["TotalDialingTime"] as! Int64
                    }
                    if dict.keys.contains("TotalHoldTime") && dict["TotalHoldTime"] != nil {
                        self.totalHoldTime = dict["TotalHoldTime"] as! Int64
                    }
                    if dict.keys.contains("TotalRingTime") && dict["TotalRingTime"] != nil {
                        self.totalRingTime = dict["TotalRingTime"] as! Int64
                    }
                    if dict.keys.contains("TotalTalkTime") && dict["TotalTalkTime"] != nil {
                        self.totalTalkTime = dict["TotalTalkTime"] as! Int64
                    }
                    if dict.keys.contains("TotalWorkTime") && dict["TotalWorkTime"] != nil {
                        self.totalWorkTime = dict["TotalWorkTime"] as! Int64
                    }
                }
            }
            public class Overall : Tea.TeaModel {
                public var averageBreakTime: Double?

                public var averageHoldTime: Double?

                public var averageReadyTime: Double?

                public var averageTalkTime: Double?

                public var averageWorkTime: Double?

                public var maxBreakTime: Int64?

                public var maxHoldTime: Int64?

                public var maxReadyTime: Int64?

                public var maxTalkTime: Int64?

                public var maxWorkTime: Int64?

                public var occupancyRate: Double?

                public var satisfactionIndex: Double?

                public var satisfactionRate: Double?

                public var satisfactionSurveysOffered: Int64?

                public var satisfactionSurveysResponded: Int64?

                public var totalBreakTime: Int64?

                public var totalCalls: Int64?

                public var totalHoldTime: Int64?

                public var totalLoggedInTime: Int64?

                public var totalReadyTime: Int64?

                public var totalTalkTime: Int64?

                public var totalWorkTime: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.averageBreakTime != nil {
                        map["AverageBreakTime"] = self.averageBreakTime!
                    }
                    if self.averageHoldTime != nil {
                        map["AverageHoldTime"] = self.averageHoldTime!
                    }
                    if self.averageReadyTime != nil {
                        map["AverageReadyTime"] = self.averageReadyTime!
                    }
                    if self.averageTalkTime != nil {
                        map["AverageTalkTime"] = self.averageTalkTime!
                    }
                    if self.averageWorkTime != nil {
                        map["AverageWorkTime"] = self.averageWorkTime!
                    }
                    if self.maxBreakTime != nil {
                        map["MaxBreakTime"] = self.maxBreakTime!
                    }
                    if self.maxHoldTime != nil {
                        map["MaxHoldTime"] = self.maxHoldTime!
                    }
                    if self.maxReadyTime != nil {
                        map["MaxReadyTime"] = self.maxReadyTime!
                    }
                    if self.maxTalkTime != nil {
                        map["MaxTalkTime"] = self.maxTalkTime!
                    }
                    if self.maxWorkTime != nil {
                        map["MaxWorkTime"] = self.maxWorkTime!
                    }
                    if self.occupancyRate != nil {
                        map["OccupancyRate"] = self.occupancyRate!
                    }
                    if self.satisfactionIndex != nil {
                        map["SatisfactionIndex"] = self.satisfactionIndex!
                    }
                    if self.satisfactionRate != nil {
                        map["SatisfactionRate"] = self.satisfactionRate!
                    }
                    if self.satisfactionSurveysOffered != nil {
                        map["SatisfactionSurveysOffered"] = self.satisfactionSurveysOffered!
                    }
                    if self.satisfactionSurveysResponded != nil {
                        map["SatisfactionSurveysResponded"] = self.satisfactionSurveysResponded!
                    }
                    if self.totalBreakTime != nil {
                        map["TotalBreakTime"] = self.totalBreakTime!
                    }
                    if self.totalCalls != nil {
                        map["TotalCalls"] = self.totalCalls!
                    }
                    if self.totalHoldTime != nil {
                        map["TotalHoldTime"] = self.totalHoldTime!
                    }
                    if self.totalLoggedInTime != nil {
                        map["TotalLoggedInTime"] = self.totalLoggedInTime!
                    }
                    if self.totalReadyTime != nil {
                        map["TotalReadyTime"] = self.totalReadyTime!
                    }
                    if self.totalTalkTime != nil {
                        map["TotalTalkTime"] = self.totalTalkTime!
                    }
                    if self.totalWorkTime != nil {
                        map["TotalWorkTime"] = self.totalWorkTime!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AverageBreakTime") && dict["AverageBreakTime"] != nil {
                        self.averageBreakTime = dict["AverageBreakTime"] as! Double
                    }
                    if dict.keys.contains("AverageHoldTime") && dict["AverageHoldTime"] != nil {
                        self.averageHoldTime = dict["AverageHoldTime"] as! Double
                    }
                    if dict.keys.contains("AverageReadyTime") && dict["AverageReadyTime"] != nil {
                        self.averageReadyTime = dict["AverageReadyTime"] as! Double
                    }
                    if dict.keys.contains("AverageTalkTime") && dict["AverageTalkTime"] != nil {
                        self.averageTalkTime = dict["AverageTalkTime"] as! Double
                    }
                    if dict.keys.contains("AverageWorkTime") && dict["AverageWorkTime"] != nil {
                        self.averageWorkTime = dict["AverageWorkTime"] as! Double
                    }
                    if dict.keys.contains("MaxBreakTime") && dict["MaxBreakTime"] != nil {
                        self.maxBreakTime = dict["MaxBreakTime"] as! Int64
                    }
                    if dict.keys.contains("MaxHoldTime") && dict["MaxHoldTime"] != nil {
                        self.maxHoldTime = dict["MaxHoldTime"] as! Int64
                    }
                    if dict.keys.contains("MaxReadyTime") && dict["MaxReadyTime"] != nil {
                        self.maxReadyTime = dict["MaxReadyTime"] as! Int64
                    }
                    if dict.keys.contains("MaxTalkTime") && dict["MaxTalkTime"] != nil {
                        self.maxTalkTime = dict["MaxTalkTime"] as! Int64
                    }
                    if dict.keys.contains("MaxWorkTime") && dict["MaxWorkTime"] != nil {
                        self.maxWorkTime = dict["MaxWorkTime"] as! Int64
                    }
                    if dict.keys.contains("OccupancyRate") && dict["OccupancyRate"] != nil {
                        self.occupancyRate = dict["OccupancyRate"] as! Double
                    }
                    if dict.keys.contains("SatisfactionIndex") && dict["SatisfactionIndex"] != nil {
                        self.satisfactionIndex = dict["SatisfactionIndex"] as! Double
                    }
                    if dict.keys.contains("SatisfactionRate") && dict["SatisfactionRate"] != nil {
                        self.satisfactionRate = dict["SatisfactionRate"] as! Double
                    }
                    if dict.keys.contains("SatisfactionSurveysOffered") && dict["SatisfactionSurveysOffered"] != nil {
                        self.satisfactionSurveysOffered = dict["SatisfactionSurveysOffered"] as! Int64
                    }
                    if dict.keys.contains("SatisfactionSurveysResponded") && dict["SatisfactionSurveysResponded"] != nil {
                        self.satisfactionSurveysResponded = dict["SatisfactionSurveysResponded"] as! Int64
                    }
                    if dict.keys.contains("TotalBreakTime") && dict["TotalBreakTime"] != nil {
                        self.totalBreakTime = dict["TotalBreakTime"] as! Int64
                    }
                    if dict.keys.contains("TotalCalls") && dict["TotalCalls"] != nil {
                        self.totalCalls = dict["TotalCalls"] as! Int64
                    }
                    if dict.keys.contains("TotalHoldTime") && dict["TotalHoldTime"] != nil {
                        self.totalHoldTime = dict["TotalHoldTime"] as! Int64
                    }
                    if dict.keys.contains("TotalLoggedInTime") && dict["TotalLoggedInTime"] != nil {
                        self.totalLoggedInTime = dict["TotalLoggedInTime"] as! Int64
                    }
                    if dict.keys.contains("TotalReadyTime") && dict["TotalReadyTime"] != nil {
                        self.totalReadyTime = dict["TotalReadyTime"] as! Int64
                    }
                    if dict.keys.contains("TotalTalkTime") && dict["TotalTalkTime"] != nil {
                        self.totalTalkTime = dict["TotalTalkTime"] as! Int64
                    }
                    if dict.keys.contains("TotalWorkTime") && dict["TotalWorkTime"] != nil {
                        self.totalWorkTime = dict["TotalWorkTime"] as! Int64
                    }
                }
            }
            public var agentId: String?

            public var agentName: String?

            public var displayId: String?

            public var inbound: ListHistoricalAgentReportResponseBody.Data.List.Inbound?

            public var outbound: ListHistoricalAgentReportResponseBody.Data.List.Outbound?

            public var overall: ListHistoricalAgentReportResponseBody.Data.List.Overall?

            public var skillGroupIds: String?

            public var skillGroupNames: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.inbound?.validate()
                try self.outbound?.validate()
                try self.overall?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.agentId != nil {
                    map["AgentId"] = self.agentId!
                }
                if self.agentName != nil {
                    map["AgentName"] = self.agentName!
                }
                if self.displayId != nil {
                    map["DisplayId"] = self.displayId!
                }
                if self.inbound != nil {
                    map["Inbound"] = self.inbound?.toMap()
                }
                if self.outbound != nil {
                    map["Outbound"] = self.outbound?.toMap()
                }
                if self.overall != nil {
                    map["Overall"] = self.overall?.toMap()
                }
                if self.skillGroupIds != nil {
                    map["SkillGroupIds"] = self.skillGroupIds!
                }
                if self.skillGroupNames != nil {
                    map["SkillGroupNames"] = self.skillGroupNames!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AgentId") && dict["AgentId"] != nil {
                    self.agentId = dict["AgentId"] as! String
                }
                if dict.keys.contains("AgentName") && dict["AgentName"] != nil {
                    self.agentName = dict["AgentName"] as! String
                }
                if dict.keys.contains("DisplayId") && dict["DisplayId"] != nil {
                    self.displayId = dict["DisplayId"] as! String
                }
                if dict.keys.contains("Inbound") && dict["Inbound"] != nil {
                    var model = ListHistoricalAgentReportResponseBody.Data.List.Inbound()
                    model.fromMap(dict["Inbound"] as! [String: Any])
                    self.inbound = model
                }
                if dict.keys.contains("Outbound") && dict["Outbound"] != nil {
                    var model = ListHistoricalAgentReportResponseBody.Data.List.Outbound()
                    model.fromMap(dict["Outbound"] as! [String: Any])
                    self.outbound = model
                }
                if dict.keys.contains("Overall") && dict["Overall"] != nil {
                    var model = ListHistoricalAgentReportResponseBody.Data.List.Overall()
                    model.fromMap(dict["Overall"] as! [String: Any])
                    self.overall = model
                }
                if dict.keys.contains("SkillGroupIds") && dict["SkillGroupIds"] != nil {
                    self.skillGroupIds = dict["SkillGroupIds"] as! String
                }
                if dict.keys.contains("SkillGroupNames") && dict["SkillGroupNames"] != nil {
                    self.skillGroupNames = dict["SkillGroupNames"] as! String
                }
            }
        }
        public var list: [ListHistoricalAgentReportResponseBody.Data.List]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.list != nil {
                var tmp : [Any] = []
                for k in self.list! {
                    tmp.append(k.toMap())
                }
                map["List"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("List") && dict["List"] != nil {
                var tmp : [ListHistoricalAgentReportResponseBody.Data.List] = []
                for v in dict["List"] as! [Any] {
                    var model = ListHistoricalAgentReportResponseBody.Data.List()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.list = tmp
            }
            if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var code: String?

    public var data: ListHistoricalAgentReportResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = ListHistoricalAgentReportResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListHistoricalAgentReportResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListHistoricalAgentReportResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListHistoricalAgentReportResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListHistoricalSkillGroupReportRequest : Tea.TeaModel {
    public var endTime: Int64?

    public var instanceId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var skillGroupIdList: String?

    public var startTime: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.skillGroupIdList != nil {
            map["SkillGroupIdList"] = self.skillGroupIdList!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SkillGroupIdList") && dict["SkillGroupIdList"] != nil {
            self.skillGroupIdList = dict["SkillGroupIdList"] as! String
        }
        if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
            self.startTime = dict["StartTime"] as! Int64
        }
    }
}

public class ListHistoricalSkillGroupReportResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class List : Tea.TeaModel {
            public class Inbound : Tea.TeaModel {
                public var abandonRate: Double?

                public var averageAbandonTime: Double?

                public var averageAbandonedInQueueTime: Double?

                public var averageAbandonedInRingTime: Double?

                public var averageHoldTime: Double?

                public var averageRingTime: Double?

                public var averageTalkTime: Double?

                public var averageWaitTime: Double?

                public var averageWorkTime: Double?

                public var callsAbandoned: Int64?

                public var callsAbandonedInQueue: Int64?

                public var callsAbandonedInRing: Int64?

                public var callsAttendedTransferIn: Int64?

                public var callsAttendedTransferOut: Int64?

                public var callsBlindTransferIn: Int64?

                public var callsBlindTransferOut: Int64?

                public var callsHandled: Int64?

                public var callsHold: Int64?

                public var callsOffered: Int64?

                public var callsOverflow: Int64?

                public var callsQueued: Int64?

                public var callsRinged: Int64?

                public var callsTimeout: Int64?

                public var handleRate: Double?

                public var maxAbandonTime: Int64?

                public var maxAbandonedInQueueTime: Int64?

                public var maxAbandonedInRingTime: Int64?

                public var maxHoldTime: Int64?

                public var maxRingTime: Int64?

                public var maxTalkTime: Int64?

                public var maxWaitTime: Int64?

                public var maxWorkTime: Int64?

                public var satisfactionIndex: Double?

                public var satisfactionRate: Double?

                public var satisfactionSurveysOffered: Int64?

                public var satisfactionSurveysResponded: Int64?

                public var serviceLevel20: Double?

                public var totalAbandonTime: Int64?

                public var totalAbandonedInQueueTime: Int64?

                public var totalAbandonedInRingTime: Int64?

                public var totalHoldTime: Int64?

                public var totalRingTime: Int64?

                public var totalTalkTime: Int64?

                public var totalWaitTime: Int64?

                public var totalWorkTime: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.abandonRate != nil {
                        map["AbandonRate"] = self.abandonRate!
                    }
                    if self.averageAbandonTime != nil {
                        map["AverageAbandonTime"] = self.averageAbandonTime!
                    }
                    if self.averageAbandonedInQueueTime != nil {
                        map["AverageAbandonedInQueueTime"] = self.averageAbandonedInQueueTime!
                    }
                    if self.averageAbandonedInRingTime != nil {
                        map["AverageAbandonedInRingTime"] = self.averageAbandonedInRingTime!
                    }
                    if self.averageHoldTime != nil {
                        map["AverageHoldTime"] = self.averageHoldTime!
                    }
                    if self.averageRingTime != nil {
                        map["AverageRingTime"] = self.averageRingTime!
                    }
                    if self.averageTalkTime != nil {
                        map["AverageTalkTime"] = self.averageTalkTime!
                    }
                    if self.averageWaitTime != nil {
                        map["AverageWaitTime"] = self.averageWaitTime!
                    }
                    if self.averageWorkTime != nil {
                        map["AverageWorkTime"] = self.averageWorkTime!
                    }
                    if self.callsAbandoned != nil {
                        map["CallsAbandoned"] = self.callsAbandoned!
                    }
                    if self.callsAbandonedInQueue != nil {
                        map["CallsAbandonedInQueue"] = self.callsAbandonedInQueue!
                    }
                    if self.callsAbandonedInRing != nil {
                        map["CallsAbandonedInRing"] = self.callsAbandonedInRing!
                    }
                    if self.callsAttendedTransferIn != nil {
                        map["CallsAttendedTransferIn"] = self.callsAttendedTransferIn!
                    }
                    if self.callsAttendedTransferOut != nil {
                        map["CallsAttendedTransferOut"] = self.callsAttendedTransferOut!
                    }
                    if self.callsBlindTransferIn != nil {
                        map["CallsBlindTransferIn"] = self.callsBlindTransferIn!
                    }
                    if self.callsBlindTransferOut != nil {
                        map["CallsBlindTransferOut"] = self.callsBlindTransferOut!
                    }
                    if self.callsHandled != nil {
                        map["CallsHandled"] = self.callsHandled!
                    }
                    if self.callsHold != nil {
                        map["CallsHold"] = self.callsHold!
                    }
                    if self.callsOffered != nil {
                        map["CallsOffered"] = self.callsOffered!
                    }
                    if self.callsOverflow != nil {
                        map["CallsOverflow"] = self.callsOverflow!
                    }
                    if self.callsQueued != nil {
                        map["CallsQueued"] = self.callsQueued!
                    }
                    if self.callsRinged != nil {
                        map["CallsRinged"] = self.callsRinged!
                    }
                    if self.callsTimeout != nil {
                        map["CallsTimeout"] = self.callsTimeout!
                    }
                    if self.handleRate != nil {
                        map["HandleRate"] = self.handleRate!
                    }
                    if self.maxAbandonTime != nil {
                        map["MaxAbandonTime"] = self.maxAbandonTime!
                    }
                    if self.maxAbandonedInQueueTime != nil {
                        map["MaxAbandonedInQueueTime"] = self.maxAbandonedInQueueTime!
                    }
                    if self.maxAbandonedInRingTime != nil {
                        map["MaxAbandonedInRingTime"] = self.maxAbandonedInRingTime!
                    }
                    if self.maxHoldTime != nil {
                        map["MaxHoldTime"] = self.maxHoldTime!
                    }
                    if self.maxRingTime != nil {
                        map["MaxRingTime"] = self.maxRingTime!
                    }
                    if self.maxTalkTime != nil {
                        map["MaxTalkTime"] = self.maxTalkTime!
                    }
                    if self.maxWaitTime != nil {
                        map["MaxWaitTime"] = self.maxWaitTime!
                    }
                    if self.maxWorkTime != nil {
                        map["MaxWorkTime"] = self.maxWorkTime!
                    }
                    if self.satisfactionIndex != nil {
                        map["SatisfactionIndex"] = self.satisfactionIndex!
                    }
                    if self.satisfactionRate != nil {
                        map["SatisfactionRate"] = self.satisfactionRate!
                    }
                    if self.satisfactionSurveysOffered != nil {
                        map["SatisfactionSurveysOffered"] = self.satisfactionSurveysOffered!
                    }
                    if self.satisfactionSurveysResponded != nil {
                        map["SatisfactionSurveysResponded"] = self.satisfactionSurveysResponded!
                    }
                    if self.serviceLevel20 != nil {
                        map["ServiceLevel20"] = self.serviceLevel20!
                    }
                    if self.totalAbandonTime != nil {
                        map["TotalAbandonTime"] = self.totalAbandonTime!
                    }
                    if self.totalAbandonedInQueueTime != nil {
                        map["TotalAbandonedInQueueTime"] = self.totalAbandonedInQueueTime!
                    }
                    if self.totalAbandonedInRingTime != nil {
                        map["TotalAbandonedInRingTime"] = self.totalAbandonedInRingTime!
                    }
                    if self.totalHoldTime != nil {
                        map["TotalHoldTime"] = self.totalHoldTime!
                    }
                    if self.totalRingTime != nil {
                        map["TotalRingTime"] = self.totalRingTime!
                    }
                    if self.totalTalkTime != nil {
                        map["TotalTalkTime"] = self.totalTalkTime!
                    }
                    if self.totalWaitTime != nil {
                        map["TotalWaitTime"] = self.totalWaitTime!
                    }
                    if self.totalWorkTime != nil {
                        map["TotalWorkTime"] = self.totalWorkTime!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AbandonRate") && dict["AbandonRate"] != nil {
                        self.abandonRate = dict["AbandonRate"] as! Double
                    }
                    if dict.keys.contains("AverageAbandonTime") && dict["AverageAbandonTime"] != nil {
                        self.averageAbandonTime = dict["AverageAbandonTime"] as! Double
                    }
                    if dict.keys.contains("AverageAbandonedInQueueTime") && dict["AverageAbandonedInQueueTime"] != nil {
                        self.averageAbandonedInQueueTime = dict["AverageAbandonedInQueueTime"] as! Double
                    }
                    if dict.keys.contains("AverageAbandonedInRingTime") && dict["AverageAbandonedInRingTime"] != nil {
                        self.averageAbandonedInRingTime = dict["AverageAbandonedInRingTime"] as! Double
                    }
                    if dict.keys.contains("AverageHoldTime") && dict["AverageHoldTime"] != nil {
                        self.averageHoldTime = dict["AverageHoldTime"] as! Double
                    }
                    if dict.keys.contains("AverageRingTime") && dict["AverageRingTime"] != nil {
                        self.averageRingTime = dict["AverageRingTime"] as! Double
                    }
                    if dict.keys.contains("AverageTalkTime") && dict["AverageTalkTime"] != nil {
                        self.averageTalkTime = dict["AverageTalkTime"] as! Double
                    }
                    if dict.keys.contains("AverageWaitTime") && dict["AverageWaitTime"] != nil {
                        self.averageWaitTime = dict["AverageWaitTime"] as! Double
                    }
                    if dict.keys.contains("AverageWorkTime") && dict["AverageWorkTime"] != nil {
                        self.averageWorkTime = dict["AverageWorkTime"] as! Double
                    }
                    if dict.keys.contains("CallsAbandoned") && dict["CallsAbandoned"] != nil {
                        self.callsAbandoned = dict["CallsAbandoned"] as! Int64
                    }
                    if dict.keys.contains("CallsAbandonedInQueue") && dict["CallsAbandonedInQueue"] != nil {
                        self.callsAbandonedInQueue = dict["CallsAbandonedInQueue"] as! Int64
                    }
                    if dict.keys.contains("CallsAbandonedInRing") && dict["CallsAbandonedInRing"] != nil {
                        self.callsAbandonedInRing = dict["CallsAbandonedInRing"] as! Int64
                    }
                    if dict.keys.contains("CallsAttendedTransferIn") && dict["CallsAttendedTransferIn"] != nil {
                        self.callsAttendedTransferIn = dict["CallsAttendedTransferIn"] as! Int64
                    }
                    if dict.keys.contains("CallsAttendedTransferOut") && dict["CallsAttendedTransferOut"] != nil {
                        self.callsAttendedTransferOut = dict["CallsAttendedTransferOut"] as! Int64
                    }
                    if dict.keys.contains("CallsBlindTransferIn") && dict["CallsBlindTransferIn"] != nil {
                        self.callsBlindTransferIn = dict["CallsBlindTransferIn"] as! Int64
                    }
                    if dict.keys.contains("CallsBlindTransferOut") && dict["CallsBlindTransferOut"] != nil {
                        self.callsBlindTransferOut = dict["CallsBlindTransferOut"] as! Int64
                    }
                    if dict.keys.contains("CallsHandled") && dict["CallsHandled"] != nil {
                        self.callsHandled = dict["CallsHandled"] as! Int64
                    }
                    if dict.keys.contains("CallsHold") && dict["CallsHold"] != nil {
                        self.callsHold = dict["CallsHold"] as! Int64
                    }
                    if dict.keys.contains("CallsOffered") && dict["CallsOffered"] != nil {
                        self.callsOffered = dict["CallsOffered"] as! Int64
                    }
                    if dict.keys.contains("CallsOverflow") && dict["CallsOverflow"] != nil {
                        self.callsOverflow = dict["CallsOverflow"] as! Int64
                    }
                    if dict.keys.contains("CallsQueued") && dict["CallsQueued"] != nil {
                        self.callsQueued = dict["CallsQueued"] as! Int64
                    }
                    if dict.keys.contains("CallsRinged") && dict["CallsRinged"] != nil {
                        self.callsRinged = dict["CallsRinged"] as! Int64
                    }
                    if dict.keys.contains("CallsTimeout") && dict["CallsTimeout"] != nil {
                        self.callsTimeout = dict["CallsTimeout"] as! Int64
                    }
                    if dict.keys.contains("HandleRate") && dict["HandleRate"] != nil {
                        self.handleRate = dict["HandleRate"] as! Double
                    }
                    if dict.keys.contains("MaxAbandonTime") && dict["MaxAbandonTime"] != nil {
                        self.maxAbandonTime = dict["MaxAbandonTime"] as! Int64
                    }
                    if dict.keys.contains("MaxAbandonedInQueueTime") && dict["MaxAbandonedInQueueTime"] != nil {
                        self.maxAbandonedInQueueTime = dict["MaxAbandonedInQueueTime"] as! Int64
                    }
                    if dict.keys.contains("MaxAbandonedInRingTime") && dict["MaxAbandonedInRingTime"] != nil {
                        self.maxAbandonedInRingTime = dict["MaxAbandonedInRingTime"] as! Int64
                    }
                    if dict.keys.contains("MaxHoldTime") && dict["MaxHoldTime"] != nil {
                        self.maxHoldTime = dict["MaxHoldTime"] as! Int64
                    }
                    if dict.keys.contains("MaxRingTime") && dict["MaxRingTime"] != nil {
                        self.maxRingTime = dict["MaxRingTime"] as! Int64
                    }
                    if dict.keys.contains("MaxTalkTime") && dict["MaxTalkTime"] != nil {
                        self.maxTalkTime = dict["MaxTalkTime"] as! Int64
                    }
                    if dict.keys.contains("MaxWaitTime") && dict["MaxWaitTime"] != nil {
                        self.maxWaitTime = dict["MaxWaitTime"] as! Int64
                    }
                    if dict.keys.contains("MaxWorkTime") && dict["MaxWorkTime"] != nil {
                        self.maxWorkTime = dict["MaxWorkTime"] as! Int64
                    }
                    if dict.keys.contains("SatisfactionIndex") && dict["SatisfactionIndex"] != nil {
                        self.satisfactionIndex = dict["SatisfactionIndex"] as! Double
                    }
                    if dict.keys.contains("SatisfactionRate") && dict["SatisfactionRate"] != nil {
                        self.satisfactionRate = dict["SatisfactionRate"] as! Double
                    }
                    if dict.keys.contains("SatisfactionSurveysOffered") && dict["SatisfactionSurveysOffered"] != nil {
                        self.satisfactionSurveysOffered = dict["SatisfactionSurveysOffered"] as! Int64
                    }
                    if dict.keys.contains("SatisfactionSurveysResponded") && dict["SatisfactionSurveysResponded"] != nil {
                        self.satisfactionSurveysResponded = dict["SatisfactionSurveysResponded"] as! Int64
                    }
                    if dict.keys.contains("ServiceLevel20") && dict["ServiceLevel20"] != nil {
                        self.serviceLevel20 = dict["ServiceLevel20"] as! Double
                    }
                    if dict.keys.contains("TotalAbandonTime") && dict["TotalAbandonTime"] != nil {
                        self.totalAbandonTime = dict["TotalAbandonTime"] as! Int64
                    }
                    if dict.keys.contains("TotalAbandonedInQueueTime") && dict["TotalAbandonedInQueueTime"] != nil {
                        self.totalAbandonedInQueueTime = dict["TotalAbandonedInQueueTime"] as! Int64
                    }
                    if dict.keys.contains("TotalAbandonedInRingTime") && dict["TotalAbandonedInRingTime"] != nil {
                        self.totalAbandonedInRingTime = dict["TotalAbandonedInRingTime"] as! Int64
                    }
                    if dict.keys.contains("TotalHoldTime") && dict["TotalHoldTime"] != nil {
                        self.totalHoldTime = dict["TotalHoldTime"] as! Int64
                    }
                    if dict.keys.contains("TotalRingTime") && dict["TotalRingTime"] != nil {
                        self.totalRingTime = dict["TotalRingTime"] as! Int64
                    }
                    if dict.keys.contains("TotalTalkTime") && dict["TotalTalkTime"] != nil {
                        self.totalTalkTime = dict["TotalTalkTime"] as! Int64
                    }
                    if dict.keys.contains("TotalWaitTime") && dict["TotalWaitTime"] != nil {
                        self.totalWaitTime = dict["TotalWaitTime"] as! Int64
                    }
                    if dict.keys.contains("TotalWorkTime") && dict["TotalWorkTime"] != nil {
                        self.totalWorkTime = dict["TotalWorkTime"] as! Int64
                    }
                }
            }
            public class Outbound : Tea.TeaModel {
                public var answerRate: Double?

                public var averageDialingTime: Double?

                public var averageHoldTime: Double?

                public var averageRingTime: Double?

                public var averageTalkTime: Double?

                public var averageWorkTime: Double?

                public var callsAnswered: Int64?

                public var callsAttendedTransferIn: Int64?

                public var callsAttendedTransferOut: Int64?

                public var callsBlindTransferIn: Int64?

                public var callsBlindTransferOut: Int64?

                public var callsDialed: Int64?

                public var callsHold: Int64?

                public var callsRinged: Int64?

                public var maxDialingTime: Int64?

                public var maxHoldTime: Int64?

                public var maxRingTime: Int64?

                public var maxTalkTime: Int64?

                public var maxWorkTime: Int64?

                public var satisfactionIndex: Double?

                public var satisfactionRate: Double?

                public var satisfactionSurveysOffered: Int64?

                public var satisfactionSurveysResponded: Int64?

                public var totalDialingTime: Int64?

                public var totalHoldTime: Int64?

                public var totalRingTime: Int64?

                public var totalTalkTime: Int64?

                public var totalWorkTime: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.answerRate != nil {
                        map["AnswerRate"] = self.answerRate!
                    }
                    if self.averageDialingTime != nil {
                        map["AverageDialingTime"] = self.averageDialingTime!
                    }
                    if self.averageHoldTime != nil {
                        map["AverageHoldTime"] = self.averageHoldTime!
                    }
                    if self.averageRingTime != nil {
                        map["AverageRingTime"] = self.averageRingTime!
                    }
                    if self.averageTalkTime != nil {
                        map["AverageTalkTime"] = self.averageTalkTime!
                    }
                    if self.averageWorkTime != nil {
                        map["AverageWorkTime"] = self.averageWorkTime!
                    }
                    if self.callsAnswered != nil {
                        map["CallsAnswered"] = self.callsAnswered!
                    }
                    if self.callsAttendedTransferIn != nil {
                        map["CallsAttendedTransferIn"] = self.callsAttendedTransferIn!
                    }
                    if self.callsAttendedTransferOut != nil {
                        map["CallsAttendedTransferOut"] = self.callsAttendedTransferOut!
                    }
                    if self.callsBlindTransferIn != nil {
                        map["CallsBlindTransferIn"] = self.callsBlindTransferIn!
                    }
                    if self.callsBlindTransferOut != nil {
                        map["CallsBlindTransferOut"] = self.callsBlindTransferOut!
                    }
                    if self.callsDialed != nil {
                        map["CallsDialed"] = self.callsDialed!
                    }
                    if self.callsHold != nil {
                        map["CallsHold"] = self.callsHold!
                    }
                    if self.callsRinged != nil {
                        map["CallsRinged"] = self.callsRinged!
                    }
                    if self.maxDialingTime != nil {
                        map["MaxDialingTime"] = self.maxDialingTime!
                    }
                    if self.maxHoldTime != nil {
                        map["MaxHoldTime"] = self.maxHoldTime!
                    }
                    if self.maxRingTime != nil {
                        map["MaxRingTime"] = self.maxRingTime!
                    }
                    if self.maxTalkTime != nil {
                        map["MaxTalkTime"] = self.maxTalkTime!
                    }
                    if self.maxWorkTime != nil {
                        map["MaxWorkTime"] = self.maxWorkTime!
                    }
                    if self.satisfactionIndex != nil {
                        map["SatisfactionIndex"] = self.satisfactionIndex!
                    }
                    if self.satisfactionRate != nil {
                        map["SatisfactionRate"] = self.satisfactionRate!
                    }
                    if self.satisfactionSurveysOffered != nil {
                        map["SatisfactionSurveysOffered"] = self.satisfactionSurveysOffered!
                    }
                    if self.satisfactionSurveysResponded != nil {
                        map["SatisfactionSurveysResponded"] = self.satisfactionSurveysResponded!
                    }
                    if self.totalDialingTime != nil {
                        map["TotalDialingTime"] = self.totalDialingTime!
                    }
                    if self.totalHoldTime != nil {
                        map["TotalHoldTime"] = self.totalHoldTime!
                    }
                    if self.totalRingTime != nil {
                        map["TotalRingTime"] = self.totalRingTime!
                    }
                    if self.totalTalkTime != nil {
                        map["TotalTalkTime"] = self.totalTalkTime!
                    }
                    if self.totalWorkTime != nil {
                        map["TotalWorkTime"] = self.totalWorkTime!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AnswerRate") && dict["AnswerRate"] != nil {
                        self.answerRate = dict["AnswerRate"] as! Double
                    }
                    if dict.keys.contains("AverageDialingTime") && dict["AverageDialingTime"] != nil {
                        self.averageDialingTime = dict["AverageDialingTime"] as! Double
                    }
                    if dict.keys.contains("AverageHoldTime") && dict["AverageHoldTime"] != nil {
                        self.averageHoldTime = dict["AverageHoldTime"] as! Double
                    }
                    if dict.keys.contains("AverageRingTime") && dict["AverageRingTime"] != nil {
                        self.averageRingTime = dict["AverageRingTime"] as! Double
                    }
                    if dict.keys.contains("AverageTalkTime") && dict["AverageTalkTime"] != nil {
                        self.averageTalkTime = dict["AverageTalkTime"] as! Double
                    }
                    if dict.keys.contains("AverageWorkTime") && dict["AverageWorkTime"] != nil {
                        self.averageWorkTime = dict["AverageWorkTime"] as! Double
                    }
                    if dict.keys.contains("CallsAnswered") && dict["CallsAnswered"] != nil {
                        self.callsAnswered = dict["CallsAnswered"] as! Int64
                    }
                    if dict.keys.contains("CallsAttendedTransferIn") && dict["CallsAttendedTransferIn"] != nil {
                        self.callsAttendedTransferIn = dict["CallsAttendedTransferIn"] as! Int64
                    }
                    if dict.keys.contains("CallsAttendedTransferOut") && dict["CallsAttendedTransferOut"] != nil {
                        self.callsAttendedTransferOut = dict["CallsAttendedTransferOut"] as! Int64
                    }
                    if dict.keys.contains("CallsBlindTransferIn") && dict["CallsBlindTransferIn"] != nil {
                        self.callsBlindTransferIn = dict["CallsBlindTransferIn"] as! Int64
                    }
                    if dict.keys.contains("CallsBlindTransferOut") && dict["CallsBlindTransferOut"] != nil {
                        self.callsBlindTransferOut = dict["CallsBlindTransferOut"] as! Int64
                    }
                    if dict.keys.contains("CallsDialed") && dict["CallsDialed"] != nil {
                        self.callsDialed = dict["CallsDialed"] as! Int64
                    }
                    if dict.keys.contains("CallsHold") && dict["CallsHold"] != nil {
                        self.callsHold = dict["CallsHold"] as! Int64
                    }
                    if dict.keys.contains("CallsRinged") && dict["CallsRinged"] != nil {
                        self.callsRinged = dict["CallsRinged"] as! Int64
                    }
                    if dict.keys.contains("MaxDialingTime") && dict["MaxDialingTime"] != nil {
                        self.maxDialingTime = dict["MaxDialingTime"] as! Int64
                    }
                    if dict.keys.contains("MaxHoldTime") && dict["MaxHoldTime"] != nil {
                        self.maxHoldTime = dict["MaxHoldTime"] as! Int64
                    }
                    if dict.keys.contains("MaxRingTime") && dict["MaxRingTime"] != nil {
                        self.maxRingTime = dict["MaxRingTime"] as! Int64
                    }
                    if dict.keys.contains("MaxTalkTime") && dict["MaxTalkTime"] != nil {
                        self.maxTalkTime = dict["MaxTalkTime"] as! Int64
                    }
                    if dict.keys.contains("MaxWorkTime") && dict["MaxWorkTime"] != nil {
                        self.maxWorkTime = dict["MaxWorkTime"] as! Int64
                    }
                    if dict.keys.contains("SatisfactionIndex") && dict["SatisfactionIndex"] != nil {
                        self.satisfactionIndex = dict["SatisfactionIndex"] as! Double
                    }
                    if dict.keys.contains("SatisfactionRate") && dict["SatisfactionRate"] != nil {
                        self.satisfactionRate = dict["SatisfactionRate"] as! Double
                    }
                    if dict.keys.contains("SatisfactionSurveysOffered") && dict["SatisfactionSurveysOffered"] != nil {
                        self.satisfactionSurveysOffered = dict["SatisfactionSurveysOffered"] as! Int64
                    }
                    if dict.keys.contains("SatisfactionSurveysResponded") && dict["SatisfactionSurveysResponded"] != nil {
                        self.satisfactionSurveysResponded = dict["SatisfactionSurveysResponded"] as! Int64
                    }
                    if dict.keys.contains("TotalDialingTime") && dict["TotalDialingTime"] != nil {
                        self.totalDialingTime = dict["TotalDialingTime"] as! Int64
                    }
                    if dict.keys.contains("TotalHoldTime") && dict["TotalHoldTime"] != nil {
                        self.totalHoldTime = dict["TotalHoldTime"] as! Int64
                    }
                    if dict.keys.contains("TotalRingTime") && dict["TotalRingTime"] != nil {
                        self.totalRingTime = dict["TotalRingTime"] as! Int64
                    }
                    if dict.keys.contains("TotalTalkTime") && dict["TotalTalkTime"] != nil {
                        self.totalTalkTime = dict["TotalTalkTime"] as! Int64
                    }
                    if dict.keys.contains("TotalWorkTime") && dict["TotalWorkTime"] != nil {
                        self.totalWorkTime = dict["TotalWorkTime"] as! Int64
                    }
                }
            }
            public class Overall : Tea.TeaModel {
                public var averageBreakTime: Double?

                public var averageHoldTime: Double?

                public var averageReadyTime: Double?

                public var averageTalkTime: Double?

                public var averageWorkTime: Double?

                public var maxBreakTime: Int64?

                public var maxHoldTime: Int64?

                public var maxReadyTime: Int64?

                public var maxTalkTime: Int64?

                public var maxWorkTime: Int64?

                public var occupancyRate: Double?

                public var satisfactionIndex: Double?

                public var satisfactionRate: Double?

                public var satisfactionSurveysOffered: Int64?

                public var satisfactionSurveysResponded: Int64?

                public var totalBreakTime: Int64?

                public var totalCalls: Int64?

                public var totalHoldTime: Int64?

                public var totalLoggedInTime: Int64?

                public var totalReadyTime: Int64?

                public var totalTalkTime: Int64?

                public var totalWorkTime: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.averageBreakTime != nil {
                        map["AverageBreakTime"] = self.averageBreakTime!
                    }
                    if self.averageHoldTime != nil {
                        map["AverageHoldTime"] = self.averageHoldTime!
                    }
                    if self.averageReadyTime != nil {
                        map["AverageReadyTime"] = self.averageReadyTime!
                    }
                    if self.averageTalkTime != nil {
                        map["AverageTalkTime"] = self.averageTalkTime!
                    }
                    if self.averageWorkTime != nil {
                        map["AverageWorkTime"] = self.averageWorkTime!
                    }
                    if self.maxBreakTime != nil {
                        map["MaxBreakTime"] = self.maxBreakTime!
                    }
                    if self.maxHoldTime != nil {
                        map["MaxHoldTime"] = self.maxHoldTime!
                    }
                    if self.maxReadyTime != nil {
                        map["MaxReadyTime"] = self.maxReadyTime!
                    }
                    if self.maxTalkTime != nil {
                        map["MaxTalkTime"] = self.maxTalkTime!
                    }
                    if self.maxWorkTime != nil {
                        map["MaxWorkTime"] = self.maxWorkTime!
                    }
                    if self.occupancyRate != nil {
                        map["OccupancyRate"] = self.occupancyRate!
                    }
                    if self.satisfactionIndex != nil {
                        map["SatisfactionIndex"] = self.satisfactionIndex!
                    }
                    if self.satisfactionRate != nil {
                        map["SatisfactionRate"] = self.satisfactionRate!
                    }
                    if self.satisfactionSurveysOffered != nil {
                        map["SatisfactionSurveysOffered"] = self.satisfactionSurveysOffered!
                    }
                    if self.satisfactionSurveysResponded != nil {
                        map["SatisfactionSurveysResponded"] = self.satisfactionSurveysResponded!
                    }
                    if self.totalBreakTime != nil {
                        map["TotalBreakTime"] = self.totalBreakTime!
                    }
                    if self.totalCalls != nil {
                        map["TotalCalls"] = self.totalCalls!
                    }
                    if self.totalHoldTime != nil {
                        map["TotalHoldTime"] = self.totalHoldTime!
                    }
                    if self.totalLoggedInTime != nil {
                        map["TotalLoggedInTime"] = self.totalLoggedInTime!
                    }
                    if self.totalReadyTime != nil {
                        map["TotalReadyTime"] = self.totalReadyTime!
                    }
                    if self.totalTalkTime != nil {
                        map["TotalTalkTime"] = self.totalTalkTime!
                    }
                    if self.totalWorkTime != nil {
                        map["TotalWorkTime"] = self.totalWorkTime!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AverageBreakTime") && dict["AverageBreakTime"] != nil {
                        self.averageBreakTime = dict["AverageBreakTime"] as! Double
                    }
                    if dict.keys.contains("AverageHoldTime") && dict["AverageHoldTime"] != nil {
                        self.averageHoldTime = dict["AverageHoldTime"] as! Double
                    }
                    if dict.keys.contains("AverageReadyTime") && dict["AverageReadyTime"] != nil {
                        self.averageReadyTime = dict["AverageReadyTime"] as! Double
                    }
                    if dict.keys.contains("AverageTalkTime") && dict["AverageTalkTime"] != nil {
                        self.averageTalkTime = dict["AverageTalkTime"] as! Double
                    }
                    if dict.keys.contains("AverageWorkTime") && dict["AverageWorkTime"] != nil {
                        self.averageWorkTime = dict["AverageWorkTime"] as! Double
                    }
                    if dict.keys.contains("MaxBreakTime") && dict["MaxBreakTime"] != nil {
                        self.maxBreakTime = dict["MaxBreakTime"] as! Int64
                    }
                    if dict.keys.contains("MaxHoldTime") && dict["MaxHoldTime"] != nil {
                        self.maxHoldTime = dict["MaxHoldTime"] as! Int64
                    }
                    if dict.keys.contains("MaxReadyTime") && dict["MaxReadyTime"] != nil {
                        self.maxReadyTime = dict["MaxReadyTime"] as! Int64
                    }
                    if dict.keys.contains("MaxTalkTime") && dict["MaxTalkTime"] != nil {
                        self.maxTalkTime = dict["MaxTalkTime"] as! Int64
                    }
                    if dict.keys.contains("MaxWorkTime") && dict["MaxWorkTime"] != nil {
                        self.maxWorkTime = dict["MaxWorkTime"] as! Int64
                    }
                    if dict.keys.contains("OccupancyRate") && dict["OccupancyRate"] != nil {
                        self.occupancyRate = dict["OccupancyRate"] as! Double
                    }
                    if dict.keys.contains("SatisfactionIndex") && dict["SatisfactionIndex"] != nil {
                        self.satisfactionIndex = dict["SatisfactionIndex"] as! Double
                    }
                    if dict.keys.contains("SatisfactionRate") && dict["SatisfactionRate"] != nil {
                        self.satisfactionRate = dict["SatisfactionRate"] as! Double
                    }
                    if dict.keys.contains("SatisfactionSurveysOffered") && dict["SatisfactionSurveysOffered"] != nil {
                        self.satisfactionSurveysOffered = dict["SatisfactionSurveysOffered"] as! Int64
                    }
                    if dict.keys.contains("SatisfactionSurveysResponded") && dict["SatisfactionSurveysResponded"] != nil {
                        self.satisfactionSurveysResponded = dict["SatisfactionSurveysResponded"] as! Int64
                    }
                    if dict.keys.contains("TotalBreakTime") && dict["TotalBreakTime"] != nil {
                        self.totalBreakTime = dict["TotalBreakTime"] as! Int64
                    }
                    if dict.keys.contains("TotalCalls") && dict["TotalCalls"] != nil {
                        self.totalCalls = dict["TotalCalls"] as! Int64
                    }
                    if dict.keys.contains("TotalHoldTime") && dict["TotalHoldTime"] != nil {
                        self.totalHoldTime = dict["TotalHoldTime"] as! Int64
                    }
                    if dict.keys.contains("TotalLoggedInTime") && dict["TotalLoggedInTime"] != nil {
                        self.totalLoggedInTime = dict["TotalLoggedInTime"] as! Int64
                    }
                    if dict.keys.contains("TotalReadyTime") && dict["TotalReadyTime"] != nil {
                        self.totalReadyTime = dict["TotalReadyTime"] as! Int64
                    }
                    if dict.keys.contains("TotalTalkTime") && dict["TotalTalkTime"] != nil {
                        self.totalTalkTime = dict["TotalTalkTime"] as! Int64
                    }
                    if dict.keys.contains("TotalWorkTime") && dict["TotalWorkTime"] != nil {
                        self.totalWorkTime = dict["TotalWorkTime"] as! Int64
                    }
                }
            }
            public var inbound: ListHistoricalSkillGroupReportResponseBody.Data.List.Inbound?

            public var outbound: ListHistoricalSkillGroupReportResponseBody.Data.List.Outbound?

            public var overall: ListHistoricalSkillGroupReportResponseBody.Data.List.Overall?

            public var skillGroupId: String?

            public var skillGroupName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.inbound?.validate()
                try self.outbound?.validate()
                try self.overall?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.inbound != nil {
                    map["Inbound"] = self.inbound?.toMap()
                }
                if self.outbound != nil {
                    map["Outbound"] = self.outbound?.toMap()
                }
                if self.overall != nil {
                    map["Overall"] = self.overall?.toMap()
                }
                if self.skillGroupId != nil {
                    map["SkillGroupId"] = self.skillGroupId!
                }
                if self.skillGroupName != nil {
                    map["SkillGroupName"] = self.skillGroupName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Inbound") && dict["Inbound"] != nil {
                    var model = ListHistoricalSkillGroupReportResponseBody.Data.List.Inbound()
                    model.fromMap(dict["Inbound"] as! [String: Any])
                    self.inbound = model
                }
                if dict.keys.contains("Outbound") && dict["Outbound"] != nil {
                    var model = ListHistoricalSkillGroupReportResponseBody.Data.List.Outbound()
                    model.fromMap(dict["Outbound"] as! [String: Any])
                    self.outbound = model
                }
                if dict.keys.contains("Overall") && dict["Overall"] != nil {
                    var model = ListHistoricalSkillGroupReportResponseBody.Data.List.Overall()
                    model.fromMap(dict["Overall"] as! [String: Any])
                    self.overall = model
                }
                if dict.keys.contains("SkillGroupId") && dict["SkillGroupId"] != nil {
                    self.skillGroupId = dict["SkillGroupId"] as! String
                }
                if dict.keys.contains("SkillGroupName") && dict["SkillGroupName"] != nil {
                    self.skillGroupName = dict["SkillGroupName"] as! String
                }
            }
        }
        public var list: [ListHistoricalSkillGroupReportResponseBody.Data.List]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.list != nil {
                var tmp : [Any] = []
                for k in self.list! {
                    tmp.append(k.toMap())
                }
                map["List"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("List") && dict["List"] != nil {
                var tmp : [ListHistoricalSkillGroupReportResponseBody.Data.List] = []
                for v in dict["List"] as! [Any] {
                    var model = ListHistoricalSkillGroupReportResponseBody.Data.List()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.list = tmp
            }
            if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var code: String?

    public var data: ListHistoricalSkillGroupReportResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = ListHistoricalSkillGroupReportResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListHistoricalSkillGroupReportResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListHistoricalSkillGroupReportResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListHistoricalSkillGroupReportResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListInstancesRequest : Tea.TeaModel {
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
    }
}

public class ListInstancesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class List : Tea.TeaModel {
            public class AdminList : Tea.TeaModel {
                public var displayName: String?

                public var email: String?

                public var extension_: String?

                public var instanceId: String?

                public var loginName: String?

                public var mobile: String?

                public var roleId: String?

                public var roleName: String?

                public var userId: String?

                public var workMode: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.displayName != nil {
                        map["DisplayName"] = self.displayName!
                    }
                    if self.email != nil {
                        map["Email"] = self.email!
                    }
                    if self.extension_ != nil {
                        map["Extension"] = self.extension_!
                    }
                    if self.instanceId != nil {
                        map["InstanceId"] = self.instanceId!
                    }
                    if self.loginName != nil {
                        map["LoginName"] = self.loginName!
                    }
                    if self.mobile != nil {
                        map["Mobile"] = self.mobile!
                    }
                    if self.roleId != nil {
                        map["RoleId"] = self.roleId!
                    }
                    if self.roleName != nil {
                        map["RoleName"] = self.roleName!
                    }
                    if self.userId != nil {
                        map["UserId"] = self.userId!
                    }
                    if self.workMode != nil {
                        map["WorkMode"] = self.workMode!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("DisplayName") && dict["DisplayName"] != nil {
                        self.displayName = dict["DisplayName"] as! String
                    }
                    if dict.keys.contains("Email") && dict["Email"] != nil {
                        self.email = dict["Email"] as! String
                    }
                    if dict.keys.contains("Extension") && dict["Extension"] != nil {
                        self.extension_ = dict["Extension"] as! String
                    }
                    if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                        self.instanceId = dict["InstanceId"] as! String
                    }
                    if dict.keys.contains("LoginName") && dict["LoginName"] != nil {
                        self.loginName = dict["LoginName"] as! String
                    }
                    if dict.keys.contains("Mobile") && dict["Mobile"] != nil {
                        self.mobile = dict["Mobile"] as! String
                    }
                    if dict.keys.contains("RoleId") && dict["RoleId"] != nil {
                        self.roleId = dict["RoleId"] as! String
                    }
                    if dict.keys.contains("RoleName") && dict["RoleName"] != nil {
                        self.roleName = dict["RoleName"] as! String
                    }
                    if dict.keys.contains("UserId") && dict["UserId"] != nil {
                        self.userId = dict["UserId"] as! String
                    }
                    if dict.keys.contains("WorkMode") && dict["WorkMode"] != nil {
                        self.workMode = dict["WorkMode"] as! String
                    }
                }
            }
            public class NumberList : Tea.TeaModel {
                public var number: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.number != nil {
                        map["Number"] = self.number!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Number") && dict["Number"] != nil {
                        self.number = dict["Number"] as! String
                    }
                }
            }
            public var adminList: [ListInstancesResponseBody.Data.List.AdminList]?

            public var aliyunUid: String?

            public var consoleUrl: String?

            public var createTime: Int64?

            public var description_: String?

            public var domainName: String?

            public var id: String?

            public var name: String?

            public var numberList: [ListInstancesResponseBody.Data.List.NumberList]?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.adminList != nil {
                    var tmp : [Any] = []
                    for k in self.adminList! {
                        tmp.append(k.toMap())
                    }
                    map["AdminList"] = tmp
                }
                if self.aliyunUid != nil {
                    map["AliyunUid"] = self.aliyunUid!
                }
                if self.consoleUrl != nil {
                    map["ConsoleUrl"] = self.consoleUrl!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.domainName != nil {
                    map["DomainName"] = self.domainName!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.numberList != nil {
                    var tmp : [Any] = []
                    for k in self.numberList! {
                        tmp.append(k.toMap())
                    }
                    map["NumberList"] = tmp
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AdminList") && dict["AdminList"] != nil {
                    var tmp : [ListInstancesResponseBody.Data.List.AdminList] = []
                    for v in dict["AdminList"] as! [Any] {
                        var model = ListInstancesResponseBody.Data.List.AdminList()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.adminList = tmp
                }
                if dict.keys.contains("AliyunUid") && dict["AliyunUid"] != nil {
                    self.aliyunUid = dict["AliyunUid"] as! String
                }
                if dict.keys.contains("ConsoleUrl") && dict["ConsoleUrl"] != nil {
                    self.consoleUrl = dict["ConsoleUrl"] as! String
                }
                if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                    self.createTime = dict["CreateTime"] as! Int64
                }
                if dict.keys.contains("Description") && dict["Description"] != nil {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("DomainName") && dict["DomainName"] != nil {
                    self.domainName = dict["DomainName"] as! String
                }
                if dict.keys.contains("Id") && dict["Id"] != nil {
                    self.id = dict["Id"] as! String
                }
                if dict.keys.contains("Name") && dict["Name"] != nil {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("NumberList") && dict["NumberList"] != nil {
                    var tmp : [ListInstancesResponseBody.Data.List.NumberList] = []
                    for v in dict["NumberList"] as! [Any] {
                        var model = ListInstancesResponseBody.Data.List.NumberList()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.numberList = tmp
                }
                if dict.keys.contains("Status") && dict["Status"] != nil {
                    self.status = dict["Status"] as! String
                }
            }
        }
        public var list: [ListInstancesResponseBody.Data.List]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.list != nil {
                var tmp : [Any] = []
                for k in self.list! {
                    tmp.append(k.toMap())
                }
                map["List"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("List") && dict["List"] != nil {
                var tmp : [ListInstancesResponseBody.Data.List] = []
                for v in dict["List"] as! [Any] {
                    var model = ListInstancesResponseBody.Data.List()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.list = tmp
            }
            if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var code: String?

    public var data: ListInstancesResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = ListInstancesResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListInstancesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListInstancesOfUserRequest : Tea.TeaModel {
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
    }
}

public class ListInstancesOfUserResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class List : Tea.TeaModel {
            public class AdminList : Tea.TeaModel {
                public var displayName: String?

                public var email: String?

                public var extension_: String?

                public var instanceId: String?

                public var loginName: String?

                public var mobile: String?

                public var roleId: String?

                public var roleName: String?

                public var userId: String?

                public var workMode: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.displayName != nil {
                        map["DisplayName"] = self.displayName!
                    }
                    if self.email != nil {
                        map["Email"] = self.email!
                    }
                    if self.extension_ != nil {
                        map["Extension"] = self.extension_!
                    }
                    if self.instanceId != nil {
                        map["InstanceId"] = self.instanceId!
                    }
                    if self.loginName != nil {
                        map["LoginName"] = self.loginName!
                    }
                    if self.mobile != nil {
                        map["Mobile"] = self.mobile!
                    }
                    if self.roleId != nil {
                        map["RoleId"] = self.roleId!
                    }
                    if self.roleName != nil {
                        map["RoleName"] = self.roleName!
                    }
                    if self.userId != nil {
                        map["UserId"] = self.userId!
                    }
                    if self.workMode != nil {
                        map["WorkMode"] = self.workMode!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("DisplayName") && dict["DisplayName"] != nil {
                        self.displayName = dict["DisplayName"] as! String
                    }
                    if dict.keys.contains("Email") && dict["Email"] != nil {
                        self.email = dict["Email"] as! String
                    }
                    if dict.keys.contains("Extension") && dict["Extension"] != nil {
                        self.extension_ = dict["Extension"] as! String
                    }
                    if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                        self.instanceId = dict["InstanceId"] as! String
                    }
                    if dict.keys.contains("LoginName") && dict["LoginName"] != nil {
                        self.loginName = dict["LoginName"] as! String
                    }
                    if dict.keys.contains("Mobile") && dict["Mobile"] != nil {
                        self.mobile = dict["Mobile"] as! String
                    }
                    if dict.keys.contains("RoleId") && dict["RoleId"] != nil {
                        self.roleId = dict["RoleId"] as! String
                    }
                    if dict.keys.contains("RoleName") && dict["RoleName"] != nil {
                        self.roleName = dict["RoleName"] as! String
                    }
                    if dict.keys.contains("UserId") && dict["UserId"] != nil {
                        self.userId = dict["UserId"] as! String
                    }
                    if dict.keys.contains("WorkMode") && dict["WorkMode"] != nil {
                        self.workMode = dict["WorkMode"] as! String
                    }
                }
            }
            public class NumberList : Tea.TeaModel {
                public class SkillGroups : Tea.TeaModel {
                    public var description_: String?

                    public var displayName: String?

                    public var instanceId: String?

                    public var name: String?

                    public var phoneNumberCount: Int32?

                    public var skillGroupId: String?

                    public var userCount: Int32?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.description_ != nil {
                            map["Description"] = self.description_!
                        }
                        if self.displayName != nil {
                            map["DisplayName"] = self.displayName!
                        }
                        if self.instanceId != nil {
                            map["InstanceId"] = self.instanceId!
                        }
                        if self.name != nil {
                            map["Name"] = self.name!
                        }
                        if self.phoneNumberCount != nil {
                            map["PhoneNumberCount"] = self.phoneNumberCount!
                        }
                        if self.skillGroupId != nil {
                            map["SkillGroupId"] = self.skillGroupId!
                        }
                        if self.userCount != nil {
                            map["UserCount"] = self.userCount!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Description") && dict["Description"] != nil {
                            self.description_ = dict["Description"] as! String
                        }
                        if dict.keys.contains("DisplayName") && dict["DisplayName"] != nil {
                            self.displayName = dict["DisplayName"] as! String
                        }
                        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                            self.instanceId = dict["InstanceId"] as! String
                        }
                        if dict.keys.contains("Name") && dict["Name"] != nil {
                            self.name = dict["Name"] as! String
                        }
                        if dict.keys.contains("PhoneNumberCount") && dict["PhoneNumberCount"] != nil {
                            self.phoneNumberCount = dict["PhoneNumberCount"] as! Int32
                        }
                        if dict.keys.contains("SkillGroupId") && dict["SkillGroupId"] != nil {
                            self.skillGroupId = dict["SkillGroupId"] as! String
                        }
                        if dict.keys.contains("UserCount") && dict["UserCount"] != nil {
                            self.userCount = dict["UserCount"] as! Int32
                        }
                    }
                }
                public var active: Bool?

                public var city: String?

                public var contactFlowId: String?

                public var instanceId: String?

                public var number: String?

                public var province: String?

                public var skillGroups: [ListInstancesOfUserResponseBody.Data.List.NumberList.SkillGroups]?

                public var usage: String?

                public var userId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.active != nil {
                        map["Active"] = self.active!
                    }
                    if self.city != nil {
                        map["City"] = self.city!
                    }
                    if self.contactFlowId != nil {
                        map["ContactFlowId"] = self.contactFlowId!
                    }
                    if self.instanceId != nil {
                        map["InstanceId"] = self.instanceId!
                    }
                    if self.number != nil {
                        map["Number"] = self.number!
                    }
                    if self.province != nil {
                        map["Province"] = self.province!
                    }
                    if self.skillGroups != nil {
                        var tmp : [Any] = []
                        for k in self.skillGroups! {
                            tmp.append(k.toMap())
                        }
                        map["SkillGroups"] = tmp
                    }
                    if self.usage != nil {
                        map["Usage"] = self.usage!
                    }
                    if self.userId != nil {
                        map["UserId"] = self.userId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Active") && dict["Active"] != nil {
                        self.active = dict["Active"] as! Bool
                    }
                    if dict.keys.contains("City") && dict["City"] != nil {
                        self.city = dict["City"] as! String
                    }
                    if dict.keys.contains("ContactFlowId") && dict["ContactFlowId"] != nil {
                        self.contactFlowId = dict["ContactFlowId"] as! String
                    }
                    if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                        self.instanceId = dict["InstanceId"] as! String
                    }
                    if dict.keys.contains("Number") && dict["Number"] != nil {
                        self.number = dict["Number"] as! String
                    }
                    if dict.keys.contains("Province") && dict["Province"] != nil {
                        self.province = dict["Province"] as! String
                    }
                    if dict.keys.contains("SkillGroups") && dict["SkillGroups"] != nil {
                        var tmp : [ListInstancesOfUserResponseBody.Data.List.NumberList.SkillGroups] = []
                        for v in dict["SkillGroups"] as! [Any] {
                            var model = ListInstancesOfUserResponseBody.Data.List.NumberList.SkillGroups()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.skillGroups = tmp
                    }
                    if dict.keys.contains("Usage") && dict["Usage"] != nil {
                        self.usage = dict["Usage"] as! String
                    }
                    if dict.keys.contains("UserId") && dict["UserId"] != nil {
                        self.userId = dict["UserId"] as! String
                    }
                }
            }
            public var adminList: [ListInstancesOfUserResponseBody.Data.List.AdminList]?

            public var aliyunUid: String?

            public var consoleUrl: String?

            public var description_: String?

            public var domainName: String?

            public var id: String?

            public var name: String?

            public var numberList: [ListInstancesOfUserResponseBody.Data.List.NumberList]?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.adminList != nil {
                    var tmp : [Any] = []
                    for k in self.adminList! {
                        tmp.append(k.toMap())
                    }
                    map["AdminList"] = tmp
                }
                if self.aliyunUid != nil {
                    map["AliyunUid"] = self.aliyunUid!
                }
                if self.consoleUrl != nil {
                    map["ConsoleUrl"] = self.consoleUrl!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.domainName != nil {
                    map["DomainName"] = self.domainName!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.numberList != nil {
                    var tmp : [Any] = []
                    for k in self.numberList! {
                        tmp.append(k.toMap())
                    }
                    map["NumberList"] = tmp
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AdminList") && dict["AdminList"] != nil {
                    var tmp : [ListInstancesOfUserResponseBody.Data.List.AdminList] = []
                    for v in dict["AdminList"] as! [Any] {
                        var model = ListInstancesOfUserResponseBody.Data.List.AdminList()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.adminList = tmp
                }
                if dict.keys.contains("AliyunUid") && dict["AliyunUid"] != nil {
                    self.aliyunUid = dict["AliyunUid"] as! String
                }
                if dict.keys.contains("ConsoleUrl") && dict["ConsoleUrl"] != nil {
                    self.consoleUrl = dict["ConsoleUrl"] as! String
                }
                if dict.keys.contains("Description") && dict["Description"] != nil {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("DomainName") && dict["DomainName"] != nil {
                    self.domainName = dict["DomainName"] as! String
                }
                if dict.keys.contains("Id") && dict["Id"] != nil {
                    self.id = dict["Id"] as! String
                }
                if dict.keys.contains("Name") && dict["Name"] != nil {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("NumberList") && dict["NumberList"] != nil {
                    var tmp : [ListInstancesOfUserResponseBody.Data.List.NumberList] = []
                    for v in dict["NumberList"] as! [Any] {
                        var model = ListInstancesOfUserResponseBody.Data.List.NumberList()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.numberList = tmp
                }
                if dict.keys.contains("Status") && dict["Status"] != nil {
                    self.status = dict["Status"] as! String
                }
            }
        }
        public var list: [ListInstancesOfUserResponseBody.Data.List]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.list != nil {
                var tmp : [Any] = []
                for k in self.list! {
                    tmp.append(k.toMap())
                }
                map["List"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("List") && dict["List"] != nil {
                var tmp : [ListInstancesOfUserResponseBody.Data.List] = []
                for v in dict["List"] as! [Any] {
                    var model = ListInstancesOfUserResponseBody.Data.List()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.list = tmp
            }
            if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var code: String?

    public var data: ListInstancesOfUserResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = ListInstancesOfUserResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListInstancesOfUserResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListInstancesOfUserResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListInstancesOfUserResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListIntervalAgentReportRequest : Tea.TeaModel {
    public var agentId: String?

    public var endTime: Int64?

    public var instanceId: String?

    public var interval: String?

    public var startTime: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.agentId != nil {
            map["AgentId"] = self.agentId!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.interval != nil {
            map["Interval"] = self.interval!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AgentId") && dict["AgentId"] != nil {
            self.agentId = dict["AgentId"] as! String
        }
        if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Interval") && dict["Interval"] != nil {
            self.interval = dict["Interval"] as! String
        }
        if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
            self.startTime = dict["StartTime"] as! Int64
        }
    }
}

public class ListIntervalAgentReportResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Inbound : Tea.TeaModel {
            public var averageHoldTime: Double?

            public var averageRingTime: Double?

            public var averageTalkTime: Double?

            public var averageWorkTime: Double?

            public var callsAttendedTransferIn: Int64?

            public var callsAttendedTransferOut: Int64?

            public var callsBlindTransferIn: Int64?

            public var callsBlindTransferOut: Int64?

            public var callsHandled: Int64?

            public var callsHold: Int64?

            public var callsOffered: Int64?

            public var callsRinged: Int64?

            public var handleRate: Double?

            public var maxHoldTime: Int64?

            public var maxRingTime: Int64?

            public var maxTalkTime: Int64?

            public var maxWorkTime: Int64?

            public var satisfactionIndex: Double?

            public var satisfactionRate: Double?

            public var satisfactionSurveysOffered: Int64?

            public var satisfactionSurveysResponded: Int64?

            public var totalHoldTime: Int64?

            public var totalRingTime: Int64?

            public var totalTalkTime: Int64?

            public var totalWorkTime: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.averageHoldTime != nil {
                    map["AverageHoldTime"] = self.averageHoldTime!
                }
                if self.averageRingTime != nil {
                    map["AverageRingTime"] = self.averageRingTime!
                }
                if self.averageTalkTime != nil {
                    map["AverageTalkTime"] = self.averageTalkTime!
                }
                if self.averageWorkTime != nil {
                    map["AverageWorkTime"] = self.averageWorkTime!
                }
                if self.callsAttendedTransferIn != nil {
                    map["CallsAttendedTransferIn"] = self.callsAttendedTransferIn!
                }
                if self.callsAttendedTransferOut != nil {
                    map["CallsAttendedTransferOut"] = self.callsAttendedTransferOut!
                }
                if self.callsBlindTransferIn != nil {
                    map["CallsBlindTransferIn"] = self.callsBlindTransferIn!
                }
                if self.callsBlindTransferOut != nil {
                    map["CallsBlindTransferOut"] = self.callsBlindTransferOut!
                }
                if self.callsHandled != nil {
                    map["CallsHandled"] = self.callsHandled!
                }
                if self.callsHold != nil {
                    map["CallsHold"] = self.callsHold!
                }
                if self.callsOffered != nil {
                    map["CallsOffered"] = self.callsOffered!
                }
                if self.callsRinged != nil {
                    map["CallsRinged"] = self.callsRinged!
                }
                if self.handleRate != nil {
                    map["HandleRate"] = self.handleRate!
                }
                if self.maxHoldTime != nil {
                    map["MaxHoldTime"] = self.maxHoldTime!
                }
                if self.maxRingTime != nil {
                    map["MaxRingTime"] = self.maxRingTime!
                }
                if self.maxTalkTime != nil {
                    map["MaxTalkTime"] = self.maxTalkTime!
                }
                if self.maxWorkTime != nil {
                    map["MaxWorkTime"] = self.maxWorkTime!
                }
                if self.satisfactionIndex != nil {
                    map["SatisfactionIndex"] = self.satisfactionIndex!
                }
                if self.satisfactionRate != nil {
                    map["SatisfactionRate"] = self.satisfactionRate!
                }
                if self.satisfactionSurveysOffered != nil {
                    map["SatisfactionSurveysOffered"] = self.satisfactionSurveysOffered!
                }
                if self.satisfactionSurveysResponded != nil {
                    map["SatisfactionSurveysResponded"] = self.satisfactionSurveysResponded!
                }
                if self.totalHoldTime != nil {
                    map["TotalHoldTime"] = self.totalHoldTime!
                }
                if self.totalRingTime != nil {
                    map["TotalRingTime"] = self.totalRingTime!
                }
                if self.totalTalkTime != nil {
                    map["TotalTalkTime"] = self.totalTalkTime!
                }
                if self.totalWorkTime != nil {
                    map["TotalWorkTime"] = self.totalWorkTime!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AverageHoldTime") && dict["AverageHoldTime"] != nil {
                    self.averageHoldTime = dict["AverageHoldTime"] as! Double
                }
                if dict.keys.contains("AverageRingTime") && dict["AverageRingTime"] != nil {
                    self.averageRingTime = dict["AverageRingTime"] as! Double
                }
                if dict.keys.contains("AverageTalkTime") && dict["AverageTalkTime"] != nil {
                    self.averageTalkTime = dict["AverageTalkTime"] as! Double
                }
                if dict.keys.contains("AverageWorkTime") && dict["AverageWorkTime"] != nil {
                    self.averageWorkTime = dict["AverageWorkTime"] as! Double
                }
                if dict.keys.contains("CallsAttendedTransferIn") && dict["CallsAttendedTransferIn"] != nil {
                    self.callsAttendedTransferIn = dict["CallsAttendedTransferIn"] as! Int64
                }
                if dict.keys.contains("CallsAttendedTransferOut") && dict["CallsAttendedTransferOut"] != nil {
                    self.callsAttendedTransferOut = dict["CallsAttendedTransferOut"] as! Int64
                }
                if dict.keys.contains("CallsBlindTransferIn") && dict["CallsBlindTransferIn"] != nil {
                    self.callsBlindTransferIn = dict["CallsBlindTransferIn"] as! Int64
                }
                if dict.keys.contains("CallsBlindTransferOut") && dict["CallsBlindTransferOut"] != nil {
                    self.callsBlindTransferOut = dict["CallsBlindTransferOut"] as! Int64
                }
                if dict.keys.contains("CallsHandled") && dict["CallsHandled"] != nil {
                    self.callsHandled = dict["CallsHandled"] as! Int64
                }
                if dict.keys.contains("CallsHold") && dict["CallsHold"] != nil {
                    self.callsHold = dict["CallsHold"] as! Int64
                }
                if dict.keys.contains("CallsOffered") && dict["CallsOffered"] != nil {
                    self.callsOffered = dict["CallsOffered"] as! Int64
                }
                if dict.keys.contains("CallsRinged") && dict["CallsRinged"] != nil {
                    self.callsRinged = dict["CallsRinged"] as! Int64
                }
                if dict.keys.contains("HandleRate") && dict["HandleRate"] != nil {
                    self.handleRate = dict["HandleRate"] as! Double
                }
                if dict.keys.contains("MaxHoldTime") && dict["MaxHoldTime"] != nil {
                    self.maxHoldTime = dict["MaxHoldTime"] as! Int64
                }
                if dict.keys.contains("MaxRingTime") && dict["MaxRingTime"] != nil {
                    self.maxRingTime = dict["MaxRingTime"] as! Int64
                }
                if dict.keys.contains("MaxTalkTime") && dict["MaxTalkTime"] != nil {
                    self.maxTalkTime = dict["MaxTalkTime"] as! Int64
                }
                if dict.keys.contains("MaxWorkTime") && dict["MaxWorkTime"] != nil {
                    self.maxWorkTime = dict["MaxWorkTime"] as! Int64
                }
                if dict.keys.contains("SatisfactionIndex") && dict["SatisfactionIndex"] != nil {
                    self.satisfactionIndex = dict["SatisfactionIndex"] as! Double
                }
                if dict.keys.contains("SatisfactionRate") && dict["SatisfactionRate"] != nil {
                    self.satisfactionRate = dict["SatisfactionRate"] as! Double
                }
                if dict.keys.contains("SatisfactionSurveysOffered") && dict["SatisfactionSurveysOffered"] != nil {
                    self.satisfactionSurveysOffered = dict["SatisfactionSurveysOffered"] as! Int64
                }
                if dict.keys.contains("SatisfactionSurveysResponded") && dict["SatisfactionSurveysResponded"] != nil {
                    self.satisfactionSurveysResponded = dict["SatisfactionSurveysResponded"] as! Int64
                }
                if dict.keys.contains("TotalHoldTime") && dict["TotalHoldTime"] != nil {
                    self.totalHoldTime = dict["TotalHoldTime"] as! Int64
                }
                if dict.keys.contains("TotalRingTime") && dict["TotalRingTime"] != nil {
                    self.totalRingTime = dict["TotalRingTime"] as! Int64
                }
                if dict.keys.contains("TotalTalkTime") && dict["TotalTalkTime"] != nil {
                    self.totalTalkTime = dict["TotalTalkTime"] as! Int64
                }
                if dict.keys.contains("TotalWorkTime") && dict["TotalWorkTime"] != nil {
                    self.totalWorkTime = dict["TotalWorkTime"] as! Int64
                }
            }
        }
        public class Outbound : Tea.TeaModel {
            public var answerRate: Double?

            public var averageDialingTime: Double?

            public var averageHoldTime: Double?

            public var averageRingTime: Double?

            public var averageTalkTime: Double?

            public var averageWorkTime: Double?

            public var callsAnswered: Int64?

            public var callsAttendedTransferIn: Int64?

            public var callsAttendedTransferOut: Int64?

            public var callsBlindTransferIn: Int64?

            public var callsBlindTransferOut: Int64?

            public var callsDialed: Int64?

            public var callsHold: Int64?

            public var callsRinged: Int64?

            public var maxDialingTime: Int64?

            public var maxHoldTime: Int64?

            public var maxRingTime: Int64?

            public var maxTalkTime: Int64?

            public var maxWorkTime: Int64?

            public var satisfactionIndex: Double?

            public var satisfactionRate: Double?

            public var satisfactionSurveysOffered: Int64?

            public var satisfactionSurveysResponded: Int64?

            public var totalDialingTime: Int64?

            public var totalHoldTime: Int64?

            public var totalRingTime: Int64?

            public var totalTalkTime: Int64?

            public var totalWorkTime: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.answerRate != nil {
                    map["AnswerRate"] = self.answerRate!
                }
                if self.averageDialingTime != nil {
                    map["AverageDialingTime"] = self.averageDialingTime!
                }
                if self.averageHoldTime != nil {
                    map["AverageHoldTime"] = self.averageHoldTime!
                }
                if self.averageRingTime != nil {
                    map["AverageRingTime"] = self.averageRingTime!
                }
                if self.averageTalkTime != nil {
                    map["AverageTalkTime"] = self.averageTalkTime!
                }
                if self.averageWorkTime != nil {
                    map["AverageWorkTime"] = self.averageWorkTime!
                }
                if self.callsAnswered != nil {
                    map["CallsAnswered"] = self.callsAnswered!
                }
                if self.callsAttendedTransferIn != nil {
                    map["CallsAttendedTransferIn"] = self.callsAttendedTransferIn!
                }
                if self.callsAttendedTransferOut != nil {
                    map["CallsAttendedTransferOut"] = self.callsAttendedTransferOut!
                }
                if self.callsBlindTransferIn != nil {
                    map["CallsBlindTransferIn"] = self.callsBlindTransferIn!
                }
                if self.callsBlindTransferOut != nil {
                    map["CallsBlindTransferOut"] = self.callsBlindTransferOut!
                }
                if self.callsDialed != nil {
                    map["CallsDialed"] = self.callsDialed!
                }
                if self.callsHold != nil {
                    map["CallsHold"] = self.callsHold!
                }
                if self.callsRinged != nil {
                    map["CallsRinged"] = self.callsRinged!
                }
                if self.maxDialingTime != nil {
                    map["MaxDialingTime"] = self.maxDialingTime!
                }
                if self.maxHoldTime != nil {
                    map["MaxHoldTime"] = self.maxHoldTime!
                }
                if self.maxRingTime != nil {
                    map["MaxRingTime"] = self.maxRingTime!
                }
                if self.maxTalkTime != nil {
                    map["MaxTalkTime"] = self.maxTalkTime!
                }
                if self.maxWorkTime != nil {
                    map["MaxWorkTime"] = self.maxWorkTime!
                }
                if self.satisfactionIndex != nil {
                    map["SatisfactionIndex"] = self.satisfactionIndex!
                }
                if self.satisfactionRate != nil {
                    map["SatisfactionRate"] = self.satisfactionRate!
                }
                if self.satisfactionSurveysOffered != nil {
                    map["SatisfactionSurveysOffered"] = self.satisfactionSurveysOffered!
                }
                if self.satisfactionSurveysResponded != nil {
                    map["SatisfactionSurveysResponded"] = self.satisfactionSurveysResponded!
                }
                if self.totalDialingTime != nil {
                    map["TotalDialingTime"] = self.totalDialingTime!
                }
                if self.totalHoldTime != nil {
                    map["TotalHoldTime"] = self.totalHoldTime!
                }
                if self.totalRingTime != nil {
                    map["TotalRingTime"] = self.totalRingTime!
                }
                if self.totalTalkTime != nil {
                    map["TotalTalkTime"] = self.totalTalkTime!
                }
                if self.totalWorkTime != nil {
                    map["TotalWorkTime"] = self.totalWorkTime!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AnswerRate") && dict["AnswerRate"] != nil {
                    self.answerRate = dict["AnswerRate"] as! Double
                }
                if dict.keys.contains("AverageDialingTime") && dict["AverageDialingTime"] != nil {
                    self.averageDialingTime = dict["AverageDialingTime"] as! Double
                }
                if dict.keys.contains("AverageHoldTime") && dict["AverageHoldTime"] != nil {
                    self.averageHoldTime = dict["AverageHoldTime"] as! Double
                }
                if dict.keys.contains("AverageRingTime") && dict["AverageRingTime"] != nil {
                    self.averageRingTime = dict["AverageRingTime"] as! Double
                }
                if dict.keys.contains("AverageTalkTime") && dict["AverageTalkTime"] != nil {
                    self.averageTalkTime = dict["AverageTalkTime"] as! Double
                }
                if dict.keys.contains("AverageWorkTime") && dict["AverageWorkTime"] != nil {
                    self.averageWorkTime = dict["AverageWorkTime"] as! Double
                }
                if dict.keys.contains("CallsAnswered") && dict["CallsAnswered"] != nil {
                    self.callsAnswered = dict["CallsAnswered"] as! Int64
                }
                if dict.keys.contains("CallsAttendedTransferIn") && dict["CallsAttendedTransferIn"] != nil {
                    self.callsAttendedTransferIn = dict["CallsAttendedTransferIn"] as! Int64
                }
                if dict.keys.contains("CallsAttendedTransferOut") && dict["CallsAttendedTransferOut"] != nil {
                    self.callsAttendedTransferOut = dict["CallsAttendedTransferOut"] as! Int64
                }
                if dict.keys.contains("CallsBlindTransferIn") && dict["CallsBlindTransferIn"] != nil {
                    self.callsBlindTransferIn = dict["CallsBlindTransferIn"] as! Int64
                }
                if dict.keys.contains("CallsBlindTransferOut") && dict["CallsBlindTransferOut"] != nil {
                    self.callsBlindTransferOut = dict["CallsBlindTransferOut"] as! Int64
                }
                if dict.keys.contains("CallsDialed") && dict["CallsDialed"] != nil {
                    self.callsDialed = dict["CallsDialed"] as! Int64
                }
                if dict.keys.contains("CallsHold") && dict["CallsHold"] != nil {
                    self.callsHold = dict["CallsHold"] as! Int64
                }
                if dict.keys.contains("CallsRinged") && dict["CallsRinged"] != nil {
                    self.callsRinged = dict["CallsRinged"] as! Int64
                }
                if dict.keys.contains("MaxDialingTime") && dict["MaxDialingTime"] != nil {
                    self.maxDialingTime = dict["MaxDialingTime"] as! Int64
                }
                if dict.keys.contains("MaxHoldTime") && dict["MaxHoldTime"] != nil {
                    self.maxHoldTime = dict["MaxHoldTime"] as! Int64
                }
                if dict.keys.contains("MaxRingTime") && dict["MaxRingTime"] != nil {
                    self.maxRingTime = dict["MaxRingTime"] as! Int64
                }
                if dict.keys.contains("MaxTalkTime") && dict["MaxTalkTime"] != nil {
                    self.maxTalkTime = dict["MaxTalkTime"] as! Int64
                }
                if dict.keys.contains("MaxWorkTime") && dict["MaxWorkTime"] != nil {
                    self.maxWorkTime = dict["MaxWorkTime"] as! Int64
                }
                if dict.keys.contains("SatisfactionIndex") && dict["SatisfactionIndex"] != nil {
                    self.satisfactionIndex = dict["SatisfactionIndex"] as! Double
                }
                if dict.keys.contains("SatisfactionRate") && dict["SatisfactionRate"] != nil {
                    self.satisfactionRate = dict["SatisfactionRate"] as! Double
                }
                if dict.keys.contains("SatisfactionSurveysOffered") && dict["SatisfactionSurveysOffered"] != nil {
                    self.satisfactionSurveysOffered = dict["SatisfactionSurveysOffered"] as! Int64
                }
                if dict.keys.contains("SatisfactionSurveysResponded") && dict["SatisfactionSurveysResponded"] != nil {
                    self.satisfactionSurveysResponded = dict["SatisfactionSurveysResponded"] as! Int64
                }
                if dict.keys.contains("TotalDialingTime") && dict["TotalDialingTime"] != nil {
                    self.totalDialingTime = dict["TotalDialingTime"] as! Int64
                }
                if dict.keys.contains("TotalHoldTime") && dict["TotalHoldTime"] != nil {
                    self.totalHoldTime = dict["TotalHoldTime"] as! Int64
                }
                if dict.keys.contains("TotalRingTime") && dict["TotalRingTime"] != nil {
                    self.totalRingTime = dict["TotalRingTime"] as! Int64
                }
                if dict.keys.contains("TotalTalkTime") && dict["TotalTalkTime"] != nil {
                    self.totalTalkTime = dict["TotalTalkTime"] as! Int64
                }
                if dict.keys.contains("TotalWorkTime") && dict["TotalWorkTime"] != nil {
                    self.totalWorkTime = dict["TotalWorkTime"] as! Int64
                }
            }
        }
        public class Overall : Tea.TeaModel {
            public var averageBreakTime: Double?

            public var averageHoldTime: Double?

            public var averageReadyTime: Double?

            public var averageTalkTime: Double?

            public var averageWorkTime: Double?

            public var firstCheckInTime: Int64?

            public var lastCheckoutTime: Int64?

            public var maxBreakTime: Int64?

            public var maxHoldTime: Int64?

            public var maxReadyTime: Int64?

            public var maxTalkTime: Int64?

            public var maxWorkTime: Int64?

            public var occupancyRate: Double?

            public var satisfactionIndex: Double?

            public var satisfactionRate: Double?

            public var satisfactionSurveysOffered: Int64?

            public var satisfactionSurveysResponded: Int64?

            public var totalBreakTime: Int64?

            public var totalCalls: Int64?

            public var totalHoldTime: Int64?

            public var totalLoggedInTime: Int64?

            public var totalReadyTime: Int64?

            public var totalTalkTime: Int64?

            public var totalWorkTime: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.averageBreakTime != nil {
                    map["AverageBreakTime"] = self.averageBreakTime!
                }
                if self.averageHoldTime != nil {
                    map["AverageHoldTime"] = self.averageHoldTime!
                }
                if self.averageReadyTime != nil {
                    map["AverageReadyTime"] = self.averageReadyTime!
                }
                if self.averageTalkTime != nil {
                    map["AverageTalkTime"] = self.averageTalkTime!
                }
                if self.averageWorkTime != nil {
                    map["AverageWorkTime"] = self.averageWorkTime!
                }
                if self.firstCheckInTime != nil {
                    map["FirstCheckInTime"] = self.firstCheckInTime!
                }
                if self.lastCheckoutTime != nil {
                    map["LastCheckoutTime"] = self.lastCheckoutTime!
                }
                if self.maxBreakTime != nil {
                    map["MaxBreakTime"] = self.maxBreakTime!
                }
                if self.maxHoldTime != nil {
                    map["MaxHoldTime"] = self.maxHoldTime!
                }
                if self.maxReadyTime != nil {
                    map["MaxReadyTime"] = self.maxReadyTime!
                }
                if self.maxTalkTime != nil {
                    map["MaxTalkTime"] = self.maxTalkTime!
                }
                if self.maxWorkTime != nil {
                    map["MaxWorkTime"] = self.maxWorkTime!
                }
                if self.occupancyRate != nil {
                    map["OccupancyRate"] = self.occupancyRate!
                }
                if self.satisfactionIndex != nil {
                    map["SatisfactionIndex"] = self.satisfactionIndex!
                }
                if self.satisfactionRate != nil {
                    map["SatisfactionRate"] = self.satisfactionRate!
                }
                if self.satisfactionSurveysOffered != nil {
                    map["SatisfactionSurveysOffered"] = self.satisfactionSurveysOffered!
                }
                if self.satisfactionSurveysResponded != nil {
                    map["SatisfactionSurveysResponded"] = self.satisfactionSurveysResponded!
                }
                if self.totalBreakTime != nil {
                    map["TotalBreakTime"] = self.totalBreakTime!
                }
                if self.totalCalls != nil {
                    map["TotalCalls"] = self.totalCalls!
                }
                if self.totalHoldTime != nil {
                    map["TotalHoldTime"] = self.totalHoldTime!
                }
                if self.totalLoggedInTime != nil {
                    map["TotalLoggedInTime"] = self.totalLoggedInTime!
                }
                if self.totalReadyTime != nil {
                    map["TotalReadyTime"] = self.totalReadyTime!
                }
                if self.totalTalkTime != nil {
                    map["TotalTalkTime"] = self.totalTalkTime!
                }
                if self.totalWorkTime != nil {
                    map["TotalWorkTime"] = self.totalWorkTime!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AverageBreakTime") && dict["AverageBreakTime"] != nil {
                    self.averageBreakTime = dict["AverageBreakTime"] as! Double
                }
                if dict.keys.contains("AverageHoldTime") && dict["AverageHoldTime"] != nil {
                    self.averageHoldTime = dict["AverageHoldTime"] as! Double
                }
                if dict.keys.contains("AverageReadyTime") && dict["AverageReadyTime"] != nil {
                    self.averageReadyTime = dict["AverageReadyTime"] as! Double
                }
                if dict.keys.contains("AverageTalkTime") && dict["AverageTalkTime"] != nil {
                    self.averageTalkTime = dict["AverageTalkTime"] as! Double
                }
                if dict.keys.contains("AverageWorkTime") && dict["AverageWorkTime"] != nil {
                    self.averageWorkTime = dict["AverageWorkTime"] as! Double
                }
                if dict.keys.contains("FirstCheckInTime") && dict["FirstCheckInTime"] != nil {
                    self.firstCheckInTime = dict["FirstCheckInTime"] as! Int64
                }
                if dict.keys.contains("LastCheckoutTime") && dict["LastCheckoutTime"] != nil {
                    self.lastCheckoutTime = dict["LastCheckoutTime"] as! Int64
                }
                if dict.keys.contains("MaxBreakTime") && dict["MaxBreakTime"] != nil {
                    self.maxBreakTime = dict["MaxBreakTime"] as! Int64
                }
                if dict.keys.contains("MaxHoldTime") && dict["MaxHoldTime"] != nil {
                    self.maxHoldTime = dict["MaxHoldTime"] as! Int64
                }
                if dict.keys.contains("MaxReadyTime") && dict["MaxReadyTime"] != nil {
                    self.maxReadyTime = dict["MaxReadyTime"] as! Int64
                }
                if dict.keys.contains("MaxTalkTime") && dict["MaxTalkTime"] != nil {
                    self.maxTalkTime = dict["MaxTalkTime"] as! Int64
                }
                if dict.keys.contains("MaxWorkTime") && dict["MaxWorkTime"] != nil {
                    self.maxWorkTime = dict["MaxWorkTime"] as! Int64
                }
                if dict.keys.contains("OccupancyRate") && dict["OccupancyRate"] != nil {
                    self.occupancyRate = dict["OccupancyRate"] as! Double
                }
                if dict.keys.contains("SatisfactionIndex") && dict["SatisfactionIndex"] != nil {
                    self.satisfactionIndex = dict["SatisfactionIndex"] as! Double
                }
                if dict.keys.contains("SatisfactionRate") && dict["SatisfactionRate"] != nil {
                    self.satisfactionRate = dict["SatisfactionRate"] as! Double
                }
                if dict.keys.contains("SatisfactionSurveysOffered") && dict["SatisfactionSurveysOffered"] != nil {
                    self.satisfactionSurveysOffered = dict["SatisfactionSurveysOffered"] as! Int64
                }
                if dict.keys.contains("SatisfactionSurveysResponded") && dict["SatisfactionSurveysResponded"] != nil {
                    self.satisfactionSurveysResponded = dict["SatisfactionSurveysResponded"] as! Int64
                }
                if dict.keys.contains("TotalBreakTime") && dict["TotalBreakTime"] != nil {
                    self.totalBreakTime = dict["TotalBreakTime"] as! Int64
                }
                if dict.keys.contains("TotalCalls") && dict["TotalCalls"] != nil {
                    self.totalCalls = dict["TotalCalls"] as! Int64
                }
                if dict.keys.contains("TotalHoldTime") && dict["TotalHoldTime"] != nil {
                    self.totalHoldTime = dict["TotalHoldTime"] as! Int64
                }
                if dict.keys.contains("TotalLoggedInTime") && dict["TotalLoggedInTime"] != nil {
                    self.totalLoggedInTime = dict["TotalLoggedInTime"] as! Int64
                }
                if dict.keys.contains("TotalReadyTime") && dict["TotalReadyTime"] != nil {
                    self.totalReadyTime = dict["TotalReadyTime"] as! Int64
                }
                if dict.keys.contains("TotalTalkTime") && dict["TotalTalkTime"] != nil {
                    self.totalTalkTime = dict["TotalTalkTime"] as! Int64
                }
                if dict.keys.contains("TotalWorkTime") && dict["TotalWorkTime"] != nil {
                    self.totalWorkTime = dict["TotalWorkTime"] as! Int64
                }
            }
        }
        public var inbound: ListIntervalAgentReportResponseBody.Data.Inbound?

        public var outbound: ListIntervalAgentReportResponseBody.Data.Outbound?

        public var overall: ListIntervalAgentReportResponseBody.Data.Overall?

        public var statsTime: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.inbound?.validate()
            try self.outbound?.validate()
            try self.overall?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.inbound != nil {
                map["Inbound"] = self.inbound?.toMap()
            }
            if self.outbound != nil {
                map["Outbound"] = self.outbound?.toMap()
            }
            if self.overall != nil {
                map["Overall"] = self.overall?.toMap()
            }
            if self.statsTime != nil {
                map["StatsTime"] = self.statsTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Inbound") && dict["Inbound"] != nil {
                var model = ListIntervalAgentReportResponseBody.Data.Inbound()
                model.fromMap(dict["Inbound"] as! [String: Any])
                self.inbound = model
            }
            if dict.keys.contains("Outbound") && dict["Outbound"] != nil {
                var model = ListIntervalAgentReportResponseBody.Data.Outbound()
                model.fromMap(dict["Outbound"] as! [String: Any])
                self.outbound = model
            }
            if dict.keys.contains("Overall") && dict["Overall"] != nil {
                var model = ListIntervalAgentReportResponseBody.Data.Overall()
                model.fromMap(dict["Overall"] as! [String: Any])
                self.overall = model
            }
            if dict.keys.contains("StatsTime") && dict["StatsTime"] != nil {
                self.statsTime = dict["StatsTime"] as! Int64
            }
        }
    }
    public var code: String?

    public var data: [ListIntervalAgentReportResponseBody.Data]?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var tmp : [ListIntervalAgentReportResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = ListIntervalAgentReportResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListIntervalAgentReportResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListIntervalAgentReportResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListIntervalAgentReportResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListIntervalInstanceReportRequest : Tea.TeaModel {
    public var endTime: Int64?

    public var instanceId: String?

    public var interval: String?

    public var startTime: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.interval != nil {
            map["Interval"] = self.interval!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Interval") && dict["Interval"] != nil {
            self.interval = dict["Interval"] as! String
        }
        if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
            self.startTime = dict["StartTime"] as! Int64
        }
    }
}

public class ListIntervalInstanceReportResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Inbound : Tea.TeaModel {
            public var abandonedRate: Double?

            public var averageAbandonTime: Double?

            public var averageAbandonedInIVRTime: Double?

            public var averageAbandonedInQueueTime: Double?

            public var averageAbandonedInRingTime: Double?

            public var averageHoldTime: Double?

            public var averageRingTime: Double?

            public var averageTalkTime: Double?

            public var averageWaitTime: Double?

            public var averageWorkTime: Double?

            public var callsAbandoned: Int64?

            public var callsAbandonedInIVR: Int64?

            public var callsAbandonedInQueue: Int64?

            public var callsAbandonedInRing: Int64?

            public var callsAbandonedInVoiceNavigator: Int64?

            public var callsAttendedTransferred: Int64?

            public var callsBlindTransferred: Int64?

            public var callsForwardToOutsideNumber: Int64?

            public var callsHandled: Int64?

            public var callsHold: Int64?

            public var callsIVRException: Int64?

            public var callsOffered: Int64?

            public var callsQueued: Int64?

            public var callsQueuingFailed: Int64?

            public var callsQueuingOverflow: Int64?

            public var callsQueuingTimeout: Int64?

            public var callsRinged: Int64?

            public var callsVoicemail: Int64?

            public var handleRate: Double?

            public var maxAbandonTime: Int64?

            public var maxAbandonedInIVRTime: Int64?

            public var maxAbandonedInQueueTime: Int64?

            public var maxAbandonedInRingTime: Int64?

            public var maxHoldTime: Int64?

            public var maxRingTime: Int64?

            public var maxTalkTime: Int64?

            public var maxWaitTime: Int64?

            public var maxWorkTime: Int64?

            public var satisfactionIndex: Double?

            public var satisfactionRate: Double?

            public var satisfactionSurveysOffered: Int64?

            public var satisfactionSurveysResponded: Int64?

            public var serviceLevel20: Double?

            public var totalAbandonTime: Int64?

            public var totalAbandonedInIVRTime: Int64?

            public var totalAbandonedInQueueTime: Int64?

            public var totalAbandonedInRingTime: Int64?

            public var totalHoldTime: Int64?

            public var totalRingTime: Int64?

            public var totalTalkTime: Int64?

            public var totalWaitTime: Int64?

            public var totalWorkTime: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.abandonedRate != nil {
                    map["AbandonedRate"] = self.abandonedRate!
                }
                if self.averageAbandonTime != nil {
                    map["AverageAbandonTime"] = self.averageAbandonTime!
                }
                if self.averageAbandonedInIVRTime != nil {
                    map["AverageAbandonedInIVRTime"] = self.averageAbandonedInIVRTime!
                }
                if self.averageAbandonedInQueueTime != nil {
                    map["AverageAbandonedInQueueTime"] = self.averageAbandonedInQueueTime!
                }
                if self.averageAbandonedInRingTime != nil {
                    map["AverageAbandonedInRingTime"] = self.averageAbandonedInRingTime!
                }
                if self.averageHoldTime != nil {
                    map["AverageHoldTime"] = self.averageHoldTime!
                }
                if self.averageRingTime != nil {
                    map["AverageRingTime"] = self.averageRingTime!
                }
                if self.averageTalkTime != nil {
                    map["AverageTalkTime"] = self.averageTalkTime!
                }
                if self.averageWaitTime != nil {
                    map["AverageWaitTime"] = self.averageWaitTime!
                }
                if self.averageWorkTime != nil {
                    map["AverageWorkTime"] = self.averageWorkTime!
                }
                if self.callsAbandoned != nil {
                    map["CallsAbandoned"] = self.callsAbandoned!
                }
                if self.callsAbandonedInIVR != nil {
                    map["CallsAbandonedInIVR"] = self.callsAbandonedInIVR!
                }
                if self.callsAbandonedInQueue != nil {
                    map["CallsAbandonedInQueue"] = self.callsAbandonedInQueue!
                }
                if self.callsAbandonedInRing != nil {
                    map["CallsAbandonedInRing"] = self.callsAbandonedInRing!
                }
                if self.callsAbandonedInVoiceNavigator != nil {
                    map["CallsAbandonedInVoiceNavigator"] = self.callsAbandonedInVoiceNavigator!
                }
                if self.callsAttendedTransferred != nil {
                    map["CallsAttendedTransferred"] = self.callsAttendedTransferred!
                }
                if self.callsBlindTransferred != nil {
                    map["CallsBlindTransferred"] = self.callsBlindTransferred!
                }
                if self.callsForwardToOutsideNumber != nil {
                    map["CallsForwardToOutsideNumber"] = self.callsForwardToOutsideNumber!
                }
                if self.callsHandled != nil {
                    map["CallsHandled"] = self.callsHandled!
                }
                if self.callsHold != nil {
                    map["CallsHold"] = self.callsHold!
                }
                if self.callsIVRException != nil {
                    map["CallsIVRException"] = self.callsIVRException!
                }
                if self.callsOffered != nil {
                    map["CallsOffered"] = self.callsOffered!
                }
                if self.callsQueued != nil {
                    map["CallsQueued"] = self.callsQueued!
                }
                if self.callsQueuingFailed != nil {
                    map["CallsQueuingFailed"] = self.callsQueuingFailed!
                }
                if self.callsQueuingOverflow != nil {
                    map["CallsQueuingOverflow"] = self.callsQueuingOverflow!
                }
                if self.callsQueuingTimeout != nil {
                    map["CallsQueuingTimeout"] = self.callsQueuingTimeout!
                }
                if self.callsRinged != nil {
                    map["CallsRinged"] = self.callsRinged!
                }
                if self.callsVoicemail != nil {
                    map["CallsVoicemail"] = self.callsVoicemail!
                }
                if self.handleRate != nil {
                    map["HandleRate"] = self.handleRate!
                }
                if self.maxAbandonTime != nil {
                    map["MaxAbandonTime"] = self.maxAbandonTime!
                }
                if self.maxAbandonedInIVRTime != nil {
                    map["MaxAbandonedInIVRTime"] = self.maxAbandonedInIVRTime!
                }
                if self.maxAbandonedInQueueTime != nil {
                    map["MaxAbandonedInQueueTime"] = self.maxAbandonedInQueueTime!
                }
                if self.maxAbandonedInRingTime != nil {
                    map["MaxAbandonedInRingTime"] = self.maxAbandonedInRingTime!
                }
                if self.maxHoldTime != nil {
                    map["MaxHoldTime"] = self.maxHoldTime!
                }
                if self.maxRingTime != nil {
                    map["MaxRingTime"] = self.maxRingTime!
                }
                if self.maxTalkTime != nil {
                    map["MaxTalkTime"] = self.maxTalkTime!
                }
                if self.maxWaitTime != nil {
                    map["MaxWaitTime"] = self.maxWaitTime!
                }
                if self.maxWorkTime != nil {
                    map["MaxWorkTime"] = self.maxWorkTime!
                }
                if self.satisfactionIndex != nil {
                    map["SatisfactionIndex"] = self.satisfactionIndex!
                }
                if self.satisfactionRate != nil {
                    map["SatisfactionRate"] = self.satisfactionRate!
                }
                if self.satisfactionSurveysOffered != nil {
                    map["SatisfactionSurveysOffered"] = self.satisfactionSurveysOffered!
                }
                if self.satisfactionSurveysResponded != nil {
                    map["SatisfactionSurveysResponded"] = self.satisfactionSurveysResponded!
                }
                if self.serviceLevel20 != nil {
                    map["ServiceLevel20"] = self.serviceLevel20!
                }
                if self.totalAbandonTime != nil {
                    map["TotalAbandonTime"] = self.totalAbandonTime!
                }
                if self.totalAbandonedInIVRTime != nil {
                    map["TotalAbandonedInIVRTime"] = self.totalAbandonedInIVRTime!
                }
                if self.totalAbandonedInQueueTime != nil {
                    map["TotalAbandonedInQueueTime"] = self.totalAbandonedInQueueTime!
                }
                if self.totalAbandonedInRingTime != nil {
                    map["TotalAbandonedInRingTime"] = self.totalAbandonedInRingTime!
                }
                if self.totalHoldTime != nil {
                    map["TotalHoldTime"] = self.totalHoldTime!
                }
                if self.totalRingTime != nil {
                    map["TotalRingTime"] = self.totalRingTime!
                }
                if self.totalTalkTime != nil {
                    map["TotalTalkTime"] = self.totalTalkTime!
                }
                if self.totalWaitTime != nil {
                    map["TotalWaitTime"] = self.totalWaitTime!
                }
                if self.totalWorkTime != nil {
                    map["TotalWorkTime"] = self.totalWorkTime!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AbandonedRate") && dict["AbandonedRate"] != nil {
                    self.abandonedRate = dict["AbandonedRate"] as! Double
                }
                if dict.keys.contains("AverageAbandonTime") && dict["AverageAbandonTime"] != nil {
                    self.averageAbandonTime = dict["AverageAbandonTime"] as! Double
                }
                if dict.keys.contains("AverageAbandonedInIVRTime") && dict["AverageAbandonedInIVRTime"] != nil {
                    self.averageAbandonedInIVRTime = dict["AverageAbandonedInIVRTime"] as! Double
                }
                if dict.keys.contains("AverageAbandonedInQueueTime") && dict["AverageAbandonedInQueueTime"] != nil {
                    self.averageAbandonedInQueueTime = dict["AverageAbandonedInQueueTime"] as! Double
                }
                if dict.keys.contains("AverageAbandonedInRingTime") && dict["AverageAbandonedInRingTime"] != nil {
                    self.averageAbandonedInRingTime = dict["AverageAbandonedInRingTime"] as! Double
                }
                if dict.keys.contains("AverageHoldTime") && dict["AverageHoldTime"] != nil {
                    self.averageHoldTime = dict["AverageHoldTime"] as! Double
                }
                if dict.keys.contains("AverageRingTime") && dict["AverageRingTime"] != nil {
                    self.averageRingTime = dict["AverageRingTime"] as! Double
                }
                if dict.keys.contains("AverageTalkTime") && dict["AverageTalkTime"] != nil {
                    self.averageTalkTime = dict["AverageTalkTime"] as! Double
                }
                if dict.keys.contains("AverageWaitTime") && dict["AverageWaitTime"] != nil {
                    self.averageWaitTime = dict["AverageWaitTime"] as! Double
                }
                if dict.keys.contains("AverageWorkTime") && dict["AverageWorkTime"] != nil {
                    self.averageWorkTime = dict["AverageWorkTime"] as! Double
                }
                if dict.keys.contains("CallsAbandoned") && dict["CallsAbandoned"] != nil {
                    self.callsAbandoned = dict["CallsAbandoned"] as! Int64
                }
                if dict.keys.contains("CallsAbandonedInIVR") && dict["CallsAbandonedInIVR"] != nil {
                    self.callsAbandonedInIVR = dict["CallsAbandonedInIVR"] as! Int64
                }
                if dict.keys.contains("CallsAbandonedInQueue") && dict["CallsAbandonedInQueue"] != nil {
                    self.callsAbandonedInQueue = dict["CallsAbandonedInQueue"] as! Int64
                }
                if dict.keys.contains("CallsAbandonedInRing") && dict["CallsAbandonedInRing"] != nil {
                    self.callsAbandonedInRing = dict["CallsAbandonedInRing"] as! Int64
                }
                if dict.keys.contains("CallsAbandonedInVoiceNavigator") && dict["CallsAbandonedInVoiceNavigator"] != nil {
                    self.callsAbandonedInVoiceNavigator = dict["CallsAbandonedInVoiceNavigator"] as! Int64
                }
                if dict.keys.contains("CallsAttendedTransferred") && dict["CallsAttendedTransferred"] != nil {
                    self.callsAttendedTransferred = dict["CallsAttendedTransferred"] as! Int64
                }
                if dict.keys.contains("CallsBlindTransferred") && dict["CallsBlindTransferred"] != nil {
                    self.callsBlindTransferred = dict["CallsBlindTransferred"] as! Int64
                }
                if dict.keys.contains("CallsForwardToOutsideNumber") && dict["CallsForwardToOutsideNumber"] != nil {
                    self.callsForwardToOutsideNumber = dict["CallsForwardToOutsideNumber"] as! Int64
                }
                if dict.keys.contains("CallsHandled") && dict["CallsHandled"] != nil {
                    self.callsHandled = dict["CallsHandled"] as! Int64
                }
                if dict.keys.contains("CallsHold") && dict["CallsHold"] != nil {
                    self.callsHold = dict["CallsHold"] as! Int64
                }
                if dict.keys.contains("CallsIVRException") && dict["CallsIVRException"] != nil {
                    self.callsIVRException = dict["CallsIVRException"] as! Int64
                }
                if dict.keys.contains("CallsOffered") && dict["CallsOffered"] != nil {
                    self.callsOffered = dict["CallsOffered"] as! Int64
                }
                if dict.keys.contains("CallsQueued") && dict["CallsQueued"] != nil {
                    self.callsQueued = dict["CallsQueued"] as! Int64
                }
                if dict.keys.contains("CallsQueuingFailed") && dict["CallsQueuingFailed"] != nil {
                    self.callsQueuingFailed = dict["CallsQueuingFailed"] as! Int64
                }
                if dict.keys.contains("CallsQueuingOverflow") && dict["CallsQueuingOverflow"] != nil {
                    self.callsQueuingOverflow = dict["CallsQueuingOverflow"] as! Int64
                }
                if dict.keys.contains("CallsQueuingTimeout") && dict["CallsQueuingTimeout"] != nil {
                    self.callsQueuingTimeout = dict["CallsQueuingTimeout"] as! Int64
                }
                if dict.keys.contains("CallsRinged") && dict["CallsRinged"] != nil {
                    self.callsRinged = dict["CallsRinged"] as! Int64
                }
                if dict.keys.contains("CallsVoicemail") && dict["CallsVoicemail"] != nil {
                    self.callsVoicemail = dict["CallsVoicemail"] as! Int64
                }
                if dict.keys.contains("HandleRate") && dict["HandleRate"] != nil {
                    self.handleRate = dict["HandleRate"] as! Double
                }
                if dict.keys.contains("MaxAbandonTime") && dict["MaxAbandonTime"] != nil {
                    self.maxAbandonTime = dict["MaxAbandonTime"] as! Int64
                }
                if dict.keys.contains("MaxAbandonedInIVRTime") && dict["MaxAbandonedInIVRTime"] != nil {
                    self.maxAbandonedInIVRTime = dict["MaxAbandonedInIVRTime"] as! Int64
                }
                if dict.keys.contains("MaxAbandonedInQueueTime") && dict["MaxAbandonedInQueueTime"] != nil {
                    self.maxAbandonedInQueueTime = dict["MaxAbandonedInQueueTime"] as! Int64
                }
                if dict.keys.contains("MaxAbandonedInRingTime") && dict["MaxAbandonedInRingTime"] != nil {
                    self.maxAbandonedInRingTime = dict["MaxAbandonedInRingTime"] as! Int64
                }
                if dict.keys.contains("MaxHoldTime") && dict["MaxHoldTime"] != nil {
                    self.maxHoldTime = dict["MaxHoldTime"] as! Int64
                }
                if dict.keys.contains("MaxRingTime") && dict["MaxRingTime"] != nil {
                    self.maxRingTime = dict["MaxRingTime"] as! Int64
                }
                if dict.keys.contains("MaxTalkTime") && dict["MaxTalkTime"] != nil {
                    self.maxTalkTime = dict["MaxTalkTime"] as! Int64
                }
                if dict.keys.contains("MaxWaitTime") && dict["MaxWaitTime"] != nil {
                    self.maxWaitTime = dict["MaxWaitTime"] as! Int64
                }
                if dict.keys.contains("MaxWorkTime") && dict["MaxWorkTime"] != nil {
                    self.maxWorkTime = dict["MaxWorkTime"] as! Int64
                }
                if dict.keys.contains("SatisfactionIndex") && dict["SatisfactionIndex"] != nil {
                    self.satisfactionIndex = dict["SatisfactionIndex"] as! Double
                }
                if dict.keys.contains("SatisfactionRate") && dict["SatisfactionRate"] != nil {
                    self.satisfactionRate = dict["SatisfactionRate"] as! Double
                }
                if dict.keys.contains("SatisfactionSurveysOffered") && dict["SatisfactionSurveysOffered"] != nil {
                    self.satisfactionSurveysOffered = dict["SatisfactionSurveysOffered"] as! Int64
                }
                if dict.keys.contains("SatisfactionSurveysResponded") && dict["SatisfactionSurveysResponded"] != nil {
                    self.satisfactionSurveysResponded = dict["SatisfactionSurveysResponded"] as! Int64
                }
                if dict.keys.contains("ServiceLevel20") && dict["ServiceLevel20"] != nil {
                    self.serviceLevel20 = dict["ServiceLevel20"] as! Double
                }
                if dict.keys.contains("TotalAbandonTime") && dict["TotalAbandonTime"] != nil {
                    self.totalAbandonTime = dict["TotalAbandonTime"] as! Int64
                }
                if dict.keys.contains("TotalAbandonedInIVRTime") && dict["TotalAbandonedInIVRTime"] != nil {
                    self.totalAbandonedInIVRTime = dict["TotalAbandonedInIVRTime"] as! Int64
                }
                if dict.keys.contains("TotalAbandonedInQueueTime") && dict["TotalAbandonedInQueueTime"] != nil {
                    self.totalAbandonedInQueueTime = dict["TotalAbandonedInQueueTime"] as! Int64
                }
                if dict.keys.contains("TotalAbandonedInRingTime") && dict["TotalAbandonedInRingTime"] != nil {
                    self.totalAbandonedInRingTime = dict["TotalAbandonedInRingTime"] as! Int64
                }
                if dict.keys.contains("TotalHoldTime") && dict["TotalHoldTime"] != nil {
                    self.totalHoldTime = dict["TotalHoldTime"] as! Int64
                }
                if dict.keys.contains("TotalRingTime") && dict["TotalRingTime"] != nil {
                    self.totalRingTime = dict["TotalRingTime"] as! Int64
                }
                if dict.keys.contains("TotalTalkTime") && dict["TotalTalkTime"] != nil {
                    self.totalTalkTime = dict["TotalTalkTime"] as! Int64
                }
                if dict.keys.contains("TotalWaitTime") && dict["TotalWaitTime"] != nil {
                    self.totalWaitTime = dict["TotalWaitTime"] as! Int64
                }
                if dict.keys.contains("TotalWorkTime") && dict["TotalWorkTime"] != nil {
                    self.totalWorkTime = dict["TotalWorkTime"] as! Int64
                }
            }
        }
        public class Outbound : Tea.TeaModel {
            public var answerRate: Double?

            public var averageDialingTime: Double?

            public var averageHoldTime: Double?

            public var averageRingTime: Double?

            public var averageTalkTime: Double?

            public var averageWorkTime: Double?

            public var callsAnswered: Int64?

            public var callsAttendedTransferred: Int64?

            public var callsBlindTransferred: Int64?

            public var callsDialed: Int64?

            public var callsHold: Int64?

            public var callsRinged: Int64?

            public var maxDialingTime: Int64?

            public var maxHoldTime: Int64?

            public var maxRingTime: Int64?

            public var maxTalkTime: Int64?

            public var maxWorkTime: Int64?

            public var satisfactionIndex: Double?

            public var satisfactionRate: Double?

            public var satisfactionSurveysOffered: Int64?

            public var satisfactionSurveysResponded: Int64?

            public var totalDialingTime: Int64?

            public var totalHoldTime: Int64?

            public var totalRingTime: Int64?

            public var totalTalkTime: Int64?

            public var totalWorkTime: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.answerRate != nil {
                    map["AnswerRate"] = self.answerRate!
                }
                if self.averageDialingTime != nil {
                    map["AverageDialingTime"] = self.averageDialingTime!
                }
                if self.averageHoldTime != nil {
                    map["AverageHoldTime"] = self.averageHoldTime!
                }
                if self.averageRingTime != nil {
                    map["AverageRingTime"] = self.averageRingTime!
                }
                if self.averageTalkTime != nil {
                    map["AverageTalkTime"] = self.averageTalkTime!
                }
                if self.averageWorkTime != nil {
                    map["AverageWorkTime"] = self.averageWorkTime!
                }
                if self.callsAnswered != nil {
                    map["CallsAnswered"] = self.callsAnswered!
                }
                if self.callsAttendedTransferred != nil {
                    map["CallsAttendedTransferred"] = self.callsAttendedTransferred!
                }
                if self.callsBlindTransferred != nil {
                    map["CallsBlindTransferred"] = self.callsBlindTransferred!
                }
                if self.callsDialed != nil {
                    map["CallsDialed"] = self.callsDialed!
                }
                if self.callsHold != nil {
                    map["CallsHold"] = self.callsHold!
                }
                if self.callsRinged != nil {
                    map["CallsRinged"] = self.callsRinged!
                }
                if self.maxDialingTime != nil {
                    map["MaxDialingTime"] = self.maxDialingTime!
                }
                if self.maxHoldTime != nil {
                    map["MaxHoldTime"] = self.maxHoldTime!
                }
                if self.maxRingTime != nil {
                    map["MaxRingTime"] = self.maxRingTime!
                }
                if self.maxTalkTime != nil {
                    map["MaxTalkTime"] = self.maxTalkTime!
                }
                if self.maxWorkTime != nil {
                    map["MaxWorkTime"] = self.maxWorkTime!
                }
                if self.satisfactionIndex != nil {
                    map["SatisfactionIndex"] = self.satisfactionIndex!
                }
                if self.satisfactionRate != nil {
                    map["SatisfactionRate"] = self.satisfactionRate!
                }
                if self.satisfactionSurveysOffered != nil {
                    map["SatisfactionSurveysOffered"] = self.satisfactionSurveysOffered!
                }
                if self.satisfactionSurveysResponded != nil {
                    map["SatisfactionSurveysResponded"] = self.satisfactionSurveysResponded!
                }
                if self.totalDialingTime != nil {
                    map["TotalDialingTime"] = self.totalDialingTime!
                }
                if self.totalHoldTime != nil {
                    map["TotalHoldTime"] = self.totalHoldTime!
                }
                if self.totalRingTime != nil {
                    map["TotalRingTime"] = self.totalRingTime!
                }
                if self.totalTalkTime != nil {
                    map["TotalTalkTime"] = self.totalTalkTime!
                }
                if self.totalWorkTime != nil {
                    map["TotalWorkTime"] = self.totalWorkTime!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AnswerRate") && dict["AnswerRate"] != nil {
                    self.answerRate = dict["AnswerRate"] as! Double
                }
                if dict.keys.contains("AverageDialingTime") && dict["AverageDialingTime"] != nil {
                    self.averageDialingTime = dict["AverageDialingTime"] as! Double
                }
                if dict.keys.contains("AverageHoldTime") && dict["AverageHoldTime"] != nil {
                    self.averageHoldTime = dict["AverageHoldTime"] as! Double
                }
                if dict.keys.contains("AverageRingTime") && dict["AverageRingTime"] != nil {
                    self.averageRingTime = dict["AverageRingTime"] as! Double
                }
                if dict.keys.contains("AverageTalkTime") && dict["AverageTalkTime"] != nil {
                    self.averageTalkTime = dict["AverageTalkTime"] as! Double
                }
                if dict.keys.contains("AverageWorkTime") && dict["AverageWorkTime"] != nil {
                    self.averageWorkTime = dict["AverageWorkTime"] as! Double
                }
                if dict.keys.contains("CallsAnswered") && dict["CallsAnswered"] != nil {
                    self.callsAnswered = dict["CallsAnswered"] as! Int64
                }
                if dict.keys.contains("CallsAttendedTransferred") && dict["CallsAttendedTransferred"] != nil {
                    self.callsAttendedTransferred = dict["CallsAttendedTransferred"] as! Int64
                }
                if dict.keys.contains("CallsBlindTransferred") && dict["CallsBlindTransferred"] != nil {
                    self.callsBlindTransferred = dict["CallsBlindTransferred"] as! Int64
                }
                if dict.keys.contains("CallsDialed") && dict["CallsDialed"] != nil {
                    self.callsDialed = dict["CallsDialed"] as! Int64
                }
                if dict.keys.contains("CallsHold") && dict["CallsHold"] != nil {
                    self.callsHold = dict["CallsHold"] as! Int64
                }
                if dict.keys.contains("CallsRinged") && dict["CallsRinged"] != nil {
                    self.callsRinged = dict["CallsRinged"] as! Int64
                }
                if dict.keys.contains("MaxDialingTime") && dict["MaxDialingTime"] != nil {
                    self.maxDialingTime = dict["MaxDialingTime"] as! Int64
                }
                if dict.keys.contains("MaxHoldTime") && dict["MaxHoldTime"] != nil {
                    self.maxHoldTime = dict["MaxHoldTime"] as! Int64
                }
                if dict.keys.contains("MaxRingTime") && dict["MaxRingTime"] != nil {
                    self.maxRingTime = dict["MaxRingTime"] as! Int64
                }
                if dict.keys.contains("MaxTalkTime") && dict["MaxTalkTime"] != nil {
                    self.maxTalkTime = dict["MaxTalkTime"] as! Int64
                }
                if dict.keys.contains("MaxWorkTime") && dict["MaxWorkTime"] != nil {
                    self.maxWorkTime = dict["MaxWorkTime"] as! Int64
                }
                if dict.keys.contains("SatisfactionIndex") && dict["SatisfactionIndex"] != nil {
                    self.satisfactionIndex = dict["SatisfactionIndex"] as! Double
                }
                if dict.keys.contains("SatisfactionRate") && dict["SatisfactionRate"] != nil {
                    self.satisfactionRate = dict["SatisfactionRate"] as! Double
                }
                if dict.keys.contains("SatisfactionSurveysOffered") && dict["SatisfactionSurveysOffered"] != nil {
                    self.satisfactionSurveysOffered = dict["SatisfactionSurveysOffered"] as! Int64
                }
                if dict.keys.contains("SatisfactionSurveysResponded") && dict["SatisfactionSurveysResponded"] != nil {
                    self.satisfactionSurveysResponded = dict["SatisfactionSurveysResponded"] as! Int64
                }
                if dict.keys.contains("TotalDialingTime") && dict["TotalDialingTime"] != nil {
                    self.totalDialingTime = dict["TotalDialingTime"] as! Int64
                }
                if dict.keys.contains("TotalHoldTime") && dict["TotalHoldTime"] != nil {
                    self.totalHoldTime = dict["TotalHoldTime"] as! Int64
                }
                if dict.keys.contains("TotalRingTime") && dict["TotalRingTime"] != nil {
                    self.totalRingTime = dict["TotalRingTime"] as! Int64
                }
                if dict.keys.contains("TotalTalkTime") && dict["TotalTalkTime"] != nil {
                    self.totalTalkTime = dict["TotalTalkTime"] as! Int64
                }
                if dict.keys.contains("TotalWorkTime") && dict["TotalWorkTime"] != nil {
                    self.totalWorkTime = dict["TotalWorkTime"] as! Int64
                }
            }
        }
        public class Overall : Tea.TeaModel {
            public var averageBreakTime: Double?

            public var averageHoldTime: Double?

            public var averageReadyTime: Double?

            public var averageTalkTime: Double?

            public var averageWorkTime: Double?

            public var maxBreakTime: Int64?

            public var maxHoldTime: Int64?

            public var maxReadyTime: Int64?

            public var maxTalkTime: Int64?

            public var maxWorkTime: Int64?

            public var occupancyRate: Double?

            public var satisfactionIndex: Double?

            public var satisfactionRate: Double?

            public var satisfactionSurveysOffered: Int64?

            public var satisfactionSurveysResponded: Int64?

            public var totalBreakTime: Int64?

            public var totalCalls: Int64?

            public var totalHoldTime: Int64?

            public var totalLoggedInTime: Int64?

            public var totalReadyTime: Int64?

            public var totalTalkTime: Int64?

            public var totalWorkTime: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.averageBreakTime != nil {
                    map["AverageBreakTime"] = self.averageBreakTime!
                }
                if self.averageHoldTime != nil {
                    map["AverageHoldTime"] = self.averageHoldTime!
                }
                if self.averageReadyTime != nil {
                    map["AverageReadyTime"] = self.averageReadyTime!
                }
                if self.averageTalkTime != nil {
                    map["AverageTalkTime"] = self.averageTalkTime!
                }
                if self.averageWorkTime != nil {
                    map["AverageWorkTime"] = self.averageWorkTime!
                }
                if self.maxBreakTime != nil {
                    map["MaxBreakTime"] = self.maxBreakTime!
                }
                if self.maxHoldTime != nil {
                    map["MaxHoldTime"] = self.maxHoldTime!
                }
                if self.maxReadyTime != nil {
                    map["MaxReadyTime"] = self.maxReadyTime!
                }
                if self.maxTalkTime != nil {
                    map["MaxTalkTime"] = self.maxTalkTime!
                }
                if self.maxWorkTime != nil {
                    map["MaxWorkTime"] = self.maxWorkTime!
                }
                if self.occupancyRate != nil {
                    map["OccupancyRate"] = self.occupancyRate!
                }
                if self.satisfactionIndex != nil {
                    map["SatisfactionIndex"] = self.satisfactionIndex!
                }
                if self.satisfactionRate != nil {
                    map["SatisfactionRate"] = self.satisfactionRate!
                }
                if self.satisfactionSurveysOffered != nil {
                    map["SatisfactionSurveysOffered"] = self.satisfactionSurveysOffered!
                }
                if self.satisfactionSurveysResponded != nil {
                    map["SatisfactionSurveysResponded"] = self.satisfactionSurveysResponded!
                }
                if self.totalBreakTime != nil {
                    map["TotalBreakTime"] = self.totalBreakTime!
                }
                if self.totalCalls != nil {
                    map["TotalCalls"] = self.totalCalls!
                }
                if self.totalHoldTime != nil {
                    map["TotalHoldTime"] = self.totalHoldTime!
                }
                if self.totalLoggedInTime != nil {
                    map["TotalLoggedInTime"] = self.totalLoggedInTime!
                }
                if self.totalReadyTime != nil {
                    map["TotalReadyTime"] = self.totalReadyTime!
                }
                if self.totalTalkTime != nil {
                    map["TotalTalkTime"] = self.totalTalkTime!
                }
                if self.totalWorkTime != nil {
                    map["TotalWorkTime"] = self.totalWorkTime!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AverageBreakTime") && dict["AverageBreakTime"] != nil {
                    self.averageBreakTime = dict["AverageBreakTime"] as! Double
                }
                if dict.keys.contains("AverageHoldTime") && dict["AverageHoldTime"] != nil {
                    self.averageHoldTime = dict["AverageHoldTime"] as! Double
                }
                if dict.keys.contains("AverageReadyTime") && dict["AverageReadyTime"] != nil {
                    self.averageReadyTime = dict["AverageReadyTime"] as! Double
                }
                if dict.keys.contains("AverageTalkTime") && dict["AverageTalkTime"] != nil {
                    self.averageTalkTime = dict["AverageTalkTime"] as! Double
                }
                if dict.keys.contains("AverageWorkTime") && dict["AverageWorkTime"] != nil {
                    self.averageWorkTime = dict["AverageWorkTime"] as! Double
                }
                if dict.keys.contains("MaxBreakTime") && dict["MaxBreakTime"] != nil {
                    self.maxBreakTime = dict["MaxBreakTime"] as! Int64
                }
                if dict.keys.contains("MaxHoldTime") && dict["MaxHoldTime"] != nil {
                    self.maxHoldTime = dict["MaxHoldTime"] as! Int64
                }
                if dict.keys.contains("MaxReadyTime") && dict["MaxReadyTime"] != nil {
                    self.maxReadyTime = dict["MaxReadyTime"] as! Int64
                }
                if dict.keys.contains("MaxTalkTime") && dict["MaxTalkTime"] != nil {
                    self.maxTalkTime = dict["MaxTalkTime"] as! Int64
                }
                if dict.keys.contains("MaxWorkTime") && dict["MaxWorkTime"] != nil {
                    self.maxWorkTime = dict["MaxWorkTime"] as! Int64
                }
                if dict.keys.contains("OccupancyRate") && dict["OccupancyRate"] != nil {
                    self.occupancyRate = dict["OccupancyRate"] as! Double
                }
                if dict.keys.contains("SatisfactionIndex") && dict["SatisfactionIndex"] != nil {
                    self.satisfactionIndex = dict["SatisfactionIndex"] as! Double
                }
                if dict.keys.contains("SatisfactionRate") && dict["SatisfactionRate"] != nil {
                    self.satisfactionRate = dict["SatisfactionRate"] as! Double
                }
                if dict.keys.contains("SatisfactionSurveysOffered") && dict["SatisfactionSurveysOffered"] != nil {
                    self.satisfactionSurveysOffered = dict["SatisfactionSurveysOffered"] as! Int64
                }
                if dict.keys.contains("SatisfactionSurveysResponded") && dict["SatisfactionSurveysResponded"] != nil {
                    self.satisfactionSurveysResponded = dict["SatisfactionSurveysResponded"] as! Int64
                }
                if dict.keys.contains("TotalBreakTime") && dict["TotalBreakTime"] != nil {
                    self.totalBreakTime = dict["TotalBreakTime"] as! Int64
                }
                if dict.keys.contains("TotalCalls") && dict["TotalCalls"] != nil {
                    self.totalCalls = dict["TotalCalls"] as! Int64
                }
                if dict.keys.contains("TotalHoldTime") && dict["TotalHoldTime"] != nil {
                    self.totalHoldTime = dict["TotalHoldTime"] as! Int64
                }
                if dict.keys.contains("TotalLoggedInTime") && dict["TotalLoggedInTime"] != nil {
                    self.totalLoggedInTime = dict["TotalLoggedInTime"] as! Int64
                }
                if dict.keys.contains("TotalReadyTime") && dict["TotalReadyTime"] != nil {
                    self.totalReadyTime = dict["TotalReadyTime"] as! Int64
                }
                if dict.keys.contains("TotalTalkTime") && dict["TotalTalkTime"] != nil {
                    self.totalTalkTime = dict["TotalTalkTime"] as! Int64
                }
                if dict.keys.contains("TotalWorkTime") && dict["TotalWorkTime"] != nil {
                    self.totalWorkTime = dict["TotalWorkTime"] as! Int64
                }
            }
        }
        public var inbound: ListIntervalInstanceReportResponseBody.Data.Inbound?

        public var outbound: ListIntervalInstanceReportResponseBody.Data.Outbound?

        public var overall: ListIntervalInstanceReportResponseBody.Data.Overall?

        public var statsTime: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.inbound?.validate()
            try self.outbound?.validate()
            try self.overall?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.inbound != nil {
                map["Inbound"] = self.inbound?.toMap()
            }
            if self.outbound != nil {
                map["Outbound"] = self.outbound?.toMap()
            }
            if self.overall != nil {
                map["Overall"] = self.overall?.toMap()
            }
            if self.statsTime != nil {
                map["StatsTime"] = self.statsTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Inbound") && dict["Inbound"] != nil {
                var model = ListIntervalInstanceReportResponseBody.Data.Inbound()
                model.fromMap(dict["Inbound"] as! [String: Any])
                self.inbound = model
            }
            if dict.keys.contains("Outbound") && dict["Outbound"] != nil {
                var model = ListIntervalInstanceReportResponseBody.Data.Outbound()
                model.fromMap(dict["Outbound"] as! [String: Any])
                self.outbound = model
            }
            if dict.keys.contains("Overall") && dict["Overall"] != nil {
                var model = ListIntervalInstanceReportResponseBody.Data.Overall()
                model.fromMap(dict["Overall"] as! [String: Any])
                self.overall = model
            }
            if dict.keys.contains("StatsTime") && dict["StatsTime"] != nil {
                self.statsTime = dict["StatsTime"] as! Int64
            }
        }
    }
    public var code: String?

    public var data: [ListIntervalInstanceReportResponseBody.Data]?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var tmp : [ListIntervalInstanceReportResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = ListIntervalInstanceReportResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListIntervalInstanceReportResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListIntervalInstanceReportResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListIntervalInstanceReportResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListIntervalSkillGroupReportRequest : Tea.TeaModel {
    public var endTime: Int64?

    public var instanceId: String?

    public var interval: String?

    public var skillGroupId: String?

    public var startTime: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.interval != nil {
            map["Interval"] = self.interval!
        }
        if self.skillGroupId != nil {
            map["SkillGroupId"] = self.skillGroupId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Interval") && dict["Interval"] != nil {
            self.interval = dict["Interval"] as! String
        }
        if dict.keys.contains("SkillGroupId") && dict["SkillGroupId"] != nil {
            self.skillGroupId = dict["SkillGroupId"] as! String
        }
        if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
            self.startTime = dict["StartTime"] as! Int64
        }
    }
}

public class ListIntervalSkillGroupReportResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Inbound : Tea.TeaModel {
            public var abandonRate: Double?

            public var averageAbandonTime: Double?

            public var averageAbandonedInQueueTime: Double?

            public var averageAbandonedInRingTime: Double?

            public var averageHoldTime: Double?

            public var averageRingTime: Double?

            public var averageTalkTime: Double?

            public var averageWaitTime: Double?

            public var averageWorkTime: Double?

            public var callsAbandoned: Int64?

            public var callsAbandonedInQueue: Int64?

            public var callsAbandonedInRing: Int64?

            public var callsAttendedTransferIn: Int64?

            public var callsAttendedTransferOut: Int64?

            public var callsBlindTransferIn: Int64?

            public var callsBlindTransferOut: Int64?

            public var callsHandled: Int64?

            public var callsHold: Int64?

            public var callsOffered: Int64?

            public var callsOverflow: Int64?

            public var callsQueued: Int64?

            public var callsRinged: Int64?

            public var callsTimeout: Int64?

            public var handleRate: Double?

            public var maxAbandonTime: Int64?

            public var maxAbandonedInQueueTime: Int64?

            public var maxAbandonedInRingTime: Int64?

            public var maxHoldTime: Int64?

            public var maxRingTime: Int64?

            public var maxTalkTime: Int64?

            public var maxWaitTime: Int64?

            public var maxWorkTime: Int64?

            public var satisfactionIndex: Double?

            public var satisfactionRate: Double?

            public var satisfactionSurveysOffered: Int64?

            public var satisfactionSurveysResponded: Int64?

            public var serviceLevel20: Double?

            public var totalAbandonTime: Int64?

            public var totalAbandonedInQueueTime: Int64?

            public var totalAbandonedInRingTime: Int64?

            public var totalHoldTime: Int64?

            public var totalRingTime: Int64?

            public var totalTalkTime: Int64?

            public var totalWaitTime: Int64?

            public var totalWorkTime: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.abandonRate != nil {
                    map["AbandonRate"] = self.abandonRate!
                }
                if self.averageAbandonTime != nil {
                    map["AverageAbandonTime"] = self.averageAbandonTime!
                }
                if self.averageAbandonedInQueueTime != nil {
                    map["AverageAbandonedInQueueTime"] = self.averageAbandonedInQueueTime!
                }
                if self.averageAbandonedInRingTime != nil {
                    map["AverageAbandonedInRingTime"] = self.averageAbandonedInRingTime!
                }
                if self.averageHoldTime != nil {
                    map["AverageHoldTime"] = self.averageHoldTime!
                }
                if self.averageRingTime != nil {
                    map["AverageRingTime"] = self.averageRingTime!
                }
                if self.averageTalkTime != nil {
                    map["AverageTalkTime"] = self.averageTalkTime!
                }
                if self.averageWaitTime != nil {
                    map["AverageWaitTime"] = self.averageWaitTime!
                }
                if self.averageWorkTime != nil {
                    map["AverageWorkTime"] = self.averageWorkTime!
                }
                if self.callsAbandoned != nil {
                    map["CallsAbandoned"] = self.callsAbandoned!
                }
                if self.callsAbandonedInQueue != nil {
                    map["CallsAbandonedInQueue"] = self.callsAbandonedInQueue!
                }
                if self.callsAbandonedInRing != nil {
                    map["CallsAbandonedInRing"] = self.callsAbandonedInRing!
                }
                if self.callsAttendedTransferIn != nil {
                    map["CallsAttendedTransferIn"] = self.callsAttendedTransferIn!
                }
                if self.callsAttendedTransferOut != nil {
                    map["CallsAttendedTransferOut"] = self.callsAttendedTransferOut!
                }
                if self.callsBlindTransferIn != nil {
                    map["CallsBlindTransferIn"] = self.callsBlindTransferIn!
                }
                if self.callsBlindTransferOut != nil {
                    map["CallsBlindTransferOut"] = self.callsBlindTransferOut!
                }
                if self.callsHandled != nil {
                    map["CallsHandled"] = self.callsHandled!
                }
                if self.callsHold != nil {
                    map["CallsHold"] = self.callsHold!
                }
                if self.callsOffered != nil {
                    map["CallsOffered"] = self.callsOffered!
                }
                if self.callsOverflow != nil {
                    map["CallsOverflow"] = self.callsOverflow!
                }
                if self.callsQueued != nil {
                    map["CallsQueued"] = self.callsQueued!
                }
                if self.callsRinged != nil {
                    map["CallsRinged"] = self.callsRinged!
                }
                if self.callsTimeout != nil {
                    map["CallsTimeout"] = self.callsTimeout!
                }
                if self.handleRate != nil {
                    map["HandleRate"] = self.handleRate!
                }
                if self.maxAbandonTime != nil {
                    map["MaxAbandonTime"] = self.maxAbandonTime!
                }
                if self.maxAbandonedInQueueTime != nil {
                    map["MaxAbandonedInQueueTime"] = self.maxAbandonedInQueueTime!
                }
                if self.maxAbandonedInRingTime != nil {
                    map["MaxAbandonedInRingTime"] = self.maxAbandonedInRingTime!
                }
                if self.maxHoldTime != nil {
                    map["MaxHoldTime"] = self.maxHoldTime!
                }
                if self.maxRingTime != nil {
                    map["MaxRingTime"] = self.maxRingTime!
                }
                if self.maxTalkTime != nil {
                    map["MaxTalkTime"] = self.maxTalkTime!
                }
                if self.maxWaitTime != nil {
                    map["MaxWaitTime"] = self.maxWaitTime!
                }
                if self.maxWorkTime != nil {
                    map["MaxWorkTime"] = self.maxWorkTime!
                }
                if self.satisfactionIndex != nil {
                    map["SatisfactionIndex"] = self.satisfactionIndex!
                }
                if self.satisfactionRate != nil {
                    map["SatisfactionRate"] = self.satisfactionRate!
                }
                if self.satisfactionSurveysOffered != nil {
                    map["SatisfactionSurveysOffered"] = self.satisfactionSurveysOffered!
                }
                if self.satisfactionSurveysResponded != nil {
                    map["SatisfactionSurveysResponded"] = self.satisfactionSurveysResponded!
                }
                if self.serviceLevel20 != nil {
                    map["ServiceLevel20"] = self.serviceLevel20!
                }
                if self.totalAbandonTime != nil {
                    map["TotalAbandonTime"] = self.totalAbandonTime!
                }
                if self.totalAbandonedInQueueTime != nil {
                    map["TotalAbandonedInQueueTime"] = self.totalAbandonedInQueueTime!
                }
                if self.totalAbandonedInRingTime != nil {
                    map["TotalAbandonedInRingTime"] = self.totalAbandonedInRingTime!
                }
                if self.totalHoldTime != nil {
                    map["TotalHoldTime"] = self.totalHoldTime!
                }
                if self.totalRingTime != nil {
                    map["TotalRingTime"] = self.totalRingTime!
                }
                if self.totalTalkTime != nil {
                    map["TotalTalkTime"] = self.totalTalkTime!
                }
                if self.totalWaitTime != nil {
                    map["TotalWaitTime"] = self.totalWaitTime!
                }
                if self.totalWorkTime != nil {
                    map["TotalWorkTime"] = self.totalWorkTime!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AbandonRate") && dict["AbandonRate"] != nil {
                    self.abandonRate = dict["AbandonRate"] as! Double
                }
                if dict.keys.contains("AverageAbandonTime") && dict["AverageAbandonTime"] != nil {
                    self.averageAbandonTime = dict["AverageAbandonTime"] as! Double
                }
                if dict.keys.contains("AverageAbandonedInQueueTime") && dict["AverageAbandonedInQueueTime"] != nil {
                    self.averageAbandonedInQueueTime = dict["AverageAbandonedInQueueTime"] as! Double
                }
                if dict.keys.contains("AverageAbandonedInRingTime") && dict["AverageAbandonedInRingTime"] != nil {
                    self.averageAbandonedInRingTime = dict["AverageAbandonedInRingTime"] as! Double
                }
                if dict.keys.contains("AverageHoldTime") && dict["AverageHoldTime"] != nil {
                    self.averageHoldTime = dict["AverageHoldTime"] as! Double
                }
                if dict.keys.contains("AverageRingTime") && dict["AverageRingTime"] != nil {
                    self.averageRingTime = dict["AverageRingTime"] as! Double
                }
                if dict.keys.contains("AverageTalkTime") && dict["AverageTalkTime"] != nil {
                    self.averageTalkTime = dict["AverageTalkTime"] as! Double
                }
                if dict.keys.contains("AverageWaitTime") && dict["AverageWaitTime"] != nil {
                    self.averageWaitTime = dict["AverageWaitTime"] as! Double
                }
                if dict.keys.contains("AverageWorkTime") && dict["AverageWorkTime"] != nil {
                    self.averageWorkTime = dict["AverageWorkTime"] as! Double
                }
                if dict.keys.contains("CallsAbandoned") && dict["CallsAbandoned"] != nil {
                    self.callsAbandoned = dict["CallsAbandoned"] as! Int64
                }
                if dict.keys.contains("CallsAbandonedInQueue") && dict["CallsAbandonedInQueue"] != nil {
                    self.callsAbandonedInQueue = dict["CallsAbandonedInQueue"] as! Int64
                }
                if dict.keys.contains("CallsAbandonedInRing") && dict["CallsAbandonedInRing"] != nil {
                    self.callsAbandonedInRing = dict["CallsAbandonedInRing"] as! Int64
                }
                if dict.keys.contains("CallsAttendedTransferIn") && dict["CallsAttendedTransferIn"] != nil {
                    self.callsAttendedTransferIn = dict["CallsAttendedTransferIn"] as! Int64
                }
                if dict.keys.contains("CallsAttendedTransferOut") && dict["CallsAttendedTransferOut"] != nil {
                    self.callsAttendedTransferOut = dict["CallsAttendedTransferOut"] as! Int64
                }
                if dict.keys.contains("CallsBlindTransferIn") && dict["CallsBlindTransferIn"] != nil {
                    self.callsBlindTransferIn = dict["CallsBlindTransferIn"] as! Int64
                }
                if dict.keys.contains("CallsBlindTransferOut") && dict["CallsBlindTransferOut"] != nil {
                    self.callsBlindTransferOut = dict["CallsBlindTransferOut"] as! Int64
                }
                if dict.keys.contains("CallsHandled") && dict["CallsHandled"] != nil {
                    self.callsHandled = dict["CallsHandled"] as! Int64
                }
                if dict.keys.contains("CallsHold") && dict["CallsHold"] != nil {
                    self.callsHold = dict["CallsHold"] as! Int64
                }
                if dict.keys.contains("CallsOffered") && dict["CallsOffered"] != nil {
                    self.callsOffered = dict["CallsOffered"] as! Int64
                }
                if dict.keys.contains("CallsOverflow") && dict["CallsOverflow"] != nil {
                    self.callsOverflow = dict["CallsOverflow"] as! Int64
                }
                if dict.keys.contains("CallsQueued") && dict["CallsQueued"] != nil {
                    self.callsQueued = dict["CallsQueued"] as! Int64
                }
                if dict.keys.contains("CallsRinged") && dict["CallsRinged"] != nil {
                    self.callsRinged = dict["CallsRinged"] as! Int64
                }
                if dict.keys.contains("CallsTimeout") && dict["CallsTimeout"] != nil {
                    self.callsTimeout = dict["CallsTimeout"] as! Int64
                }
                if dict.keys.contains("HandleRate") && dict["HandleRate"] != nil {
                    self.handleRate = dict["HandleRate"] as! Double
                }
                if dict.keys.contains("MaxAbandonTime") && dict["MaxAbandonTime"] != nil {
                    self.maxAbandonTime = dict["MaxAbandonTime"] as! Int64
                }
                if dict.keys.contains("MaxAbandonedInQueueTime") && dict["MaxAbandonedInQueueTime"] != nil {
                    self.maxAbandonedInQueueTime = dict["MaxAbandonedInQueueTime"] as! Int64
                }
                if dict.keys.contains("MaxAbandonedInRingTime") && dict["MaxAbandonedInRingTime"] != nil {
                    self.maxAbandonedInRingTime = dict["MaxAbandonedInRingTime"] as! Int64
                }
                if dict.keys.contains("MaxHoldTime") && dict["MaxHoldTime"] != nil {
                    self.maxHoldTime = dict["MaxHoldTime"] as! Int64
                }
                if dict.keys.contains("MaxRingTime") && dict["MaxRingTime"] != nil {
                    self.maxRingTime = dict["MaxRingTime"] as! Int64
                }
                if dict.keys.contains("MaxTalkTime") && dict["MaxTalkTime"] != nil {
                    self.maxTalkTime = dict["MaxTalkTime"] as! Int64
                }
                if dict.keys.contains("MaxWaitTime") && dict["MaxWaitTime"] != nil {
                    self.maxWaitTime = dict["MaxWaitTime"] as! Int64
                }
                if dict.keys.contains("MaxWorkTime") && dict["MaxWorkTime"] != nil {
                    self.maxWorkTime = dict["MaxWorkTime"] as! Int64
                }
                if dict.keys.contains("SatisfactionIndex") && dict["SatisfactionIndex"] != nil {
                    self.satisfactionIndex = dict["SatisfactionIndex"] as! Double
                }
                if dict.keys.contains("SatisfactionRate") && dict["SatisfactionRate"] != nil {
                    self.satisfactionRate = dict["SatisfactionRate"] as! Double
                }
                if dict.keys.contains("SatisfactionSurveysOffered") && dict["SatisfactionSurveysOffered"] != nil {
                    self.satisfactionSurveysOffered = dict["SatisfactionSurveysOffered"] as! Int64
                }
                if dict.keys.contains("SatisfactionSurveysResponded") && dict["SatisfactionSurveysResponded"] != nil {
                    self.satisfactionSurveysResponded = dict["SatisfactionSurveysResponded"] as! Int64
                }
                if dict.keys.contains("ServiceLevel20") && dict["ServiceLevel20"] != nil {
                    self.serviceLevel20 = dict["ServiceLevel20"] as! Double
                }
                if dict.keys.contains("TotalAbandonTime") && dict["TotalAbandonTime"] != nil {
                    self.totalAbandonTime = dict["TotalAbandonTime"] as! Int64
                }
                if dict.keys.contains("TotalAbandonedInQueueTime") && dict["TotalAbandonedInQueueTime"] != nil {
                    self.totalAbandonedInQueueTime = dict["TotalAbandonedInQueueTime"] as! Int64
                }
                if dict.keys.contains("TotalAbandonedInRingTime") && dict["TotalAbandonedInRingTime"] != nil {
                    self.totalAbandonedInRingTime = dict["TotalAbandonedInRingTime"] as! Int64
                }
                if dict.keys.contains("TotalHoldTime") && dict["TotalHoldTime"] != nil {
                    self.totalHoldTime = dict["TotalHoldTime"] as! Int64
                }
                if dict.keys.contains("TotalRingTime") && dict["TotalRingTime"] != nil {
                    self.totalRingTime = dict["TotalRingTime"] as! Int64
                }
                if dict.keys.contains("TotalTalkTime") && dict["TotalTalkTime"] != nil {
                    self.totalTalkTime = dict["TotalTalkTime"] as! Int64
                }
                if dict.keys.contains("TotalWaitTime") && dict["TotalWaitTime"] != nil {
                    self.totalWaitTime = dict["TotalWaitTime"] as! Int64
                }
                if dict.keys.contains("TotalWorkTime") && dict["TotalWorkTime"] != nil {
                    self.totalWorkTime = dict["TotalWorkTime"] as! Int64
                }
            }
        }
        public class Outbound : Tea.TeaModel {
            public var answerRate: Double?

            public var averageDialingTime: Double?

            public var averageHoldTime: Double?

            public var averageRingTime: Double?

            public var averageTalkTime: Double?

            public var averageWorkTime: Double?

            public var callsAnswered: Int64?

            public var callsAttendedTransferIn: Int64?

            public var callsAttendedTransferOut: Int64?

            public var callsBlindTransferIn: Int64?

            public var callsBlindTransferOut: Int64?

            public var callsDialed: Int64?

            public var callsHold: Int64?

            public var callsRinged: Int64?

            public var maxDialingTime: Int64?

            public var maxHoldTime: Int64?

            public var maxRingTime: Int64?

            public var maxTalkTime: Int64?

            public var maxWorkTime: Int64?

            public var satisfactionIndex: Double?

            public var satisfactionRate: Double?

            public var satisfactionSurveysOffered: Int64?

            public var satisfactionSurveysResponded: Int64?

            public var totalDialingTime: Int64?

            public var totalHoldTime: Int64?

            public var totalRingTime: Int64?

            public var totalTalkTime: Int64?

            public var totalWorkTime: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.answerRate != nil {
                    map["AnswerRate"] = self.answerRate!
                }
                if self.averageDialingTime != nil {
                    map["AverageDialingTime"] = self.averageDialingTime!
                }
                if self.averageHoldTime != nil {
                    map["AverageHoldTime"] = self.averageHoldTime!
                }
                if self.averageRingTime != nil {
                    map["AverageRingTime"] = self.averageRingTime!
                }
                if self.averageTalkTime != nil {
                    map["AverageTalkTime"] = self.averageTalkTime!
                }
                if self.averageWorkTime != nil {
                    map["AverageWorkTime"] = self.averageWorkTime!
                }
                if self.callsAnswered != nil {
                    map["CallsAnswered"] = self.callsAnswered!
                }
                if self.callsAttendedTransferIn != nil {
                    map["CallsAttendedTransferIn"] = self.callsAttendedTransferIn!
                }
                if self.callsAttendedTransferOut != nil {
                    map["CallsAttendedTransferOut"] = self.callsAttendedTransferOut!
                }
                if self.callsBlindTransferIn != nil {
                    map["CallsBlindTransferIn"] = self.callsBlindTransferIn!
                }
                if self.callsBlindTransferOut != nil {
                    map["CallsBlindTransferOut"] = self.callsBlindTransferOut!
                }
                if self.callsDialed != nil {
                    map["CallsDialed"] = self.callsDialed!
                }
                if self.callsHold != nil {
                    map["CallsHold"] = self.callsHold!
                }
                if self.callsRinged != nil {
                    map["CallsRinged"] = self.callsRinged!
                }
                if self.maxDialingTime != nil {
                    map["MaxDialingTime"] = self.maxDialingTime!
                }
                if self.maxHoldTime != nil {
                    map["MaxHoldTime"] = self.maxHoldTime!
                }
                if self.maxRingTime != nil {
                    map["MaxRingTime"] = self.maxRingTime!
                }
                if self.maxTalkTime != nil {
                    map["MaxTalkTime"] = self.maxTalkTime!
                }
                if self.maxWorkTime != nil {
                    map["MaxWorkTime"] = self.maxWorkTime!
                }
                if self.satisfactionIndex != nil {
                    map["SatisfactionIndex"] = self.satisfactionIndex!
                }
                if self.satisfactionRate != nil {
                    map["SatisfactionRate"] = self.satisfactionRate!
                }
                if self.satisfactionSurveysOffered != nil {
                    map["SatisfactionSurveysOffered"] = self.satisfactionSurveysOffered!
                }
                if self.satisfactionSurveysResponded != nil {
                    map["SatisfactionSurveysResponded"] = self.satisfactionSurveysResponded!
                }
                if self.totalDialingTime != nil {
                    map["TotalDialingTime"] = self.totalDialingTime!
                }
                if self.totalHoldTime != nil {
                    map["TotalHoldTime"] = self.totalHoldTime!
                }
                if self.totalRingTime != nil {
                    map["TotalRingTime"] = self.totalRingTime!
                }
                if self.totalTalkTime != nil {
                    map["TotalTalkTime"] = self.totalTalkTime!
                }
                if self.totalWorkTime != nil {
                    map["TotalWorkTime"] = self.totalWorkTime!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AnswerRate") && dict["AnswerRate"] != nil {
                    self.answerRate = dict["AnswerRate"] as! Double
                }
                if dict.keys.contains("AverageDialingTime") && dict["AverageDialingTime"] != nil {
                    self.averageDialingTime = dict["AverageDialingTime"] as! Double
                }
                if dict.keys.contains("AverageHoldTime") && dict["AverageHoldTime"] != nil {
                    self.averageHoldTime = dict["AverageHoldTime"] as! Double
                }
                if dict.keys.contains("AverageRingTime") && dict["AverageRingTime"] != nil {
                    self.averageRingTime = dict["AverageRingTime"] as! Double
                }
                if dict.keys.contains("AverageTalkTime") && dict["AverageTalkTime"] != nil {
                    self.averageTalkTime = dict["AverageTalkTime"] as! Double
                }
                if dict.keys.contains("AverageWorkTime") && dict["AverageWorkTime"] != nil {
                    self.averageWorkTime = dict["AverageWorkTime"] as! Double
                }
                if dict.keys.contains("CallsAnswered") && dict["CallsAnswered"] != nil {
                    self.callsAnswered = dict["CallsAnswered"] as! Int64
                }
                if dict.keys.contains("CallsAttendedTransferIn") && dict["CallsAttendedTransferIn"] != nil {
                    self.callsAttendedTransferIn = dict["CallsAttendedTransferIn"] as! Int64
                }
                if dict.keys.contains("CallsAttendedTransferOut") && dict["CallsAttendedTransferOut"] != nil {
                    self.callsAttendedTransferOut = dict["CallsAttendedTransferOut"] as! Int64
                }
                if dict.keys.contains("CallsBlindTransferIn") && dict["CallsBlindTransferIn"] != nil {
                    self.callsBlindTransferIn = dict["CallsBlindTransferIn"] as! Int64
                }
                if dict.keys.contains("CallsBlindTransferOut") && dict["CallsBlindTransferOut"] != nil {
                    self.callsBlindTransferOut = dict["CallsBlindTransferOut"] as! Int64
                }
                if dict.keys.contains("CallsDialed") && dict["CallsDialed"] != nil {
                    self.callsDialed = dict["CallsDialed"] as! Int64
                }
                if dict.keys.contains("CallsHold") && dict["CallsHold"] != nil {
                    self.callsHold = dict["CallsHold"] as! Int64
                }
                if dict.keys.contains("CallsRinged") && dict["CallsRinged"] != nil {
                    self.callsRinged = dict["CallsRinged"] as! Int64
                }
                if dict.keys.contains("MaxDialingTime") && dict["MaxDialingTime"] != nil {
                    self.maxDialingTime = dict["MaxDialingTime"] as! Int64
                }
                if dict.keys.contains("MaxHoldTime") && dict["MaxHoldTime"] != nil {
                    self.maxHoldTime = dict["MaxHoldTime"] as! Int64
                }
                if dict.keys.contains("MaxRingTime") && dict["MaxRingTime"] != nil {
                    self.maxRingTime = dict["MaxRingTime"] as! Int64
                }
                if dict.keys.contains("MaxTalkTime") && dict["MaxTalkTime"] != nil {
                    self.maxTalkTime = dict["MaxTalkTime"] as! Int64
                }
                if dict.keys.contains("MaxWorkTime") && dict["MaxWorkTime"] != nil {
                    self.maxWorkTime = dict["MaxWorkTime"] as! Int64
                }
                if dict.keys.contains("SatisfactionIndex") && dict["SatisfactionIndex"] != nil {
                    self.satisfactionIndex = dict["SatisfactionIndex"] as! Double
                }
                if dict.keys.contains("SatisfactionRate") && dict["SatisfactionRate"] != nil {
                    self.satisfactionRate = dict["SatisfactionRate"] as! Double
                }
                if dict.keys.contains("SatisfactionSurveysOffered") && dict["SatisfactionSurveysOffered"] != nil {
                    self.satisfactionSurveysOffered = dict["SatisfactionSurveysOffered"] as! Int64
                }
                if dict.keys.contains("SatisfactionSurveysResponded") && dict["SatisfactionSurveysResponded"] != nil {
                    self.satisfactionSurveysResponded = dict["SatisfactionSurveysResponded"] as! Int64
                }
                if dict.keys.contains("TotalDialingTime") && dict["TotalDialingTime"] != nil {
                    self.totalDialingTime = dict["TotalDialingTime"] as! Int64
                }
                if dict.keys.contains("TotalHoldTime") && dict["TotalHoldTime"] != nil {
                    self.totalHoldTime = dict["TotalHoldTime"] as! Int64
                }
                if dict.keys.contains("TotalRingTime") && dict["TotalRingTime"] != nil {
                    self.totalRingTime = dict["TotalRingTime"] as! Int64
                }
                if dict.keys.contains("TotalTalkTime") && dict["TotalTalkTime"] != nil {
                    self.totalTalkTime = dict["TotalTalkTime"] as! Int64
                }
                if dict.keys.contains("TotalWorkTime") && dict["TotalWorkTime"] != nil {
                    self.totalWorkTime = dict["TotalWorkTime"] as! Int64
                }
            }
        }
        public class Overall : Tea.TeaModel {
            public var averageBreakTime: Double?

            public var averageHoldTime: Double?

            public var averageReadyTime: Double?

            public var averageTalkTime: Double?

            public var averageWorkTime: Double?

            public var maxBreakTime: Int64?

            public var maxHoldTime: Int64?

            public var maxReadyTime: Int64?

            public var maxTalkTime: Int64?

            public var maxWorkTime: Int64?

            public var occupancyRate: Double?

            public var satisfactionIndex: Double?

            public var satisfactionRate: Double?

            public var satisfactionSurveysOffered: Int64?

            public var satisfactionSurveysResponded: Int64?

            public var totalBreakTime: Int64?

            public var totalCalls: Int64?

            public var totalHoldTime: Int64?

            public var totalLoggedInTime: Int64?

            public var totalReadyTime: Int64?

            public var totalTalkTime: Int64?

            public var totalWorkTime: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.averageBreakTime != nil {
                    map["AverageBreakTime"] = self.averageBreakTime!
                }
                if self.averageHoldTime != nil {
                    map["AverageHoldTime"] = self.averageHoldTime!
                }
                if self.averageReadyTime != nil {
                    map["AverageReadyTime"] = self.averageReadyTime!
                }
                if self.averageTalkTime != nil {
                    map["AverageTalkTime"] = self.averageTalkTime!
                }
                if self.averageWorkTime != nil {
                    map["AverageWorkTime"] = self.averageWorkTime!
                }
                if self.maxBreakTime != nil {
                    map["MaxBreakTime"] = self.maxBreakTime!
                }
                if self.maxHoldTime != nil {
                    map["MaxHoldTime"] = self.maxHoldTime!
                }
                if self.maxReadyTime != nil {
                    map["MaxReadyTime"] = self.maxReadyTime!
                }
                if self.maxTalkTime != nil {
                    map["MaxTalkTime"] = self.maxTalkTime!
                }
                if self.maxWorkTime != nil {
                    map["MaxWorkTime"] = self.maxWorkTime!
                }
                if self.occupancyRate != nil {
                    map["OccupancyRate"] = self.occupancyRate!
                }
                if self.satisfactionIndex != nil {
                    map["SatisfactionIndex"] = self.satisfactionIndex!
                }
                if self.satisfactionRate != nil {
                    map["SatisfactionRate"] = self.satisfactionRate!
                }
                if self.satisfactionSurveysOffered != nil {
                    map["SatisfactionSurveysOffered"] = self.satisfactionSurveysOffered!
                }
                if self.satisfactionSurveysResponded != nil {
                    map["SatisfactionSurveysResponded"] = self.satisfactionSurveysResponded!
                }
                if self.totalBreakTime != nil {
                    map["TotalBreakTime"] = self.totalBreakTime!
                }
                if self.totalCalls != nil {
                    map["TotalCalls"] = self.totalCalls!
                }
                if self.totalHoldTime != nil {
                    map["TotalHoldTime"] = self.totalHoldTime!
                }
                if self.totalLoggedInTime != nil {
                    map["TotalLoggedInTime"] = self.totalLoggedInTime!
                }
                if self.totalReadyTime != nil {
                    map["TotalReadyTime"] = self.totalReadyTime!
                }
                if self.totalTalkTime != nil {
                    map["TotalTalkTime"] = self.totalTalkTime!
                }
                if self.totalWorkTime != nil {
                    map["TotalWorkTime"] = self.totalWorkTime!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AverageBreakTime") && dict["AverageBreakTime"] != nil {
                    self.averageBreakTime = dict["AverageBreakTime"] as! Double
                }
                if dict.keys.contains("AverageHoldTime") && dict["AverageHoldTime"] != nil {
                    self.averageHoldTime = dict["AverageHoldTime"] as! Double
                }
                if dict.keys.contains("AverageReadyTime") && dict["AverageReadyTime"] != nil {
                    self.averageReadyTime = dict["AverageReadyTime"] as! Double
                }
                if dict.keys.contains("AverageTalkTime") && dict["AverageTalkTime"] != nil {
                    self.averageTalkTime = dict["AverageTalkTime"] as! Double
                }
                if dict.keys.contains("AverageWorkTime") && dict["AverageWorkTime"] != nil {
                    self.averageWorkTime = dict["AverageWorkTime"] as! Double
                }
                if dict.keys.contains("MaxBreakTime") && dict["MaxBreakTime"] != nil {
                    self.maxBreakTime = dict["MaxBreakTime"] as! Int64
                }
                if dict.keys.contains("MaxHoldTime") && dict["MaxHoldTime"] != nil {
                    self.maxHoldTime = dict["MaxHoldTime"] as! Int64
                }
                if dict.keys.contains("MaxReadyTime") && dict["MaxReadyTime"] != nil {
                    self.maxReadyTime = dict["MaxReadyTime"] as! Int64
                }
                if dict.keys.contains("MaxTalkTime") && dict["MaxTalkTime"] != nil {
                    self.maxTalkTime = dict["MaxTalkTime"] as! Int64
                }
                if dict.keys.contains("MaxWorkTime") && dict["MaxWorkTime"] != nil {
                    self.maxWorkTime = dict["MaxWorkTime"] as! Int64
                }
                if dict.keys.contains("OccupancyRate") && dict["OccupancyRate"] != nil {
                    self.occupancyRate = dict["OccupancyRate"] as! Double
                }
                if dict.keys.contains("SatisfactionIndex") && dict["SatisfactionIndex"] != nil {
                    self.satisfactionIndex = dict["SatisfactionIndex"] as! Double
                }
                if dict.keys.contains("SatisfactionRate") && dict["SatisfactionRate"] != nil {
                    self.satisfactionRate = dict["SatisfactionRate"] as! Double
                }
                if dict.keys.contains("SatisfactionSurveysOffered") && dict["SatisfactionSurveysOffered"] != nil {
                    self.satisfactionSurveysOffered = dict["SatisfactionSurveysOffered"] as! Int64
                }
                if dict.keys.contains("SatisfactionSurveysResponded") && dict["SatisfactionSurveysResponded"] != nil {
                    self.satisfactionSurveysResponded = dict["SatisfactionSurveysResponded"] as! Int64
                }
                if dict.keys.contains("TotalBreakTime") && dict["TotalBreakTime"] != nil {
                    self.totalBreakTime = dict["TotalBreakTime"] as! Int64
                }
                if dict.keys.contains("TotalCalls") && dict["TotalCalls"] != nil {
                    self.totalCalls = dict["TotalCalls"] as! Int64
                }
                if dict.keys.contains("TotalHoldTime") && dict["TotalHoldTime"] != nil {
                    self.totalHoldTime = dict["TotalHoldTime"] as! Int64
                }
                if dict.keys.contains("TotalLoggedInTime") && dict["TotalLoggedInTime"] != nil {
                    self.totalLoggedInTime = dict["TotalLoggedInTime"] as! Int64
                }
                if dict.keys.contains("TotalReadyTime") && dict["TotalReadyTime"] != nil {
                    self.totalReadyTime = dict["TotalReadyTime"] as! Int64
                }
                if dict.keys.contains("TotalTalkTime") && dict["TotalTalkTime"] != nil {
                    self.totalTalkTime = dict["TotalTalkTime"] as! Int64
                }
                if dict.keys.contains("TotalWorkTime") && dict["TotalWorkTime"] != nil {
                    self.totalWorkTime = dict["TotalWorkTime"] as! Int64
                }
            }
        }
        public var inbound: ListIntervalSkillGroupReportResponseBody.Data.Inbound?

        public var outbound: ListIntervalSkillGroupReportResponseBody.Data.Outbound?

        public var overall: ListIntervalSkillGroupReportResponseBody.Data.Overall?

        public var statsTime: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.inbound?.validate()
            try self.outbound?.validate()
            try self.overall?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.inbound != nil {
                map["Inbound"] = self.inbound?.toMap()
            }
            if self.outbound != nil {
                map["Outbound"] = self.outbound?.toMap()
            }
            if self.overall != nil {
                map["Overall"] = self.overall?.toMap()
            }
            if self.statsTime != nil {
                map["StatsTime"] = self.statsTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Inbound") && dict["Inbound"] != nil {
                var model = ListIntervalSkillGroupReportResponseBody.Data.Inbound()
                model.fromMap(dict["Inbound"] as! [String: Any])
                self.inbound = model
            }
            if dict.keys.contains("Outbound") && dict["Outbound"] != nil {
                var model = ListIntervalSkillGroupReportResponseBody.Data.Outbound()
                model.fromMap(dict["Outbound"] as! [String: Any])
                self.outbound = model
            }
            if dict.keys.contains("Overall") && dict["Overall"] != nil {
                var model = ListIntervalSkillGroupReportResponseBody.Data.Overall()
                model.fromMap(dict["Overall"] as! [String: Any])
                self.overall = model
            }
            if dict.keys.contains("StatsTime") && dict["StatsTime"] != nil {
                self.statsTime = dict["StatsTime"] as! Int64
            }
        }
    }
    public var code: String?

    public var data: [ListIntervalSkillGroupReportResponseBody.Data]?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var tmp : [ListIntervalSkillGroupReportResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = ListIntervalSkillGroupReportResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListIntervalSkillGroupReportResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListIntervalSkillGroupReportResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListIntervalSkillGroupReportResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListIvrTrackingDetailsRequest : Tea.TeaModel {
    public var contactId: String?

    public var instanceId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.contactId != nil {
            map["ContactId"] = self.contactId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ContactId") && dict["ContactId"] != nil {
            self.contactId = dict["ContactId"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
    }
}

public class ListIvrTrackingDetailsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class List : Tea.TeaModel {
            public var callee: String?

            public var caller: String?

            public var channelId: String?

            public var channelVariables: String?

            public var contactId: String?

            public var enterTime: Int64?

            public var flowId: String?

            public var flowName: String?

            public var instance: String?

            public var leaveTime: Int64?

            public var nodeExitCode: String?

            public var nodeId: String?

            public var nodeName: String?

            public var nodeProperties: [String: Any]?

            public var nodeType: String?

            public var nodeVariables: [String: Any]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.callee != nil {
                    map["Callee"] = self.callee!
                }
                if self.caller != nil {
                    map["Caller"] = self.caller!
                }
                if self.channelId != nil {
                    map["ChannelId"] = self.channelId!
                }
                if self.channelVariables != nil {
                    map["ChannelVariables"] = self.channelVariables!
                }
                if self.contactId != nil {
                    map["ContactId"] = self.contactId!
                }
                if self.enterTime != nil {
                    map["EnterTime"] = self.enterTime!
                }
                if self.flowId != nil {
                    map["FlowId"] = self.flowId!
                }
                if self.flowName != nil {
                    map["FlowName"] = self.flowName!
                }
                if self.instance != nil {
                    map["Instance"] = self.instance!
                }
                if self.leaveTime != nil {
                    map["LeaveTime"] = self.leaveTime!
                }
                if self.nodeExitCode != nil {
                    map["NodeExitCode"] = self.nodeExitCode!
                }
                if self.nodeId != nil {
                    map["NodeId"] = self.nodeId!
                }
                if self.nodeName != nil {
                    map["NodeName"] = self.nodeName!
                }
                if self.nodeProperties != nil {
                    map["NodeProperties"] = self.nodeProperties!
                }
                if self.nodeType != nil {
                    map["NodeType"] = self.nodeType!
                }
                if self.nodeVariables != nil {
                    map["NodeVariables"] = self.nodeVariables!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Callee") && dict["Callee"] != nil {
                    self.callee = dict["Callee"] as! String
                }
                if dict.keys.contains("Caller") && dict["Caller"] != nil {
                    self.caller = dict["Caller"] as! String
                }
                if dict.keys.contains("ChannelId") && dict["ChannelId"] != nil {
                    self.channelId = dict["ChannelId"] as! String
                }
                if dict.keys.contains("ChannelVariables") && dict["ChannelVariables"] != nil {
                    self.channelVariables = dict["ChannelVariables"] as! String
                }
                if dict.keys.contains("ContactId") && dict["ContactId"] != nil {
                    self.contactId = dict["ContactId"] as! String
                }
                if dict.keys.contains("EnterTime") && dict["EnterTime"] != nil {
                    self.enterTime = dict["EnterTime"] as! Int64
                }
                if dict.keys.contains("FlowId") && dict["FlowId"] != nil {
                    self.flowId = dict["FlowId"] as! String
                }
                if dict.keys.contains("FlowName") && dict["FlowName"] != nil {
                    self.flowName = dict["FlowName"] as! String
                }
                if dict.keys.contains("Instance") && dict["Instance"] != nil {
                    self.instance = dict["Instance"] as! String
                }
                if dict.keys.contains("LeaveTime") && dict["LeaveTime"] != nil {
                    self.leaveTime = dict["LeaveTime"] as! Int64
                }
                if dict.keys.contains("NodeExitCode") && dict["NodeExitCode"] != nil {
                    self.nodeExitCode = dict["NodeExitCode"] as! String
                }
                if dict.keys.contains("NodeId") && dict["NodeId"] != nil {
                    self.nodeId = dict["NodeId"] as! String
                }
                if dict.keys.contains("NodeName") && dict["NodeName"] != nil {
                    self.nodeName = dict["NodeName"] as! String
                }
                if dict.keys.contains("NodeProperties") && dict["NodeProperties"] != nil {
                    self.nodeProperties = dict["NodeProperties"] as! [String: Any]
                }
                if dict.keys.contains("NodeType") && dict["NodeType"] != nil {
                    self.nodeType = dict["NodeType"] as! String
                }
                if dict.keys.contains("NodeVariables") && dict["NodeVariables"] != nil {
                    self.nodeVariables = dict["NodeVariables"] as! [String: Any]
                }
            }
        }
        public var list: [ListIvrTrackingDetailsResponseBody.Data.List]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.list != nil {
                var tmp : [Any] = []
                for k in self.list! {
                    tmp.append(k.toMap())
                }
                map["List"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("List") && dict["List"] != nil {
                var tmp : [ListIvrTrackingDetailsResponseBody.Data.List] = []
                for v in dict["List"] as! [Any] {
                    var model = ListIvrTrackingDetailsResponseBody.Data.List()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.list = tmp
            }
            if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var code: String?

    public var data: ListIvrTrackingDetailsResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = ListIvrTrackingDetailsResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListIvrTrackingDetailsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListIvrTrackingDetailsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListIvrTrackingDetailsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListLegacyAgentEventLogsRequest : Tea.TeaModel {
    public var agentId: String?

    public var endTime: Int64?

    public var instanceId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var startTime: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.agentId != nil {
            map["AgentId"] = self.agentId!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AgentId") && dict["AgentId"] != nil {
            self.agentId = dict["AgentId"] as! String
        }
        if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
            self.startTime = dict["StartTime"] as! Int64
        }
    }
}

public class ListLegacyAgentEventLogsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class List : Tea.TeaModel {
            public var agentDropCall: String?

            public var agentNo: String?

            public var callDir: String?

            public var callId: String?

            public var callMode: String?

            public var callType: String?

            public var calleeId: String?

            public var callerId: String?

            public var connId: String?

            public var event: String?

            public var groupNo: String?

            public var outboundScenario: Bool?

            public var phoneNo: String?

            public var statisticDate: String?

            public var targetRequest: String?

            public var targetSelect: String?

            public var tenantId: String?

            public var transferNumber: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.agentDropCall != nil {
                    map["AgentDropCall"] = self.agentDropCall!
                }
                if self.agentNo != nil {
                    map["AgentNo"] = self.agentNo!
                }
                if self.callDir != nil {
                    map["CallDir"] = self.callDir!
                }
                if self.callId != nil {
                    map["CallId"] = self.callId!
                }
                if self.callMode != nil {
                    map["CallMode"] = self.callMode!
                }
                if self.callType != nil {
                    map["CallType"] = self.callType!
                }
                if self.calleeId != nil {
                    map["CalleeId"] = self.calleeId!
                }
                if self.callerId != nil {
                    map["CallerId"] = self.callerId!
                }
                if self.connId != nil {
                    map["ConnId"] = self.connId!
                }
                if self.event != nil {
                    map["Event"] = self.event!
                }
                if self.groupNo != nil {
                    map["GroupNo"] = self.groupNo!
                }
                if self.outboundScenario != nil {
                    map["OutboundScenario"] = self.outboundScenario!
                }
                if self.phoneNo != nil {
                    map["PhoneNo"] = self.phoneNo!
                }
                if self.statisticDate != nil {
                    map["StatisticDate"] = self.statisticDate!
                }
                if self.targetRequest != nil {
                    map["TargetRequest"] = self.targetRequest!
                }
                if self.targetSelect != nil {
                    map["TargetSelect"] = self.targetSelect!
                }
                if self.tenantId != nil {
                    map["TenantId"] = self.tenantId!
                }
                if self.transferNumber != nil {
                    map["TransferNumber"] = self.transferNumber!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AgentDropCall") && dict["AgentDropCall"] != nil {
                    self.agentDropCall = dict["AgentDropCall"] as! String
                }
                if dict.keys.contains("AgentNo") && dict["AgentNo"] != nil {
                    self.agentNo = dict["AgentNo"] as! String
                }
                if dict.keys.contains("CallDir") && dict["CallDir"] != nil {
                    self.callDir = dict["CallDir"] as! String
                }
                if dict.keys.contains("CallId") && dict["CallId"] != nil {
                    self.callId = dict["CallId"] as! String
                }
                if dict.keys.contains("CallMode") && dict["CallMode"] != nil {
                    self.callMode = dict["CallMode"] as! String
                }
                if dict.keys.contains("CallType") && dict["CallType"] != nil {
                    self.callType = dict["CallType"] as! String
                }
                if dict.keys.contains("CalleeId") && dict["CalleeId"] != nil {
                    self.calleeId = dict["CalleeId"] as! String
                }
                if dict.keys.contains("CallerId") && dict["CallerId"] != nil {
                    self.callerId = dict["CallerId"] as! String
                }
                if dict.keys.contains("ConnId") && dict["ConnId"] != nil {
                    self.connId = dict["ConnId"] as! String
                }
                if dict.keys.contains("Event") && dict["Event"] != nil {
                    self.event = dict["Event"] as! String
                }
                if dict.keys.contains("GroupNo") && dict["GroupNo"] != nil {
                    self.groupNo = dict["GroupNo"] as! String
                }
                if dict.keys.contains("OutboundScenario") && dict["OutboundScenario"] != nil {
                    self.outboundScenario = dict["OutboundScenario"] as! Bool
                }
                if dict.keys.contains("PhoneNo") && dict["PhoneNo"] != nil {
                    self.phoneNo = dict["PhoneNo"] as! String
                }
                if dict.keys.contains("StatisticDate") && dict["StatisticDate"] != nil {
                    self.statisticDate = dict["StatisticDate"] as! String
                }
                if dict.keys.contains("TargetRequest") && dict["TargetRequest"] != nil {
                    self.targetRequest = dict["TargetRequest"] as! String
                }
                if dict.keys.contains("TargetSelect") && dict["TargetSelect"] != nil {
                    self.targetSelect = dict["TargetSelect"] as! String
                }
                if dict.keys.contains("TenantId") && dict["TenantId"] != nil {
                    self.tenantId = dict["TenantId"] as! String
                }
                if dict.keys.contains("TransferNumber") && dict["TransferNumber"] != nil {
                    self.transferNumber = dict["TransferNumber"] as! String
                }
            }
        }
        public var list: [ListLegacyAgentEventLogsResponseBody.Data.List]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.list != nil {
                var tmp : [Any] = []
                for k in self.list! {
                    tmp.append(k.toMap())
                }
                map["List"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("List") && dict["List"] != nil {
                var tmp : [ListLegacyAgentEventLogsResponseBody.Data.List] = []
                for v in dict["List"] as! [Any] {
                    var model = ListLegacyAgentEventLogsResponseBody.Data.List()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.list = tmp
            }
            if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var code: String?

    public var data: ListLegacyAgentEventLogsResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = ListLegacyAgentEventLogsResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListLegacyAgentEventLogsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListLegacyAgentEventLogsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListLegacyAgentEventLogsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListLegacyAgentStatusLogsRequest : Tea.TeaModel {
    public var agentId: String?

    public var endTime: Int64?

    public var instanceId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var startTime: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.agentId != nil {
            map["AgentId"] = self.agentId!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AgentId") && dict["AgentId"] != nil {
            self.agentId = dict["AgentId"] as! String
        }
        if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
            self.startTime = dict["StartTime"] as! Int64
        }
    }
}

public class ListLegacyAgentStatusLogsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class List : Tea.TeaModel {
            public var agentDropCall: String?

            public var agentNo: String?

            public var aliHangupCause: String?

            public var callDir: String?

            public var callId: String?

            public var callType: String?

            public var calleeId: String?

            public var callerId: String?

            public var connId: String?

            public var extend1: String?

            public var extend2: String?

            public var extend3: String?

            public var extend4: String?

            public var groupNo: String?

            public var monitedAgentNo: String?

            public var monitedAgentPhoneNo: String?

            public var outboundScenario: Bool?

            public var phoneNo: String?

            public var statisticDate: String?

            public var statisticTime: Int32?

            public var status: String?

            public var targetRequest: String?

            public var targetSelect: String?

            public var tenantId: String?

            public var transferNo: String?

            public var transferNumber: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.agentDropCall != nil {
                    map["AgentDropCall"] = self.agentDropCall!
                }
                if self.agentNo != nil {
                    map["AgentNo"] = self.agentNo!
                }
                if self.aliHangupCause != nil {
                    map["AliHangupCause"] = self.aliHangupCause!
                }
                if self.callDir != nil {
                    map["CallDir"] = self.callDir!
                }
                if self.callId != nil {
                    map["CallId"] = self.callId!
                }
                if self.callType != nil {
                    map["CallType"] = self.callType!
                }
                if self.calleeId != nil {
                    map["CalleeId"] = self.calleeId!
                }
                if self.callerId != nil {
                    map["CallerId"] = self.callerId!
                }
                if self.connId != nil {
                    map["ConnId"] = self.connId!
                }
                if self.extend1 != nil {
                    map["Extend1"] = self.extend1!
                }
                if self.extend2 != nil {
                    map["Extend2"] = self.extend2!
                }
                if self.extend3 != nil {
                    map["Extend3"] = self.extend3!
                }
                if self.extend4 != nil {
                    map["Extend4"] = self.extend4!
                }
                if self.groupNo != nil {
                    map["GroupNo"] = self.groupNo!
                }
                if self.monitedAgentNo != nil {
                    map["MonitedAgentNo"] = self.monitedAgentNo!
                }
                if self.monitedAgentPhoneNo != nil {
                    map["MonitedAgentPhoneNo"] = self.monitedAgentPhoneNo!
                }
                if self.outboundScenario != nil {
                    map["OutboundScenario"] = self.outboundScenario!
                }
                if self.phoneNo != nil {
                    map["PhoneNo"] = self.phoneNo!
                }
                if self.statisticDate != nil {
                    map["StatisticDate"] = self.statisticDate!
                }
                if self.statisticTime != nil {
                    map["StatisticTime"] = self.statisticTime!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.targetRequest != nil {
                    map["TargetRequest"] = self.targetRequest!
                }
                if self.targetSelect != nil {
                    map["TargetSelect"] = self.targetSelect!
                }
                if self.tenantId != nil {
                    map["TenantId"] = self.tenantId!
                }
                if self.transferNo != nil {
                    map["TransferNo"] = self.transferNo!
                }
                if self.transferNumber != nil {
                    map["TransferNumber"] = self.transferNumber!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AgentDropCall") && dict["AgentDropCall"] != nil {
                    self.agentDropCall = dict["AgentDropCall"] as! String
                }
                if dict.keys.contains("AgentNo") && dict["AgentNo"] != nil {
                    self.agentNo = dict["AgentNo"] as! String
                }
                if dict.keys.contains("AliHangupCause") && dict["AliHangupCause"] != nil {
                    self.aliHangupCause = dict["AliHangupCause"] as! String
                }
                if dict.keys.contains("CallDir") && dict["CallDir"] != nil {
                    self.callDir = dict["CallDir"] as! String
                }
                if dict.keys.contains("CallId") && dict["CallId"] != nil {
                    self.callId = dict["CallId"] as! String
                }
                if dict.keys.contains("CallType") && dict["CallType"] != nil {
                    self.callType = dict["CallType"] as! String
                }
                if dict.keys.contains("CalleeId") && dict["CalleeId"] != nil {
                    self.calleeId = dict["CalleeId"] as! String
                }
                if dict.keys.contains("CallerId") && dict["CallerId"] != nil {
                    self.callerId = dict["CallerId"] as! String
                }
                if dict.keys.contains("ConnId") && dict["ConnId"] != nil {
                    self.connId = dict["ConnId"] as! String
                }
                if dict.keys.contains("Extend1") && dict["Extend1"] != nil {
                    self.extend1 = dict["Extend1"] as! String
                }
                if dict.keys.contains("Extend2") && dict["Extend2"] != nil {
                    self.extend2 = dict["Extend2"] as! String
                }
                if dict.keys.contains("Extend3") && dict["Extend3"] != nil {
                    self.extend3 = dict["Extend3"] as! String
                }
                if dict.keys.contains("Extend4") && dict["Extend4"] != nil {
                    self.extend4 = dict["Extend4"] as! String
                }
                if dict.keys.contains("GroupNo") && dict["GroupNo"] != nil {
                    self.groupNo = dict["GroupNo"] as! String
                }
                if dict.keys.contains("MonitedAgentNo") && dict["MonitedAgentNo"] != nil {
                    self.monitedAgentNo = dict["MonitedAgentNo"] as! String
                }
                if dict.keys.contains("MonitedAgentPhoneNo") && dict["MonitedAgentPhoneNo"] != nil {
                    self.monitedAgentPhoneNo = dict["MonitedAgentPhoneNo"] as! String
                }
                if dict.keys.contains("OutboundScenario") && dict["OutboundScenario"] != nil {
                    self.outboundScenario = dict["OutboundScenario"] as! Bool
                }
                if dict.keys.contains("PhoneNo") && dict["PhoneNo"] != nil {
                    self.phoneNo = dict["PhoneNo"] as! String
                }
                if dict.keys.contains("StatisticDate") && dict["StatisticDate"] != nil {
                    self.statisticDate = dict["StatisticDate"] as! String
                }
                if dict.keys.contains("StatisticTime") && dict["StatisticTime"] != nil {
                    self.statisticTime = dict["StatisticTime"] as! Int32
                }
                if dict.keys.contains("Status") && dict["Status"] != nil {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("TargetRequest") && dict["TargetRequest"] != nil {
                    self.targetRequest = dict["TargetRequest"] as! String
                }
                if dict.keys.contains("TargetSelect") && dict["TargetSelect"] != nil {
                    self.targetSelect = dict["TargetSelect"] as! String
                }
                if dict.keys.contains("TenantId") && dict["TenantId"] != nil {
                    self.tenantId = dict["TenantId"] as! String
                }
                if dict.keys.contains("TransferNo") && dict["TransferNo"] != nil {
                    self.transferNo = dict["TransferNo"] as! String
                }
                if dict.keys.contains("TransferNumber") && dict["TransferNumber"] != nil {
                    self.transferNumber = dict["TransferNumber"] as! String
                }
            }
        }
        public var list: [ListLegacyAgentStatusLogsResponseBody.Data.List]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.list != nil {
                var tmp : [Any] = []
                for k in self.list! {
                    tmp.append(k.toMap())
                }
                map["List"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("List") && dict["List"] != nil {
                var tmp : [ListLegacyAgentStatusLogsResponseBody.Data.List] = []
                for v in dict["List"] as! [Any] {
                    var model = ListLegacyAgentStatusLogsResponseBody.Data.List()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.list = tmp
            }
            if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var code: String?

    public var data: ListLegacyAgentStatusLogsResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = ListLegacyAgentStatusLogsResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListLegacyAgentStatusLogsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListLegacyAgentStatusLogsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListLegacyAgentStatusLogsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListLegacyAppraiseLogsRequest : Tea.TeaModel {
    public var endTime: Int64?

    public var instanceId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var startTime: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
            self.startTime = dict["StartTime"] as! Int64
        }
    }
}

public class ListLegacyAppraiseLogsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class List : Tea.TeaModel {
            public var acid: String?

            public var contactType: String?

            public var id: Int64?

            public var instanceId: String?

            public var keyMarkRelation: String?

            public var note: String?

            public var parentNote: String?

            public var pressKey: String?

            public var ramId: String?

            public var skillGroupId: String?

            public var statisticDate: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.acid != nil {
                    map["Acid"] = self.acid!
                }
                if self.contactType != nil {
                    map["ContactType"] = self.contactType!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.keyMarkRelation != nil {
                    map["KeyMarkRelation"] = self.keyMarkRelation!
                }
                if self.note != nil {
                    map["Note"] = self.note!
                }
                if self.parentNote != nil {
                    map["ParentNote"] = self.parentNote!
                }
                if self.pressKey != nil {
                    map["PressKey"] = self.pressKey!
                }
                if self.ramId != nil {
                    map["RamId"] = self.ramId!
                }
                if self.skillGroupId != nil {
                    map["SkillGroupId"] = self.skillGroupId!
                }
                if self.statisticDate != nil {
                    map["StatisticDate"] = self.statisticDate!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Acid") && dict["Acid"] != nil {
                    self.acid = dict["Acid"] as! String
                }
                if dict.keys.contains("ContactType") && dict["ContactType"] != nil {
                    self.contactType = dict["ContactType"] as! String
                }
                if dict.keys.contains("Id") && dict["Id"] != nil {
                    self.id = dict["Id"] as! Int64
                }
                if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("KeyMarkRelation") && dict["KeyMarkRelation"] != nil {
                    self.keyMarkRelation = dict["KeyMarkRelation"] as! String
                }
                if dict.keys.contains("Note") && dict["Note"] != nil {
                    self.note = dict["Note"] as! String
                }
                if dict.keys.contains("ParentNote") && dict["ParentNote"] != nil {
                    self.parentNote = dict["ParentNote"] as! String
                }
                if dict.keys.contains("PressKey") && dict["PressKey"] != nil {
                    self.pressKey = dict["PressKey"] as! String
                }
                if dict.keys.contains("RamId") && dict["RamId"] != nil {
                    self.ramId = dict["RamId"] as! String
                }
                if dict.keys.contains("SkillGroupId") && dict["SkillGroupId"] != nil {
                    self.skillGroupId = dict["SkillGroupId"] as! String
                }
                if dict.keys.contains("StatisticDate") && dict["StatisticDate"] != nil {
                    self.statisticDate = dict["StatisticDate"] as! String
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var list: [ListLegacyAppraiseLogsResponseBody.Data.List]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.list != nil {
                var tmp : [Any] = []
                for k in self.list! {
                    tmp.append(k.toMap())
                }
                map["List"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("List") && dict["List"] != nil {
                var tmp : [ListLegacyAppraiseLogsResponseBody.Data.List] = []
                for v in dict["List"] as! [Any] {
                    var model = ListLegacyAppraiseLogsResponseBody.Data.List()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.list = tmp
            }
            if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var code: String?

    public var data: ListLegacyAppraiseLogsResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = ListLegacyAppraiseLogsResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListLegacyAppraiseLogsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListLegacyAppraiseLogsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListLegacyAppraiseLogsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListLegacyQueueEventLogsRequest : Tea.TeaModel {
    public var endTime: Int64?

    public var instanceId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var skillGroupId: String?

    public var startTime: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.skillGroupId != nil {
            map["SkillGroupId"] = self.skillGroupId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SkillGroupId") && dict["SkillGroupId"] != nil {
            self.skillGroupId = dict["SkillGroupId"] as! String
        }
        if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
            self.startTime = dict["StartTime"] as! Int64
        }
    }
}

public class ListLegacyQueueEventLogsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class List : Tea.TeaModel {
            public var acid: String?

            public var ani: String?

            public var answerPhone: String?

            public var answerTime: Int64?

            public var cause: String?

            public var dnis: String?

            public var id: Int64?

            public var queueTime: Int64?

            public var statisticDate: String?

            public var tenantId: String?

            public var vq: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.acid != nil {
                    map["Acid"] = self.acid!
                }
                if self.ani != nil {
                    map["Ani"] = self.ani!
                }
                if self.answerPhone != nil {
                    map["AnswerPhone"] = self.answerPhone!
                }
                if self.answerTime != nil {
                    map["AnswerTime"] = self.answerTime!
                }
                if self.cause != nil {
                    map["Cause"] = self.cause!
                }
                if self.dnis != nil {
                    map["Dnis"] = self.dnis!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.queueTime != nil {
                    map["QueueTime"] = self.queueTime!
                }
                if self.statisticDate != nil {
                    map["StatisticDate"] = self.statisticDate!
                }
                if self.tenantId != nil {
                    map["TenantId"] = self.tenantId!
                }
                if self.vq != nil {
                    map["Vq"] = self.vq!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Acid") && dict["Acid"] != nil {
                    self.acid = dict["Acid"] as! String
                }
                if dict.keys.contains("Ani") && dict["Ani"] != nil {
                    self.ani = dict["Ani"] as! String
                }
                if dict.keys.contains("AnswerPhone") && dict["AnswerPhone"] != nil {
                    self.answerPhone = dict["AnswerPhone"] as! String
                }
                if dict.keys.contains("AnswerTime") && dict["AnswerTime"] != nil {
                    self.answerTime = dict["AnswerTime"] as! Int64
                }
                if dict.keys.contains("Cause") && dict["Cause"] != nil {
                    self.cause = dict["Cause"] as! String
                }
                if dict.keys.contains("Dnis") && dict["Dnis"] != nil {
                    self.dnis = dict["Dnis"] as! String
                }
                if dict.keys.contains("Id") && dict["Id"] != nil {
                    self.id = dict["Id"] as! Int64
                }
                if dict.keys.contains("QueueTime") && dict["QueueTime"] != nil {
                    self.queueTime = dict["QueueTime"] as! Int64
                }
                if dict.keys.contains("StatisticDate") && dict["StatisticDate"] != nil {
                    self.statisticDate = dict["StatisticDate"] as! String
                }
                if dict.keys.contains("TenantId") && dict["TenantId"] != nil {
                    self.tenantId = dict["TenantId"] as! String
                }
                if dict.keys.contains("Vq") && dict["Vq"] != nil {
                    self.vq = dict["Vq"] as! String
                }
            }
        }
        public var list: [ListLegacyQueueEventLogsResponseBody.Data.List]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.list != nil {
                var tmp : [Any] = []
                for k in self.list! {
                    tmp.append(k.toMap())
                }
                map["List"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("List") && dict["List"] != nil {
                var tmp : [ListLegacyQueueEventLogsResponseBody.Data.List] = []
                for v in dict["List"] as! [Any] {
                    var model = ListLegacyQueueEventLogsResponseBody.Data.List()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.list = tmp
            }
            if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var code: String?

    public var data: ListLegacyQueueEventLogsResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = ListLegacyQueueEventLogsResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListLegacyQueueEventLogsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListLegacyQueueEventLogsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListLegacyQueueEventLogsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListMonoRecordingsRequest : Tea.TeaModel {
    public var contactId: String?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.contactId != nil {
            map["ContactId"] = self.contactId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ContactId") && dict["ContactId"] != nil {
            self.contactId = dict["ContactId"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
    }
}

public class ListMonoRecordingsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var agentId: String?

        public var agentName: String?

        public var contactId: String?

        public var duration: String?

        public var fileName: String?

        public var fileUrl: String?

        public var ramId: String?

        public var skillGroupId: String?

        public var startTime: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.agentId != nil {
                map["AgentId"] = self.agentId!
            }
            if self.agentName != nil {
                map["AgentName"] = self.agentName!
            }
            if self.contactId != nil {
                map["ContactId"] = self.contactId!
            }
            if self.duration != nil {
                map["Duration"] = self.duration!
            }
            if self.fileName != nil {
                map["FileName"] = self.fileName!
            }
            if self.fileUrl != nil {
                map["FileUrl"] = self.fileUrl!
            }
            if self.ramId != nil {
                map["RamId"] = self.ramId!
            }
            if self.skillGroupId != nil {
                map["SkillGroupId"] = self.skillGroupId!
            }
            if self.startTime != nil {
                map["StartTime"] = self.startTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AgentId") && dict["AgentId"] != nil {
                self.agentId = dict["AgentId"] as! String
            }
            if dict.keys.contains("AgentName") && dict["AgentName"] != nil {
                self.agentName = dict["AgentName"] as! String
            }
            if dict.keys.contains("ContactId") && dict["ContactId"] != nil {
                self.contactId = dict["ContactId"] as! String
            }
            if dict.keys.contains("Duration") && dict["Duration"] != nil {
                self.duration = dict["Duration"] as! String
            }
            if dict.keys.contains("FileName") && dict["FileName"] != nil {
                self.fileName = dict["FileName"] as! String
            }
            if dict.keys.contains("FileUrl") && dict["FileUrl"] != nil {
                self.fileUrl = dict["FileUrl"] as! String
            }
            if dict.keys.contains("RamId") && dict["RamId"] != nil {
                self.ramId = dict["RamId"] as! String
            }
            if dict.keys.contains("SkillGroupId") && dict["SkillGroupId"] != nil {
                self.skillGroupId = dict["SkillGroupId"] as! String
            }
            if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
                self.startTime = dict["StartTime"] as! String
            }
        }
    }
    public var code: String?

    public var data: [ListMonoRecordingsResponseBody.Data]?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var tmp : [ListMonoRecordingsResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = ListMonoRecordingsResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListMonoRecordingsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListMonoRecordingsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListMonoRecordingsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListMultiChannelRecordingsRequest : Tea.TeaModel {
    public var contactId: String?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.contactId != nil {
            map["ContactId"] = self.contactId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ContactId") && dict["ContactId"] != nil {
            self.contactId = dict["ContactId"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
    }
}

public class ListMultiChannelRecordingsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class HoldTimeSegments : Tea.TeaModel {
            public var endTime: Int64?

            public var startTime: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.endTime != nil {
                    map["EndTime"] = self.endTime!
                }
                if self.startTime != nil {
                    map["StartTime"] = self.startTime!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
                    self.endTime = dict["EndTime"] as! Int64
                }
                if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
                    self.startTime = dict["StartTime"] as! Int64
                }
            }
        }
        public var agentChannelId: String?

        public var agentId: String?

        public var agentName: String?

        public var contactId: String?

        public var duration: String?

        public var fileName: String?

        public var fileUrl: String?

        public var holdTimeSegments: [ListMultiChannelRecordingsResponseBody.Data.HoldTimeSegments]?

        public var ramId: String?

        public var skillGroupId: String?

        public var startTime: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.agentChannelId != nil {
                map["AgentChannelId"] = self.agentChannelId!
            }
            if self.agentId != nil {
                map["AgentId"] = self.agentId!
            }
            if self.agentName != nil {
                map["AgentName"] = self.agentName!
            }
            if self.contactId != nil {
                map["ContactId"] = self.contactId!
            }
            if self.duration != nil {
                map["Duration"] = self.duration!
            }
            if self.fileName != nil {
                map["FileName"] = self.fileName!
            }
            if self.fileUrl != nil {
                map["FileUrl"] = self.fileUrl!
            }
            if self.holdTimeSegments != nil {
                var tmp : [Any] = []
                for k in self.holdTimeSegments! {
                    tmp.append(k.toMap())
                }
                map["HoldTimeSegments"] = tmp
            }
            if self.ramId != nil {
                map["RamId"] = self.ramId!
            }
            if self.skillGroupId != nil {
                map["SkillGroupId"] = self.skillGroupId!
            }
            if self.startTime != nil {
                map["StartTime"] = self.startTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AgentChannelId") && dict["AgentChannelId"] != nil {
                self.agentChannelId = dict["AgentChannelId"] as! String
            }
            if dict.keys.contains("AgentId") && dict["AgentId"] != nil {
                self.agentId = dict["AgentId"] as! String
            }
            if dict.keys.contains("AgentName") && dict["AgentName"] != nil {
                self.agentName = dict["AgentName"] as! String
            }
            if dict.keys.contains("ContactId") && dict["ContactId"] != nil {
                self.contactId = dict["ContactId"] as! String
            }
            if dict.keys.contains("Duration") && dict["Duration"] != nil {
                self.duration = dict["Duration"] as! String
            }
            if dict.keys.contains("FileName") && dict["FileName"] != nil {
                self.fileName = dict["FileName"] as! String
            }
            if dict.keys.contains("FileUrl") && dict["FileUrl"] != nil {
                self.fileUrl = dict["FileUrl"] as! String
            }
            if dict.keys.contains("HoldTimeSegments") && dict["HoldTimeSegments"] != nil {
                var tmp : [ListMultiChannelRecordingsResponseBody.Data.HoldTimeSegments] = []
                for v in dict["HoldTimeSegments"] as! [Any] {
                    var model = ListMultiChannelRecordingsResponseBody.Data.HoldTimeSegments()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.holdTimeSegments = tmp
            }
            if dict.keys.contains("RamId") && dict["RamId"] != nil {
                self.ramId = dict["RamId"] as! String
            }
            if dict.keys.contains("SkillGroupId") && dict["SkillGroupId"] != nil {
                self.skillGroupId = dict["SkillGroupId"] as! String
            }
            if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
                self.startTime = dict["StartTime"] as! Int64
            }
        }
    }
    public var code: String?

    public var data: [ListMultiChannelRecordingsResponseBody.Data]?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var tmp : [ListMultiChannelRecordingsResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = ListMultiChannelRecordingsResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListMultiChannelRecordingsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListMultiChannelRecordingsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListMultiChannelRecordingsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListOutboundNumbersOfUserRequest : Tea.TeaModel {
    public var instanceId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var skillGroupIdList: String?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.skillGroupIdList != nil {
            map["SkillGroupIdList"] = self.skillGroupIdList!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SkillGroupIdList") && dict["SkillGroupIdList"] != nil {
            self.skillGroupIdList = dict["SkillGroupIdList"] as! String
        }
        if dict.keys.contains("UserId") && dict["UserId"] != nil {
            self.userId = dict["UserId"] as! String
        }
    }
}

public class ListOutboundNumbersOfUserResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class List : Tea.TeaModel {
            public var city: String?

            public var number: String?

            public var province: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.city != nil {
                    map["City"] = self.city!
                }
                if self.number != nil {
                    map["Number"] = self.number!
                }
                if self.province != nil {
                    map["Province"] = self.province!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("City") && dict["City"] != nil {
                    self.city = dict["City"] as! String
                }
                if dict.keys.contains("Number") && dict["Number"] != nil {
                    self.number = dict["Number"] as! String
                }
                if dict.keys.contains("Province") && dict["Province"] != nil {
                    self.province = dict["Province"] as! String
                }
            }
        }
        public var list: [ListOutboundNumbersOfUserResponseBody.Data.List]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.list != nil {
                var tmp : [Any] = []
                for k in self.list! {
                    tmp.append(k.toMap())
                }
                map["List"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("List") && dict["List"] != nil {
                var tmp : [ListOutboundNumbersOfUserResponseBody.Data.List] = []
                for v in dict["List"] as! [Any] {
                    var model = ListOutboundNumbersOfUserResponseBody.Data.List()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.list = tmp
            }
            if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var code: String?

    public var data: ListOutboundNumbersOfUserResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = ListOutboundNumbersOfUserResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListOutboundNumbersOfUserResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListOutboundNumbersOfUserResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListOutboundNumbersOfUserResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListPersonalNumbersOfUserRequest : Tea.TeaModel {
    public var instanceId: String?

    public var isMember: Bool?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var searchPattern: String?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.isMember != nil {
            map["IsMember"] = self.isMember!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.searchPattern != nil {
            map["SearchPattern"] = self.searchPattern!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("IsMember") && dict["IsMember"] != nil {
            self.isMember = dict["IsMember"] as! Bool
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SearchPattern") && dict["SearchPattern"] != nil {
            self.searchPattern = dict["SearchPattern"] as! String
        }
        if dict.keys.contains("UserId") && dict["UserId"] != nil {
            self.userId = dict["UserId"] as! String
        }
    }
}

public class ListPersonalNumbersOfUserResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class List : Tea.TeaModel {
            public var active: Bool?

            public var city: String?

            public var contactFlowId: String?

            public var instanceId: String?

            public var number: String?

            public var province: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.active != nil {
                    map["Active"] = self.active!
                }
                if self.city != nil {
                    map["City"] = self.city!
                }
                if self.contactFlowId != nil {
                    map["ContactFlowId"] = self.contactFlowId!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.number != nil {
                    map["Number"] = self.number!
                }
                if self.province != nil {
                    map["Province"] = self.province!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Active") && dict["Active"] != nil {
                    self.active = dict["Active"] as! Bool
                }
                if dict.keys.contains("City") && dict["City"] != nil {
                    self.city = dict["City"] as! String
                }
                if dict.keys.contains("ContactFlowId") && dict["ContactFlowId"] != nil {
                    self.contactFlowId = dict["ContactFlowId"] as! String
                }
                if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("Number") && dict["Number"] != nil {
                    self.number = dict["Number"] as! String
                }
                if dict.keys.contains("Province") && dict["Province"] != nil {
                    self.province = dict["Province"] as! String
                }
            }
        }
        public var list: [ListPersonalNumbersOfUserResponseBody.Data.List]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.list != nil {
                var tmp : [Any] = []
                for k in self.list! {
                    tmp.append(k.toMap())
                }
                map["List"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("List") && dict["List"] != nil {
                var tmp : [ListPersonalNumbersOfUserResponseBody.Data.List] = []
                for v in dict["List"] as! [Any] {
                    var model = ListPersonalNumbersOfUserResponseBody.Data.List()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.list = tmp
            }
            if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var code: String?

    public var data: ListPersonalNumbersOfUserResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = ListPersonalNumbersOfUserResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListPersonalNumbersOfUserResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListPersonalNumbersOfUserResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListPersonalNumbersOfUserResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListPhoneNumbersRequest : Tea.TeaModel {
    public var active: Bool?

    public var instanceId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var searchPattern: String?

    public var usage: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.active != nil {
            map["Active"] = self.active!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.searchPattern != nil {
            map["SearchPattern"] = self.searchPattern!
        }
        if self.usage != nil {
            map["Usage"] = self.usage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Active") && dict["Active"] != nil {
            self.active = dict["Active"] as! Bool
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SearchPattern") && dict["SearchPattern"] != nil {
            self.searchPattern = dict["SearchPattern"] as! String
        }
        if dict.keys.contains("Usage") && dict["Usage"] != nil {
            self.usage = dict["Usage"] as! String
        }
    }
}

public class ListPhoneNumbersResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class List : Tea.TeaModel {
            public class SkillGroups : Tea.TeaModel {
                public var displayName: String?

                public var instanceId: String?

                public var name: String?

                public var skillGroupId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.displayName != nil {
                        map["DisplayName"] = self.displayName!
                    }
                    if self.instanceId != nil {
                        map["InstanceId"] = self.instanceId!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.skillGroupId != nil {
                        map["SkillGroupId"] = self.skillGroupId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("DisplayName") && dict["DisplayName"] != nil {
                        self.displayName = dict["DisplayName"] as! String
                    }
                    if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                        self.instanceId = dict["InstanceId"] as! String
                    }
                    if dict.keys.contains("Name") && dict["Name"] != nil {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("SkillGroupId") && dict["SkillGroupId"] != nil {
                        self.skillGroupId = dict["SkillGroupId"] as! String
                    }
                }
            }
            public var active: Bool?

            public var city: String?

            public var contactFlowId: String?

            public var contactFlowName: String?

            public var createTime: String?

            public var instanceId: String?

            public var number: String?

            public var provider: String?

            public var province: String?

            public var skillGroups: [ListPhoneNumbersResponseBody.Data.List.SkillGroups]?

            public var tags: String?

            public var usage: String?

            public var userId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.active != nil {
                    map["Active"] = self.active!
                }
                if self.city != nil {
                    map["City"] = self.city!
                }
                if self.contactFlowId != nil {
                    map["ContactFlowId"] = self.contactFlowId!
                }
                if self.contactFlowName != nil {
                    map["ContactFlowName"] = self.contactFlowName!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.number != nil {
                    map["Number"] = self.number!
                }
                if self.provider != nil {
                    map["Provider"] = self.provider!
                }
                if self.province != nil {
                    map["Province"] = self.province!
                }
                if self.skillGroups != nil {
                    var tmp : [Any] = []
                    for k in self.skillGroups! {
                        tmp.append(k.toMap())
                    }
                    map["SkillGroups"] = tmp
                }
                if self.tags != nil {
                    map["Tags"] = self.tags!
                }
                if self.usage != nil {
                    map["Usage"] = self.usage!
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Active") && dict["Active"] != nil {
                    self.active = dict["Active"] as! Bool
                }
                if dict.keys.contains("City") && dict["City"] != nil {
                    self.city = dict["City"] as! String
                }
                if dict.keys.contains("ContactFlowId") && dict["ContactFlowId"] != nil {
                    self.contactFlowId = dict["ContactFlowId"] as! String
                }
                if dict.keys.contains("ContactFlowName") && dict["ContactFlowName"] != nil {
                    self.contactFlowName = dict["ContactFlowName"] as! String
                }
                if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                    self.createTime = dict["CreateTime"] as! String
                }
                if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("Number") && dict["Number"] != nil {
                    self.number = dict["Number"] as! String
                }
                if dict.keys.contains("Provider") && dict["Provider"] != nil {
                    self.provider = dict["Provider"] as! String
                }
                if dict.keys.contains("Province") && dict["Province"] != nil {
                    self.province = dict["Province"] as! String
                }
                if dict.keys.contains("SkillGroups") && dict["SkillGroups"] != nil {
                    var tmp : [ListPhoneNumbersResponseBody.Data.List.SkillGroups] = []
                    for v in dict["SkillGroups"] as! [Any] {
                        var model = ListPhoneNumbersResponseBody.Data.List.SkillGroups()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.skillGroups = tmp
                }
                if dict.keys.contains("Tags") && dict["Tags"] != nil {
                    self.tags = dict["Tags"] as! String
                }
                if dict.keys.contains("Usage") && dict["Usage"] != nil {
                    self.usage = dict["Usage"] as! String
                }
                if dict.keys.contains("UserId") && dict["UserId"] != nil {
                    self.userId = dict["UserId"] as! String
                }
            }
        }
        public var list: [ListPhoneNumbersResponseBody.Data.List]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.list != nil {
                var tmp : [Any] = []
                for k in self.list! {
                    tmp.append(k.toMap())
                }
                map["List"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("List") && dict["List"] != nil {
                var tmp : [ListPhoneNumbersResponseBody.Data.List] = []
                for v in dict["List"] as! [Any] {
                    var model = ListPhoneNumbersResponseBody.Data.List()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.list = tmp
            }
            if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var code: String?

    public var data: ListPhoneNumbersResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = ListPhoneNumbersResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListPhoneNumbersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListPhoneNumbersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListPhoneNumbersResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListPhoneNumbersOfSkillGroupRequest : Tea.TeaModel {
    public var active: Bool?

    public var instanceId: String?

    public var isMember: Bool?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var searchPattern: String?

    public var skillGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.active != nil {
            map["Active"] = self.active!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.isMember != nil {
            map["IsMember"] = self.isMember!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.searchPattern != nil {
            map["SearchPattern"] = self.searchPattern!
        }
        if self.skillGroupId != nil {
            map["SkillGroupId"] = self.skillGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Active") && dict["Active"] != nil {
            self.active = dict["Active"] as! Bool
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("IsMember") && dict["IsMember"] != nil {
            self.isMember = dict["IsMember"] as! Bool
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SearchPattern") && dict["SearchPattern"] != nil {
            self.searchPattern = dict["SearchPattern"] as! String
        }
        if dict.keys.contains("SkillGroupId") && dict["SkillGroupId"] != nil {
            self.skillGroupId = dict["SkillGroupId"] as! String
        }
    }
}

public class ListPhoneNumbersOfSkillGroupResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class List : Tea.TeaModel {
            public var active: Bool?

            public var city: String?

            public var contactFlowId: String?

            public var instanceId: String?

            public var number: String?

            public var province: String?

            public var usage: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.active != nil {
                    map["Active"] = self.active!
                }
                if self.city != nil {
                    map["City"] = self.city!
                }
                if self.contactFlowId != nil {
                    map["ContactFlowId"] = self.contactFlowId!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.number != nil {
                    map["Number"] = self.number!
                }
                if self.province != nil {
                    map["Province"] = self.province!
                }
                if self.usage != nil {
                    map["Usage"] = self.usage!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Active") && dict["Active"] != nil {
                    self.active = dict["Active"] as! Bool
                }
                if dict.keys.contains("City") && dict["City"] != nil {
                    self.city = dict["City"] as! String
                }
                if dict.keys.contains("ContactFlowId") && dict["ContactFlowId"] != nil {
                    self.contactFlowId = dict["ContactFlowId"] as! String
                }
                if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("Number") && dict["Number"] != nil {
                    self.number = dict["Number"] as! String
                }
                if dict.keys.contains("Province") && dict["Province"] != nil {
                    self.province = dict["Province"] as! String
                }
                if dict.keys.contains("Usage") && dict["Usage"] != nil {
                    self.usage = dict["Usage"] as! String
                }
            }
        }
        public var list: [ListPhoneNumbersOfSkillGroupResponseBody.Data.List]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.list != nil {
                var tmp : [Any] = []
                for k in self.list! {
                    tmp.append(k.toMap())
                }
                map["List"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("List") && dict["List"] != nil {
                var tmp : [ListPhoneNumbersOfSkillGroupResponseBody.Data.List] = []
                for v in dict["List"] as! [Any] {
                    var model = ListPhoneNumbersOfSkillGroupResponseBody.Data.List()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.list = tmp
            }
            if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var code: String?

    public var data: ListPhoneNumbersOfSkillGroupResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = ListPhoneNumbersOfSkillGroupResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListPhoneNumbersOfSkillGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListPhoneNumbersOfSkillGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListPhoneNumbersOfSkillGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListPrivilegesOfUserRequest : Tea.TeaModel {
    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
    }
}

public class ListPrivilegesOfUserResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var instanceId: String?

        public var name: String?

        public var scope: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.scope != nil {
                map["Scope"] = self.scope!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Scope") && dict["Scope"] != nil {
                self.scope = dict["Scope"] as! String
            }
        }
    }
    public var code: String?

    public var data: [ListPrivilegesOfUserResponseBody.Data]?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var tmp : [ListPrivilegesOfUserResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = ListPrivilegesOfUserResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListPrivilegesOfUserResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListPrivilegesOfUserResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListPrivilegesOfUserResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListRamUsersRequest : Tea.TeaModel {
    public var instanceId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var searchPattern: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.searchPattern != nil {
            map["SearchPattern"] = self.searchPattern!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SearchPattern") && dict["SearchPattern"] != nil {
            self.searchPattern = dict["SearchPattern"] as! String
        }
    }
}

public class ListRamUsersResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class List : Tea.TeaModel {
            public var aliyunUid: Int64?

            public var displayName: String?

            public var email: String?

            public var loginName: String?

            public var mobile: String?

            public var primary: Bool?

            public var ramId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.aliyunUid != nil {
                    map["AliyunUid"] = self.aliyunUid!
                }
                if self.displayName != nil {
                    map["DisplayName"] = self.displayName!
                }
                if self.email != nil {
                    map["Email"] = self.email!
                }
                if self.loginName != nil {
                    map["LoginName"] = self.loginName!
                }
                if self.mobile != nil {
                    map["Mobile"] = self.mobile!
                }
                if self.primary != nil {
                    map["Primary"] = self.primary!
                }
                if self.ramId != nil {
                    map["RamId"] = self.ramId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AliyunUid") && dict["AliyunUid"] != nil {
                    self.aliyunUid = dict["AliyunUid"] as! Int64
                }
                if dict.keys.contains("DisplayName") && dict["DisplayName"] != nil {
                    self.displayName = dict["DisplayName"] as! String
                }
                if dict.keys.contains("Email") && dict["Email"] != nil {
                    self.email = dict["Email"] as! String
                }
                if dict.keys.contains("LoginName") && dict["LoginName"] != nil {
                    self.loginName = dict["LoginName"] as! String
                }
                if dict.keys.contains("Mobile") && dict["Mobile"] != nil {
                    self.mobile = dict["Mobile"] as! String
                }
                if dict.keys.contains("Primary") && dict["Primary"] != nil {
                    self.primary = dict["Primary"] as! Bool
                }
                if dict.keys.contains("RamId") && dict["RamId"] != nil {
                    self.ramId = dict["RamId"] as! String
                }
            }
        }
        public var list: [ListRamUsersResponseBody.Data.List]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.list != nil {
                var tmp : [Any] = []
                for k in self.list! {
                    tmp.append(k.toMap())
                }
                map["List"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("List") && dict["List"] != nil {
                var tmp : [ListRamUsersResponseBody.Data.List] = []
                for v in dict["List"] as! [Any] {
                    var model = ListRamUsersResponseBody.Data.List()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.list = tmp
            }
            if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var code: String?

    public var data: ListRamUsersResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = ListRamUsersResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListRamUsersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListRamUsersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListRamUsersResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListRealtimeAgentStatesRequest : Tea.TeaModel {
    public var agentIdList: String?

    public var agentName: String?

    public var callTypeList: String?

    public var instanceId: String?

    public var outboundScenario: Bool?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var query: String?

    public var skillGroupId: String?

    public var stateList: String?

    public var workModeList: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.agentIdList != nil {
            map["AgentIdList"] = self.agentIdList!
        }
        if self.agentName != nil {
            map["AgentName"] = self.agentName!
        }
        if self.callTypeList != nil {
            map["CallTypeList"] = self.callTypeList!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.outboundScenario != nil {
            map["OutboundScenario"] = self.outboundScenario!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.query != nil {
            map["Query"] = self.query!
        }
        if self.skillGroupId != nil {
            map["SkillGroupId"] = self.skillGroupId!
        }
        if self.stateList != nil {
            map["StateList"] = self.stateList!
        }
        if self.workModeList != nil {
            map["WorkModeList"] = self.workModeList!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AgentIdList") && dict["AgentIdList"] != nil {
            self.agentIdList = dict["AgentIdList"] as! String
        }
        if dict.keys.contains("AgentName") && dict["AgentName"] != nil {
            self.agentName = dict["AgentName"] as! String
        }
        if dict.keys.contains("CallTypeList") && dict["CallTypeList"] != nil {
            self.callTypeList = dict["CallTypeList"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("OutboundScenario") && dict["OutboundScenario"] != nil {
            self.outboundScenario = dict["OutboundScenario"] as! Bool
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("Query") && dict["Query"] != nil {
            self.query = dict["Query"] as! String
        }
        if dict.keys.contains("SkillGroupId") && dict["SkillGroupId"] != nil {
            self.skillGroupId = dict["SkillGroupId"] as! String
        }
        if dict.keys.contains("StateList") && dict["StateList"] != nil {
            self.stateList = dict["StateList"] as! String
        }
        if dict.keys.contains("WorkModeList") && dict["WorkModeList"] != nil {
            self.workModeList = dict["WorkModeList"] as! String
        }
    }
}

public class ListRealtimeAgentStatesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class List : Tea.TeaModel {
            public var agentId: String?

            public var agentName: String?

            public var callType: String?

            public var counterParty: String?

            public var duration: Int64?

            public var extension_: String?

            public var instanceId: String?

            public var mobile: String?

            public var outboundScenario: Bool?

            public var skillGroupIdList: [String]?

            public var skillGroupNameList: [String]?

            public var state: String?

            public var stateCode: String?

            public var stateTime: Int64?

            public var workMode: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.agentId != nil {
                    map["AgentId"] = self.agentId!
                }
                if self.agentName != nil {
                    map["AgentName"] = self.agentName!
                }
                if self.callType != nil {
                    map["CallType"] = self.callType!
                }
                if self.counterParty != nil {
                    map["CounterParty"] = self.counterParty!
                }
                if self.duration != nil {
                    map["Duration"] = self.duration!
                }
                if self.extension_ != nil {
                    map["Extension"] = self.extension_!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.mobile != nil {
                    map["Mobile"] = self.mobile!
                }
                if self.outboundScenario != nil {
                    map["OutboundScenario"] = self.outboundScenario!
                }
                if self.skillGroupIdList != nil {
                    map["SkillGroupIdList"] = self.skillGroupIdList!
                }
                if self.skillGroupNameList != nil {
                    map["SkillGroupNameList"] = self.skillGroupNameList!
                }
                if self.state != nil {
                    map["State"] = self.state!
                }
                if self.stateCode != nil {
                    map["StateCode"] = self.stateCode!
                }
                if self.stateTime != nil {
                    map["StateTime"] = self.stateTime!
                }
                if self.workMode != nil {
                    map["WorkMode"] = self.workMode!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AgentId") && dict["AgentId"] != nil {
                    self.agentId = dict["AgentId"] as! String
                }
                if dict.keys.contains("AgentName") && dict["AgentName"] != nil {
                    self.agentName = dict["AgentName"] as! String
                }
                if dict.keys.contains("CallType") && dict["CallType"] != nil {
                    self.callType = dict["CallType"] as! String
                }
                if dict.keys.contains("CounterParty") && dict["CounterParty"] != nil {
                    self.counterParty = dict["CounterParty"] as! String
                }
                if dict.keys.contains("Duration") && dict["Duration"] != nil {
                    self.duration = dict["Duration"] as! Int64
                }
                if dict.keys.contains("Extension") && dict["Extension"] != nil {
                    self.extension_ = dict["Extension"] as! String
                }
                if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("Mobile") && dict["Mobile"] != nil {
                    self.mobile = dict["Mobile"] as! String
                }
                if dict.keys.contains("OutboundScenario") && dict["OutboundScenario"] != nil {
                    self.outboundScenario = dict["OutboundScenario"] as! Bool
                }
                if dict.keys.contains("SkillGroupIdList") && dict["SkillGroupIdList"] != nil {
                    self.skillGroupIdList = dict["SkillGroupIdList"] as! [String]
                }
                if dict.keys.contains("SkillGroupNameList") && dict["SkillGroupNameList"] != nil {
                    self.skillGroupNameList = dict["SkillGroupNameList"] as! [String]
                }
                if dict.keys.contains("State") && dict["State"] != nil {
                    self.state = dict["State"] as! String
                }
                if dict.keys.contains("StateCode") && dict["StateCode"] != nil {
                    self.stateCode = dict["StateCode"] as! String
                }
                if dict.keys.contains("StateTime") && dict["StateTime"] != nil {
                    self.stateTime = dict["StateTime"] as! Int64
                }
                if dict.keys.contains("WorkMode") && dict["WorkMode"] != nil {
                    self.workMode = dict["WorkMode"] as! String
                }
            }
        }
        public var list: [ListRealtimeAgentStatesResponseBody.Data.List]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.list != nil {
                var tmp : [Any] = []
                for k in self.list! {
                    tmp.append(k.toMap())
                }
                map["List"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("List") && dict["List"] != nil {
                var tmp : [ListRealtimeAgentStatesResponseBody.Data.List] = []
                for v in dict["List"] as! [Any] {
                    var model = ListRealtimeAgentStatesResponseBody.Data.List()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.list = tmp
            }
            if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var code: String?

    public var data: ListRealtimeAgentStatesResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = ListRealtimeAgentStatesResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListRealtimeAgentStatesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListRealtimeAgentStatesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListRealtimeAgentStatesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListRealtimeSkillGroupStatesRequest : Tea.TeaModel {
    public var instanceId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var skillGroupIdList: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.skillGroupIdList != nil {
            map["SkillGroupIdList"] = self.skillGroupIdList!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SkillGroupIdList") && dict["SkillGroupIdList"] != nil {
            self.skillGroupIdList = dict["SkillGroupIdList"] as! String
        }
    }
}

public class ListRealtimeSkillGroupStatesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class List : Tea.TeaModel {
            public var breakingAgents: Int64?

            public var instanceId: String?

            public var loggedInAgents: Int64?

            public var longestWaitingTime: Int64?

            public var outboundScenarioReadyAgents: Int64?

            public var readyAgents: Int64?

            public var skillGroupId: String?

            public var skillGroupName: String?

            public var talkingAgents: Int64?

            public var waitingCalls: Int64?

            public var workingAgents: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.breakingAgents != nil {
                    map["BreakingAgents"] = self.breakingAgents!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.loggedInAgents != nil {
                    map["LoggedInAgents"] = self.loggedInAgents!
                }
                if self.longestWaitingTime != nil {
                    map["LongestWaitingTime"] = self.longestWaitingTime!
                }
                if self.outboundScenarioReadyAgents != nil {
                    map["OutboundScenarioReadyAgents"] = self.outboundScenarioReadyAgents!
                }
                if self.readyAgents != nil {
                    map["ReadyAgents"] = self.readyAgents!
                }
                if self.skillGroupId != nil {
                    map["SkillGroupId"] = self.skillGroupId!
                }
                if self.skillGroupName != nil {
                    map["SkillGroupName"] = self.skillGroupName!
                }
                if self.talkingAgents != nil {
                    map["TalkingAgents"] = self.talkingAgents!
                }
                if self.waitingCalls != nil {
                    map["WaitingCalls"] = self.waitingCalls!
                }
                if self.workingAgents != nil {
                    map["WorkingAgents"] = self.workingAgents!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BreakingAgents") && dict["BreakingAgents"] != nil {
                    self.breakingAgents = dict["BreakingAgents"] as! Int64
                }
                if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("LoggedInAgents") && dict["LoggedInAgents"] != nil {
                    self.loggedInAgents = dict["LoggedInAgents"] as! Int64
                }
                if dict.keys.contains("LongestWaitingTime") && dict["LongestWaitingTime"] != nil {
                    self.longestWaitingTime = dict["LongestWaitingTime"] as! Int64
                }
                if dict.keys.contains("OutboundScenarioReadyAgents") && dict["OutboundScenarioReadyAgents"] != nil {
                    self.outboundScenarioReadyAgents = dict["OutboundScenarioReadyAgents"] as! Int64
                }
                if dict.keys.contains("ReadyAgents") && dict["ReadyAgents"] != nil {
                    self.readyAgents = dict["ReadyAgents"] as! Int64
                }
                if dict.keys.contains("SkillGroupId") && dict["SkillGroupId"] != nil {
                    self.skillGroupId = dict["SkillGroupId"] as! String
                }
                if dict.keys.contains("SkillGroupName") && dict["SkillGroupName"] != nil {
                    self.skillGroupName = dict["SkillGroupName"] as! String
                }
                if dict.keys.contains("TalkingAgents") && dict["TalkingAgents"] != nil {
                    self.talkingAgents = dict["TalkingAgents"] as! Int64
                }
                if dict.keys.contains("WaitingCalls") && dict["WaitingCalls"] != nil {
                    self.waitingCalls = dict["WaitingCalls"] as! Int64
                }
                if dict.keys.contains("WorkingAgents") && dict["WorkingAgents"] != nil {
                    self.workingAgents = dict["WorkingAgents"] as! Int64
                }
            }
        }
        public var list: [ListRealtimeSkillGroupStatesResponseBody.Data.List]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.list != nil {
                var tmp : [Any] = []
                for k in self.list! {
                    tmp.append(k.toMap())
                }
                map["List"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("List") && dict["List"] != nil {
                var tmp : [ListRealtimeSkillGroupStatesResponseBody.Data.List] = []
                for v in dict["List"] as! [Any] {
                    var model = ListRealtimeSkillGroupStatesResponseBody.Data.List()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.list = tmp
            }
            if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var code: String?

    public var data: ListRealtimeSkillGroupStatesResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = ListRealtimeSkillGroupStatesResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListRealtimeSkillGroupStatesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListRealtimeSkillGroupStatesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListRealtimeSkillGroupStatesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListRecentCallDetailRecordsRequest : Tea.TeaModel {
    public var criteria: String?

    public var endTime: Int64?

    public var instanceId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var startTime: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.criteria != nil {
            map["Criteria"] = self.criteria!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Criteria") && dict["Criteria"] != nil {
            self.criteria = dict["Criteria"] as! String
        }
        if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
            self.startTime = dict["StartTime"] as! Int64
        }
    }
}

public class ListRecentCallDetailRecordsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class List : Tea.TeaModel {
            public var agentIds: String?

            public var callDuration: String?

            public var calledNumber: String?

            public var callingNumber: String?

            public var contactDisposition: String?

            public var contactId: String?

            public var contactType: String?

            public var duration: Int64?

            public var instanceId: String?

            public var skillGroupIds: String?

            public var startTime: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.agentIds != nil {
                    map["AgentIds"] = self.agentIds!
                }
                if self.callDuration != nil {
                    map["CallDuration"] = self.callDuration!
                }
                if self.calledNumber != nil {
                    map["CalledNumber"] = self.calledNumber!
                }
                if self.callingNumber != nil {
                    map["CallingNumber"] = self.callingNumber!
                }
                if self.contactDisposition != nil {
                    map["ContactDisposition"] = self.contactDisposition!
                }
                if self.contactId != nil {
                    map["ContactId"] = self.contactId!
                }
                if self.contactType != nil {
                    map["ContactType"] = self.contactType!
                }
                if self.duration != nil {
                    map["Duration"] = self.duration!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.skillGroupIds != nil {
                    map["SkillGroupIds"] = self.skillGroupIds!
                }
                if self.startTime != nil {
                    map["StartTime"] = self.startTime!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AgentIds") && dict["AgentIds"] != nil {
                    self.agentIds = dict["AgentIds"] as! String
                }
                if dict.keys.contains("CallDuration") && dict["CallDuration"] != nil {
                    self.callDuration = dict["CallDuration"] as! String
                }
                if dict.keys.contains("CalledNumber") && dict["CalledNumber"] != nil {
                    self.calledNumber = dict["CalledNumber"] as! String
                }
                if dict.keys.contains("CallingNumber") && dict["CallingNumber"] != nil {
                    self.callingNumber = dict["CallingNumber"] as! String
                }
                if dict.keys.contains("ContactDisposition") && dict["ContactDisposition"] != nil {
                    self.contactDisposition = dict["ContactDisposition"] as! String
                }
                if dict.keys.contains("ContactId") && dict["ContactId"] != nil {
                    self.contactId = dict["ContactId"] as! String
                }
                if dict.keys.contains("ContactType") && dict["ContactType"] != nil {
                    self.contactType = dict["ContactType"] as! String
                }
                if dict.keys.contains("Duration") && dict["Duration"] != nil {
                    self.duration = dict["Duration"] as! Int64
                }
                if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("SkillGroupIds") && dict["SkillGroupIds"] != nil {
                    self.skillGroupIds = dict["SkillGroupIds"] as! String
                }
                if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
                    self.startTime = dict["StartTime"] as! Int64
                }
            }
        }
        public var list: [ListRecentCallDetailRecordsResponseBody.Data.List]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.list != nil {
                var tmp : [Any] = []
                for k in self.list! {
                    tmp.append(k.toMap())
                }
                map["List"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("List") && dict["List"] != nil {
                var tmp : [ListRecentCallDetailRecordsResponseBody.Data.List] = []
                for v in dict["List"] as! [Any] {
                    var model = ListRecentCallDetailRecordsResponseBody.Data.List()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.list = tmp
            }
            if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var code: String?

    public var data: ListRecentCallDetailRecordsResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = ListRecentCallDetailRecordsResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListRecentCallDetailRecordsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListRecentCallDetailRecordsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListRecentCallDetailRecordsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListRolesRequest : Tea.TeaModel {
    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
    }
}

public class ListRolesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var name: String?

        public var roleId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.roleId != nil {
                map["RoleId"] = self.roleId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("RoleId") && dict["RoleId"] != nil {
                self.roleId = dict["RoleId"] as! String
            }
        }
    }
    public var code: String?

    public var data: [ListRolesResponseBody.Data]?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var tmp : [ListRolesResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = ListRolesResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListRolesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListRolesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListRolesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListSkillGroupStatesRequest : Tea.TeaModel {
    public var instanceId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var skillGroupIds: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.skillGroupIds != nil {
            map["SkillGroupIds"] = self.skillGroupIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SkillGroupIds") && dict["SkillGroupIds"] != nil {
            self.skillGroupIds = dict["SkillGroupIds"] as! String
        }
    }
}

public class ListSkillGroupStatesResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class List : Tea.TeaModel {
            public var averageWaitingTime: Int64?

            public var breakingAgents: Int64?

            public var inboundTalkingAgents: Int64?

            public var instanceId: String?

            public var loggedInAgents: Int64?

            public var longestCall: Int64?

            public var outboundScenarioReadyAgents: Int64?

            public var outboundTalkingAgents: Int64?

            public var readyAgents: Int64?

            public var skillGroupId: String?

            public var skillGroupName: String?

            public var talkingAgents: Int64?

            public var waitingCalls: Int64?

            public var waitingCallsLevel10: Int64?

            public var waitingCallsLevel20: Int64?

            public var waitingCallsLevel30: Int64?

            public var workingAgents: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.averageWaitingTime != nil {
                    map["AverageWaitingTime"] = self.averageWaitingTime!
                }
                if self.breakingAgents != nil {
                    map["BreakingAgents"] = self.breakingAgents!
                }
                if self.inboundTalkingAgents != nil {
                    map["InboundTalkingAgents"] = self.inboundTalkingAgents!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.loggedInAgents != nil {
                    map["LoggedInAgents"] = self.loggedInAgents!
                }
                if self.longestCall != nil {
                    map["LongestCall"] = self.longestCall!
                }
                if self.outboundScenarioReadyAgents != nil {
                    map["OutboundScenarioReadyAgents"] = self.outboundScenarioReadyAgents!
                }
                if self.outboundTalkingAgents != nil {
                    map["OutboundTalkingAgents"] = self.outboundTalkingAgents!
                }
                if self.readyAgents != nil {
                    map["ReadyAgents"] = self.readyAgents!
                }
                if self.skillGroupId != nil {
                    map["SkillGroupId"] = self.skillGroupId!
                }
                if self.skillGroupName != nil {
                    map["SkillGroupName"] = self.skillGroupName!
                }
                if self.talkingAgents != nil {
                    map["TalkingAgents"] = self.talkingAgents!
                }
                if self.waitingCalls != nil {
                    map["WaitingCalls"] = self.waitingCalls!
                }
                if self.waitingCallsLevel10 != nil {
                    map["WaitingCallsLevel10"] = self.waitingCallsLevel10!
                }
                if self.waitingCallsLevel20 != nil {
                    map["WaitingCallsLevel20"] = self.waitingCallsLevel20!
                }
                if self.waitingCallsLevel30 != nil {
                    map["WaitingCallsLevel30"] = self.waitingCallsLevel30!
                }
                if self.workingAgents != nil {
                    map["WorkingAgents"] = self.workingAgents!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AverageWaitingTime") && dict["AverageWaitingTime"] != nil {
                    self.averageWaitingTime = dict["AverageWaitingTime"] as! Int64
                }
                if dict.keys.contains("BreakingAgents") && dict["BreakingAgents"] != nil {
                    self.breakingAgents = dict["BreakingAgents"] as! Int64
                }
                if dict.keys.contains("InboundTalkingAgents") && dict["InboundTalkingAgents"] != nil {
                    self.inboundTalkingAgents = dict["InboundTalkingAgents"] as! Int64
                }
                if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("LoggedInAgents") && dict["LoggedInAgents"] != nil {
                    self.loggedInAgents = dict["LoggedInAgents"] as! Int64
                }
                if dict.keys.contains("LongestCall") && dict["LongestCall"] != nil {
                    self.longestCall = dict["LongestCall"] as! Int64
                }
                if dict.keys.contains("OutboundScenarioReadyAgents") && dict["OutboundScenarioReadyAgents"] != nil {
                    self.outboundScenarioReadyAgents = dict["OutboundScenarioReadyAgents"] as! Int64
                }
                if dict.keys.contains("OutboundTalkingAgents") && dict["OutboundTalkingAgents"] != nil {
                    self.outboundTalkingAgents = dict["OutboundTalkingAgents"] as! Int64
                }
                if dict.keys.contains("ReadyAgents") && dict["ReadyAgents"] != nil {
                    self.readyAgents = dict["ReadyAgents"] as! Int64
                }
                if dict.keys.contains("SkillGroupId") && dict["SkillGroupId"] != nil {
                    self.skillGroupId = dict["SkillGroupId"] as! String
                }
                if dict.keys.contains("SkillGroupName") && dict["SkillGroupName"] != nil {
                    self.skillGroupName = dict["SkillGroupName"] as! String
                }
                if dict.keys.contains("TalkingAgents") && dict["TalkingAgents"] != nil {
                    self.talkingAgents = dict["TalkingAgents"] as! Int64
                }
                if dict.keys.contains("WaitingCalls") && dict["WaitingCalls"] != nil {
                    self.waitingCalls = dict["WaitingCalls"] as! Int64
                }
                if dict.keys.contains("WaitingCallsLevel10") && dict["WaitingCallsLevel10"] != nil {
                    self.waitingCallsLevel10 = dict["WaitingCallsLevel10"] as! Int64
                }
                if dict.keys.contains("WaitingCallsLevel20") && dict["WaitingCallsLevel20"] != nil {
                    self.waitingCallsLevel20 = dict["WaitingCallsLevel20"] as! Int64
                }
                if dict.keys.contains("WaitingCallsLevel30") && dict["WaitingCallsLevel30"] != nil {
                    self.waitingCallsLevel30 = dict["WaitingCallsLevel30"] as! Int64
                }
                if dict.keys.contains("WorkingAgents") && dict["WorkingAgents"] != nil {
                    self.workingAgents = dict["WorkingAgents"] as! Int64
                }
            }
        }
        public var list: [ListSkillGroupStatesResponseBody.Data.List]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.list != nil {
                var tmp : [Any] = []
                for k in self.list! {
                    tmp.append(k.toMap())
                }
                map["List"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("List") && dict["List"] != nil {
                var tmp : [ListSkillGroupStatesResponseBody.Data.List] = []
                for v in dict["List"] as! [Any] {
                    var model = ListSkillGroupStatesResponseBody.Data.List()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.list = tmp
            }
            if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var code: String?

    public var data: ListSkillGroupStatesResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = ListSkillGroupStatesResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListSkillGroupStatesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListSkillGroupStatesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListSkillGroupStatesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListSkillGroupSummaryReportsSinceMidnightRequest : Tea.TeaModel {
    public var instanceId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var skillGroups: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.skillGroups != nil {
            map["SkillGroups"] = self.skillGroups!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SkillGroups") && dict["SkillGroups"] != nil {
            self.skillGroups = dict["SkillGroups"] as! String
        }
    }
}

public class ListSkillGroupSummaryReportsSinceMidnightResponseBody : Tea.TeaModel {
    public class PagedSkillGroupSummaryReport : Tea.TeaModel {
        public class List : Tea.TeaModel {
            public class Inbound : Tea.TeaModel {
                public var abandonedInQueueOfQueueCount: Int64?

                public var answeredByAgentOfQueueCount: Int64?

                public var answeredByAgentOfQueueMaxWaitTimeDuration: Int64?

                public var answeredByAgentOfQueueWaitTimeDuration: Int64?

                public var averageRingTime: Int64?

                public var averageTalkTime: Int64?

                public var averageWorkTime: Int64?

                public var callsAttendedTransferOut: Int64?

                public var callsBlindTransferOut: Int64?

                public var callsHandled: Int64?

                public var callsOffered: Int64?

                public var callsServiceLevel10: Int64?

                public var callsServiceLevel20: Int64?

                public var callsServiceLevel30: Int64?

                public var giveUpByAgentOfQueueCount: Int64?

                public var handleRate: Double?

                public var inComingQueueOfQueueCount: Int64?

                public var maxRingTime: Int64?

                public var maxTalkTime: String?

                public var maxWorkTime: Int64?

                public var overFlowInQueueOfQueueCount: Int64?

                public var queueMaxWaitTimeDuration: Int64?

                public var queueWaitTimeDuration: Int64?

                public var satisfactionIndex: Double?

                public var satisfactionSurveysOffered: Int64?

                public var satisfactionSurveysResponded: Int64?

                public var serviceLevel20: Double?

                public var totalRingTime: Int64?

                public var totalTalkTime: Int64?

                public var totalWorkTime: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.abandonedInQueueOfQueueCount != nil {
                        map["AbandonedInQueueOfQueueCount"] = self.abandonedInQueueOfQueueCount!
                    }
                    if self.answeredByAgentOfQueueCount != nil {
                        map["AnsweredByAgentOfQueueCount"] = self.answeredByAgentOfQueueCount!
                    }
                    if self.answeredByAgentOfQueueMaxWaitTimeDuration != nil {
                        map["AnsweredByAgentOfQueueMaxWaitTimeDuration"] = self.answeredByAgentOfQueueMaxWaitTimeDuration!
                    }
                    if self.answeredByAgentOfQueueWaitTimeDuration != nil {
                        map["AnsweredByAgentOfQueueWaitTimeDuration"] = self.answeredByAgentOfQueueWaitTimeDuration!
                    }
                    if self.averageRingTime != nil {
                        map["AverageRingTime"] = self.averageRingTime!
                    }
                    if self.averageTalkTime != nil {
                        map["AverageTalkTime"] = self.averageTalkTime!
                    }
                    if self.averageWorkTime != nil {
                        map["AverageWorkTime"] = self.averageWorkTime!
                    }
                    if self.callsAttendedTransferOut != nil {
                        map["CallsAttendedTransferOut"] = self.callsAttendedTransferOut!
                    }
                    if self.callsBlindTransferOut != nil {
                        map["CallsBlindTransferOut"] = self.callsBlindTransferOut!
                    }
                    if self.callsHandled != nil {
                        map["CallsHandled"] = self.callsHandled!
                    }
                    if self.callsOffered != nil {
                        map["CallsOffered"] = self.callsOffered!
                    }
                    if self.callsServiceLevel10 != nil {
                        map["CallsServiceLevel10"] = self.callsServiceLevel10!
                    }
                    if self.callsServiceLevel20 != nil {
                        map["CallsServiceLevel20"] = self.callsServiceLevel20!
                    }
                    if self.callsServiceLevel30 != nil {
                        map["CallsServiceLevel30"] = self.callsServiceLevel30!
                    }
                    if self.giveUpByAgentOfQueueCount != nil {
                        map["GiveUpByAgentOfQueueCount"] = self.giveUpByAgentOfQueueCount!
                    }
                    if self.handleRate != nil {
                        map["HandleRate"] = self.handleRate!
                    }
                    if self.inComingQueueOfQueueCount != nil {
                        map["InComingQueueOfQueueCount"] = self.inComingQueueOfQueueCount!
                    }
                    if self.maxRingTime != nil {
                        map["MaxRingTime"] = self.maxRingTime!
                    }
                    if self.maxTalkTime != nil {
                        map["MaxTalkTime"] = self.maxTalkTime!
                    }
                    if self.maxWorkTime != nil {
                        map["MaxWorkTime"] = self.maxWorkTime!
                    }
                    if self.overFlowInQueueOfQueueCount != nil {
                        map["OverFlowInQueueOfQueueCount"] = self.overFlowInQueueOfQueueCount!
                    }
                    if self.queueMaxWaitTimeDuration != nil {
                        map["QueueMaxWaitTimeDuration"] = self.queueMaxWaitTimeDuration!
                    }
                    if self.queueWaitTimeDuration != nil {
                        map["QueueWaitTimeDuration"] = self.queueWaitTimeDuration!
                    }
                    if self.satisfactionIndex != nil {
                        map["SatisfactionIndex"] = self.satisfactionIndex!
                    }
                    if self.satisfactionSurveysOffered != nil {
                        map["SatisfactionSurveysOffered"] = self.satisfactionSurveysOffered!
                    }
                    if self.satisfactionSurveysResponded != nil {
                        map["SatisfactionSurveysResponded"] = self.satisfactionSurveysResponded!
                    }
                    if self.serviceLevel20 != nil {
                        map["ServiceLevel20"] = self.serviceLevel20!
                    }
                    if self.totalRingTime != nil {
                        map["TotalRingTime"] = self.totalRingTime!
                    }
                    if self.totalTalkTime != nil {
                        map["TotalTalkTime"] = self.totalTalkTime!
                    }
                    if self.totalWorkTime != nil {
                        map["TotalWorkTime"] = self.totalWorkTime!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AbandonedInQueueOfQueueCount") && dict["AbandonedInQueueOfQueueCount"] != nil {
                        self.abandonedInQueueOfQueueCount = dict["AbandonedInQueueOfQueueCount"] as! Int64
                    }
                    if dict.keys.contains("AnsweredByAgentOfQueueCount") && dict["AnsweredByAgentOfQueueCount"] != nil {
                        self.answeredByAgentOfQueueCount = dict["AnsweredByAgentOfQueueCount"] as! Int64
                    }
                    if dict.keys.contains("AnsweredByAgentOfQueueMaxWaitTimeDuration") && dict["AnsweredByAgentOfQueueMaxWaitTimeDuration"] != nil {
                        self.answeredByAgentOfQueueMaxWaitTimeDuration = dict["AnsweredByAgentOfQueueMaxWaitTimeDuration"] as! Int64
                    }
                    if dict.keys.contains("AnsweredByAgentOfQueueWaitTimeDuration") && dict["AnsweredByAgentOfQueueWaitTimeDuration"] != nil {
                        self.answeredByAgentOfQueueWaitTimeDuration = dict["AnsweredByAgentOfQueueWaitTimeDuration"] as! Int64
                    }
                    if dict.keys.contains("AverageRingTime") && dict["AverageRingTime"] != nil {
                        self.averageRingTime = dict["AverageRingTime"] as! Int64
                    }
                    if dict.keys.contains("AverageTalkTime") && dict["AverageTalkTime"] != nil {
                        self.averageTalkTime = dict["AverageTalkTime"] as! Int64
                    }
                    if dict.keys.contains("AverageWorkTime") && dict["AverageWorkTime"] != nil {
                        self.averageWorkTime = dict["AverageWorkTime"] as! Int64
                    }
                    if dict.keys.contains("CallsAttendedTransferOut") && dict["CallsAttendedTransferOut"] != nil {
                        self.callsAttendedTransferOut = dict["CallsAttendedTransferOut"] as! Int64
                    }
                    if dict.keys.contains("CallsBlindTransferOut") && dict["CallsBlindTransferOut"] != nil {
                        self.callsBlindTransferOut = dict["CallsBlindTransferOut"] as! Int64
                    }
                    if dict.keys.contains("CallsHandled") && dict["CallsHandled"] != nil {
                        self.callsHandled = dict["CallsHandled"] as! Int64
                    }
                    if dict.keys.contains("CallsOffered") && dict["CallsOffered"] != nil {
                        self.callsOffered = dict["CallsOffered"] as! Int64
                    }
                    if dict.keys.contains("CallsServiceLevel10") && dict["CallsServiceLevel10"] != nil {
                        self.callsServiceLevel10 = dict["CallsServiceLevel10"] as! Int64
                    }
                    if dict.keys.contains("CallsServiceLevel20") && dict["CallsServiceLevel20"] != nil {
                        self.callsServiceLevel20 = dict["CallsServiceLevel20"] as! Int64
                    }
                    if dict.keys.contains("CallsServiceLevel30") && dict["CallsServiceLevel30"] != nil {
                        self.callsServiceLevel30 = dict["CallsServiceLevel30"] as! Int64
                    }
                    if dict.keys.contains("GiveUpByAgentOfQueueCount") && dict["GiveUpByAgentOfQueueCount"] != nil {
                        self.giveUpByAgentOfQueueCount = dict["GiveUpByAgentOfQueueCount"] as! Int64
                    }
                    if dict.keys.contains("HandleRate") && dict["HandleRate"] != nil {
                        self.handleRate = dict["HandleRate"] as! Double
                    }
                    if dict.keys.contains("InComingQueueOfQueueCount") && dict["InComingQueueOfQueueCount"] != nil {
                        self.inComingQueueOfQueueCount = dict["InComingQueueOfQueueCount"] as! Int64
                    }
                    if dict.keys.contains("MaxRingTime") && dict["MaxRingTime"] != nil {
                        self.maxRingTime = dict["MaxRingTime"] as! Int64
                    }
                    if dict.keys.contains("MaxTalkTime") && dict["MaxTalkTime"] != nil {
                        self.maxTalkTime = dict["MaxTalkTime"] as! String
                    }
                    if dict.keys.contains("MaxWorkTime") && dict["MaxWorkTime"] != nil {
                        self.maxWorkTime = dict["MaxWorkTime"] as! Int64
                    }
                    if dict.keys.contains("OverFlowInQueueOfQueueCount") && dict["OverFlowInQueueOfQueueCount"] != nil {
                        self.overFlowInQueueOfQueueCount = dict["OverFlowInQueueOfQueueCount"] as! Int64
                    }
                    if dict.keys.contains("QueueMaxWaitTimeDuration") && dict["QueueMaxWaitTimeDuration"] != nil {
                        self.queueMaxWaitTimeDuration = dict["QueueMaxWaitTimeDuration"] as! Int64
                    }
                    if dict.keys.contains("QueueWaitTimeDuration") && dict["QueueWaitTimeDuration"] != nil {
                        self.queueWaitTimeDuration = dict["QueueWaitTimeDuration"] as! Int64
                    }
                    if dict.keys.contains("SatisfactionIndex") && dict["SatisfactionIndex"] != nil {
                        self.satisfactionIndex = dict["SatisfactionIndex"] as! Double
                    }
                    if dict.keys.contains("SatisfactionSurveysOffered") && dict["SatisfactionSurveysOffered"] != nil {
                        self.satisfactionSurveysOffered = dict["SatisfactionSurveysOffered"] as! Int64
                    }
                    if dict.keys.contains("SatisfactionSurveysResponded") && dict["SatisfactionSurveysResponded"] != nil {
                        self.satisfactionSurveysResponded = dict["SatisfactionSurveysResponded"] as! Int64
                    }
                    if dict.keys.contains("ServiceLevel20") && dict["ServiceLevel20"] != nil {
                        self.serviceLevel20 = dict["ServiceLevel20"] as! Double
                    }
                    if dict.keys.contains("TotalRingTime") && dict["TotalRingTime"] != nil {
                        self.totalRingTime = dict["TotalRingTime"] as! Int64
                    }
                    if dict.keys.contains("TotalTalkTime") && dict["TotalTalkTime"] != nil {
                        self.totalTalkTime = dict["TotalTalkTime"] as! Int64
                    }
                    if dict.keys.contains("TotalWorkTime") && dict["TotalWorkTime"] != nil {
                        self.totalWorkTime = dict["TotalWorkTime"] as! Int64
                    }
                }
            }
            public class Outbound : Tea.TeaModel {
                public var answerRate: Double?

                public var averageDialingTime: Int64?

                public var averageTalkTime: Int64?

                public var averageWorkTime: Int64?

                public var callsAnswered: Int64?

                public var callsDialed: Int64?

                public var callsServiceLevel30: String?

                public var maxDialingTime: Int64?

                public var maxTalkTime: Int64?

                public var maxWorkTime: Int64?

                public var satisfactionIndex: Double?

                public var satisfactionSurveysOffered: Int64?

                public var satisfactionSurveysResponded: Int64?

                public var totalDialingTime: Int64?

                public var totalTalkTime: Int64?

                public var totalWorkTime: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.answerRate != nil {
                        map["AnswerRate"] = self.answerRate!
                    }
                    if self.averageDialingTime != nil {
                        map["AverageDialingTime"] = self.averageDialingTime!
                    }
                    if self.averageTalkTime != nil {
                        map["AverageTalkTime"] = self.averageTalkTime!
                    }
                    if self.averageWorkTime != nil {
                        map["AverageWorkTime"] = self.averageWorkTime!
                    }
                    if self.callsAnswered != nil {
                        map["CallsAnswered"] = self.callsAnswered!
                    }
                    if self.callsDialed != nil {
                        map["CallsDialed"] = self.callsDialed!
                    }
                    if self.callsServiceLevel30 != nil {
                        map["CallsServiceLevel30"] = self.callsServiceLevel30!
                    }
                    if self.maxDialingTime != nil {
                        map["MaxDialingTime"] = self.maxDialingTime!
                    }
                    if self.maxTalkTime != nil {
                        map["MaxTalkTime"] = self.maxTalkTime!
                    }
                    if self.maxWorkTime != nil {
                        map["MaxWorkTime"] = self.maxWorkTime!
                    }
                    if self.satisfactionIndex != nil {
                        map["SatisfactionIndex"] = self.satisfactionIndex!
                    }
                    if self.satisfactionSurveysOffered != nil {
                        map["SatisfactionSurveysOffered"] = self.satisfactionSurveysOffered!
                    }
                    if self.satisfactionSurveysResponded != nil {
                        map["SatisfactionSurveysResponded"] = self.satisfactionSurveysResponded!
                    }
                    if self.totalDialingTime != nil {
                        map["TotalDialingTime"] = self.totalDialingTime!
                    }
                    if self.totalTalkTime != nil {
                        map["TotalTalkTime"] = self.totalTalkTime!
                    }
                    if self.totalWorkTime != nil {
                        map["TotalWorkTime"] = self.totalWorkTime!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AnswerRate") && dict["AnswerRate"] != nil {
                        self.answerRate = dict["AnswerRate"] as! Double
                    }
                    if dict.keys.contains("AverageDialingTime") && dict["AverageDialingTime"] != nil {
                        self.averageDialingTime = dict["AverageDialingTime"] as! Int64
                    }
                    if dict.keys.contains("AverageTalkTime") && dict["AverageTalkTime"] != nil {
                        self.averageTalkTime = dict["AverageTalkTime"] as! Int64
                    }
                    if dict.keys.contains("AverageWorkTime") && dict["AverageWorkTime"] != nil {
                        self.averageWorkTime = dict["AverageWorkTime"] as! Int64
                    }
                    if dict.keys.contains("CallsAnswered") && dict["CallsAnswered"] != nil {
                        self.callsAnswered = dict["CallsAnswered"] as! Int64
                    }
                    if dict.keys.contains("CallsDialed") && dict["CallsDialed"] != nil {
                        self.callsDialed = dict["CallsDialed"] as! Int64
                    }
                    if dict.keys.contains("CallsServiceLevel30") && dict["CallsServiceLevel30"] != nil {
                        self.callsServiceLevel30 = dict["CallsServiceLevel30"] as! String
                    }
                    if dict.keys.contains("MaxDialingTime") && dict["MaxDialingTime"] != nil {
                        self.maxDialingTime = dict["MaxDialingTime"] as! Int64
                    }
                    if dict.keys.contains("MaxTalkTime") && dict["MaxTalkTime"] != nil {
                        self.maxTalkTime = dict["MaxTalkTime"] as! Int64
                    }
                    if dict.keys.contains("MaxWorkTime") && dict["MaxWorkTime"] != nil {
                        self.maxWorkTime = dict["MaxWorkTime"] as! Int64
                    }
                    if dict.keys.contains("SatisfactionIndex") && dict["SatisfactionIndex"] != nil {
                        self.satisfactionIndex = dict["SatisfactionIndex"] as! Double
                    }
                    if dict.keys.contains("SatisfactionSurveysOffered") && dict["SatisfactionSurveysOffered"] != nil {
                        self.satisfactionSurveysOffered = dict["SatisfactionSurveysOffered"] as! Int64
                    }
                    if dict.keys.contains("SatisfactionSurveysResponded") && dict["SatisfactionSurveysResponded"] != nil {
                        self.satisfactionSurveysResponded = dict["SatisfactionSurveysResponded"] as! Int64
                    }
                    if dict.keys.contains("TotalDialingTime") && dict["TotalDialingTime"] != nil {
                        self.totalDialingTime = dict["TotalDialingTime"] as! Int64
                    }
                    if dict.keys.contains("TotalTalkTime") && dict["TotalTalkTime"] != nil {
                        self.totalTalkTime = dict["TotalTalkTime"] as! Int64
                    }
                    if dict.keys.contains("TotalWorkTime") && dict["TotalWorkTime"] != nil {
                        self.totalWorkTime = dict["TotalWorkTime"] as! Int64
                    }
                }
            }
            public class Overall : Tea.TeaModel {
                public var averageReadyTime: Int64?

                public var averageTalkTime: Int64?

                public var averageWorkTime: Int64?

                public var maxReadyTime: Int64?

                public var maxTalkTime: Int64?

                public var maxWorkTime: Int64?

                public var occupancyRate: Double?

                public var satisfactionIndex: Double?

                public var satisfactionSurveysOffered: Int64?

                public var satisfactionSurveysResponded: Int64?

                public var totalBreakTime: Int64?

                public var totalCalls: Int64?

                public var totalLoggedInTime: Int64?

                public var totalReadyTime: Int64?

                public var totalTalkTime: Int64?

                public var totalWorkTime: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.averageReadyTime != nil {
                        map["AverageReadyTime"] = self.averageReadyTime!
                    }
                    if self.averageTalkTime != nil {
                        map["AverageTalkTime"] = self.averageTalkTime!
                    }
                    if self.averageWorkTime != nil {
                        map["AverageWorkTime"] = self.averageWorkTime!
                    }
                    if self.maxReadyTime != nil {
                        map["MaxReadyTime"] = self.maxReadyTime!
                    }
                    if self.maxTalkTime != nil {
                        map["MaxTalkTime"] = self.maxTalkTime!
                    }
                    if self.maxWorkTime != nil {
                        map["MaxWorkTime"] = self.maxWorkTime!
                    }
                    if self.occupancyRate != nil {
                        map["OccupancyRate"] = self.occupancyRate!
                    }
                    if self.satisfactionIndex != nil {
                        map["SatisfactionIndex"] = self.satisfactionIndex!
                    }
                    if self.satisfactionSurveysOffered != nil {
                        map["SatisfactionSurveysOffered"] = self.satisfactionSurveysOffered!
                    }
                    if self.satisfactionSurveysResponded != nil {
                        map["SatisfactionSurveysResponded"] = self.satisfactionSurveysResponded!
                    }
                    if self.totalBreakTime != nil {
                        map["TotalBreakTime"] = self.totalBreakTime!
                    }
                    if self.totalCalls != nil {
                        map["TotalCalls"] = self.totalCalls!
                    }
                    if self.totalLoggedInTime != nil {
                        map["TotalLoggedInTime"] = self.totalLoggedInTime!
                    }
                    if self.totalReadyTime != nil {
                        map["TotalReadyTime"] = self.totalReadyTime!
                    }
                    if self.totalTalkTime != nil {
                        map["TotalTalkTime"] = self.totalTalkTime!
                    }
                    if self.totalWorkTime != nil {
                        map["TotalWorkTime"] = self.totalWorkTime!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AverageReadyTime") && dict["AverageReadyTime"] != nil {
                        self.averageReadyTime = dict["AverageReadyTime"] as! Int64
                    }
                    if dict.keys.contains("AverageTalkTime") && dict["AverageTalkTime"] != nil {
                        self.averageTalkTime = dict["AverageTalkTime"] as! Int64
                    }
                    if dict.keys.contains("AverageWorkTime") && dict["AverageWorkTime"] != nil {
                        self.averageWorkTime = dict["AverageWorkTime"] as! Int64
                    }
                    if dict.keys.contains("MaxReadyTime") && dict["MaxReadyTime"] != nil {
                        self.maxReadyTime = dict["MaxReadyTime"] as! Int64
                    }
                    if dict.keys.contains("MaxTalkTime") && dict["MaxTalkTime"] != nil {
                        self.maxTalkTime = dict["MaxTalkTime"] as! Int64
                    }
                    if dict.keys.contains("MaxWorkTime") && dict["MaxWorkTime"] != nil {
                        self.maxWorkTime = dict["MaxWorkTime"] as! Int64
                    }
                    if dict.keys.contains("OccupancyRate") && dict["OccupancyRate"] != nil {
                        self.occupancyRate = dict["OccupancyRate"] as! Double
                    }
                    if dict.keys.contains("SatisfactionIndex") && dict["SatisfactionIndex"] != nil {
                        self.satisfactionIndex = dict["SatisfactionIndex"] as! Double
                    }
                    if dict.keys.contains("SatisfactionSurveysOffered") && dict["SatisfactionSurveysOffered"] != nil {
                        self.satisfactionSurveysOffered = dict["SatisfactionSurveysOffered"] as! Int64
                    }
                    if dict.keys.contains("SatisfactionSurveysResponded") && dict["SatisfactionSurveysResponded"] != nil {
                        self.satisfactionSurveysResponded = dict["SatisfactionSurveysResponded"] as! Int64
                    }
                    if dict.keys.contains("TotalBreakTime") && dict["TotalBreakTime"] != nil {
                        self.totalBreakTime = dict["TotalBreakTime"] as! Int64
                    }
                    if dict.keys.contains("TotalCalls") && dict["TotalCalls"] != nil {
                        self.totalCalls = dict["TotalCalls"] as! Int64
                    }
                    if dict.keys.contains("TotalLoggedInTime") && dict["TotalLoggedInTime"] != nil {
                        self.totalLoggedInTime = dict["TotalLoggedInTime"] as! Int64
                    }
                    if dict.keys.contains("TotalReadyTime") && dict["TotalReadyTime"] != nil {
                        self.totalReadyTime = dict["TotalReadyTime"] as! Int64
                    }
                    if dict.keys.contains("TotalTalkTime") && dict["TotalTalkTime"] != nil {
                        self.totalTalkTime = dict["TotalTalkTime"] as! Int64
                    }
                    if dict.keys.contains("TotalWorkTime") && dict["TotalWorkTime"] != nil {
                        self.totalWorkTime = dict["TotalWorkTime"] as! Int64
                    }
                }
            }
            public var inbound: ListSkillGroupSummaryReportsSinceMidnightResponseBody.PagedSkillGroupSummaryReport.List.Inbound?

            public var instanceId: String?

            public var outbound: ListSkillGroupSummaryReportsSinceMidnightResponseBody.PagedSkillGroupSummaryReport.List.Outbound?

            public var overall: ListSkillGroupSummaryReportsSinceMidnightResponseBody.PagedSkillGroupSummaryReport.List.Overall?

            public var skillGroupId: String?

            public var skillGroupName: String?

            public var timestamp: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.inbound?.validate()
                try self.outbound?.validate()
                try self.overall?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.inbound != nil {
                    map["Inbound"] = self.inbound?.toMap()
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.outbound != nil {
                    map["Outbound"] = self.outbound?.toMap()
                }
                if self.overall != nil {
                    map["Overall"] = self.overall?.toMap()
                }
                if self.skillGroupId != nil {
                    map["SkillGroupId"] = self.skillGroupId!
                }
                if self.skillGroupName != nil {
                    map["SkillGroupName"] = self.skillGroupName!
                }
                if self.timestamp != nil {
                    map["Timestamp"] = self.timestamp!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Inbound") && dict["Inbound"] != nil {
                    var model = ListSkillGroupSummaryReportsSinceMidnightResponseBody.PagedSkillGroupSummaryReport.List.Inbound()
                    model.fromMap(dict["Inbound"] as! [String: Any])
                    self.inbound = model
                }
                if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("Outbound") && dict["Outbound"] != nil {
                    var model = ListSkillGroupSummaryReportsSinceMidnightResponseBody.PagedSkillGroupSummaryReport.List.Outbound()
                    model.fromMap(dict["Outbound"] as! [String: Any])
                    self.outbound = model
                }
                if dict.keys.contains("Overall") && dict["Overall"] != nil {
                    var model = ListSkillGroupSummaryReportsSinceMidnightResponseBody.PagedSkillGroupSummaryReport.List.Overall()
                    model.fromMap(dict["Overall"] as! [String: Any])
                    self.overall = model
                }
                if dict.keys.contains("SkillGroupId") && dict["SkillGroupId"] != nil {
                    self.skillGroupId = dict["SkillGroupId"] as! String
                }
                if dict.keys.contains("SkillGroupName") && dict["SkillGroupName"] != nil {
                    self.skillGroupName = dict["SkillGroupName"] as! String
                }
                if dict.keys.contains("Timestamp") && dict["Timestamp"] != nil {
                    self.timestamp = dict["Timestamp"] as! String
                }
            }
        }
        public var list: [ListSkillGroupSummaryReportsSinceMidnightResponseBody.PagedSkillGroupSummaryReport.List]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.list != nil {
                var tmp : [Any] = []
                for k in self.list! {
                    tmp.append(k.toMap())
                }
                map["List"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("List") && dict["List"] != nil {
                var tmp : [ListSkillGroupSummaryReportsSinceMidnightResponseBody.PagedSkillGroupSummaryReport.List] = []
                for v in dict["List"] as! [Any] {
                    var model = ListSkillGroupSummaryReportsSinceMidnightResponseBody.PagedSkillGroupSummaryReport.List()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.list = tmp
            }
            if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var code: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var pagedSkillGroupSummaryReport: ListSkillGroupSummaryReportsSinceMidnightResponseBody.PagedSkillGroupSummaryReport?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.pagedSkillGroupSummaryReport?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.pagedSkillGroupSummaryReport != nil {
            map["PagedSkillGroupSummaryReport"] = self.pagedSkillGroupSummaryReport?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("PagedSkillGroupSummaryReport") && dict["PagedSkillGroupSummaryReport"] != nil {
            var model = ListSkillGroupSummaryReportsSinceMidnightResponseBody.PagedSkillGroupSummaryReport()
            model.fromMap(dict["PagedSkillGroupSummaryReport"] as! [String: Any])
            self.pagedSkillGroupSummaryReport = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class ListSkillGroupSummaryReportsSinceMidnightResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListSkillGroupSummaryReportsSinceMidnightResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListSkillGroupSummaryReportsSinceMidnightResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListSkillGroupsRequest : Tea.TeaModel {
    public var instanceId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var searchPattern: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.searchPattern != nil {
            map["SearchPattern"] = self.searchPattern!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SearchPattern") && dict["SearchPattern"] != nil {
            self.searchPattern = dict["SearchPattern"] as! String
        }
    }
}

public class ListSkillGroupsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class List : Tea.TeaModel {
            public var description_: String?

            public var displayName: String?

            public var instanceId: String?

            public var phoneNumberCount: Int32?

            public var skillGroupId: String?

            public var skillGroupName: String?

            public var userCount: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.displayName != nil {
                    map["DisplayName"] = self.displayName!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.phoneNumberCount != nil {
                    map["PhoneNumberCount"] = self.phoneNumberCount!
                }
                if self.skillGroupId != nil {
                    map["SkillGroupId"] = self.skillGroupId!
                }
                if self.skillGroupName != nil {
                    map["SkillGroupName"] = self.skillGroupName!
                }
                if self.userCount != nil {
                    map["UserCount"] = self.userCount!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Description") && dict["Description"] != nil {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("DisplayName") && dict["DisplayName"] != nil {
                    self.displayName = dict["DisplayName"] as! String
                }
                if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("PhoneNumberCount") && dict["PhoneNumberCount"] != nil {
                    self.phoneNumberCount = dict["PhoneNumberCount"] as! Int32
                }
                if dict.keys.contains("SkillGroupId") && dict["SkillGroupId"] != nil {
                    self.skillGroupId = dict["SkillGroupId"] as! String
                }
                if dict.keys.contains("SkillGroupName") && dict["SkillGroupName"] != nil {
                    self.skillGroupName = dict["SkillGroupName"] as! String
                }
                if dict.keys.contains("UserCount") && dict["UserCount"] != nil {
                    self.userCount = dict["UserCount"] as! Int32
                }
            }
        }
        public var list: [ListSkillGroupsResponseBody.Data.List]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.list != nil {
                var tmp : [Any] = []
                for k in self.list! {
                    tmp.append(k.toMap())
                }
                map["List"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("List") && dict["List"] != nil {
                var tmp : [ListSkillGroupsResponseBody.Data.List] = []
                for v in dict["List"] as! [Any] {
                    var model = ListSkillGroupsResponseBody.Data.List()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.list = tmp
            }
            if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var code: String?

    public var data: ListSkillGroupsResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = ListSkillGroupsResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListSkillGroupsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListSkillGroupsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListSkillGroupsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListSkillLevelsOfUserRequest : Tea.TeaModel {
    public var instanceId: String?

    public var isMember: Bool?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var searchPattern: String?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.isMember != nil {
            map["IsMember"] = self.isMember!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.searchPattern != nil {
            map["SearchPattern"] = self.searchPattern!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("IsMember") && dict["IsMember"] != nil {
            self.isMember = dict["IsMember"] as! Bool
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SearchPattern") && dict["SearchPattern"] != nil {
            self.searchPattern = dict["SearchPattern"] as! String
        }
        if dict.keys.contains("UserId") && dict["UserId"] != nil {
            self.userId = dict["UserId"] as! String
        }
    }
}

public class ListSkillLevelsOfUserResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class List : Tea.TeaModel {
            public var skillGroupId: String?

            public var skillGroupName: String?

            public var skillLevel: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.skillGroupId != nil {
                    map["SkillGroupId"] = self.skillGroupId!
                }
                if self.skillGroupName != nil {
                    map["SkillGroupName"] = self.skillGroupName!
                }
                if self.skillLevel != nil {
                    map["SkillLevel"] = self.skillLevel!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("SkillGroupId") && dict["SkillGroupId"] != nil {
                    self.skillGroupId = dict["SkillGroupId"] as! String
                }
                if dict.keys.contains("SkillGroupName") && dict["SkillGroupName"] != nil {
                    self.skillGroupName = dict["SkillGroupName"] as! String
                }
                if dict.keys.contains("SkillLevel") && dict["SkillLevel"] != nil {
                    self.skillLevel = dict["SkillLevel"] as! String
                }
            }
        }
        public var list: [ListSkillLevelsOfUserResponseBody.Data.List]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.list != nil {
                var tmp : [Any] = []
                for k in self.list! {
                    tmp.append(k.toMap())
                }
                map["List"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("List") && dict["List"] != nil {
                var tmp : [ListSkillLevelsOfUserResponseBody.Data.List] = []
                for v in dict["List"] as! [Any] {
                    var model = ListSkillLevelsOfUserResponseBody.Data.List()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.list = tmp
            }
            if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var code: String?

    public var data: ListSkillLevelsOfUserResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = ListSkillLevelsOfUserResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListSkillLevelsOfUserResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListSkillLevelsOfUserResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListSkillLevelsOfUserResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListUnassignedNumbersRequest : Tea.TeaModel {
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var searchPattern: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.searchPattern != nil {
            map["SearchPattern"] = self.searchPattern!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SearchPattern") && dict["SearchPattern"] != nil {
            self.searchPattern = dict["SearchPattern"] as! String
        }
    }
}

public class ListUnassignedNumbersResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class List : Tea.TeaModel {
            public var city: String?

            public var number: String?

            public var province: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.city != nil {
                    map["City"] = self.city!
                }
                if self.number != nil {
                    map["Number"] = self.number!
                }
                if self.province != nil {
                    map["Province"] = self.province!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("City") && dict["City"] != nil {
                    self.city = dict["City"] as! String
                }
                if dict.keys.contains("Number") && dict["Number"] != nil {
                    self.number = dict["Number"] as! String
                }
                if dict.keys.contains("Province") && dict["Province"] != nil {
                    self.province = dict["Province"] as! String
                }
            }
        }
        public var list: [ListUnassignedNumbersResponseBody.Data.List]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.list != nil {
                var tmp : [Any] = []
                for k in self.list! {
                    tmp.append(k.toMap())
                }
                map["List"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("List") && dict["List"] != nil {
                var tmp : [ListUnassignedNumbersResponseBody.Data.List] = []
                for v in dict["List"] as! [Any] {
                    var model = ListUnassignedNumbersResponseBody.Data.List()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.list = tmp
            }
            if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var code: String?

    public var data: ListUnassignedNumbersResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = ListUnassignedNumbersResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListUnassignedNumbersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListUnassignedNumbersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListUnassignedNumbersResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListUserLevelsOfSkillGroupRequest : Tea.TeaModel {
    public var instanceId: String?

    public var isMember: Bool?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var searchPattern: String?

    public var skillGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.isMember != nil {
            map["IsMember"] = self.isMember!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.searchPattern != nil {
            map["SearchPattern"] = self.searchPattern!
        }
        if self.skillGroupId != nil {
            map["SkillGroupId"] = self.skillGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("IsMember") && dict["IsMember"] != nil {
            self.isMember = dict["IsMember"] as! Bool
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SearchPattern") && dict["SearchPattern"] != nil {
            self.searchPattern = dict["SearchPattern"] as! String
        }
        if dict.keys.contains("SkillGroupId") && dict["SkillGroupId"] != nil {
            self.skillGroupId = dict["SkillGroupId"] as! String
        }
    }
}

public class ListUserLevelsOfSkillGroupResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class List : Tea.TeaModel {
            public var displayName: String?

            public var loginName: String?

            public var ramId: String?

            public var roleId: String?

            public var roleName: String?

            public var skillGroupId: String?

            public var skillGroupName: String?

            public var skillLevel: Int32?

            public var userId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.displayName != nil {
                    map["DisplayName"] = self.displayName!
                }
                if self.loginName != nil {
                    map["LoginName"] = self.loginName!
                }
                if self.ramId != nil {
                    map["RamId"] = self.ramId!
                }
                if self.roleId != nil {
                    map["RoleId"] = self.roleId!
                }
                if self.roleName != nil {
                    map["RoleName"] = self.roleName!
                }
                if self.skillGroupId != nil {
                    map["SkillGroupId"] = self.skillGroupId!
                }
                if self.skillGroupName != nil {
                    map["SkillGroupName"] = self.skillGroupName!
                }
                if self.skillLevel != nil {
                    map["SkillLevel"] = self.skillLevel!
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DisplayName") && dict["DisplayName"] != nil {
                    self.displayName = dict["DisplayName"] as! String
                }
                if dict.keys.contains("LoginName") && dict["LoginName"] != nil {
                    self.loginName = dict["LoginName"] as! String
                }
                if dict.keys.contains("RamId") && dict["RamId"] != nil {
                    self.ramId = dict["RamId"] as! String
                }
                if dict.keys.contains("RoleId") && dict["RoleId"] != nil {
                    self.roleId = dict["RoleId"] as! String
                }
                if dict.keys.contains("RoleName") && dict["RoleName"] != nil {
                    self.roleName = dict["RoleName"] as! String
                }
                if dict.keys.contains("SkillGroupId") && dict["SkillGroupId"] != nil {
                    self.skillGroupId = dict["SkillGroupId"] as! String
                }
                if dict.keys.contains("SkillGroupName") && dict["SkillGroupName"] != nil {
                    self.skillGroupName = dict["SkillGroupName"] as! String
                }
                if dict.keys.contains("SkillLevel") && dict["SkillLevel"] != nil {
                    self.skillLevel = dict["SkillLevel"] as! Int32
                }
                if dict.keys.contains("UserId") && dict["UserId"] != nil {
                    self.userId = dict["UserId"] as! String
                }
            }
        }
        public var list: [ListUserLevelsOfSkillGroupResponseBody.Data.List]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.list != nil {
                var tmp : [Any] = []
                for k in self.list! {
                    tmp.append(k.toMap())
                }
                map["List"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("List") && dict["List"] != nil {
                var tmp : [ListUserLevelsOfSkillGroupResponseBody.Data.List] = []
                for v in dict["List"] as! [Any] {
                    var model = ListUserLevelsOfSkillGroupResponseBody.Data.List()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.list = tmp
            }
            if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var code: String?

    public var data: ListUserLevelsOfSkillGroupResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = ListUserLevelsOfSkillGroupResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListUserLevelsOfSkillGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListUserLevelsOfSkillGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListUserLevelsOfSkillGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListUsersRequest : Tea.TeaModel {
    public var instanceId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var searchPattern: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.searchPattern != nil {
            map["SearchPattern"] = self.searchPattern!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("SearchPattern") && dict["SearchPattern"] != nil {
            self.searchPattern = dict["SearchPattern"] as! String
        }
    }
}

public class ListUsersResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class List : Tea.TeaModel {
            public class PersonalOutboundNumberList : Tea.TeaModel {
                public var active: Bool?

                public var city: String?

                public var number: String?

                public var province: String?

                public var usage: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.active != nil {
                        map["Active"] = self.active!
                    }
                    if self.city != nil {
                        map["City"] = self.city!
                    }
                    if self.number != nil {
                        map["Number"] = self.number!
                    }
                    if self.province != nil {
                        map["Province"] = self.province!
                    }
                    if self.usage != nil {
                        map["Usage"] = self.usage!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Active") && dict["Active"] != nil {
                        self.active = dict["Active"] as! Bool
                    }
                    if dict.keys.contains("City") && dict["City"] != nil {
                        self.city = dict["City"] as! String
                    }
                    if dict.keys.contains("Number") && dict["Number"] != nil {
                        self.number = dict["Number"] as! String
                    }
                    if dict.keys.contains("Province") && dict["Province"] != nil {
                        self.province = dict["Province"] as! String
                    }
                    if dict.keys.contains("Usage") && dict["Usage"] != nil {
                        self.usage = dict["Usage"] as! String
                    }
                }
            }
            public class SkillLevelList : Tea.TeaModel {
                public var skillGroupId: String?

                public var skillGroupName: String?

                public var skillLevel: Int32?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.skillGroupId != nil {
                        map["SkillGroupId"] = self.skillGroupId!
                    }
                    if self.skillGroupName != nil {
                        map["SkillGroupName"] = self.skillGroupName!
                    }
                    if self.skillLevel != nil {
                        map["SkillLevel"] = self.skillLevel!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("SkillGroupId") && dict["SkillGroupId"] != nil {
                        self.skillGroupId = dict["SkillGroupId"] as! String
                    }
                    if dict.keys.contains("SkillGroupName") && dict["SkillGroupName"] != nil {
                        self.skillGroupName = dict["SkillGroupName"] as! String
                    }
                    if dict.keys.contains("SkillLevel") && dict["SkillLevel"] != nil {
                        self.skillLevel = dict["SkillLevel"] as! Int32
                    }
                }
            }
            public var deviceExt: String?

            public var deviceId: String?

            public var deviceState: String?

            public var displayId: String?

            public var displayName: String?

            public var email: String?

            public var extension_: String?

            public var loginName: String?

            public var mobile: String?

            public var personalOutboundNumberList: [ListUsersResponseBody.Data.List.PersonalOutboundNumberList]?

            public var primaryAccount: Bool?

            public var ramId: Int64?

            public var roleId: String?

            public var roleName: String?

            public var skillLevelList: [ListUsersResponseBody.Data.List.SkillLevelList]?

            public var userId: String?

            public var workMode: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.deviceExt != nil {
                    map["DeviceExt"] = self.deviceExt!
                }
                if self.deviceId != nil {
                    map["DeviceId"] = self.deviceId!
                }
                if self.deviceState != nil {
                    map["DeviceState"] = self.deviceState!
                }
                if self.displayId != nil {
                    map["DisplayId"] = self.displayId!
                }
                if self.displayName != nil {
                    map["DisplayName"] = self.displayName!
                }
                if self.email != nil {
                    map["Email"] = self.email!
                }
                if self.extension_ != nil {
                    map["Extension"] = self.extension_!
                }
                if self.loginName != nil {
                    map["LoginName"] = self.loginName!
                }
                if self.mobile != nil {
                    map["Mobile"] = self.mobile!
                }
                if self.personalOutboundNumberList != nil {
                    var tmp : [Any] = []
                    for k in self.personalOutboundNumberList! {
                        tmp.append(k.toMap())
                    }
                    map["PersonalOutboundNumberList"] = tmp
                }
                if self.primaryAccount != nil {
                    map["PrimaryAccount"] = self.primaryAccount!
                }
                if self.ramId != nil {
                    map["RamId"] = self.ramId!
                }
                if self.roleId != nil {
                    map["RoleId"] = self.roleId!
                }
                if self.roleName != nil {
                    map["RoleName"] = self.roleName!
                }
                if self.skillLevelList != nil {
                    var tmp : [Any] = []
                    for k in self.skillLevelList! {
                        tmp.append(k.toMap())
                    }
                    map["SkillLevelList"] = tmp
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                if self.workMode != nil {
                    map["WorkMode"] = self.workMode!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DeviceExt") && dict["DeviceExt"] != nil {
                    self.deviceExt = dict["DeviceExt"] as! String
                }
                if dict.keys.contains("DeviceId") && dict["DeviceId"] != nil {
                    self.deviceId = dict["DeviceId"] as! String
                }
                if dict.keys.contains("DeviceState") && dict["DeviceState"] != nil {
                    self.deviceState = dict["DeviceState"] as! String
                }
                if dict.keys.contains("DisplayId") && dict["DisplayId"] != nil {
                    self.displayId = dict["DisplayId"] as! String
                }
                if dict.keys.contains("DisplayName") && dict["DisplayName"] != nil {
                    self.displayName = dict["DisplayName"] as! String
                }
                if dict.keys.contains("Email") && dict["Email"] != nil {
                    self.email = dict["Email"] as! String
                }
                if dict.keys.contains("Extension") && dict["Extension"] != nil {
                    self.extension_ = dict["Extension"] as! String
                }
                if dict.keys.contains("LoginName") && dict["LoginName"] != nil {
                    self.loginName = dict["LoginName"] as! String
                }
                if dict.keys.contains("Mobile") && dict["Mobile"] != nil {
                    self.mobile = dict["Mobile"] as! String
                }
                if dict.keys.contains("PersonalOutboundNumberList") && dict["PersonalOutboundNumberList"] != nil {
                    var tmp : [ListUsersResponseBody.Data.List.PersonalOutboundNumberList] = []
                    for v in dict["PersonalOutboundNumberList"] as! [Any] {
                        var model = ListUsersResponseBody.Data.List.PersonalOutboundNumberList()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.personalOutboundNumberList = tmp
                }
                if dict.keys.contains("PrimaryAccount") && dict["PrimaryAccount"] != nil {
                    self.primaryAccount = dict["PrimaryAccount"] as! Bool
                }
                if dict.keys.contains("RamId") && dict["RamId"] != nil {
                    self.ramId = dict["RamId"] as! Int64
                }
                if dict.keys.contains("RoleId") && dict["RoleId"] != nil {
                    self.roleId = dict["RoleId"] as! String
                }
                if dict.keys.contains("RoleName") && dict["RoleName"] != nil {
                    self.roleName = dict["RoleName"] as! String
                }
                if dict.keys.contains("SkillLevelList") && dict["SkillLevelList"] != nil {
                    var tmp : [ListUsersResponseBody.Data.List.SkillLevelList] = []
                    for v in dict["SkillLevelList"] as! [Any] {
                        var model = ListUsersResponseBody.Data.List.SkillLevelList()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.skillLevelList = tmp
                }
                if dict.keys.contains("UserId") && dict["UserId"] != nil {
                    self.userId = dict["UserId"] as! String
                }
                if dict.keys.contains("WorkMode") && dict["WorkMode"] != nil {
                    self.workMode = dict["WorkMode"] as! String
                }
            }
        }
        public var list: [ListUsersResponseBody.Data.List]?

        public var pageNumber: Int32?

        public var pageSize: Int32?

        public var totalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.list != nil {
                var tmp : [Any] = []
                for k in self.list! {
                    tmp.append(k.toMap())
                }
                map["List"] = tmp
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("List") && dict["List"] != nil {
                var tmp : [ListUsersResponseBody.Data.List] = []
                for v in dict["List"] as! [Any] {
                    var model = ListUsersResponseBody.Data.List()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.list = tmp
            }
            if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
                self.pageNumber = dict["PageNumber"] as! Int32
            }
            if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
                self.pageSize = dict["PageSize"] as! Int32
            }
            if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
                self.totalCount = dict["TotalCount"] as! Int32
            }
        }
    }
    public var code: String?

    public var data: ListUsersResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = ListUsersResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListUsersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListUsersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListUsersResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class MakeCallRequest : Tea.TeaModel {
    public var callee: String?

    public var caller: String?

    public var deviceId: String?

    public var instanceId: String?

    public var maskedCallee: String?

    public var tags: String?

    public var timeoutSeconds: Int32?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.callee != nil {
            map["Callee"] = self.callee!
        }
        if self.caller != nil {
            map["Caller"] = self.caller!
        }
        if self.deviceId != nil {
            map["DeviceId"] = self.deviceId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.maskedCallee != nil {
            map["MaskedCallee"] = self.maskedCallee!
        }
        if self.tags != nil {
            map["Tags"] = self.tags!
        }
        if self.timeoutSeconds != nil {
            map["TimeoutSeconds"] = self.timeoutSeconds!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Callee") && dict["Callee"] != nil {
            self.callee = dict["Callee"] as! String
        }
        if dict.keys.contains("Caller") && dict["Caller"] != nil {
            self.caller = dict["Caller"] as! String
        }
        if dict.keys.contains("DeviceId") && dict["DeviceId"] != nil {
            self.deviceId = dict["DeviceId"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("MaskedCallee") && dict["MaskedCallee"] != nil {
            self.maskedCallee = dict["MaskedCallee"] as! String
        }
        if dict.keys.contains("Tags") && dict["Tags"] != nil {
            self.tags = dict["Tags"] as! String
        }
        if dict.keys.contains("TimeoutSeconds") && dict["TimeoutSeconds"] != nil {
            self.timeoutSeconds = dict["TimeoutSeconds"] as! Int32
        }
        if dict.keys.contains("UserId") && dict["UserId"] != nil {
            self.userId = dict["UserId"] as! String
        }
    }
}

public class MakeCallResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class CallContext : Tea.TeaModel {
            public class ChannelContexts : Tea.TeaModel {
                public var callType: String?

                public var channelFlags: String?

                public var channelId: String?

                public var channelState: String?

                public var destination: String?

                public var jobId: String?

                public var originator: String?

                public var releaseInitiator: String?

                public var releaseReason: String?

                public var timestamp: Int64?

                public var userExtension: String?

                public var userId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.callType != nil {
                        map["CallType"] = self.callType!
                    }
                    if self.channelFlags != nil {
                        map["ChannelFlags"] = self.channelFlags!
                    }
                    if self.channelId != nil {
                        map["ChannelId"] = self.channelId!
                    }
                    if self.channelState != nil {
                        map["ChannelState"] = self.channelState!
                    }
                    if self.destination != nil {
                        map["Destination"] = self.destination!
                    }
                    if self.jobId != nil {
                        map["JobId"] = self.jobId!
                    }
                    if self.originator != nil {
                        map["Originator"] = self.originator!
                    }
                    if self.releaseInitiator != nil {
                        map["ReleaseInitiator"] = self.releaseInitiator!
                    }
                    if self.releaseReason != nil {
                        map["ReleaseReason"] = self.releaseReason!
                    }
                    if self.timestamp != nil {
                        map["Timestamp"] = self.timestamp!
                    }
                    if self.userExtension != nil {
                        map["UserExtension"] = self.userExtension!
                    }
                    if self.userId != nil {
                        map["UserId"] = self.userId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("CallType") && dict["CallType"] != nil {
                        self.callType = dict["CallType"] as! String
                    }
                    if dict.keys.contains("ChannelFlags") && dict["ChannelFlags"] != nil {
                        self.channelFlags = dict["ChannelFlags"] as! String
                    }
                    if dict.keys.contains("ChannelId") && dict["ChannelId"] != nil {
                        self.channelId = dict["ChannelId"] as! String
                    }
                    if dict.keys.contains("ChannelState") && dict["ChannelState"] != nil {
                        self.channelState = dict["ChannelState"] as! String
                    }
                    if dict.keys.contains("Destination") && dict["Destination"] != nil {
                        self.destination = dict["Destination"] as! String
                    }
                    if dict.keys.contains("JobId") && dict["JobId"] != nil {
                        self.jobId = dict["JobId"] as! String
                    }
                    if dict.keys.contains("Originator") && dict["Originator"] != nil {
                        self.originator = dict["Originator"] as! String
                    }
                    if dict.keys.contains("ReleaseInitiator") && dict["ReleaseInitiator"] != nil {
                        self.releaseInitiator = dict["ReleaseInitiator"] as! String
                    }
                    if dict.keys.contains("ReleaseReason") && dict["ReleaseReason"] != nil {
                        self.releaseReason = dict["ReleaseReason"] as! String
                    }
                    if dict.keys.contains("Timestamp") && dict["Timestamp"] != nil {
                        self.timestamp = dict["Timestamp"] as! Int64
                    }
                    if dict.keys.contains("UserExtension") && dict["UserExtension"] != nil {
                        self.userExtension = dict["UserExtension"] as! String
                    }
                    if dict.keys.contains("UserId") && dict["UserId"] != nil {
                        self.userId = dict["UserId"] as! String
                    }
                }
            }
            public var callType: String?

            public var channelContexts: [MakeCallResponseBody.Data.CallContext.ChannelContexts]?

            public var instanceId: String?

            public var jobId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.callType != nil {
                    map["CallType"] = self.callType!
                }
                if self.channelContexts != nil {
                    var tmp : [Any] = []
                    for k in self.channelContexts! {
                        tmp.append(k.toMap())
                    }
                    map["ChannelContexts"] = tmp
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.jobId != nil {
                    map["JobId"] = self.jobId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CallType") && dict["CallType"] != nil {
                    self.callType = dict["CallType"] as! String
                }
                if dict.keys.contains("ChannelContexts") && dict["ChannelContexts"] != nil {
                    var tmp : [MakeCallResponseBody.Data.CallContext.ChannelContexts] = []
                    for v in dict["ChannelContexts"] as! [Any] {
                        var model = MakeCallResponseBody.Data.CallContext.ChannelContexts()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.channelContexts = tmp
                }
                if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("JobId") && dict["JobId"] != nil {
                    self.jobId = dict["JobId"] as! String
                }
            }
        }
        public class UserContext : Tea.TeaModel {
            public var breakCode: String?

            public var deviceId: String?

            public var extension_: String?

            public var instanceId: String?

            public var jobId: String?

            public var outboundScenario: Bool?

            public var signedSkillGroupIdList: [String]?

            public var userId: String?

            public var userState: String?

            public var workMode: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.breakCode != nil {
                    map["BreakCode"] = self.breakCode!
                }
                if self.deviceId != nil {
                    map["DeviceId"] = self.deviceId!
                }
                if self.extension_ != nil {
                    map["Extension"] = self.extension_!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.jobId != nil {
                    map["JobId"] = self.jobId!
                }
                if self.outboundScenario != nil {
                    map["OutboundScenario"] = self.outboundScenario!
                }
                if self.signedSkillGroupIdList != nil {
                    map["SignedSkillGroupIdList"] = self.signedSkillGroupIdList!
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                if self.userState != nil {
                    map["UserState"] = self.userState!
                }
                if self.workMode != nil {
                    map["WorkMode"] = self.workMode!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BreakCode") && dict["BreakCode"] != nil {
                    self.breakCode = dict["BreakCode"] as! String
                }
                if dict.keys.contains("DeviceId") && dict["DeviceId"] != nil {
                    self.deviceId = dict["DeviceId"] as! String
                }
                if dict.keys.contains("Extension") && dict["Extension"] != nil {
                    self.extension_ = dict["Extension"] as! String
                }
                if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("JobId") && dict["JobId"] != nil {
                    self.jobId = dict["JobId"] as! String
                }
                if dict.keys.contains("OutboundScenario") && dict["OutboundScenario"] != nil {
                    self.outboundScenario = dict["OutboundScenario"] as! Bool
                }
                if dict.keys.contains("SignedSkillGroupIdList") && dict["SignedSkillGroupIdList"] != nil {
                    self.signedSkillGroupIdList = dict["SignedSkillGroupIdList"] as! [String]
                }
                if dict.keys.contains("UserId") && dict["UserId"] != nil {
                    self.userId = dict["UserId"] as! String
                }
                if dict.keys.contains("UserState") && dict["UserState"] != nil {
                    self.userState = dict["UserState"] as! String
                }
                if dict.keys.contains("WorkMode") && dict["WorkMode"] != nil {
                    self.workMode = dict["WorkMode"] as! String
                }
            }
        }
        public var callContext: MakeCallResponseBody.Data.CallContext?

        public var contextId: Int64?

        public var userContext: MakeCallResponseBody.Data.UserContext?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.callContext?.validate()
            try self.userContext?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.callContext != nil {
                map["CallContext"] = self.callContext?.toMap()
            }
            if self.contextId != nil {
                map["ContextId"] = self.contextId!
            }
            if self.userContext != nil {
                map["UserContext"] = self.userContext?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CallContext") && dict["CallContext"] != nil {
                var model = MakeCallResponseBody.Data.CallContext()
                model.fromMap(dict["CallContext"] as! [String: Any])
                self.callContext = model
            }
            if dict.keys.contains("ContextId") && dict["ContextId"] != nil {
                self.contextId = dict["ContextId"] as! Int64
            }
            if dict.keys.contains("UserContext") && dict["UserContext"] != nil {
                var model = MakeCallResponseBody.Data.UserContext()
                model.fromMap(dict["UserContext"] as! [String: Any])
                self.userContext = model
            }
        }
    }
    public var code: String?

    public var data: MakeCallResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var params: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.params != nil {
            map["Params"] = self.params!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = MakeCallResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Params") && dict["Params"] != nil {
            self.params = dict["Params"] as! [String]
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class MakeCallResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: MakeCallResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = MakeCallResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyAudioFileRequest : Tea.TeaModel {
    public var audioFileName: String?

    public var audioResourceId: String?

    public var instanceId: String?

    public var name: String?

    public var ossFileKey: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.audioFileName != nil {
            map["AudioFileName"] = self.audioFileName!
        }
        if self.audioResourceId != nil {
            map["AudioResourceId"] = self.audioResourceId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.ossFileKey != nil {
            map["OssFileKey"] = self.ossFileKey!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AudioFileName") && dict["AudioFileName"] != nil {
            self.audioFileName = dict["AudioFileName"] as! String
        }
        if dict.keys.contains("AudioResourceId") && dict["AudioResourceId"] != nil {
            self.audioResourceId = dict["AudioResourceId"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("OssFileKey") && dict["OssFileKey"] != nil {
            self.ossFileKey = dict["OssFileKey"] as! String
        }
    }
}

public class ModifyAudioFileResponseBody : Tea.TeaModel {
    public var code: String?

    public var data: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyAudioFileResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyAudioFileResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ModifyAudioFileResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyCustomCallTaggingRequest : Tea.TeaModel {
    public var callTagNameList: String?

    public var description_: String?

    public var instanceId: String?

    public var number: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.callTagNameList != nil {
            map["CallTagNameList"] = self.callTagNameList!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.number != nil {
            map["Number"] = self.number!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CallTagNameList") && dict["CallTagNameList"] != nil {
            self.callTagNameList = dict["CallTagNameList"] as! String
        }
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Number") && dict["Number"] != nil {
            self.number = dict["Number"] as! String
        }
    }
}

public class ModifyCustomCallTaggingResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyCustomCallTaggingResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyCustomCallTaggingResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ModifyCustomCallTaggingResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyInstanceRequest : Tea.TeaModel {
    public var description_: String?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
    }
}

public class ModifyInstanceResponseBody : Tea.TeaModel {
    public var code: String?

    public var data: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ModifyInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyPhoneNumberRequest : Tea.TeaModel {
    public var contactFlowId: String?

    public var instanceId: String?

    public var number: String?

    public var usage: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.contactFlowId != nil {
            map["ContactFlowId"] = self.contactFlowId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.number != nil {
            map["Number"] = self.number!
        }
        if self.usage != nil {
            map["Usage"] = self.usage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ContactFlowId") && dict["ContactFlowId"] != nil {
            self.contactFlowId = dict["ContactFlowId"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Number") && dict["Number"] != nil {
            self.number = dict["Number"] as! String
        }
        if dict.keys.contains("Usage") && dict["Usage"] != nil {
            self.usage = dict["Usage"] as! String
        }
    }
}

public class ModifyPhoneNumberResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyPhoneNumberResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyPhoneNumberResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ModifyPhoneNumberResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifySkillGroupRequest : Tea.TeaModel {
    public var description_: String?

    public var displayName: String?

    public var instanceId: String?

    public var skillGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.displayName != nil {
            map["DisplayName"] = self.displayName!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.skillGroupId != nil {
            map["SkillGroupId"] = self.skillGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("DisplayName") && dict["DisplayName"] != nil {
            self.displayName = dict["DisplayName"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("SkillGroupId") && dict["SkillGroupId"] != nil {
            self.skillGroupId = dict["SkillGroupId"] as! String
        }
    }
}

public class ModifySkillGroupResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifySkillGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifySkillGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ModifySkillGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifySkillLevelsOfUserRequest : Tea.TeaModel {
    public var instanceId: String?

    public var skillLevelList: String?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.skillLevelList != nil {
            map["SkillLevelList"] = self.skillLevelList!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("SkillLevelList") && dict["SkillLevelList"] != nil {
            self.skillLevelList = dict["SkillLevelList"] as! String
        }
        if dict.keys.contains("UserId") && dict["UserId"] != nil {
            self.userId = dict["UserId"] as! String
        }
    }
}

public class ModifySkillLevelsOfUserResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifySkillLevelsOfUserResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifySkillLevelsOfUserResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ModifySkillLevelsOfUserResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyUserRequest : Tea.TeaModel {
    public var displayId: String?

    public var displayName: String?

    public var force: Bool?

    public var instanceId: String?

    public var mobile: String?

    public var roleId: String?

    public var userId: String?

    public var workMode: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.displayId != nil {
            map["DisplayId"] = self.displayId!
        }
        if self.displayName != nil {
            map["DisplayName"] = self.displayName!
        }
        if self.force != nil {
            map["Force"] = self.force!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.mobile != nil {
            map["Mobile"] = self.mobile!
        }
        if self.roleId != nil {
            map["RoleId"] = self.roleId!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        if self.workMode != nil {
            map["WorkMode"] = self.workMode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DisplayId") && dict["DisplayId"] != nil {
            self.displayId = dict["DisplayId"] as! String
        }
        if dict.keys.contains("DisplayName") && dict["DisplayName"] != nil {
            self.displayName = dict["DisplayName"] as! String
        }
        if dict.keys.contains("Force") && dict["Force"] != nil {
            self.force = dict["Force"] as! Bool
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Mobile") && dict["Mobile"] != nil {
            self.mobile = dict["Mobile"] as! String
        }
        if dict.keys.contains("RoleId") && dict["RoleId"] != nil {
            self.roleId = dict["RoleId"] as! String
        }
        if dict.keys.contains("UserId") && dict["UserId"] != nil {
            self.userId = dict["UserId"] as! String
        }
        if dict.keys.contains("WorkMode") && dict["WorkMode"] != nil {
            self.workMode = dict["WorkMode"] as! String
        }
    }
}

public class ModifyUserResponseBody : Tea.TeaModel {
    public var code: String?

    public var data: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyUserResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyUserResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ModifyUserResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyUserLevelsOfSkillGroupRequest : Tea.TeaModel {
    public var instanceId: String?

    public var skillGroupId: String?

    public var userLevelList: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.skillGroupId != nil {
            map["SkillGroupId"] = self.skillGroupId!
        }
        if self.userLevelList != nil {
            map["UserLevelList"] = self.userLevelList!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("SkillGroupId") && dict["SkillGroupId"] != nil {
            self.skillGroupId = dict["SkillGroupId"] as! String
        }
        if dict.keys.contains("UserLevelList") && dict["UserLevelList"] != nil {
            self.userLevelList = dict["UserLevelList"] as! String
        }
    }
}

public class ModifyUserLevelsOfSkillGroupResponseBody : Tea.TeaModel {
    public var code: String?

    public var data: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyUserLevelsOfSkillGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyUserLevelsOfSkillGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ModifyUserLevelsOfSkillGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class MonitorCallRequest : Tea.TeaModel {
    public var deviceId: String?

    public var instanceId: String?

    public var monitoredUserId: String?

    public var timeoutSeconds: Int32?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.deviceId != nil {
            map["DeviceId"] = self.deviceId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.monitoredUserId != nil {
            map["MonitoredUserId"] = self.monitoredUserId!
        }
        if self.timeoutSeconds != nil {
            map["TimeoutSeconds"] = self.timeoutSeconds!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DeviceId") && dict["DeviceId"] != nil {
            self.deviceId = dict["DeviceId"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("MonitoredUserId") && dict["MonitoredUserId"] != nil {
            self.monitoredUserId = dict["MonitoredUserId"] as! String
        }
        if dict.keys.contains("TimeoutSeconds") && dict["TimeoutSeconds"] != nil {
            self.timeoutSeconds = dict["TimeoutSeconds"] as! Int32
        }
        if dict.keys.contains("UserId") && dict["UserId"] != nil {
            self.userId = dict["UserId"] as! String
        }
    }
}

public class MonitorCallResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class CallContext : Tea.TeaModel {
            public class ChannelContexts : Tea.TeaModel {
                public var callType: String?

                public var channelFlags: String?

                public var channelId: String?

                public var channelState: String?

                public var destination: String?

                public var index: Int32?

                public var jobId: String?

                public var originator: String?

                public var releaseInitiator: String?

                public var releaseReason: String?

                public var skillGroupId: String?

                public var timestamp: Int64?

                public var userExtension: String?

                public var userId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.callType != nil {
                        map["CallType"] = self.callType!
                    }
                    if self.channelFlags != nil {
                        map["ChannelFlags"] = self.channelFlags!
                    }
                    if self.channelId != nil {
                        map["ChannelId"] = self.channelId!
                    }
                    if self.channelState != nil {
                        map["ChannelState"] = self.channelState!
                    }
                    if self.destination != nil {
                        map["Destination"] = self.destination!
                    }
                    if self.index != nil {
                        map["Index"] = self.index!
                    }
                    if self.jobId != nil {
                        map["JobId"] = self.jobId!
                    }
                    if self.originator != nil {
                        map["Originator"] = self.originator!
                    }
                    if self.releaseInitiator != nil {
                        map["ReleaseInitiator"] = self.releaseInitiator!
                    }
                    if self.releaseReason != nil {
                        map["ReleaseReason"] = self.releaseReason!
                    }
                    if self.skillGroupId != nil {
                        map["SkillGroupId"] = self.skillGroupId!
                    }
                    if self.timestamp != nil {
                        map["Timestamp"] = self.timestamp!
                    }
                    if self.userExtension != nil {
                        map["UserExtension"] = self.userExtension!
                    }
                    if self.userId != nil {
                        map["UserId"] = self.userId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("CallType") && dict["CallType"] != nil {
                        self.callType = dict["CallType"] as! String
                    }
                    if dict.keys.contains("ChannelFlags") && dict["ChannelFlags"] != nil {
                        self.channelFlags = dict["ChannelFlags"] as! String
                    }
                    if dict.keys.contains("ChannelId") && dict["ChannelId"] != nil {
                        self.channelId = dict["ChannelId"] as! String
                    }
                    if dict.keys.contains("ChannelState") && dict["ChannelState"] != nil {
                        self.channelState = dict["ChannelState"] as! String
                    }
                    if dict.keys.contains("Destination") && dict["Destination"] != nil {
                        self.destination = dict["Destination"] as! String
                    }
                    if dict.keys.contains("Index") && dict["Index"] != nil {
                        self.index = dict["Index"] as! Int32
                    }
                    if dict.keys.contains("JobId") && dict["JobId"] != nil {
                        self.jobId = dict["JobId"] as! String
                    }
                    if dict.keys.contains("Originator") && dict["Originator"] != nil {
                        self.originator = dict["Originator"] as! String
                    }
                    if dict.keys.contains("ReleaseInitiator") && dict["ReleaseInitiator"] != nil {
                        self.releaseInitiator = dict["ReleaseInitiator"] as! String
                    }
                    if dict.keys.contains("ReleaseReason") && dict["ReleaseReason"] != nil {
                        self.releaseReason = dict["ReleaseReason"] as! String
                    }
                    if dict.keys.contains("SkillGroupId") && dict["SkillGroupId"] != nil {
                        self.skillGroupId = dict["SkillGroupId"] as! String
                    }
                    if dict.keys.contains("Timestamp") && dict["Timestamp"] != nil {
                        self.timestamp = dict["Timestamp"] as! Int64
                    }
                    if dict.keys.contains("UserExtension") && dict["UserExtension"] != nil {
                        self.userExtension = dict["UserExtension"] as! String
                    }
                    if dict.keys.contains("UserId") && dict["UserId"] != nil {
                        self.userId = dict["UserId"] as! String
                    }
                }
            }
            public var callType: String?

            public var channelContexts: [MonitorCallResponseBody.Data.CallContext.ChannelContexts]?

            public var instanceId: String?

            public var jobId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.callType != nil {
                    map["CallType"] = self.callType!
                }
                if self.channelContexts != nil {
                    var tmp : [Any] = []
                    for k in self.channelContexts! {
                        tmp.append(k.toMap())
                    }
                    map["ChannelContexts"] = tmp
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.jobId != nil {
                    map["JobId"] = self.jobId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CallType") && dict["CallType"] != nil {
                    self.callType = dict["CallType"] as! String
                }
                if dict.keys.contains("ChannelContexts") && dict["ChannelContexts"] != nil {
                    var tmp : [MonitorCallResponseBody.Data.CallContext.ChannelContexts] = []
                    for v in dict["ChannelContexts"] as! [Any] {
                        var model = MonitorCallResponseBody.Data.CallContext.ChannelContexts()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.channelContexts = tmp
                }
                if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("JobId") && dict["JobId"] != nil {
                    self.jobId = dict["JobId"] as! String
                }
            }
        }
        public class UserContext : Tea.TeaModel {
            public var breakCode: String?

            public var deviceId: String?

            public var extension_: String?

            public var heartbeat: Int64?

            public var instanceId: String?

            public var jobId: String?

            public var mobile: String?

            public var outboundScenario: Bool?

            public var reserved: Int64?

            public var signedSkillGroupIdList: [String]?

            public var userId: String?

            public var userState: String?

            public var workMode: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.breakCode != nil {
                    map["BreakCode"] = self.breakCode!
                }
                if self.deviceId != nil {
                    map["DeviceId"] = self.deviceId!
                }
                if self.extension_ != nil {
                    map["Extension"] = self.extension_!
                }
                if self.heartbeat != nil {
                    map["Heartbeat"] = self.heartbeat!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.jobId != nil {
                    map["JobId"] = self.jobId!
                }
                if self.mobile != nil {
                    map["Mobile"] = self.mobile!
                }
                if self.outboundScenario != nil {
                    map["OutboundScenario"] = self.outboundScenario!
                }
                if self.reserved != nil {
                    map["Reserved"] = self.reserved!
                }
                if self.signedSkillGroupIdList != nil {
                    map["SignedSkillGroupIdList"] = self.signedSkillGroupIdList!
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                if self.userState != nil {
                    map["UserState"] = self.userState!
                }
                if self.workMode != nil {
                    map["WorkMode"] = self.workMode!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BreakCode") && dict["BreakCode"] != nil {
                    self.breakCode = dict["BreakCode"] as! String
                }
                if dict.keys.contains("DeviceId") && dict["DeviceId"] != nil {
                    self.deviceId = dict["DeviceId"] as! String
                }
                if dict.keys.contains("Extension") && dict["Extension"] != nil {
                    self.extension_ = dict["Extension"] as! String
                }
                if dict.keys.contains("Heartbeat") && dict["Heartbeat"] != nil {
                    self.heartbeat = dict["Heartbeat"] as! Int64
                }
                if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("JobId") && dict["JobId"] != nil {
                    self.jobId = dict["JobId"] as! String
                }
                if dict.keys.contains("Mobile") && dict["Mobile"] != nil {
                    self.mobile = dict["Mobile"] as! String
                }
                if dict.keys.contains("OutboundScenario") && dict["OutboundScenario"] != nil {
                    self.outboundScenario = dict["OutboundScenario"] as! Bool
                }
                if dict.keys.contains("Reserved") && dict["Reserved"] != nil {
                    self.reserved = dict["Reserved"] as! Int64
                }
                if dict.keys.contains("SignedSkillGroupIdList") && dict["SignedSkillGroupIdList"] != nil {
                    self.signedSkillGroupIdList = dict["SignedSkillGroupIdList"] as! [String]
                }
                if dict.keys.contains("UserId") && dict["UserId"] != nil {
                    self.userId = dict["UserId"] as! String
                }
                if dict.keys.contains("UserState") && dict["UserState"] != nil {
                    self.userState = dict["UserState"] as! String
                }
                if dict.keys.contains("WorkMode") && dict["WorkMode"] != nil {
                    self.workMode = dict["WorkMode"] as! String
                }
            }
        }
        public var callContext: MonitorCallResponseBody.Data.CallContext?

        public var userContext: MonitorCallResponseBody.Data.UserContext?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.callContext?.validate()
            try self.userContext?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.callContext != nil {
                map["CallContext"] = self.callContext?.toMap()
            }
            if self.userContext != nil {
                map["UserContext"] = self.userContext?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CallContext") && dict["CallContext"] != nil {
                var model = MonitorCallResponseBody.Data.CallContext()
                model.fromMap(dict["CallContext"] as! [String: Any])
                self.callContext = model
            }
            if dict.keys.contains("UserContext") && dict["UserContext"] != nil {
                var model = MonitorCallResponseBody.Data.UserContext()
                model.fromMap(dict["UserContext"] as! [String: Any])
                self.userContext = model
            }
        }
    }
    public var code: String?

    public var data: MonitorCallResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var params: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.params != nil {
            map["Params"] = self.params!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = MonitorCallResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Params") && dict["Params"] != nil {
            self.params = dict["Params"] as! [String]
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class MonitorCallResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: MonitorCallResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = MonitorCallResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class MuteCallRequest : Tea.TeaModel {
    public var channelId: String?

    public var deviceId: String?

    public var instanceId: String?

    public var jobId: String?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.channelId != nil {
            map["ChannelId"] = self.channelId!
        }
        if self.deviceId != nil {
            map["DeviceId"] = self.deviceId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ChannelId") && dict["ChannelId"] != nil {
            self.channelId = dict["ChannelId"] as! String
        }
        if dict.keys.contains("DeviceId") && dict["DeviceId"] != nil {
            self.deviceId = dict["DeviceId"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("JobId") && dict["JobId"] != nil {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("UserId") && dict["UserId"] != nil {
            self.userId = dict["UserId"] as! String
        }
    }
}

public class MuteCallResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class CallContext : Tea.TeaModel {
            public class ChannelContexts : Tea.TeaModel {
                public var callType: String?

                public var channelFlags: String?

                public var channelId: String?

                public var channelState: String?

                public var destination: String?

                public var index: Int32?

                public var jobId: String?

                public var originator: String?

                public var releaseInitiator: String?

                public var releaseReason: String?

                public var timestamp: Int64?

                public var userExtension: String?

                public var userId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.callType != nil {
                        map["CallType"] = self.callType!
                    }
                    if self.channelFlags != nil {
                        map["ChannelFlags"] = self.channelFlags!
                    }
                    if self.channelId != nil {
                        map["ChannelId"] = self.channelId!
                    }
                    if self.channelState != nil {
                        map["ChannelState"] = self.channelState!
                    }
                    if self.destination != nil {
                        map["Destination"] = self.destination!
                    }
                    if self.index != nil {
                        map["Index"] = self.index!
                    }
                    if self.jobId != nil {
                        map["JobId"] = self.jobId!
                    }
                    if self.originator != nil {
                        map["Originator"] = self.originator!
                    }
                    if self.releaseInitiator != nil {
                        map["ReleaseInitiator"] = self.releaseInitiator!
                    }
                    if self.releaseReason != nil {
                        map["ReleaseReason"] = self.releaseReason!
                    }
                    if self.timestamp != nil {
                        map["Timestamp"] = self.timestamp!
                    }
                    if self.userExtension != nil {
                        map["UserExtension"] = self.userExtension!
                    }
                    if self.userId != nil {
                        map["UserId"] = self.userId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("CallType") && dict["CallType"] != nil {
                        self.callType = dict["CallType"] as! String
                    }
                    if dict.keys.contains("ChannelFlags") && dict["ChannelFlags"] != nil {
                        self.channelFlags = dict["ChannelFlags"] as! String
                    }
                    if dict.keys.contains("ChannelId") && dict["ChannelId"] != nil {
                        self.channelId = dict["ChannelId"] as! String
                    }
                    if dict.keys.contains("ChannelState") && dict["ChannelState"] != nil {
                        self.channelState = dict["ChannelState"] as! String
                    }
                    if dict.keys.contains("Destination") && dict["Destination"] != nil {
                        self.destination = dict["Destination"] as! String
                    }
                    if dict.keys.contains("Index") && dict["Index"] != nil {
                        self.index = dict["Index"] as! Int32
                    }
                    if dict.keys.contains("JobId") && dict["JobId"] != nil {
                        self.jobId = dict["JobId"] as! String
                    }
                    if dict.keys.contains("Originator") && dict["Originator"] != nil {
                        self.originator = dict["Originator"] as! String
                    }
                    if dict.keys.contains("ReleaseInitiator") && dict["ReleaseInitiator"] != nil {
                        self.releaseInitiator = dict["ReleaseInitiator"] as! String
                    }
                    if dict.keys.contains("ReleaseReason") && dict["ReleaseReason"] != nil {
                        self.releaseReason = dict["ReleaseReason"] as! String
                    }
                    if dict.keys.contains("Timestamp") && dict["Timestamp"] != nil {
                        self.timestamp = dict["Timestamp"] as! Int64
                    }
                    if dict.keys.contains("UserExtension") && dict["UserExtension"] != nil {
                        self.userExtension = dict["UserExtension"] as! String
                    }
                    if dict.keys.contains("UserId") && dict["UserId"] != nil {
                        self.userId = dict["UserId"] as! String
                    }
                }
            }
            public var callType: String?

            public var channelContexts: [MuteCallResponseBody.Data.CallContext.ChannelContexts]?

            public var instanceId: String?

            public var jobId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.callType != nil {
                    map["CallType"] = self.callType!
                }
                if self.channelContexts != nil {
                    var tmp : [Any] = []
                    for k in self.channelContexts! {
                        tmp.append(k.toMap())
                    }
                    map["ChannelContexts"] = tmp
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.jobId != nil {
                    map["JobId"] = self.jobId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CallType") && dict["CallType"] != nil {
                    self.callType = dict["CallType"] as! String
                }
                if dict.keys.contains("ChannelContexts") && dict["ChannelContexts"] != nil {
                    var tmp : [MuteCallResponseBody.Data.CallContext.ChannelContexts] = []
                    for v in dict["ChannelContexts"] as! [Any] {
                        var model = MuteCallResponseBody.Data.CallContext.ChannelContexts()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.channelContexts = tmp
                }
                if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("JobId") && dict["JobId"] != nil {
                    self.jobId = dict["JobId"] as! String
                }
            }
        }
        public class UserContext : Tea.TeaModel {
            public var breakCode: String?

            public var deviceId: String?

            public var extension_: String?

            public var heartbeat: Int64?

            public var instanceId: String?

            public var jobId: String?

            public var mobile: String?

            public var outboundScenario: Bool?

            public var reserved: Int64?

            public var signedSkillGroupIdList: [String]?

            public var userId: String?

            public var userState: String?

            public var workMode: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.breakCode != nil {
                    map["BreakCode"] = self.breakCode!
                }
                if self.deviceId != nil {
                    map["DeviceId"] = self.deviceId!
                }
                if self.extension_ != nil {
                    map["Extension"] = self.extension_!
                }
                if self.heartbeat != nil {
                    map["Heartbeat"] = self.heartbeat!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.jobId != nil {
                    map["JobId"] = self.jobId!
                }
                if self.mobile != nil {
                    map["Mobile"] = self.mobile!
                }
                if self.outboundScenario != nil {
                    map["OutboundScenario"] = self.outboundScenario!
                }
                if self.reserved != nil {
                    map["Reserved"] = self.reserved!
                }
                if self.signedSkillGroupIdList != nil {
                    map["SignedSkillGroupIdList"] = self.signedSkillGroupIdList!
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                if self.userState != nil {
                    map["UserState"] = self.userState!
                }
                if self.workMode != nil {
                    map["WorkMode"] = self.workMode!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BreakCode") && dict["BreakCode"] != nil {
                    self.breakCode = dict["BreakCode"] as! String
                }
                if dict.keys.contains("DeviceId") && dict["DeviceId"] != nil {
                    self.deviceId = dict["DeviceId"] as! String
                }
                if dict.keys.contains("Extension") && dict["Extension"] != nil {
                    self.extension_ = dict["Extension"] as! String
                }
                if dict.keys.contains("Heartbeat") && dict["Heartbeat"] != nil {
                    self.heartbeat = dict["Heartbeat"] as! Int64
                }
                if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("JobId") && dict["JobId"] != nil {
                    self.jobId = dict["JobId"] as! String
                }
                if dict.keys.contains("Mobile") && dict["Mobile"] != nil {
                    self.mobile = dict["Mobile"] as! String
                }
                if dict.keys.contains("OutboundScenario") && dict["OutboundScenario"] != nil {
                    self.outboundScenario = dict["OutboundScenario"] as! Bool
                }
                if dict.keys.contains("Reserved") && dict["Reserved"] != nil {
                    self.reserved = dict["Reserved"] as! Int64
                }
                if dict.keys.contains("SignedSkillGroupIdList") && dict["SignedSkillGroupIdList"] != nil {
                    self.signedSkillGroupIdList = dict["SignedSkillGroupIdList"] as! [String]
                }
                if dict.keys.contains("UserId") && dict["UserId"] != nil {
                    self.userId = dict["UserId"] as! String
                }
                if dict.keys.contains("UserState") && dict["UserState"] != nil {
                    self.userState = dict["UserState"] as! String
                }
                if dict.keys.contains("WorkMode") && dict["WorkMode"] != nil {
                    self.workMode = dict["WorkMode"] as! String
                }
            }
        }
        public var callContext: MuteCallResponseBody.Data.CallContext?

        public var userContext: MuteCallResponseBody.Data.UserContext?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.callContext?.validate()
            try self.userContext?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.callContext != nil {
                map["CallContext"] = self.callContext?.toMap()
            }
            if self.userContext != nil {
                map["UserContext"] = self.userContext?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CallContext") && dict["CallContext"] != nil {
                var model = MuteCallResponseBody.Data.CallContext()
                model.fromMap(dict["CallContext"] as! [String: Any])
                self.callContext = model
            }
            if dict.keys.contains("UserContext") && dict["UserContext"] != nil {
                var model = MuteCallResponseBody.Data.UserContext()
                model.fromMap(dict["UserContext"] as! [String: Any])
                self.userContext = model
            }
        }
    }
    public var code: String?

    public var data: MuteCallResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var params: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.params != nil {
            map["Params"] = self.params!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = MuteCallResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Params") && dict["Params"] != nil {
            self.params = dict["Params"] as! [String]
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class MuteCallResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: MuteCallResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = MuteCallResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class PauseCampaignRequest : Tea.TeaModel {
    public var campaignId: String?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.campaignId != nil {
            map["CampaignId"] = self.campaignId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CampaignId") && dict["CampaignId"] != nil {
            self.campaignId = dict["CampaignId"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
    }
}

public class PauseCampaignResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpStatusCode: String?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class PauseCampaignResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: PauseCampaignResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = PauseCampaignResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class PickOutboundNumbersRequest : Tea.TeaModel {
    public var calledNumber: String?

    public var count: Int32?

    public var instanceId: String?

    public var skillGroupIdList: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.calledNumber != nil {
            map["CalledNumber"] = self.calledNumber!
        }
        if self.count != nil {
            map["Count"] = self.count!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.skillGroupIdList != nil {
            map["SkillGroupIdList"] = self.skillGroupIdList!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CalledNumber") && dict["CalledNumber"] != nil {
            self.calledNumber = dict["CalledNumber"] as! String
        }
        if dict.keys.contains("Count") && dict["Count"] != nil {
            self.count = dict["Count"] as! Int32
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("SkillGroupIdList") && dict["SkillGroupIdList"] != nil {
            self.skillGroupIdList = dict["SkillGroupIdList"] as! String
        }
    }
}

public class PickOutboundNumbersResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class Callee : Tea.TeaModel {
            public var city: String?

            public var number: String?

            public var province: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.city != nil {
                    map["City"] = self.city!
                }
                if self.number != nil {
                    map["Number"] = self.number!
                }
                if self.province != nil {
                    map["Province"] = self.province!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("City") && dict["City"] != nil {
                    self.city = dict["City"] as! String
                }
                if dict.keys.contains("Number") && dict["Number"] != nil {
                    self.number = dict["Number"] as! String
                }
                if dict.keys.contains("Province") && dict["Province"] != nil {
                    self.province = dict["Province"] as! String
                }
            }
        }
        public class Caller : Tea.TeaModel {
            public var city: String?

            public var number: String?

            public var province: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.city != nil {
                    map["City"] = self.city!
                }
                if self.number != nil {
                    map["Number"] = self.number!
                }
                if self.province != nil {
                    map["Province"] = self.province!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("City") && dict["City"] != nil {
                    self.city = dict["City"] as! String
                }
                if dict.keys.contains("Number") && dict["Number"] != nil {
                    self.number = dict["Number"] as! String
                }
                if dict.keys.contains("Province") && dict["Province"] != nil {
                    self.province = dict["Province"] as! String
                }
            }
        }
        public var callee: PickOutboundNumbersResponseBody.Data.Callee?

        public var caller: PickOutboundNumbersResponseBody.Data.Caller?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.callee?.validate()
            try self.caller?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.callee != nil {
                map["Callee"] = self.callee?.toMap()
            }
            if self.caller != nil {
                map["Caller"] = self.caller?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Callee") && dict["Callee"] != nil {
                var model = PickOutboundNumbersResponseBody.Data.Callee()
                model.fromMap(dict["Callee"] as! [String: Any])
                self.callee = model
            }
            if dict.keys.contains("Caller") && dict["Caller"] != nil {
                var model = PickOutboundNumbersResponseBody.Data.Caller()
                model.fromMap(dict["Caller"] as! [String: Any])
                self.caller = model
            }
        }
    }
    public var code: String?

    public var data: [PickOutboundNumbersResponseBody.Data]?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var tmp : [PickOutboundNumbersResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = PickOutboundNumbersResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class PickOutboundNumbersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: PickOutboundNumbersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = PickOutboundNumbersResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class PollUserStatusRequest : Tea.TeaModel {
    public var deviceId: String?

    public var instanceId: String?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.deviceId != nil {
            map["DeviceId"] = self.deviceId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DeviceId") && dict["DeviceId"] != nil {
            self.deviceId = dict["DeviceId"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("UserId") && dict["UserId"] != nil {
            self.userId = dict["UserId"] as! String
        }
    }
}

public class PollUserStatusResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class CallContext : Tea.TeaModel {
            public class ChannelContexts : Tea.TeaModel {
                public var callType: String?

                public var channelFlags: String?

                public var channelId: String?

                public var channelState: String?

                public var channelVariables: String?

                public var destination: String?

                public var index: Int32?

                public var jobId: String?

                public var originator: String?

                public var releaseInitiator: String?

                public var releaseReason: String?

                public var skillGroupId: String?

                public var timestamp: Int64?

                public var userExtension: String?

                public var userId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.callType != nil {
                        map["CallType"] = self.callType!
                    }
                    if self.channelFlags != nil {
                        map["ChannelFlags"] = self.channelFlags!
                    }
                    if self.channelId != nil {
                        map["ChannelId"] = self.channelId!
                    }
                    if self.channelState != nil {
                        map["ChannelState"] = self.channelState!
                    }
                    if self.channelVariables != nil {
                        map["ChannelVariables"] = self.channelVariables!
                    }
                    if self.destination != nil {
                        map["Destination"] = self.destination!
                    }
                    if self.index != nil {
                        map["Index"] = self.index!
                    }
                    if self.jobId != nil {
                        map["JobId"] = self.jobId!
                    }
                    if self.originator != nil {
                        map["Originator"] = self.originator!
                    }
                    if self.releaseInitiator != nil {
                        map["ReleaseInitiator"] = self.releaseInitiator!
                    }
                    if self.releaseReason != nil {
                        map["ReleaseReason"] = self.releaseReason!
                    }
                    if self.skillGroupId != nil {
                        map["SkillGroupId"] = self.skillGroupId!
                    }
                    if self.timestamp != nil {
                        map["Timestamp"] = self.timestamp!
                    }
                    if self.userExtension != nil {
                        map["UserExtension"] = self.userExtension!
                    }
                    if self.userId != nil {
                        map["UserId"] = self.userId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("CallType") && dict["CallType"] != nil {
                        self.callType = dict["CallType"] as! String
                    }
                    if dict.keys.contains("ChannelFlags") && dict["ChannelFlags"] != nil {
                        self.channelFlags = dict["ChannelFlags"] as! String
                    }
                    if dict.keys.contains("ChannelId") && dict["ChannelId"] != nil {
                        self.channelId = dict["ChannelId"] as! String
                    }
                    if dict.keys.contains("ChannelState") && dict["ChannelState"] != nil {
                        self.channelState = dict["ChannelState"] as! String
                    }
                    if dict.keys.contains("ChannelVariables") && dict["ChannelVariables"] != nil {
                        self.channelVariables = dict["ChannelVariables"] as! String
                    }
                    if dict.keys.contains("Destination") && dict["Destination"] != nil {
                        self.destination = dict["Destination"] as! String
                    }
                    if dict.keys.contains("Index") && dict["Index"] != nil {
                        self.index = dict["Index"] as! Int32
                    }
                    if dict.keys.contains("JobId") && dict["JobId"] != nil {
                        self.jobId = dict["JobId"] as! String
                    }
                    if dict.keys.contains("Originator") && dict["Originator"] != nil {
                        self.originator = dict["Originator"] as! String
                    }
                    if dict.keys.contains("ReleaseInitiator") && dict["ReleaseInitiator"] != nil {
                        self.releaseInitiator = dict["ReleaseInitiator"] as! String
                    }
                    if dict.keys.contains("ReleaseReason") && dict["ReleaseReason"] != nil {
                        self.releaseReason = dict["ReleaseReason"] as! String
                    }
                    if dict.keys.contains("SkillGroupId") && dict["SkillGroupId"] != nil {
                        self.skillGroupId = dict["SkillGroupId"] as! String
                    }
                    if dict.keys.contains("Timestamp") && dict["Timestamp"] != nil {
                        self.timestamp = dict["Timestamp"] as! Int64
                    }
                    if dict.keys.contains("UserExtension") && dict["UserExtension"] != nil {
                        self.userExtension = dict["UserExtension"] as! String
                    }
                    if dict.keys.contains("UserId") && dict["UserId"] != nil {
                        self.userId = dict["UserId"] as! String
                    }
                }
            }
            public var callType: String?

            public var callVariables: String?

            public var channelContexts: [PollUserStatusResponseBody.Data.CallContext.ChannelContexts]?

            public var instanceId: String?

            public var jobId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.callType != nil {
                    map["CallType"] = self.callType!
                }
                if self.callVariables != nil {
                    map["CallVariables"] = self.callVariables!
                }
                if self.channelContexts != nil {
                    var tmp : [Any] = []
                    for k in self.channelContexts! {
                        tmp.append(k.toMap())
                    }
                    map["ChannelContexts"] = tmp
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.jobId != nil {
                    map["JobId"] = self.jobId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CallType") && dict["CallType"] != nil {
                    self.callType = dict["CallType"] as! String
                }
                if dict.keys.contains("CallVariables") && dict["CallVariables"] != nil {
                    self.callVariables = dict["CallVariables"] as! String
                }
                if dict.keys.contains("ChannelContexts") && dict["ChannelContexts"] != nil {
                    var tmp : [PollUserStatusResponseBody.Data.CallContext.ChannelContexts] = []
                    for v in dict["ChannelContexts"] as! [Any] {
                        var model = PollUserStatusResponseBody.Data.CallContext.ChannelContexts()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.channelContexts = tmp
                }
                if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("JobId") && dict["JobId"] != nil {
                    self.jobId = dict["JobId"] as! String
                }
            }
        }
        public class UserContext : Tea.TeaModel {
            public var breakCode: String?

            public var deviceId: String?

            public var extension_: String?

            public var heartbeat: Int64?

            public var instanceId: String?

            public var jobId: String?

            public var mobile: String?

            public var outboundScenario: Bool?

            public var reserved: Int64?

            public var signedSkillGroupIdList: [String]?

            public var userId: String?

            public var userState: String?

            public var workMode: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.breakCode != nil {
                    map["BreakCode"] = self.breakCode!
                }
                if self.deviceId != nil {
                    map["DeviceId"] = self.deviceId!
                }
                if self.extension_ != nil {
                    map["Extension"] = self.extension_!
                }
                if self.heartbeat != nil {
                    map["Heartbeat"] = self.heartbeat!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.jobId != nil {
                    map["JobId"] = self.jobId!
                }
                if self.mobile != nil {
                    map["Mobile"] = self.mobile!
                }
                if self.outboundScenario != nil {
                    map["OutboundScenario"] = self.outboundScenario!
                }
                if self.reserved != nil {
                    map["Reserved"] = self.reserved!
                }
                if self.signedSkillGroupIdList != nil {
                    map["SignedSkillGroupIdList"] = self.signedSkillGroupIdList!
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                if self.userState != nil {
                    map["UserState"] = self.userState!
                }
                if self.workMode != nil {
                    map["WorkMode"] = self.workMode!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BreakCode") && dict["BreakCode"] != nil {
                    self.breakCode = dict["BreakCode"] as! String
                }
                if dict.keys.contains("DeviceId") && dict["DeviceId"] != nil {
                    self.deviceId = dict["DeviceId"] as! String
                }
                if dict.keys.contains("Extension") && dict["Extension"] != nil {
                    self.extension_ = dict["Extension"] as! String
                }
                if dict.keys.contains("Heartbeat") && dict["Heartbeat"] != nil {
                    self.heartbeat = dict["Heartbeat"] as! Int64
                }
                if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("JobId") && dict["JobId"] != nil {
                    self.jobId = dict["JobId"] as! String
                }
                if dict.keys.contains("Mobile") && dict["Mobile"] != nil {
                    self.mobile = dict["Mobile"] as! String
                }
                if dict.keys.contains("OutboundScenario") && dict["OutboundScenario"] != nil {
                    self.outboundScenario = dict["OutboundScenario"] as! Bool
                }
                if dict.keys.contains("Reserved") && dict["Reserved"] != nil {
                    self.reserved = dict["Reserved"] as! Int64
                }
                if dict.keys.contains("SignedSkillGroupIdList") && dict["SignedSkillGroupIdList"] != nil {
                    self.signedSkillGroupIdList = dict["SignedSkillGroupIdList"] as! [String]
                }
                if dict.keys.contains("UserId") && dict["UserId"] != nil {
                    self.userId = dict["UserId"] as! String
                }
                if dict.keys.contains("UserState") && dict["UserState"] != nil {
                    self.userState = dict["UserState"] as! String
                }
                if dict.keys.contains("WorkMode") && dict["WorkMode"] != nil {
                    self.workMode = dict["WorkMode"] as! String
                }
            }
        }
        public var callContext: PollUserStatusResponseBody.Data.CallContext?

        public var contextId: Int64?

        public var userContext: PollUserStatusResponseBody.Data.UserContext?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.callContext?.validate()
            try self.userContext?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.callContext != nil {
                map["CallContext"] = self.callContext?.toMap()
            }
            if self.contextId != nil {
                map["ContextId"] = self.contextId!
            }
            if self.userContext != nil {
                map["UserContext"] = self.userContext?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CallContext") && dict["CallContext"] != nil {
                var model = PollUserStatusResponseBody.Data.CallContext()
                model.fromMap(dict["CallContext"] as! [String: Any])
                self.callContext = model
            }
            if dict.keys.contains("ContextId") && dict["ContextId"] != nil {
                self.contextId = dict["ContextId"] as! Int64
            }
            if dict.keys.contains("UserContext") && dict["UserContext"] != nil {
                var model = PollUserStatusResponseBody.Data.UserContext()
                model.fromMap(dict["UserContext"] as! [String: Any])
                self.userContext = model
            }
        }
    }
    public var code: String?

    public var data: PollUserStatusResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var params: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.params != nil {
            map["Params"] = self.params!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = PollUserStatusResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Params") && dict["Params"] != nil {
            self.params = dict["Params"] as! [String]
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class PollUserStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: PollUserStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = PollUserStatusResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class PublishContactFlowRequest : Tea.TeaModel {
    public var contactFlowId: String?

    public var draftId: String?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.contactFlowId != nil {
            map["ContactFlowId"] = self.contactFlowId!
        }
        if self.draftId != nil {
            map["DraftId"] = self.draftId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ContactFlowId") && dict["ContactFlowId"] != nil {
            self.contactFlowId = dict["ContactFlowId"] as! String
        }
        if dict.keys.contains("DraftId") && dict["DraftId"] != nil {
            self.draftId = dict["DraftId"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
    }
}

public class PublishContactFlowResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class PublishContactFlowResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: PublishContactFlowResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = PublishContactFlowResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ReadyForServiceRequest : Tea.TeaModel {
    public var deviceId: String?

    public var instanceId: String?

    public var outboundScenario: Bool?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.deviceId != nil {
            map["DeviceId"] = self.deviceId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.outboundScenario != nil {
            map["OutboundScenario"] = self.outboundScenario!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DeviceId") && dict["DeviceId"] != nil {
            self.deviceId = dict["DeviceId"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("OutboundScenario") && dict["OutboundScenario"] != nil {
            self.outboundScenario = dict["OutboundScenario"] as! Bool
        }
        if dict.keys.contains("UserId") && dict["UserId"] != nil {
            self.userId = dict["UserId"] as! String
        }
    }
}

public class ReadyForServiceResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var breakCode: String?

        public var deviceId: String?

        public var extension_: String?

        public var instanceId: String?

        public var jobId: String?

        public var outboundScenario: Bool?

        public var signedSkillGroupIdList: [String]?

        public var userId: String?

        public var userState: String?

        public var workMode: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.breakCode != nil {
                map["BreakCode"] = self.breakCode!
            }
            if self.deviceId != nil {
                map["DeviceId"] = self.deviceId!
            }
            if self.extension_ != nil {
                map["Extension"] = self.extension_!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            if self.outboundScenario != nil {
                map["OutboundScenario"] = self.outboundScenario!
            }
            if self.signedSkillGroupIdList != nil {
                map["SignedSkillGroupIdList"] = self.signedSkillGroupIdList!
            }
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            if self.userState != nil {
                map["UserState"] = self.userState!
            }
            if self.workMode != nil {
                map["WorkMode"] = self.workMode!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BreakCode") && dict["BreakCode"] != nil {
                self.breakCode = dict["BreakCode"] as! String
            }
            if dict.keys.contains("DeviceId") && dict["DeviceId"] != nil {
                self.deviceId = dict["DeviceId"] as! String
            }
            if dict.keys.contains("Extension") && dict["Extension"] != nil {
                self.extension_ = dict["Extension"] as! String
            }
            if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("JobId") && dict["JobId"] != nil {
                self.jobId = dict["JobId"] as! String
            }
            if dict.keys.contains("OutboundScenario") && dict["OutboundScenario"] != nil {
                self.outboundScenario = dict["OutboundScenario"] as! Bool
            }
            if dict.keys.contains("SignedSkillGroupIdList") && dict["SignedSkillGroupIdList"] != nil {
                self.signedSkillGroupIdList = dict["SignedSkillGroupIdList"] as! [String]
            }
            if dict.keys.contains("UserId") && dict["UserId"] != nil {
                self.userId = dict["UserId"] as! String
            }
            if dict.keys.contains("UserState") && dict["UserState"] != nil {
                self.userState = dict["UserState"] as! String
            }
            if dict.keys.contains("WorkMode") && dict["WorkMode"] != nil {
                self.workMode = dict["WorkMode"] as! String
            }
        }
    }
    public var code: String?

    public var data: ReadyForServiceResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var params: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.params != nil {
            map["Params"] = self.params!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = ReadyForServiceResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Params") && dict["Params"] != nil {
            self.params = dict["Params"] as! [String]
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ReadyForServiceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ReadyForServiceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ReadyForServiceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RedialCallRequest : Tea.TeaModel {
    public var callee: String?

    public var caller: String?

    public var deviceId: String?

    public var instanceId: String?

    public var jobId: String?

    public var tags: String?

    public var timeoutSeconds: Int32?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.callee != nil {
            map["Callee"] = self.callee!
        }
        if self.caller != nil {
            map["Caller"] = self.caller!
        }
        if self.deviceId != nil {
            map["DeviceId"] = self.deviceId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.tags != nil {
            map["Tags"] = self.tags!
        }
        if self.timeoutSeconds != nil {
            map["TimeoutSeconds"] = self.timeoutSeconds!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Callee") && dict["Callee"] != nil {
            self.callee = dict["Callee"] as! String
        }
        if dict.keys.contains("Caller") && dict["Caller"] != nil {
            self.caller = dict["Caller"] as! String
        }
        if dict.keys.contains("DeviceId") && dict["DeviceId"] != nil {
            self.deviceId = dict["DeviceId"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("JobId") && dict["JobId"] != nil {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("Tags") && dict["Tags"] != nil {
            self.tags = dict["Tags"] as! String
        }
        if dict.keys.contains("TimeoutSeconds") && dict["TimeoutSeconds"] != nil {
            self.timeoutSeconds = dict["TimeoutSeconds"] as! Int32
        }
        if dict.keys.contains("UserId") && dict["UserId"] != nil {
            self.userId = dict["UserId"] as! String
        }
    }
}

public class RedialCallResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class CallContext : Tea.TeaModel {
            public class ChannelContexts : Tea.TeaModel {
                public var callType: String?

                public var channelFlags: String?

                public var channelId: String?

                public var channelState: String?

                public var destination: String?

                public var jobId: String?

                public var originator: String?

                public var releaseInitiator: String?

                public var releaseReason: String?

                public var timestamp: Int64?

                public var userExtension: String?

                public var userId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.callType != nil {
                        map["CallType"] = self.callType!
                    }
                    if self.channelFlags != nil {
                        map["ChannelFlags"] = self.channelFlags!
                    }
                    if self.channelId != nil {
                        map["ChannelId"] = self.channelId!
                    }
                    if self.channelState != nil {
                        map["ChannelState"] = self.channelState!
                    }
                    if self.destination != nil {
                        map["Destination"] = self.destination!
                    }
                    if self.jobId != nil {
                        map["JobId"] = self.jobId!
                    }
                    if self.originator != nil {
                        map["Originator"] = self.originator!
                    }
                    if self.releaseInitiator != nil {
                        map["ReleaseInitiator"] = self.releaseInitiator!
                    }
                    if self.releaseReason != nil {
                        map["ReleaseReason"] = self.releaseReason!
                    }
                    if self.timestamp != nil {
                        map["Timestamp"] = self.timestamp!
                    }
                    if self.userExtension != nil {
                        map["UserExtension"] = self.userExtension!
                    }
                    if self.userId != nil {
                        map["UserId"] = self.userId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("CallType") && dict["CallType"] != nil {
                        self.callType = dict["CallType"] as! String
                    }
                    if dict.keys.contains("ChannelFlags") && dict["ChannelFlags"] != nil {
                        self.channelFlags = dict["ChannelFlags"] as! String
                    }
                    if dict.keys.contains("ChannelId") && dict["ChannelId"] != nil {
                        self.channelId = dict["ChannelId"] as! String
                    }
                    if dict.keys.contains("ChannelState") && dict["ChannelState"] != nil {
                        self.channelState = dict["ChannelState"] as! String
                    }
                    if dict.keys.contains("Destination") && dict["Destination"] != nil {
                        self.destination = dict["Destination"] as! String
                    }
                    if dict.keys.contains("JobId") && dict["JobId"] != nil {
                        self.jobId = dict["JobId"] as! String
                    }
                    if dict.keys.contains("Originator") && dict["Originator"] != nil {
                        self.originator = dict["Originator"] as! String
                    }
                    if dict.keys.contains("ReleaseInitiator") && dict["ReleaseInitiator"] != nil {
                        self.releaseInitiator = dict["ReleaseInitiator"] as! String
                    }
                    if dict.keys.contains("ReleaseReason") && dict["ReleaseReason"] != nil {
                        self.releaseReason = dict["ReleaseReason"] as! String
                    }
                    if dict.keys.contains("Timestamp") && dict["Timestamp"] != nil {
                        self.timestamp = dict["Timestamp"] as! Int64
                    }
                    if dict.keys.contains("UserExtension") && dict["UserExtension"] != nil {
                        self.userExtension = dict["UserExtension"] as! String
                    }
                    if dict.keys.contains("UserId") && dict["UserId"] != nil {
                        self.userId = dict["UserId"] as! String
                    }
                }
            }
            public var callType: String?

            public var channelContexts: [RedialCallResponseBody.Data.CallContext.ChannelContexts]?

            public var instanceId: String?

            public var jobId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.callType != nil {
                    map["CallType"] = self.callType!
                }
                if self.channelContexts != nil {
                    var tmp : [Any] = []
                    for k in self.channelContexts! {
                        tmp.append(k.toMap())
                    }
                    map["ChannelContexts"] = tmp
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.jobId != nil {
                    map["JobId"] = self.jobId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CallType") && dict["CallType"] != nil {
                    self.callType = dict["CallType"] as! String
                }
                if dict.keys.contains("ChannelContexts") && dict["ChannelContexts"] != nil {
                    var tmp : [RedialCallResponseBody.Data.CallContext.ChannelContexts] = []
                    for v in dict["ChannelContexts"] as! [Any] {
                        var model = RedialCallResponseBody.Data.CallContext.ChannelContexts()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.channelContexts = tmp
                }
                if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("JobId") && dict["JobId"] != nil {
                    self.jobId = dict["JobId"] as! String
                }
            }
        }
        public class UserContext : Tea.TeaModel {
            public var breakCode: String?

            public var deviceId: String?

            public var extension_: String?

            public var instanceId: String?

            public var jobId: String?

            public var outboundScenario: Bool?

            public var signedSkillGroupIdList: [String]?

            public var userId: String?

            public var userState: String?

            public var workMode: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.breakCode != nil {
                    map["BreakCode"] = self.breakCode!
                }
                if self.deviceId != nil {
                    map["DeviceId"] = self.deviceId!
                }
                if self.extension_ != nil {
                    map["Extension"] = self.extension_!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.jobId != nil {
                    map["JobId"] = self.jobId!
                }
                if self.outboundScenario != nil {
                    map["OutboundScenario"] = self.outboundScenario!
                }
                if self.signedSkillGroupIdList != nil {
                    map["SignedSkillGroupIdList"] = self.signedSkillGroupIdList!
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                if self.userState != nil {
                    map["UserState"] = self.userState!
                }
                if self.workMode != nil {
                    map["WorkMode"] = self.workMode!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BreakCode") && dict["BreakCode"] != nil {
                    self.breakCode = dict["BreakCode"] as! String
                }
                if dict.keys.contains("DeviceId") && dict["DeviceId"] != nil {
                    self.deviceId = dict["DeviceId"] as! String
                }
                if dict.keys.contains("Extension") && dict["Extension"] != nil {
                    self.extension_ = dict["Extension"] as! String
                }
                if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("JobId") && dict["JobId"] != nil {
                    self.jobId = dict["JobId"] as! String
                }
                if dict.keys.contains("OutboundScenario") && dict["OutboundScenario"] != nil {
                    self.outboundScenario = dict["OutboundScenario"] as! Bool
                }
                if dict.keys.contains("SignedSkillGroupIdList") && dict["SignedSkillGroupIdList"] != nil {
                    self.signedSkillGroupIdList = dict["SignedSkillGroupIdList"] as! [String]
                }
                if dict.keys.contains("UserId") && dict["UserId"] != nil {
                    self.userId = dict["UserId"] as! String
                }
                if dict.keys.contains("UserState") && dict["UserState"] != nil {
                    self.userState = dict["UserState"] as! String
                }
                if dict.keys.contains("WorkMode") && dict["WorkMode"] != nil {
                    self.workMode = dict["WorkMode"] as! String
                }
            }
        }
        public var callContext: RedialCallResponseBody.Data.CallContext?

        public var contextId: Int64?

        public var userContext: RedialCallResponseBody.Data.UserContext?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.callContext?.validate()
            try self.userContext?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.callContext != nil {
                map["CallContext"] = self.callContext?.toMap()
            }
            if self.contextId != nil {
                map["ContextId"] = self.contextId!
            }
            if self.userContext != nil {
                map["UserContext"] = self.userContext?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CallContext") && dict["CallContext"] != nil {
                var model = RedialCallResponseBody.Data.CallContext()
                model.fromMap(dict["CallContext"] as! [String: Any])
                self.callContext = model
            }
            if dict.keys.contains("ContextId") && dict["ContextId"] != nil {
                self.contextId = dict["ContextId"] as! Int64
            }
            if dict.keys.contains("UserContext") && dict["UserContext"] != nil {
                var model = RedialCallResponseBody.Data.UserContext()
                model.fromMap(dict["UserContext"] as! [String: Any])
                self.userContext = model
            }
        }
    }
    public var code: String?

    public var data: RedialCallResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var params: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.params != nil {
            map["Params"] = self.params!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = RedialCallResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Params") && dict["Params"] != nil {
            self.params = dict["Params"] as! [String]
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class RedialCallResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RedialCallResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = RedialCallResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RegisterDeviceRequest : Tea.TeaModel {
    public var deviceId: String?

    public var instanceId: String?

    public var password: String?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.deviceId != nil {
            map["DeviceId"] = self.deviceId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.password != nil {
            map["Password"] = self.password!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DeviceId") && dict["DeviceId"] != nil {
            self.deviceId = dict["DeviceId"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Password") && dict["Password"] != nil {
            self.password = dict["Password"] as! String
        }
        if dict.keys.contains("UserId") && dict["UserId"] != nil {
            self.userId = dict["UserId"] as! String
        }
    }
}

public class RegisterDeviceResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var params: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.params != nil {
            map["Params"] = self.params!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Params") && dict["Params"] != nil {
            self.params = dict["Params"] as! [String]
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class RegisterDeviceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RegisterDeviceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = RegisterDeviceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RegisterDevicesRequest : Tea.TeaModel {
    public var deviceId: String?

    public var instanceId: String?

    public var password: String?

    public var userIdListJson: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.deviceId != nil {
            map["DeviceId"] = self.deviceId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.password != nil {
            map["Password"] = self.password!
        }
        if self.userIdListJson != nil {
            map["UserIdListJson"] = self.userIdListJson!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DeviceId") && dict["DeviceId"] != nil {
            self.deviceId = dict["DeviceId"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Password") && dict["Password"] != nil {
            self.password = dict["Password"] as! String
        }
        if dict.keys.contains("UserIdListJson") && dict["UserIdListJson"] != nil {
            self.userIdListJson = dict["UserIdListJson"] as! String
        }
    }
}

public class RegisterDevicesResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var params: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.params != nil {
            map["Params"] = self.params!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Params") && dict["Params"] != nil {
            self.params = dict["Params"] as! [String]
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class RegisterDevicesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RegisterDevicesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = RegisterDevicesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ReleaseCallRequest : Tea.TeaModel {
    public var channelId: String?

    public var deviceId: String?

    public var instanceId: String?

    public var jobId: String?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.channelId != nil {
            map["ChannelId"] = self.channelId!
        }
        if self.deviceId != nil {
            map["DeviceId"] = self.deviceId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ChannelId") && dict["ChannelId"] != nil {
            self.channelId = dict["ChannelId"] as! String
        }
        if dict.keys.contains("DeviceId") && dict["DeviceId"] != nil {
            self.deviceId = dict["DeviceId"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("JobId") && dict["JobId"] != nil {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("UserId") && dict["UserId"] != nil {
            self.userId = dict["UserId"] as! String
        }
    }
}

public class ReleaseCallResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class CallContext : Tea.TeaModel {
            public class ChannelContexts : Tea.TeaModel {
                public var callType: String?

                public var channelId: String?

                public var channelState: String?

                public var destination: String?

                public var jobId: String?

                public var originator: String?

                public var releaseInitiator: String?

                public var releaseReason: String?

                public var timestamp: Int64?

                public var userExtension: String?

                public var userId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.callType != nil {
                        map["CallType"] = self.callType!
                    }
                    if self.channelId != nil {
                        map["ChannelId"] = self.channelId!
                    }
                    if self.channelState != nil {
                        map["ChannelState"] = self.channelState!
                    }
                    if self.destination != nil {
                        map["Destination"] = self.destination!
                    }
                    if self.jobId != nil {
                        map["JobId"] = self.jobId!
                    }
                    if self.originator != nil {
                        map["Originator"] = self.originator!
                    }
                    if self.releaseInitiator != nil {
                        map["ReleaseInitiator"] = self.releaseInitiator!
                    }
                    if self.releaseReason != nil {
                        map["ReleaseReason"] = self.releaseReason!
                    }
                    if self.timestamp != nil {
                        map["Timestamp"] = self.timestamp!
                    }
                    if self.userExtension != nil {
                        map["UserExtension"] = self.userExtension!
                    }
                    if self.userId != nil {
                        map["UserId"] = self.userId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("CallType") && dict["CallType"] != nil {
                        self.callType = dict["CallType"] as! String
                    }
                    if dict.keys.contains("ChannelId") && dict["ChannelId"] != nil {
                        self.channelId = dict["ChannelId"] as! String
                    }
                    if dict.keys.contains("ChannelState") && dict["ChannelState"] != nil {
                        self.channelState = dict["ChannelState"] as! String
                    }
                    if dict.keys.contains("Destination") && dict["Destination"] != nil {
                        self.destination = dict["Destination"] as! String
                    }
                    if dict.keys.contains("JobId") && dict["JobId"] != nil {
                        self.jobId = dict["JobId"] as! String
                    }
                    if dict.keys.contains("Originator") && dict["Originator"] != nil {
                        self.originator = dict["Originator"] as! String
                    }
                    if dict.keys.contains("ReleaseInitiator") && dict["ReleaseInitiator"] != nil {
                        self.releaseInitiator = dict["ReleaseInitiator"] as! String
                    }
                    if dict.keys.contains("ReleaseReason") && dict["ReleaseReason"] != nil {
                        self.releaseReason = dict["ReleaseReason"] as! String
                    }
                    if dict.keys.contains("Timestamp") && dict["Timestamp"] != nil {
                        self.timestamp = dict["Timestamp"] as! Int64
                    }
                    if dict.keys.contains("UserExtension") && dict["UserExtension"] != nil {
                        self.userExtension = dict["UserExtension"] as! String
                    }
                    if dict.keys.contains("UserId") && dict["UserId"] != nil {
                        self.userId = dict["UserId"] as! String
                    }
                }
            }
            public var channelContexts: [ReleaseCallResponseBody.Data.CallContext.ChannelContexts]?

            public var instanceId: String?

            public var jobId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.channelContexts != nil {
                    var tmp : [Any] = []
                    for k in self.channelContexts! {
                        tmp.append(k.toMap())
                    }
                    map["ChannelContexts"] = tmp
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.jobId != nil {
                    map["JobId"] = self.jobId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ChannelContexts") && dict["ChannelContexts"] != nil {
                    var tmp : [ReleaseCallResponseBody.Data.CallContext.ChannelContexts] = []
                    for v in dict["ChannelContexts"] as! [Any] {
                        var model = ReleaseCallResponseBody.Data.CallContext.ChannelContexts()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.channelContexts = tmp
                }
                if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("JobId") && dict["JobId"] != nil {
                    self.jobId = dict["JobId"] as! String
                }
            }
        }
        public class UserContext : Tea.TeaModel {
            public var breakCode: String?

            public var deviceId: String?

            public var extension_: String?

            public var instanceId: String?

            public var jobId: String?

            public var outboundScenario: Bool?

            public var signedSkillGroupIdList: [String]?

            public var userId: String?

            public var userState: String?

            public var workMode: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.breakCode != nil {
                    map["BreakCode"] = self.breakCode!
                }
                if self.deviceId != nil {
                    map["DeviceId"] = self.deviceId!
                }
                if self.extension_ != nil {
                    map["Extension"] = self.extension_!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.jobId != nil {
                    map["JobId"] = self.jobId!
                }
                if self.outboundScenario != nil {
                    map["OutboundScenario"] = self.outboundScenario!
                }
                if self.signedSkillGroupIdList != nil {
                    map["SignedSkillGroupIdList"] = self.signedSkillGroupIdList!
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                if self.userState != nil {
                    map["UserState"] = self.userState!
                }
                if self.workMode != nil {
                    map["WorkMode"] = self.workMode!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BreakCode") && dict["BreakCode"] != nil {
                    self.breakCode = dict["BreakCode"] as! String
                }
                if dict.keys.contains("DeviceId") && dict["DeviceId"] != nil {
                    self.deviceId = dict["DeviceId"] as! String
                }
                if dict.keys.contains("Extension") && dict["Extension"] != nil {
                    self.extension_ = dict["Extension"] as! String
                }
                if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("JobId") && dict["JobId"] != nil {
                    self.jobId = dict["JobId"] as! String
                }
                if dict.keys.contains("OutboundScenario") && dict["OutboundScenario"] != nil {
                    self.outboundScenario = dict["OutboundScenario"] as! Bool
                }
                if dict.keys.contains("SignedSkillGroupIdList") && dict["SignedSkillGroupIdList"] != nil {
                    self.signedSkillGroupIdList = dict["SignedSkillGroupIdList"] as! [String]
                }
                if dict.keys.contains("UserId") && dict["UserId"] != nil {
                    self.userId = dict["UserId"] as! String
                }
                if dict.keys.contains("UserState") && dict["UserState"] != nil {
                    self.userState = dict["UserState"] as! String
                }
                if dict.keys.contains("WorkMode") && dict["WorkMode"] != nil {
                    self.workMode = dict["WorkMode"] as! String
                }
            }
        }
        public var callContext: ReleaseCallResponseBody.Data.CallContext?

        public var contextId: Int64?

        public var userContext: ReleaseCallResponseBody.Data.UserContext?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.callContext?.validate()
            try self.userContext?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.callContext != nil {
                map["CallContext"] = self.callContext?.toMap()
            }
            if self.contextId != nil {
                map["ContextId"] = self.contextId!
            }
            if self.userContext != nil {
                map["UserContext"] = self.userContext?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CallContext") && dict["CallContext"] != nil {
                var model = ReleaseCallResponseBody.Data.CallContext()
                model.fromMap(dict["CallContext"] as! [String: Any])
                self.callContext = model
            }
            if dict.keys.contains("ContextId") && dict["ContextId"] != nil {
                self.contextId = dict["ContextId"] as! Int64
            }
            if dict.keys.contains("UserContext") && dict["UserContext"] != nil {
                var model = ReleaseCallResponseBody.Data.UserContext()
                model.fromMap(dict["UserContext"] as! [String: Any])
                self.userContext = model
            }
        }
    }
    public var code: String?

    public var data: ReleaseCallResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var params: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.params != nil {
            map["Params"] = self.params!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = ReleaseCallResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Params") && dict["Params"] != nil {
            self.params = dict["Params"] as! [String]
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ReleaseCallResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ReleaseCallResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ReleaseCallResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RemoveDoNotCallNumbersRequest : Tea.TeaModel {
    public var instanceId: String?

    public var numberList: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.numberList != nil {
            map["NumberList"] = self.numberList!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("NumberList") && dict["NumberList"] != nil {
            self.numberList = dict["NumberList"] as! String
        }
    }
}

public class RemoveDoNotCallNumbersResponseBody : Tea.TeaModel {
    public var code: String?

    public var data: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class RemoveDoNotCallNumbersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RemoveDoNotCallNumbersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = RemoveDoNotCallNumbersResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RemovePersonalNumbersFromUserRequest : Tea.TeaModel {
    public var instanceId: String?

    public var numberList: String?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.numberList != nil {
            map["NumberList"] = self.numberList!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("NumberList") && dict["NumberList"] != nil {
            self.numberList = dict["NumberList"] as! String
        }
        if dict.keys.contains("UserId") && dict["UserId"] != nil {
            self.userId = dict["UserId"] as! String
        }
    }
}

public class RemovePersonalNumbersFromUserResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class RemovePersonalNumbersFromUserResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RemovePersonalNumbersFromUserResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = RemovePersonalNumbersFromUserResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RemovePhoneNumberFromSkillGroupsRequest : Tea.TeaModel {
    public var instanceId: String?

    public var number: String?

    public var skillGroupIdList: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.number != nil {
            map["Number"] = self.number!
        }
        if self.skillGroupIdList != nil {
            map["SkillGroupIdList"] = self.skillGroupIdList!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Number") && dict["Number"] != nil {
            self.number = dict["Number"] as! String
        }
        if dict.keys.contains("SkillGroupIdList") && dict["SkillGroupIdList"] != nil {
            self.skillGroupIdList = dict["SkillGroupIdList"] as! String
        }
    }
}

public class RemovePhoneNumberFromSkillGroupsResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class RemovePhoneNumberFromSkillGroupsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RemovePhoneNumberFromSkillGroupsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = RemovePhoneNumberFromSkillGroupsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RemovePhoneNumbersRequest : Tea.TeaModel {
    public var force: Bool?

    public var instanceId: String?

    public var numberList: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.force != nil {
            map["Force"] = self.force!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.numberList != nil {
            map["NumberList"] = self.numberList!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Force") && dict["Force"] != nil {
            self.force = dict["Force"] as! Bool
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("NumberList") && dict["NumberList"] != nil {
            self.numberList = dict["NumberList"] as! String
        }
    }
}

public class RemovePhoneNumbersResponseBody : Tea.TeaModel {
    public var code: String?

    public var data: [String]?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! [String]
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class RemovePhoneNumbersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RemovePhoneNumbersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = RemovePhoneNumbersResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RemovePhoneNumbersFromSkillGroupRequest : Tea.TeaModel {
    public var instanceId: String?

    public var numberList: String?

    public var skillGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.numberList != nil {
            map["NumberList"] = self.numberList!
        }
        if self.skillGroupId != nil {
            map["SkillGroupId"] = self.skillGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("NumberList") && dict["NumberList"] != nil {
            self.numberList = dict["NumberList"] as! String
        }
        if dict.keys.contains("SkillGroupId") && dict["SkillGroupId"] != nil {
            self.skillGroupId = dict["SkillGroupId"] as! String
        }
    }
}

public class RemovePhoneNumbersFromSkillGroupResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class RemovePhoneNumbersFromSkillGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RemovePhoneNumbersFromSkillGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = RemovePhoneNumbersFromSkillGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RemoveSkillGroupsFromUserRequest : Tea.TeaModel {
    public var instanceId: String?

    public var skillGroupIdList: String?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.skillGroupIdList != nil {
            map["SkillGroupIdList"] = self.skillGroupIdList!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("SkillGroupIdList") && dict["SkillGroupIdList"] != nil {
            self.skillGroupIdList = dict["SkillGroupIdList"] as! String
        }
        if dict.keys.contains("UserId") && dict["UserId"] != nil {
            self.userId = dict["UserId"] as! String
        }
    }
}

public class RemoveSkillGroupsFromUserResponseBody : Tea.TeaModel {
    public var code: String?

    public var data: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class RemoveSkillGroupsFromUserResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RemoveSkillGroupsFromUserResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = RemoveSkillGroupsFromUserResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RemoveUsersRequest : Tea.TeaModel {
    public var force: Bool?

    public var instanceId: String?

    public var userIdList: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.force != nil {
            map["Force"] = self.force!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.userIdList != nil {
            map["UserIdList"] = self.userIdList!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Force") && dict["Force"] != nil {
            self.force = dict["Force"] as! Bool
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("UserIdList") && dict["UserIdList"] != nil {
            self.userIdList = dict["UserIdList"] as! String
        }
    }
}

public class RemoveUsersResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var params: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.params != nil {
            map["Params"] = self.params!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Params") && dict["Params"] != nil {
            self.params = dict["Params"] as! [String]
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class RemoveUsersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RemoveUsersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = RemoveUsersResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RemoveUsersFromSkillGroupRequest : Tea.TeaModel {
    public var instanceId: String?

    public var skillGroupId: String?

    public var userIdList: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.skillGroupId != nil {
            map["SkillGroupId"] = self.skillGroupId!
        }
        if self.userIdList != nil {
            map["UserIdList"] = self.userIdList!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("SkillGroupId") && dict["SkillGroupId"] != nil {
            self.skillGroupId = dict["SkillGroupId"] as! String
        }
        if dict.keys.contains("UserIdList") && dict["UserIdList"] != nil {
            self.userIdList = dict["UserIdList"] as! String
        }
    }
}

public class RemoveUsersFromSkillGroupResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class RemoveUsersFromSkillGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RemoveUsersFromSkillGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = RemoveUsersFromSkillGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ResetAgentStateRequest : Tea.TeaModel {
    public var deviceId: String?

    public var instanceId: String?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.deviceId != nil {
            map["DeviceId"] = self.deviceId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DeviceId") && dict["DeviceId"] != nil {
            self.deviceId = dict["DeviceId"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("UserId") && dict["UserId"] != nil {
            self.userId = dict["UserId"] as! String
        }
    }
}

public class ResetAgentStateResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var breakCode: String?

        public var deviceId: String?

        public var extension_: String?

        public var instanceId: String?

        public var jobId: String?

        public var outboundScenario: Bool?

        public var signedSkillGroupIdList: [String]?

        public var userId: String?

        public var userState: String?

        public var workMode: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.breakCode != nil {
                map["BreakCode"] = self.breakCode!
            }
            if self.deviceId != nil {
                map["DeviceId"] = self.deviceId!
            }
            if self.extension_ != nil {
                map["Extension"] = self.extension_!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            if self.outboundScenario != nil {
                map["OutboundScenario"] = self.outboundScenario!
            }
            if self.signedSkillGroupIdList != nil {
                map["SignedSkillGroupIdList"] = self.signedSkillGroupIdList!
            }
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            if self.userState != nil {
                map["UserState"] = self.userState!
            }
            if self.workMode != nil {
                map["WorkMode"] = self.workMode!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BreakCode") && dict["BreakCode"] != nil {
                self.breakCode = dict["BreakCode"] as! String
            }
            if dict.keys.contains("DeviceId") && dict["DeviceId"] != nil {
                self.deviceId = dict["DeviceId"] as! String
            }
            if dict.keys.contains("Extension") && dict["Extension"] != nil {
                self.extension_ = dict["Extension"] as! String
            }
            if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("JobId") && dict["JobId"] != nil {
                self.jobId = dict["JobId"] as! String
            }
            if dict.keys.contains("OutboundScenario") && dict["OutboundScenario"] != nil {
                self.outboundScenario = dict["OutboundScenario"] as! Bool
            }
            if dict.keys.contains("SignedSkillGroupIdList") && dict["SignedSkillGroupIdList"] != nil {
                self.signedSkillGroupIdList = dict["SignedSkillGroupIdList"] as! [String]
            }
            if dict.keys.contains("UserId") && dict["UserId"] != nil {
                self.userId = dict["UserId"] as! String
            }
            if dict.keys.contains("UserState") && dict["UserState"] != nil {
                self.userState = dict["UserState"] as! String
            }
            if dict.keys.contains("WorkMode") && dict["WorkMode"] != nil {
                self.workMode = dict["WorkMode"] as! String
            }
        }
    }
    public var code: String?

    public var data: ResetAgentStateResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var params: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.params != nil {
            map["Params"] = self.params!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = ResetAgentStateResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Params") && dict["Params"] != nil {
            self.params = dict["Params"] as! [String]
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ResetAgentStateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ResetAgentStateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ResetAgentStateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ResetUserPasswordRequest : Tea.TeaModel {
    public var instanceId: String?

    public var password: String?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.password != nil {
            map["Password"] = self.password!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Password") && dict["Password"] != nil {
            self.password = dict["Password"] as! String
        }
        if dict.keys.contains("UserId") && dict["UserId"] != nil {
            self.userId = dict["UserId"] as! String
        }
    }
}

public class ResetUserPasswordResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ResetUserPasswordResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ResetUserPasswordResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ResetUserPasswordResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RestoreArchivedRecordingsRequest : Tea.TeaModel {
    public var contactIds: String?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.contactIds != nil {
            map["ContactIds"] = self.contactIds!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ContactIds") && dict["ContactIds"] != nil {
            self.contactIds = dict["ContactIds"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
    }
}

public class RestoreArchivedRecordingsResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var contactId: String?

        public var exists: String?

        public var status: String?

        public var storageType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.contactId != nil {
                map["ContactId"] = self.contactId!
            }
            if self.exists != nil {
                map["Exists"] = self.exists!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.storageType != nil {
                map["StorageType"] = self.storageType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ContactId") && dict["ContactId"] != nil {
                self.contactId = dict["ContactId"] as! String
            }
            if dict.keys.contains("Exists") && dict["Exists"] != nil {
                self.exists = dict["Exists"] as! String
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("StorageType") && dict["StorageType"] != nil {
                self.storageType = dict["StorageType"] as! String
            }
        }
    }
    public var code: String?

    public var data: [RestoreArchivedRecordingsResponseBody.Data]?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            var tmp : [Any] = []
            for k in self.data! {
                tmp.append(k.toMap())
            }
            map["Data"] = tmp
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var tmp : [RestoreArchivedRecordingsResponseBody.Data] = []
            for v in dict["Data"] as! [Any] {
                var model = RestoreArchivedRecordingsResponseBody.Data()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.data = tmp
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class RestoreArchivedRecordingsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RestoreArchivedRecordingsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = RestoreArchivedRecordingsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ResumeCampaignRequest : Tea.TeaModel {
    public var campaignId: String?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.campaignId != nil {
            map["CampaignId"] = self.campaignId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CampaignId") && dict["CampaignId"] != nil {
            self.campaignId = dict["CampaignId"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
    }
}

public class ResumeCampaignResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpStatusCode: String?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ResumeCampaignResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ResumeCampaignResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ResumeCampaignResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RetrieveCallRequest : Tea.TeaModel {
    public var channelId: String?

    public var deviceId: String?

    public var instanceId: String?

    public var jobId: String?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.channelId != nil {
            map["ChannelId"] = self.channelId!
        }
        if self.deviceId != nil {
            map["DeviceId"] = self.deviceId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ChannelId") && dict["ChannelId"] != nil {
            self.channelId = dict["ChannelId"] as! String
        }
        if dict.keys.contains("DeviceId") && dict["DeviceId"] != nil {
            self.deviceId = dict["DeviceId"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("JobId") && dict["JobId"] != nil {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("UserId") && dict["UserId"] != nil {
            self.userId = dict["UserId"] as! String
        }
    }
}

public class RetrieveCallResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class CallContext : Tea.TeaModel {
            public class ChannelContexts : Tea.TeaModel {
                public var callType: String?

                public var channelId: String?

                public var channelState: String?

                public var destination: String?

                public var jobId: String?

                public var originator: String?

                public var releaseInitiator: String?

                public var releaseReason: String?

                public var skillGroupId: String?

                public var timestamp: Int64?

                public var userExtension: String?

                public var userId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.callType != nil {
                        map["CallType"] = self.callType!
                    }
                    if self.channelId != nil {
                        map["ChannelId"] = self.channelId!
                    }
                    if self.channelState != nil {
                        map["ChannelState"] = self.channelState!
                    }
                    if self.destination != nil {
                        map["Destination"] = self.destination!
                    }
                    if self.jobId != nil {
                        map["JobId"] = self.jobId!
                    }
                    if self.originator != nil {
                        map["Originator"] = self.originator!
                    }
                    if self.releaseInitiator != nil {
                        map["ReleaseInitiator"] = self.releaseInitiator!
                    }
                    if self.releaseReason != nil {
                        map["ReleaseReason"] = self.releaseReason!
                    }
                    if self.skillGroupId != nil {
                        map["SkillGroupId"] = self.skillGroupId!
                    }
                    if self.timestamp != nil {
                        map["Timestamp"] = self.timestamp!
                    }
                    if self.userExtension != nil {
                        map["UserExtension"] = self.userExtension!
                    }
                    if self.userId != nil {
                        map["UserId"] = self.userId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("CallType") && dict["CallType"] != nil {
                        self.callType = dict["CallType"] as! String
                    }
                    if dict.keys.contains("ChannelId") && dict["ChannelId"] != nil {
                        self.channelId = dict["ChannelId"] as! String
                    }
                    if dict.keys.contains("ChannelState") && dict["ChannelState"] != nil {
                        self.channelState = dict["ChannelState"] as! String
                    }
                    if dict.keys.contains("Destination") && dict["Destination"] != nil {
                        self.destination = dict["Destination"] as! String
                    }
                    if dict.keys.contains("JobId") && dict["JobId"] != nil {
                        self.jobId = dict["JobId"] as! String
                    }
                    if dict.keys.contains("Originator") && dict["Originator"] != nil {
                        self.originator = dict["Originator"] as! String
                    }
                    if dict.keys.contains("ReleaseInitiator") && dict["ReleaseInitiator"] != nil {
                        self.releaseInitiator = dict["ReleaseInitiator"] as! String
                    }
                    if dict.keys.contains("ReleaseReason") && dict["ReleaseReason"] != nil {
                        self.releaseReason = dict["ReleaseReason"] as! String
                    }
                    if dict.keys.contains("SkillGroupId") && dict["SkillGroupId"] != nil {
                        self.skillGroupId = dict["SkillGroupId"] as! String
                    }
                    if dict.keys.contains("Timestamp") && dict["Timestamp"] != nil {
                        self.timestamp = dict["Timestamp"] as! Int64
                    }
                    if dict.keys.contains("UserExtension") && dict["UserExtension"] != nil {
                        self.userExtension = dict["UserExtension"] as! String
                    }
                    if dict.keys.contains("UserId") && dict["UserId"] != nil {
                        self.userId = dict["UserId"] as! String
                    }
                }
            }
            public var callType: String?

            public var channelContexts: [RetrieveCallResponseBody.Data.CallContext.ChannelContexts]?

            public var instanceId: String?

            public var jobId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.callType != nil {
                    map["CallType"] = self.callType!
                }
                if self.channelContexts != nil {
                    var tmp : [Any] = []
                    for k in self.channelContexts! {
                        tmp.append(k.toMap())
                    }
                    map["ChannelContexts"] = tmp
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.jobId != nil {
                    map["JobId"] = self.jobId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CallType") && dict["CallType"] != nil {
                    self.callType = dict["CallType"] as! String
                }
                if dict.keys.contains("ChannelContexts") && dict["ChannelContexts"] != nil {
                    var tmp : [RetrieveCallResponseBody.Data.CallContext.ChannelContexts] = []
                    for v in dict["ChannelContexts"] as! [Any] {
                        var model = RetrieveCallResponseBody.Data.CallContext.ChannelContexts()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.channelContexts = tmp
                }
                if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("JobId") && dict["JobId"] != nil {
                    self.jobId = dict["JobId"] as! String
                }
            }
        }
        public class UserContext : Tea.TeaModel {
            public var breakCode: String?

            public var deviceId: String?

            public var extension_: String?

            public var heartbeat: Int64?

            public var instanceId: String?

            public var jobId: String?

            public var mobile: String?

            public var outboundScenario: Bool?

            public var reserved: Int64?

            public var signedSkillGroupIdList: [String]?

            public var userId: String?

            public var userState: String?

            public var workMode: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.breakCode != nil {
                    map["BreakCode"] = self.breakCode!
                }
                if self.deviceId != nil {
                    map["DeviceId"] = self.deviceId!
                }
                if self.extension_ != nil {
                    map["Extension"] = self.extension_!
                }
                if self.heartbeat != nil {
                    map["Heartbeat"] = self.heartbeat!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.jobId != nil {
                    map["JobId"] = self.jobId!
                }
                if self.mobile != nil {
                    map["Mobile"] = self.mobile!
                }
                if self.outboundScenario != nil {
                    map["OutboundScenario"] = self.outboundScenario!
                }
                if self.reserved != nil {
                    map["Reserved"] = self.reserved!
                }
                if self.signedSkillGroupIdList != nil {
                    map["SignedSkillGroupIdList"] = self.signedSkillGroupIdList!
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                if self.userState != nil {
                    map["UserState"] = self.userState!
                }
                if self.workMode != nil {
                    map["WorkMode"] = self.workMode!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BreakCode") && dict["BreakCode"] != nil {
                    self.breakCode = dict["BreakCode"] as! String
                }
                if dict.keys.contains("DeviceId") && dict["DeviceId"] != nil {
                    self.deviceId = dict["DeviceId"] as! String
                }
                if dict.keys.contains("Extension") && dict["Extension"] != nil {
                    self.extension_ = dict["Extension"] as! String
                }
                if dict.keys.contains("Heartbeat") && dict["Heartbeat"] != nil {
                    self.heartbeat = dict["Heartbeat"] as! Int64
                }
                if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("JobId") && dict["JobId"] != nil {
                    self.jobId = dict["JobId"] as! String
                }
                if dict.keys.contains("Mobile") && dict["Mobile"] != nil {
                    self.mobile = dict["Mobile"] as! String
                }
                if dict.keys.contains("OutboundScenario") && dict["OutboundScenario"] != nil {
                    self.outboundScenario = dict["OutboundScenario"] as! Bool
                }
                if dict.keys.contains("Reserved") && dict["Reserved"] != nil {
                    self.reserved = dict["Reserved"] as! Int64
                }
                if dict.keys.contains("SignedSkillGroupIdList") && dict["SignedSkillGroupIdList"] != nil {
                    self.signedSkillGroupIdList = dict["SignedSkillGroupIdList"] as! [String]
                }
                if dict.keys.contains("UserId") && dict["UserId"] != nil {
                    self.userId = dict["UserId"] as! String
                }
                if dict.keys.contains("UserState") && dict["UserState"] != nil {
                    self.userState = dict["UserState"] as! String
                }
                if dict.keys.contains("WorkMode") && dict["WorkMode"] != nil {
                    self.workMode = dict["WorkMode"] as! String
                }
            }
        }
        public var callContext: RetrieveCallResponseBody.Data.CallContext?

        public var userContext: RetrieveCallResponseBody.Data.UserContext?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.callContext?.validate()
            try self.userContext?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.callContext != nil {
                map["CallContext"] = self.callContext?.toMap()
            }
            if self.userContext != nil {
                map["UserContext"] = self.userContext?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CallContext") && dict["CallContext"] != nil {
                var model = RetrieveCallResponseBody.Data.CallContext()
                model.fromMap(dict["CallContext"] as! [String: Any])
                self.callContext = model
            }
            if dict.keys.contains("UserContext") && dict["UserContext"] != nil {
                var model = RetrieveCallResponseBody.Data.UserContext()
                model.fromMap(dict["UserContext"] as! [String: Any])
                self.userContext = model
            }
        }
    }
    public var code: String?

    public var data: RetrieveCallResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var params: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.params != nil {
            map["Params"] = self.params!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = RetrieveCallResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Params") && dict["Params"] != nil {
            self.params = dict["Params"] as! [String]
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class RetrieveCallResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RetrieveCallResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = RetrieveCallResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SaveRTCStatsV2Request : Tea.TeaModel {
    public var callId: String?

    public var generalInfo: String?

    public var googAddress: String?

    public var instanceId: String?

    public var receiverReport: String?

    public var senderReport: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.callId != nil {
            map["CallId"] = self.callId!
        }
        if self.generalInfo != nil {
            map["GeneralInfo"] = self.generalInfo!
        }
        if self.googAddress != nil {
            map["GoogAddress"] = self.googAddress!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.receiverReport != nil {
            map["ReceiverReport"] = self.receiverReport!
        }
        if self.senderReport != nil {
            map["SenderReport"] = self.senderReport!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CallId") && dict["CallId"] != nil {
            self.callId = dict["CallId"] as! String
        }
        if dict.keys.contains("GeneralInfo") && dict["GeneralInfo"] != nil {
            self.generalInfo = dict["GeneralInfo"] as! String
        }
        if dict.keys.contains("GoogAddress") && dict["GoogAddress"] != nil {
            self.googAddress = dict["GoogAddress"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("ReceiverReport") && dict["ReceiverReport"] != nil {
            self.receiverReport = dict["ReceiverReport"] as! String
        }
        if dict.keys.contains("SenderReport") && dict["SenderReport"] != nil {
            self.senderReport = dict["SenderReport"] as! String
        }
    }
}

public class SaveRTCStatsV2ResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpStatusCode: Int64?

    public var message: String?

    public var requestId: String?

    public var rowCount: Int64?

    public var success: Bool?

    public var timeStamp: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.rowCount != nil {
            map["RowCount"] = self.rowCount!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.timeStamp != nil {
            map["TimeStamp"] = self.timeStamp!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int64
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("RowCount") && dict["RowCount"] != nil {
            self.rowCount = dict["RowCount"] as! Int64
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TimeStamp") && dict["TimeStamp"] != nil {
            self.timeStamp = dict["TimeStamp"] as! Int64
        }
    }
}

public class SaveRTCStatsV2Response : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SaveRTCStatsV2ResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = SaveRTCStatsV2ResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SaveTerminalLogRequest : Tea.TeaModel {
    public var appName: String?

    public var callId: String?

    public var content: String?

    public var dataType: Int32?

    public var instanceId: String?

    public var jobId: String?

    public var methodName: String?

    public var status: String?

    public var uniqueRequestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appName != nil {
            map["AppName"] = self.appName!
        }
        if self.callId != nil {
            map["CallId"] = self.callId!
        }
        if self.content != nil {
            map["Content"] = self.content!
        }
        if self.dataType != nil {
            map["DataType"] = self.dataType!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.methodName != nil {
            map["MethodName"] = self.methodName!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.uniqueRequestId != nil {
            map["UniqueRequestId"] = self.uniqueRequestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppName") && dict["AppName"] != nil {
            self.appName = dict["AppName"] as! String
        }
        if dict.keys.contains("CallId") && dict["CallId"] != nil {
            self.callId = dict["CallId"] as! String
        }
        if dict.keys.contains("Content") && dict["Content"] != nil {
            self.content = dict["Content"] as! String
        }
        if dict.keys.contains("DataType") && dict["DataType"] != nil {
            self.dataType = dict["DataType"] as! Int32
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("JobId") && dict["JobId"] != nil {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("MethodName") && dict["MethodName"] != nil {
            self.methodName = dict["MethodName"] as! String
        }
        if dict.keys.contains("Status") && dict["Status"] != nil {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("UniqueRequestId") && dict["UniqueRequestId"] != nil {
            self.uniqueRequestId = dict["UniqueRequestId"] as! String
        }
    }
}

public class SaveTerminalLogResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpStatusCode: Int64?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public var timeStamp: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.timeStamp != nil {
            map["TimeStamp"] = self.timeStamp!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int64
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TimeStamp") && dict["TimeStamp"] != nil {
            self.timeStamp = dict["TimeStamp"] as! Int64
        }
    }
}

public class SaveTerminalLogResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SaveTerminalLogResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = SaveTerminalLogResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SaveWebRTCStatsRequest : Tea.TeaModel {
    public var callId: String?

    public var generalInfo: String?

    public var googAddress: String?

    public var instanceId: String?

    public var receiverReport: String?

    public var senderReport: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.callId != nil {
            map["CallId"] = self.callId!
        }
        if self.generalInfo != nil {
            map["GeneralInfo"] = self.generalInfo!
        }
        if self.googAddress != nil {
            map["GoogAddress"] = self.googAddress!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.receiverReport != nil {
            map["ReceiverReport"] = self.receiverReport!
        }
        if self.senderReport != nil {
            map["SenderReport"] = self.senderReport!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CallId") && dict["CallId"] != nil {
            self.callId = dict["CallId"] as! String
        }
        if dict.keys.contains("GeneralInfo") && dict["GeneralInfo"] != nil {
            self.generalInfo = dict["GeneralInfo"] as! String
        }
        if dict.keys.contains("GoogAddress") && dict["GoogAddress"] != nil {
            self.googAddress = dict["GoogAddress"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("ReceiverReport") && dict["ReceiverReport"] != nil {
            self.receiverReport = dict["ReceiverReport"] as! String
        }
        if dict.keys.contains("SenderReport") && dict["SenderReport"] != nil {
            self.senderReport = dict["SenderReport"] as! String
        }
    }
}

public class SaveWebRTCStatsResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpStatusCode: Int64?

    public var message: String?

    public var requestId: String?

    public var rowCount: Int64?

    public var success: Bool?

    public var timeStamp: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.rowCount != nil {
            map["RowCount"] = self.rowCount!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.timeStamp != nil {
            map["TimeStamp"] = self.timeStamp!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int64
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("RowCount") && dict["RowCount"] != nil {
            self.rowCount = dict["RowCount"] as! Int64
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TimeStamp") && dict["TimeStamp"] != nil {
            self.timeStamp = dict["TimeStamp"] as! Int64
        }
    }
}

public class SaveWebRTCStatsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SaveWebRTCStatsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = SaveWebRTCStatsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SaveWebRtcInfoRequest : Tea.TeaModel {
    public var callId: String?

    public var content: String?

    public var contentType: String?

    public var instanceId: String?

    public var jobId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.callId != nil {
            map["CallId"] = self.callId!
        }
        if self.content != nil {
            map["Content"] = self.content!
        }
        if self.contentType != nil {
            map["ContentType"] = self.contentType!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CallId") && dict["CallId"] != nil {
            self.callId = dict["CallId"] as! String
        }
        if dict.keys.contains("Content") && dict["Content"] != nil {
            self.content = dict["Content"] as! String
        }
        if dict.keys.contains("ContentType") && dict["ContentType"] != nil {
            self.contentType = dict["ContentType"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("JobId") && dict["JobId"] != nil {
            self.jobId = dict["JobId"] as! String
        }
    }
}

public class SaveWebRtcInfoResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpStatusCode: Int64?

    public var message: String?

    public var requestId: String?

    public var rowCount: Int64?

    public var success: Bool?

    public var timeStamp: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.rowCount != nil {
            map["RowCount"] = self.rowCount!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        if self.timeStamp != nil {
            map["TimeStamp"] = self.timeStamp!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int64
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("RowCount") && dict["RowCount"] != nil {
            self.rowCount = dict["RowCount"] as! Int64
        }
        if dict.keys.contains("Success") && dict["Success"] != nil {
            self.success = dict["Success"] as! Bool
        }
        if dict.keys.contains("TimeStamp") && dict["TimeStamp"] != nil {
            self.timeStamp = dict["TimeStamp"] as! Int64
        }
    }
}

public class SaveWebRtcInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SaveWebRtcInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = SaveWebRtcInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SendDtmfSignalingRequest : Tea.TeaModel {
    public var channelId: String?

    public var deviceId: String?

    public var dtmf: String?

    public var instanceId: String?

    public var jobId: String?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.channelId != nil {
            map["ChannelId"] = self.channelId!
        }
        if self.deviceId != nil {
            map["DeviceId"] = self.deviceId!
        }
        if self.dtmf != nil {
            map["Dtmf"] = self.dtmf!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ChannelId") && dict["ChannelId"] != nil {
            self.channelId = dict["ChannelId"] as! String
        }
        if dict.keys.contains("DeviceId") && dict["DeviceId"] != nil {
            self.deviceId = dict["DeviceId"] as! String
        }
        if dict.keys.contains("Dtmf") && dict["Dtmf"] != nil {
            self.dtmf = dict["Dtmf"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("JobId") && dict["JobId"] != nil {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("UserId") && dict["UserId"] != nil {
            self.userId = dict["UserId"] as! String
        }
    }
}

public class SendDtmfSignalingResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class CallContext : Tea.TeaModel {
            public class ChannelContexts : Tea.TeaModel {
                public var callType: String?

                public var channelFlags: String?

                public var channelId: String?

                public var channelState: String?

                public var destination: String?

                public var index: Int32?

                public var jobId: String?

                public var originator: String?

                public var releaseInitiator: String?

                public var releaseReason: String?

                public var skillGroupId: String?

                public var timestamp: Int64?

                public var userExtension: String?

                public var userId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.callType != nil {
                        map["CallType"] = self.callType!
                    }
                    if self.channelFlags != nil {
                        map["ChannelFlags"] = self.channelFlags!
                    }
                    if self.channelId != nil {
                        map["ChannelId"] = self.channelId!
                    }
                    if self.channelState != nil {
                        map["ChannelState"] = self.channelState!
                    }
                    if self.destination != nil {
                        map["Destination"] = self.destination!
                    }
                    if self.index != nil {
                        map["Index"] = self.index!
                    }
                    if self.jobId != nil {
                        map["JobId"] = self.jobId!
                    }
                    if self.originator != nil {
                        map["Originator"] = self.originator!
                    }
                    if self.releaseInitiator != nil {
                        map["ReleaseInitiator"] = self.releaseInitiator!
                    }
                    if self.releaseReason != nil {
                        map["ReleaseReason"] = self.releaseReason!
                    }
                    if self.skillGroupId != nil {
                        map["SkillGroupId"] = self.skillGroupId!
                    }
                    if self.timestamp != nil {
                        map["Timestamp"] = self.timestamp!
                    }
                    if self.userExtension != nil {
                        map["UserExtension"] = self.userExtension!
                    }
                    if self.userId != nil {
                        map["UserId"] = self.userId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("CallType") && dict["CallType"] != nil {
                        self.callType = dict["CallType"] as! String
                    }
                    if dict.keys.contains("ChannelFlags") && dict["ChannelFlags"] != nil {
                        self.channelFlags = dict["ChannelFlags"] as! String
                    }
                    if dict.keys.contains("ChannelId") && dict["ChannelId"] != nil {
                        self.channelId = dict["ChannelId"] as! String
                    }
                    if dict.keys.contains("ChannelState") && dict["ChannelState"] != nil {
                        self.channelState = dict["ChannelState"] as! String
                    }
                    if dict.keys.contains("Destination") && dict["Destination"] != nil {
                        self.destination = dict["Destination"] as! String
                    }
                    if dict.keys.contains("Index") && dict["Index"] != nil {
                        self.index = dict["Index"] as! Int32
                    }
                    if dict.keys.contains("JobId") && dict["JobId"] != nil {
                        self.jobId = dict["JobId"] as! String
                    }
                    if dict.keys.contains("Originator") && dict["Originator"] != nil {
                        self.originator = dict["Originator"] as! String
                    }
                    if dict.keys.contains("ReleaseInitiator") && dict["ReleaseInitiator"] != nil {
                        self.releaseInitiator = dict["ReleaseInitiator"] as! String
                    }
                    if dict.keys.contains("ReleaseReason") && dict["ReleaseReason"] != nil {
                        self.releaseReason = dict["ReleaseReason"] as! String
                    }
                    if dict.keys.contains("SkillGroupId") && dict["SkillGroupId"] != nil {
                        self.skillGroupId = dict["SkillGroupId"] as! String
                    }
                    if dict.keys.contains("Timestamp") && dict["Timestamp"] != nil {
                        self.timestamp = dict["Timestamp"] as! Int64
                    }
                    if dict.keys.contains("UserExtension") && dict["UserExtension"] != nil {
                        self.userExtension = dict["UserExtension"] as! String
                    }
                    if dict.keys.contains("UserId") && dict["UserId"] != nil {
                        self.userId = dict["UserId"] as! String
                    }
                }
            }
            public var callType: String?

            public var channelContexts: [SendDtmfSignalingResponseBody.Data.CallContext.ChannelContexts]?

            public var instanceId: String?

            public var jobId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.callType != nil {
                    map["CallType"] = self.callType!
                }
                if self.channelContexts != nil {
                    var tmp : [Any] = []
                    for k in self.channelContexts! {
                        tmp.append(k.toMap())
                    }
                    map["ChannelContexts"] = tmp
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.jobId != nil {
                    map["JobId"] = self.jobId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CallType") && dict["CallType"] != nil {
                    self.callType = dict["CallType"] as! String
                }
                if dict.keys.contains("ChannelContexts") && dict["ChannelContexts"] != nil {
                    var tmp : [SendDtmfSignalingResponseBody.Data.CallContext.ChannelContexts] = []
                    for v in dict["ChannelContexts"] as! [Any] {
                        var model = SendDtmfSignalingResponseBody.Data.CallContext.ChannelContexts()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.channelContexts = tmp
                }
                if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("JobId") && dict["JobId"] != nil {
                    self.jobId = dict["JobId"] as! String
                }
            }
        }
        public class UserContext : Tea.TeaModel {
            public var breakCode: String?

            public var deviceId: String?

            public var extension_: String?

            public var heartbeat: Int64?

            public var instanceId: String?

            public var jobId: String?

            public var mobile: String?

            public var outboundScenario: Bool?

            public var reserved: Int64?

            public var signedSkillGroupIdList: [String]?

            public var userId: String?

            public var userState: String?

            public var workMode: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.breakCode != nil {
                    map["BreakCode"] = self.breakCode!
                }
                if self.deviceId != nil {
                    map["DeviceId"] = self.deviceId!
                }
                if self.extension_ != nil {
                    map["Extension"] = self.extension_!
                }
                if self.heartbeat != nil {
                    map["Heartbeat"] = self.heartbeat!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.jobId != nil {
                    map["JobId"] = self.jobId!
                }
                if self.mobile != nil {
                    map["Mobile"] = self.mobile!
                }
                if self.outboundScenario != nil {
                    map["OutboundScenario"] = self.outboundScenario!
                }
                if self.reserved != nil {
                    map["Reserved"] = self.reserved!
                }
                if self.signedSkillGroupIdList != nil {
                    map["SignedSkillGroupIdList"] = self.signedSkillGroupIdList!
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                if self.userState != nil {
                    map["UserState"] = self.userState!
                }
                if self.workMode != nil {
                    map["WorkMode"] = self.workMode!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BreakCode") && dict["BreakCode"] != nil {
                    self.breakCode = dict["BreakCode"] as! String
                }
                if dict.keys.contains("DeviceId") && dict["DeviceId"] != nil {
                    self.deviceId = dict["DeviceId"] as! String
                }
                if dict.keys.contains("Extension") && dict["Extension"] != nil {
                    self.extension_ = dict["Extension"] as! String
                }
                if dict.keys.contains("Heartbeat") && dict["Heartbeat"] != nil {
                    self.heartbeat = dict["Heartbeat"] as! Int64
                }
                if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("JobId") && dict["JobId"] != nil {
                    self.jobId = dict["JobId"] as! String
                }
                if dict.keys.contains("Mobile") && dict["Mobile"] != nil {
                    self.mobile = dict["Mobile"] as! String
                }
                if dict.keys.contains("OutboundScenario") && dict["OutboundScenario"] != nil {
                    self.outboundScenario = dict["OutboundScenario"] as! Bool
                }
                if dict.keys.contains("Reserved") && dict["Reserved"] != nil {
                    self.reserved = dict["Reserved"] as! Int64
                }
                if dict.keys.contains("SignedSkillGroupIdList") && dict["SignedSkillGroupIdList"] != nil {
                    self.signedSkillGroupIdList = dict["SignedSkillGroupIdList"] as! [String]
                }
                if dict.keys.contains("UserId") && dict["UserId"] != nil {
                    self.userId = dict["UserId"] as! String
                }
                if dict.keys.contains("UserState") && dict["UserState"] != nil {
                    self.userState = dict["UserState"] as! String
                }
                if dict.keys.contains("WorkMode") && dict["WorkMode"] != nil {
                    self.workMode = dict["WorkMode"] as! String
                }
            }
        }
        public var callContext: SendDtmfSignalingResponseBody.Data.CallContext?

        public var userContext: SendDtmfSignalingResponseBody.Data.UserContext?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.callContext?.validate()
            try self.userContext?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.callContext != nil {
                map["CallContext"] = self.callContext?.toMap()
            }
            if self.userContext != nil {
                map["UserContext"] = self.userContext?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CallContext") && dict["CallContext"] != nil {
                var model = SendDtmfSignalingResponseBody.Data.CallContext()
                model.fromMap(dict["CallContext"] as! [String: Any])
                self.callContext = model
            }
            if dict.keys.contains("UserContext") && dict["UserContext"] != nil {
                var model = SendDtmfSignalingResponseBody.Data.UserContext()
                model.fromMap(dict["UserContext"] as! [String: Any])
                self.userContext = model
            }
        }
    }
    public var code: String?

    public var data: SendDtmfSignalingResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var params: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.params != nil {
            map["Params"] = self.params!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = SendDtmfSignalingResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Params") && dict["Params"] != nil {
            self.params = dict["Params"] as! [String]
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SendDtmfSignalingResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SendDtmfSignalingResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = SendDtmfSignalingResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SignInGroupRequest : Tea.TeaModel {
    public var deviceId: String?

    public var instanceId: String?

    public var signedSkillGroupIdList: String?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.deviceId != nil {
            map["DeviceId"] = self.deviceId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.signedSkillGroupIdList != nil {
            map["SignedSkillGroupIdList"] = self.signedSkillGroupIdList!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DeviceId") && dict["DeviceId"] != nil {
            self.deviceId = dict["DeviceId"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("SignedSkillGroupIdList") && dict["SignedSkillGroupIdList"] != nil {
            self.signedSkillGroupIdList = dict["SignedSkillGroupIdList"] as! String
        }
        if dict.keys.contains("UserId") && dict["UserId"] != nil {
            self.userId = dict["UserId"] as! String
        }
    }
}

public class SignInGroupResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var breakCode: String?

        public var deviceId: String?

        public var extension_: String?

        public var instanceId: String?

        public var jobId: String?

        public var outboundScenario: Bool?

        public var signedSkillGroupIdList: [String]?

        public var userId: String?

        public var userState: String?

        public var workMode: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.breakCode != nil {
                map["BreakCode"] = self.breakCode!
            }
            if self.deviceId != nil {
                map["DeviceId"] = self.deviceId!
            }
            if self.extension_ != nil {
                map["Extension"] = self.extension_!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            if self.outboundScenario != nil {
                map["OutboundScenario"] = self.outboundScenario!
            }
            if self.signedSkillGroupIdList != nil {
                map["SignedSkillGroupIdList"] = self.signedSkillGroupIdList!
            }
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            if self.userState != nil {
                map["UserState"] = self.userState!
            }
            if self.workMode != nil {
                map["WorkMode"] = self.workMode!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BreakCode") && dict["BreakCode"] != nil {
                self.breakCode = dict["BreakCode"] as! String
            }
            if dict.keys.contains("DeviceId") && dict["DeviceId"] != nil {
                self.deviceId = dict["DeviceId"] as! String
            }
            if dict.keys.contains("Extension") && dict["Extension"] != nil {
                self.extension_ = dict["Extension"] as! String
            }
            if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("JobId") && dict["JobId"] != nil {
                self.jobId = dict["JobId"] as! String
            }
            if dict.keys.contains("OutboundScenario") && dict["OutboundScenario"] != nil {
                self.outboundScenario = dict["OutboundScenario"] as! Bool
            }
            if dict.keys.contains("SignedSkillGroupIdList") && dict["SignedSkillGroupIdList"] != nil {
                self.signedSkillGroupIdList = dict["SignedSkillGroupIdList"] as! [String]
            }
            if dict.keys.contains("UserId") && dict["UserId"] != nil {
                self.userId = dict["UserId"] as! String
            }
            if dict.keys.contains("UserState") && dict["UserState"] != nil {
                self.userState = dict["UserState"] as! String
            }
            if dict.keys.contains("WorkMode") && dict["WorkMode"] != nil {
                self.workMode = dict["WorkMode"] as! String
            }
        }
    }
    public var code: String?

    public var data: SignInGroupResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var params: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.params != nil {
            map["Params"] = self.params!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = SignInGroupResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Params") && dict["Params"] != nil {
            self.params = dict["Params"] as! [String]
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SignInGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SignInGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = SignInGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SignOutGroupRequest : Tea.TeaModel {
    public var deviceId: String?

    public var instanceId: String?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.deviceId != nil {
            map["DeviceId"] = self.deviceId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DeviceId") && dict["DeviceId"] != nil {
            self.deviceId = dict["DeviceId"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("UserId") && dict["UserId"] != nil {
            self.userId = dict["UserId"] as! String
        }
    }
}

public class SignOutGroupResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var breakCode: String?

        public var deviceId: String?

        public var extension_: String?

        public var heartbeat: Int64?

        public var instanceId: String?

        public var jobId: String?

        public var mobile: String?

        public var outboundScenario: Bool?

        public var reserved: Int64?

        public var signedSkillGroupIdList: [String]?

        public var userId: String?

        public var userState: String?

        public var workMode: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.breakCode != nil {
                map["BreakCode"] = self.breakCode!
            }
            if self.deviceId != nil {
                map["DeviceId"] = self.deviceId!
            }
            if self.extension_ != nil {
                map["Extension"] = self.extension_!
            }
            if self.heartbeat != nil {
                map["Heartbeat"] = self.heartbeat!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            if self.mobile != nil {
                map["Mobile"] = self.mobile!
            }
            if self.outboundScenario != nil {
                map["OutboundScenario"] = self.outboundScenario!
            }
            if self.reserved != nil {
                map["Reserved"] = self.reserved!
            }
            if self.signedSkillGroupIdList != nil {
                map["SignedSkillGroupIdList"] = self.signedSkillGroupIdList!
            }
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            if self.userState != nil {
                map["UserState"] = self.userState!
            }
            if self.workMode != nil {
                map["WorkMode"] = self.workMode!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BreakCode") && dict["BreakCode"] != nil {
                self.breakCode = dict["BreakCode"] as! String
            }
            if dict.keys.contains("DeviceId") && dict["DeviceId"] != nil {
                self.deviceId = dict["DeviceId"] as! String
            }
            if dict.keys.contains("Extension") && dict["Extension"] != nil {
                self.extension_ = dict["Extension"] as! String
            }
            if dict.keys.contains("Heartbeat") && dict["Heartbeat"] != nil {
                self.heartbeat = dict["Heartbeat"] as! Int64
            }
            if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("JobId") && dict["JobId"] != nil {
                self.jobId = dict["JobId"] as! String
            }
            if dict.keys.contains("Mobile") && dict["Mobile"] != nil {
                self.mobile = dict["Mobile"] as! String
            }
            if dict.keys.contains("OutboundScenario") && dict["OutboundScenario"] != nil {
                self.outboundScenario = dict["OutboundScenario"] as! Bool
            }
            if dict.keys.contains("Reserved") && dict["Reserved"] != nil {
                self.reserved = dict["Reserved"] as! Int64
            }
            if dict.keys.contains("SignedSkillGroupIdList") && dict["SignedSkillGroupIdList"] != nil {
                self.signedSkillGroupIdList = dict["SignedSkillGroupIdList"] as! [String]
            }
            if dict.keys.contains("UserId") && dict["UserId"] != nil {
                self.userId = dict["UserId"] as! String
            }
            if dict.keys.contains("UserState") && dict["UserState"] != nil {
                self.userState = dict["UserState"] as! String
            }
            if dict.keys.contains("WorkMode") && dict["WorkMode"] != nil {
                self.workMode = dict["WorkMode"] as! String
            }
        }
    }
    public var code: String?

    public var data: SignOutGroupResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var params: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.params != nil {
            map["Params"] = self.params!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = SignOutGroupResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Params") && dict["Params"] != nil {
            self.params = dict["Params"] as! [String]
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SignOutGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SignOutGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = SignOutGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class StartBack2BackCallRequest : Tea.TeaModel {
    public var additionalBroker: String?

    public var broker: String?

    public var callee: String?

    public var caller: String?

    public var instanceId: String?

    public var tags: String?

    public var timeoutSeconds: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.additionalBroker != nil {
            map["AdditionalBroker"] = self.additionalBroker!
        }
        if self.broker != nil {
            map["Broker"] = self.broker!
        }
        if self.callee != nil {
            map["Callee"] = self.callee!
        }
        if self.caller != nil {
            map["Caller"] = self.caller!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.tags != nil {
            map["Tags"] = self.tags!
        }
        if self.timeoutSeconds != nil {
            map["TimeoutSeconds"] = self.timeoutSeconds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AdditionalBroker") && dict["AdditionalBroker"] != nil {
            self.additionalBroker = dict["AdditionalBroker"] as! String
        }
        if dict.keys.contains("Broker") && dict["Broker"] != nil {
            self.broker = dict["Broker"] as! String
        }
        if dict.keys.contains("Callee") && dict["Callee"] != nil {
            self.callee = dict["Callee"] as! String
        }
        if dict.keys.contains("Caller") && dict["Caller"] != nil {
            self.caller = dict["Caller"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Tags") && dict["Tags"] != nil {
            self.tags = dict["Tags"] as! String
        }
        if dict.keys.contains("TimeoutSeconds") && dict["TimeoutSeconds"] != nil {
            self.timeoutSeconds = dict["TimeoutSeconds"] as! Int32
        }
    }
}

public class StartBack2BackCallResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class CallContext : Tea.TeaModel {
            public class ChannelContexts : Tea.TeaModel {
                public var callType: String?

                public var channelFlags: String?

                public var channelId: String?

                public var channelState: String?

                public var destination: String?

                public var jobId: String?

                public var originator: String?

                public var releaseInitiator: String?

                public var releaseReason: String?

                public var timestamp: Int64?

                public var userExtension: String?

                public var userId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.callType != nil {
                        map["CallType"] = self.callType!
                    }
                    if self.channelFlags != nil {
                        map["ChannelFlags"] = self.channelFlags!
                    }
                    if self.channelId != nil {
                        map["ChannelId"] = self.channelId!
                    }
                    if self.channelState != nil {
                        map["ChannelState"] = self.channelState!
                    }
                    if self.destination != nil {
                        map["Destination"] = self.destination!
                    }
                    if self.jobId != nil {
                        map["JobId"] = self.jobId!
                    }
                    if self.originator != nil {
                        map["Originator"] = self.originator!
                    }
                    if self.releaseInitiator != nil {
                        map["ReleaseInitiator"] = self.releaseInitiator!
                    }
                    if self.releaseReason != nil {
                        map["ReleaseReason"] = self.releaseReason!
                    }
                    if self.timestamp != nil {
                        map["Timestamp"] = self.timestamp!
                    }
                    if self.userExtension != nil {
                        map["UserExtension"] = self.userExtension!
                    }
                    if self.userId != nil {
                        map["UserId"] = self.userId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("CallType") && dict["CallType"] != nil {
                        self.callType = dict["CallType"] as! String
                    }
                    if dict.keys.contains("ChannelFlags") && dict["ChannelFlags"] != nil {
                        self.channelFlags = dict["ChannelFlags"] as! String
                    }
                    if dict.keys.contains("ChannelId") && dict["ChannelId"] != nil {
                        self.channelId = dict["ChannelId"] as! String
                    }
                    if dict.keys.contains("ChannelState") && dict["ChannelState"] != nil {
                        self.channelState = dict["ChannelState"] as! String
                    }
                    if dict.keys.contains("Destination") && dict["Destination"] != nil {
                        self.destination = dict["Destination"] as! String
                    }
                    if dict.keys.contains("JobId") && dict["JobId"] != nil {
                        self.jobId = dict["JobId"] as! String
                    }
                    if dict.keys.contains("Originator") && dict["Originator"] != nil {
                        self.originator = dict["Originator"] as! String
                    }
                    if dict.keys.contains("ReleaseInitiator") && dict["ReleaseInitiator"] != nil {
                        self.releaseInitiator = dict["ReleaseInitiator"] as! String
                    }
                    if dict.keys.contains("ReleaseReason") && dict["ReleaseReason"] != nil {
                        self.releaseReason = dict["ReleaseReason"] as! String
                    }
                    if dict.keys.contains("Timestamp") && dict["Timestamp"] != nil {
                        self.timestamp = dict["Timestamp"] as! Int64
                    }
                    if dict.keys.contains("UserExtension") && dict["UserExtension"] != nil {
                        self.userExtension = dict["UserExtension"] as! String
                    }
                    if dict.keys.contains("UserId") && dict["UserId"] != nil {
                        self.userId = dict["UserId"] as! String
                    }
                }
            }
            public var callType: String?

            public var channelContexts: [StartBack2BackCallResponseBody.Data.CallContext.ChannelContexts]?

            public var instanceId: String?

            public var jobId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.callType != nil {
                    map["CallType"] = self.callType!
                }
                if self.channelContexts != nil {
                    var tmp : [Any] = []
                    for k in self.channelContexts! {
                        tmp.append(k.toMap())
                    }
                    map["ChannelContexts"] = tmp
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.jobId != nil {
                    map["JobId"] = self.jobId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CallType") && dict["CallType"] != nil {
                    self.callType = dict["CallType"] as! String
                }
                if dict.keys.contains("ChannelContexts") && dict["ChannelContexts"] != nil {
                    var tmp : [StartBack2BackCallResponseBody.Data.CallContext.ChannelContexts] = []
                    for v in dict["ChannelContexts"] as! [Any] {
                        var model = StartBack2BackCallResponseBody.Data.CallContext.ChannelContexts()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.channelContexts = tmp
                }
                if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("JobId") && dict["JobId"] != nil {
                    self.jobId = dict["JobId"] as! String
                }
            }
        }
        public class UserContext : Tea.TeaModel {
            public var breakCode: String?

            public var deviceId: String?

            public var deviceState: String?

            public var extension_: String?

            public var heartbeat: Int64?

            public var instanceId: String?

            public var jobId: String?

            public var mobile: String?

            public var outboundScenario: Bool?

            public var reserved: Int64?

            public var signedSkillGroupIdList: [String]?

            public var userId: String?

            public var userState: String?

            public var workMode: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.breakCode != nil {
                    map["BreakCode"] = self.breakCode!
                }
                if self.deviceId != nil {
                    map["DeviceId"] = self.deviceId!
                }
                if self.deviceState != nil {
                    map["DeviceState"] = self.deviceState!
                }
                if self.extension_ != nil {
                    map["Extension"] = self.extension_!
                }
                if self.heartbeat != nil {
                    map["Heartbeat"] = self.heartbeat!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.jobId != nil {
                    map["JobId"] = self.jobId!
                }
                if self.mobile != nil {
                    map["Mobile"] = self.mobile!
                }
                if self.outboundScenario != nil {
                    map["OutboundScenario"] = self.outboundScenario!
                }
                if self.reserved != nil {
                    map["Reserved"] = self.reserved!
                }
                if self.signedSkillGroupIdList != nil {
                    map["SignedSkillGroupIdList"] = self.signedSkillGroupIdList!
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                if self.userState != nil {
                    map["UserState"] = self.userState!
                }
                if self.workMode != nil {
                    map["WorkMode"] = self.workMode!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BreakCode") && dict["BreakCode"] != nil {
                    self.breakCode = dict["BreakCode"] as! String
                }
                if dict.keys.contains("DeviceId") && dict["DeviceId"] != nil {
                    self.deviceId = dict["DeviceId"] as! String
                }
                if dict.keys.contains("DeviceState") && dict["DeviceState"] != nil {
                    self.deviceState = dict["DeviceState"] as! String
                }
                if dict.keys.contains("Extension") && dict["Extension"] != nil {
                    self.extension_ = dict["Extension"] as! String
                }
                if dict.keys.contains("Heartbeat") && dict["Heartbeat"] != nil {
                    self.heartbeat = dict["Heartbeat"] as! Int64
                }
                if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("JobId") && dict["JobId"] != nil {
                    self.jobId = dict["JobId"] as! String
                }
                if dict.keys.contains("Mobile") && dict["Mobile"] != nil {
                    self.mobile = dict["Mobile"] as! String
                }
                if dict.keys.contains("OutboundScenario") && dict["OutboundScenario"] != nil {
                    self.outboundScenario = dict["OutboundScenario"] as! Bool
                }
                if dict.keys.contains("Reserved") && dict["Reserved"] != nil {
                    self.reserved = dict["Reserved"] as! Int64
                }
                if dict.keys.contains("SignedSkillGroupIdList") && dict["SignedSkillGroupIdList"] != nil {
                    self.signedSkillGroupIdList = dict["SignedSkillGroupIdList"] as! [String]
                }
                if dict.keys.contains("UserId") && dict["UserId"] != nil {
                    self.userId = dict["UserId"] as! String
                }
                if dict.keys.contains("UserState") && dict["UserState"] != nil {
                    self.userState = dict["UserState"] as! String
                }
                if dict.keys.contains("WorkMode") && dict["WorkMode"] != nil {
                    self.workMode = dict["WorkMode"] as! String
                }
            }
        }
        public var callContext: StartBack2BackCallResponseBody.Data.CallContext?

        public var userContext: StartBack2BackCallResponseBody.Data.UserContext?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.callContext?.validate()
            try self.userContext?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.callContext != nil {
                map["CallContext"] = self.callContext?.toMap()
            }
            if self.userContext != nil {
                map["UserContext"] = self.userContext?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CallContext") && dict["CallContext"] != nil {
                var model = StartBack2BackCallResponseBody.Data.CallContext()
                model.fromMap(dict["CallContext"] as! [String: Any])
                self.callContext = model
            }
            if dict.keys.contains("UserContext") && dict["UserContext"] != nil {
                var model = StartBack2BackCallResponseBody.Data.UserContext()
                model.fromMap(dict["UserContext"] as! [String: Any])
                self.userContext = model
            }
        }
    }
    public var code: String?

    public var data: StartBack2BackCallResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var params: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.params != nil {
            map["Params"] = self.params!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = StartBack2BackCallResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Params") && dict["Params"] != nil {
            self.params = dict["Params"] as! [String]
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class StartBack2BackCallResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StartBack2BackCallResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = StartBack2BackCallResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class StartConferenceRequest : Tea.TeaModel {
    public var instanceId: String?

    public var participantListJson: String?

    public var tags: String?

    public var timeoutSeconds: Int32?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.participantListJson != nil {
            map["ParticipantListJson"] = self.participantListJson!
        }
        if self.tags != nil {
            map["Tags"] = self.tags!
        }
        if self.timeoutSeconds != nil {
            map["TimeoutSeconds"] = self.timeoutSeconds!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("ParticipantListJson") && dict["ParticipantListJson"] != nil {
            self.participantListJson = dict["ParticipantListJson"] as! String
        }
        if dict.keys.contains("Tags") && dict["Tags"] != nil {
            self.tags = dict["Tags"] as! String
        }
        if dict.keys.contains("TimeoutSeconds") && dict["TimeoutSeconds"] != nil {
            self.timeoutSeconds = dict["TimeoutSeconds"] as! Int32
        }
        if dict.keys.contains("UserId") && dict["UserId"] != nil {
            self.userId = dict["UserId"] as! String
        }
    }
}

public class StartConferenceResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class CallContext : Tea.TeaModel {
            public class ChannelContexts : Tea.TeaModel {
                public var callType: String?

                public var channelFlags: String?

                public var channelId: String?

                public var channelState: String?

                public var destination: String?

                public var jobId: String?

                public var originator: String?

                public var releaseInitiator: String?

                public var releaseReason: String?

                public var timestamp: Int64?

                public var userExtension: String?

                public var userId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.callType != nil {
                        map["CallType"] = self.callType!
                    }
                    if self.channelFlags != nil {
                        map["ChannelFlags"] = self.channelFlags!
                    }
                    if self.channelId != nil {
                        map["ChannelId"] = self.channelId!
                    }
                    if self.channelState != nil {
                        map["ChannelState"] = self.channelState!
                    }
                    if self.destination != nil {
                        map["Destination"] = self.destination!
                    }
                    if self.jobId != nil {
                        map["JobId"] = self.jobId!
                    }
                    if self.originator != nil {
                        map["Originator"] = self.originator!
                    }
                    if self.releaseInitiator != nil {
                        map["ReleaseInitiator"] = self.releaseInitiator!
                    }
                    if self.releaseReason != nil {
                        map["ReleaseReason"] = self.releaseReason!
                    }
                    if self.timestamp != nil {
                        map["Timestamp"] = self.timestamp!
                    }
                    if self.userExtension != nil {
                        map["UserExtension"] = self.userExtension!
                    }
                    if self.userId != nil {
                        map["UserId"] = self.userId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("CallType") && dict["CallType"] != nil {
                        self.callType = dict["CallType"] as! String
                    }
                    if dict.keys.contains("ChannelFlags") && dict["ChannelFlags"] != nil {
                        self.channelFlags = dict["ChannelFlags"] as! String
                    }
                    if dict.keys.contains("ChannelId") && dict["ChannelId"] != nil {
                        self.channelId = dict["ChannelId"] as! String
                    }
                    if dict.keys.contains("ChannelState") && dict["ChannelState"] != nil {
                        self.channelState = dict["ChannelState"] as! String
                    }
                    if dict.keys.contains("Destination") && dict["Destination"] != nil {
                        self.destination = dict["Destination"] as! String
                    }
                    if dict.keys.contains("JobId") && dict["JobId"] != nil {
                        self.jobId = dict["JobId"] as! String
                    }
                    if dict.keys.contains("Originator") && dict["Originator"] != nil {
                        self.originator = dict["Originator"] as! String
                    }
                    if dict.keys.contains("ReleaseInitiator") && dict["ReleaseInitiator"] != nil {
                        self.releaseInitiator = dict["ReleaseInitiator"] as! String
                    }
                    if dict.keys.contains("ReleaseReason") && dict["ReleaseReason"] != nil {
                        self.releaseReason = dict["ReleaseReason"] as! String
                    }
                    if dict.keys.contains("Timestamp") && dict["Timestamp"] != nil {
                        self.timestamp = dict["Timestamp"] as! Int64
                    }
                    if dict.keys.contains("UserExtension") && dict["UserExtension"] != nil {
                        self.userExtension = dict["UserExtension"] as! String
                    }
                    if dict.keys.contains("UserId") && dict["UserId"] != nil {
                        self.userId = dict["UserId"] as! String
                    }
                }
            }
            public var callType: String?

            public var channelContexts: [StartConferenceResponseBody.Data.CallContext.ChannelContexts]?

            public var instanceId: String?

            public var jobId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.callType != nil {
                    map["CallType"] = self.callType!
                }
                if self.channelContexts != nil {
                    var tmp : [Any] = []
                    for k in self.channelContexts! {
                        tmp.append(k.toMap())
                    }
                    map["ChannelContexts"] = tmp
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.jobId != nil {
                    map["JobId"] = self.jobId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CallType") && dict["CallType"] != nil {
                    self.callType = dict["CallType"] as! String
                }
                if dict.keys.contains("ChannelContexts") && dict["ChannelContexts"] != nil {
                    var tmp : [StartConferenceResponseBody.Data.CallContext.ChannelContexts] = []
                    for v in dict["ChannelContexts"] as! [Any] {
                        var model = StartConferenceResponseBody.Data.CallContext.ChannelContexts()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.channelContexts = tmp
                }
                if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("JobId") && dict["JobId"] != nil {
                    self.jobId = dict["JobId"] as! String
                }
            }
        }
        public class UserContext : Tea.TeaModel {
            public var breakCode: String?

            public var deviceId: String?

            public var deviceState: String?

            public var extension_: String?

            public var heartbeat: Int64?

            public var instanceId: String?

            public var jobId: String?

            public var mobile: String?

            public var outboundScenario: Bool?

            public var reserved: Int64?

            public var signedSkillGroupIdList: [String]?

            public var userId: String?

            public var userState: String?

            public var workMode: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.breakCode != nil {
                    map["BreakCode"] = self.breakCode!
                }
                if self.deviceId != nil {
                    map["DeviceId"] = self.deviceId!
                }
                if self.deviceState != nil {
                    map["DeviceState"] = self.deviceState!
                }
                if self.extension_ != nil {
                    map["Extension"] = self.extension_!
                }
                if self.heartbeat != nil {
                    map["Heartbeat"] = self.heartbeat!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.jobId != nil {
                    map["JobId"] = self.jobId!
                }
                if self.mobile != nil {
                    map["Mobile"] = self.mobile!
                }
                if self.outboundScenario != nil {
                    map["OutboundScenario"] = self.outboundScenario!
                }
                if self.reserved != nil {
                    map["Reserved"] = self.reserved!
                }
                if self.signedSkillGroupIdList != nil {
                    map["SignedSkillGroupIdList"] = self.signedSkillGroupIdList!
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                if self.userState != nil {
                    map["UserState"] = self.userState!
                }
                if self.workMode != nil {
                    map["WorkMode"] = self.workMode!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BreakCode") && dict["BreakCode"] != nil {
                    self.breakCode = dict["BreakCode"] as! String
                }
                if dict.keys.contains("DeviceId") && dict["DeviceId"] != nil {
                    self.deviceId = dict["DeviceId"] as! String
                }
                if dict.keys.contains("DeviceState") && dict["DeviceState"] != nil {
                    self.deviceState = dict["DeviceState"] as! String
                }
                if dict.keys.contains("Extension") && dict["Extension"] != nil {
                    self.extension_ = dict["Extension"] as! String
                }
                if dict.keys.contains("Heartbeat") && dict["Heartbeat"] != nil {
                    self.heartbeat = dict["Heartbeat"] as! Int64
                }
                if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("JobId") && dict["JobId"] != nil {
                    self.jobId = dict["JobId"] as! String
                }
                if dict.keys.contains("Mobile") && dict["Mobile"] != nil {
                    self.mobile = dict["Mobile"] as! String
                }
                if dict.keys.contains("OutboundScenario") && dict["OutboundScenario"] != nil {
                    self.outboundScenario = dict["OutboundScenario"] as! Bool
                }
                if dict.keys.contains("Reserved") && dict["Reserved"] != nil {
                    self.reserved = dict["Reserved"] as! Int64
                }
                if dict.keys.contains("SignedSkillGroupIdList") && dict["SignedSkillGroupIdList"] != nil {
                    self.signedSkillGroupIdList = dict["SignedSkillGroupIdList"] as! [String]
                }
                if dict.keys.contains("UserId") && dict["UserId"] != nil {
                    self.userId = dict["UserId"] as! String
                }
                if dict.keys.contains("UserState") && dict["UserState"] != nil {
                    self.userState = dict["UserState"] as! String
                }
                if dict.keys.contains("WorkMode") && dict["WorkMode"] != nil {
                    self.workMode = dict["WorkMode"] as! String
                }
            }
        }
        public var callContext: StartConferenceResponseBody.Data.CallContext?

        public var userContext: StartConferenceResponseBody.Data.UserContext?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.callContext?.validate()
            try self.userContext?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.callContext != nil {
                map["CallContext"] = self.callContext?.toMap()
            }
            if self.userContext != nil {
                map["UserContext"] = self.userContext?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CallContext") && dict["CallContext"] != nil {
                var model = StartConferenceResponseBody.Data.CallContext()
                model.fromMap(dict["CallContext"] as! [String: Any])
                self.callContext = model
            }
            if dict.keys.contains("UserContext") && dict["UserContext"] != nil {
                var model = StartConferenceResponseBody.Data.UserContext()
                model.fromMap(dict["UserContext"] as! [String: Any])
                self.userContext = model
            }
        }
    }
    public var code: String?

    public var data: StartConferenceResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var params: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.params != nil {
            map["Params"] = self.params!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = StartConferenceResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Params") && dict["Params"] != nil {
            self.params = dict["Params"] as! [String]
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class StartConferenceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StartConferenceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = StartConferenceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class StartEditContactFlowRequest : Tea.TeaModel {
    public var contactFlowId: String?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.contactFlowId != nil {
            map["ContactFlowId"] = self.contactFlowId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ContactFlowId") && dict["ContactFlowId"] != nil {
            self.contactFlowId = dict["ContactFlowId"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
    }
}

public class StartEditContactFlowResponseBody : Tea.TeaModel {
    public var code: String?

    public var data: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class StartEditContactFlowResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StartEditContactFlowResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = StartEditContactFlowResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class StartPredictiveCallRequest : Tea.TeaModel {
    public var callee: String?

    public var caller: String?

    public var contactFlowId: String?

    public var contactFlowVariables: String?

    public var instanceId: String?

    public var maskedCallee: String?

    public var skillGroupId: String?

    public var tags: String?

    public var timeoutSeconds: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.callee != nil {
            map["Callee"] = self.callee!
        }
        if self.caller != nil {
            map["Caller"] = self.caller!
        }
        if self.contactFlowId != nil {
            map["ContactFlowId"] = self.contactFlowId!
        }
        if self.contactFlowVariables != nil {
            map["ContactFlowVariables"] = self.contactFlowVariables!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.maskedCallee != nil {
            map["MaskedCallee"] = self.maskedCallee!
        }
        if self.skillGroupId != nil {
            map["SkillGroupId"] = self.skillGroupId!
        }
        if self.tags != nil {
            map["Tags"] = self.tags!
        }
        if self.timeoutSeconds != nil {
            map["TimeoutSeconds"] = self.timeoutSeconds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Callee") && dict["Callee"] != nil {
            self.callee = dict["Callee"] as! String
        }
        if dict.keys.contains("Caller") && dict["Caller"] != nil {
            self.caller = dict["Caller"] as! String
        }
        if dict.keys.contains("ContactFlowId") && dict["ContactFlowId"] != nil {
            self.contactFlowId = dict["ContactFlowId"] as! String
        }
        if dict.keys.contains("ContactFlowVariables") && dict["ContactFlowVariables"] != nil {
            self.contactFlowVariables = dict["ContactFlowVariables"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("MaskedCallee") && dict["MaskedCallee"] != nil {
            self.maskedCallee = dict["MaskedCallee"] as! String
        }
        if dict.keys.contains("SkillGroupId") && dict["SkillGroupId"] != nil {
            self.skillGroupId = dict["SkillGroupId"] as! String
        }
        if dict.keys.contains("Tags") && dict["Tags"] != nil {
            self.tags = dict["Tags"] as! String
        }
        if dict.keys.contains("TimeoutSeconds") && dict["TimeoutSeconds"] != nil {
            self.timeoutSeconds = dict["TimeoutSeconds"] as! Int32
        }
    }
}

public class StartPredictiveCallResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class CallContext : Tea.TeaModel {
            public class ChannelContexts : Tea.TeaModel {
                public var callType: String?

                public var channelFlags: String?

                public var channelId: String?

                public var channelState: String?

                public var destination: String?

                public var jobId: String?

                public var originator: String?

                public var releaseInitiator: String?

                public var releaseReason: String?

                public var timestamp: Int64?

                public var userExtension: String?

                public var userId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.callType != nil {
                        map["CallType"] = self.callType!
                    }
                    if self.channelFlags != nil {
                        map["ChannelFlags"] = self.channelFlags!
                    }
                    if self.channelId != nil {
                        map["ChannelId"] = self.channelId!
                    }
                    if self.channelState != nil {
                        map["ChannelState"] = self.channelState!
                    }
                    if self.destination != nil {
                        map["Destination"] = self.destination!
                    }
                    if self.jobId != nil {
                        map["JobId"] = self.jobId!
                    }
                    if self.originator != nil {
                        map["Originator"] = self.originator!
                    }
                    if self.releaseInitiator != nil {
                        map["ReleaseInitiator"] = self.releaseInitiator!
                    }
                    if self.releaseReason != nil {
                        map["ReleaseReason"] = self.releaseReason!
                    }
                    if self.timestamp != nil {
                        map["Timestamp"] = self.timestamp!
                    }
                    if self.userExtension != nil {
                        map["UserExtension"] = self.userExtension!
                    }
                    if self.userId != nil {
                        map["UserId"] = self.userId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("CallType") && dict["CallType"] != nil {
                        self.callType = dict["CallType"] as! String
                    }
                    if dict.keys.contains("ChannelFlags") && dict["ChannelFlags"] != nil {
                        self.channelFlags = dict["ChannelFlags"] as! String
                    }
                    if dict.keys.contains("ChannelId") && dict["ChannelId"] != nil {
                        self.channelId = dict["ChannelId"] as! String
                    }
                    if dict.keys.contains("ChannelState") && dict["ChannelState"] != nil {
                        self.channelState = dict["ChannelState"] as! String
                    }
                    if dict.keys.contains("Destination") && dict["Destination"] != nil {
                        self.destination = dict["Destination"] as! String
                    }
                    if dict.keys.contains("JobId") && dict["JobId"] != nil {
                        self.jobId = dict["JobId"] as! String
                    }
                    if dict.keys.contains("Originator") && dict["Originator"] != nil {
                        self.originator = dict["Originator"] as! String
                    }
                    if dict.keys.contains("ReleaseInitiator") && dict["ReleaseInitiator"] != nil {
                        self.releaseInitiator = dict["ReleaseInitiator"] as! String
                    }
                    if dict.keys.contains("ReleaseReason") && dict["ReleaseReason"] != nil {
                        self.releaseReason = dict["ReleaseReason"] as! String
                    }
                    if dict.keys.contains("Timestamp") && dict["Timestamp"] != nil {
                        self.timestamp = dict["Timestamp"] as! Int64
                    }
                    if dict.keys.contains("UserExtension") && dict["UserExtension"] != nil {
                        self.userExtension = dict["UserExtension"] as! String
                    }
                    if dict.keys.contains("UserId") && dict["UserId"] != nil {
                        self.userId = dict["UserId"] as! String
                    }
                }
            }
            public var callType: String?

            public var channelContexts: [StartPredictiveCallResponseBody.Data.CallContext.ChannelContexts]?

            public var instanceId: String?

            public var jobId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.callType != nil {
                    map["CallType"] = self.callType!
                }
                if self.channelContexts != nil {
                    var tmp : [Any] = []
                    for k in self.channelContexts! {
                        tmp.append(k.toMap())
                    }
                    map["ChannelContexts"] = tmp
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.jobId != nil {
                    map["JobId"] = self.jobId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CallType") && dict["CallType"] != nil {
                    self.callType = dict["CallType"] as! String
                }
                if dict.keys.contains("ChannelContexts") && dict["ChannelContexts"] != nil {
                    var tmp : [StartPredictiveCallResponseBody.Data.CallContext.ChannelContexts] = []
                    for v in dict["ChannelContexts"] as! [Any] {
                        var model = StartPredictiveCallResponseBody.Data.CallContext.ChannelContexts()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.channelContexts = tmp
                }
                if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("JobId") && dict["JobId"] != nil {
                    self.jobId = dict["JobId"] as! String
                }
            }
        }
        public class UserContext : Tea.TeaModel {
            public var breakCode: String?

            public var deviceId: String?

            public var deviceState: String?

            public var extension_: String?

            public var heartbeat: Int64?

            public var instanceId: String?

            public var jobId: String?

            public var mobile: String?

            public var outboundScenario: Bool?

            public var reserved: Int64?

            public var signedSkillGroupIdList: [String]?

            public var userId: String?

            public var userState: String?

            public var workMode: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.breakCode != nil {
                    map["BreakCode"] = self.breakCode!
                }
                if self.deviceId != nil {
                    map["DeviceId"] = self.deviceId!
                }
                if self.deviceState != nil {
                    map["DeviceState"] = self.deviceState!
                }
                if self.extension_ != nil {
                    map["Extension"] = self.extension_!
                }
                if self.heartbeat != nil {
                    map["Heartbeat"] = self.heartbeat!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.jobId != nil {
                    map["JobId"] = self.jobId!
                }
                if self.mobile != nil {
                    map["Mobile"] = self.mobile!
                }
                if self.outboundScenario != nil {
                    map["OutboundScenario"] = self.outboundScenario!
                }
                if self.reserved != nil {
                    map["Reserved"] = self.reserved!
                }
                if self.signedSkillGroupIdList != nil {
                    map["SignedSkillGroupIdList"] = self.signedSkillGroupIdList!
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                if self.userState != nil {
                    map["UserState"] = self.userState!
                }
                if self.workMode != nil {
                    map["WorkMode"] = self.workMode!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BreakCode") && dict["BreakCode"] != nil {
                    self.breakCode = dict["BreakCode"] as! String
                }
                if dict.keys.contains("DeviceId") && dict["DeviceId"] != nil {
                    self.deviceId = dict["DeviceId"] as! String
                }
                if dict.keys.contains("DeviceState") && dict["DeviceState"] != nil {
                    self.deviceState = dict["DeviceState"] as! String
                }
                if dict.keys.contains("Extension") && dict["Extension"] != nil {
                    self.extension_ = dict["Extension"] as! String
                }
                if dict.keys.contains("Heartbeat") && dict["Heartbeat"] != nil {
                    self.heartbeat = dict["Heartbeat"] as! Int64
                }
                if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("JobId") && dict["JobId"] != nil {
                    self.jobId = dict["JobId"] as! String
                }
                if dict.keys.contains("Mobile") && dict["Mobile"] != nil {
                    self.mobile = dict["Mobile"] as! String
                }
                if dict.keys.contains("OutboundScenario") && dict["OutboundScenario"] != nil {
                    self.outboundScenario = dict["OutboundScenario"] as! Bool
                }
                if dict.keys.contains("Reserved") && dict["Reserved"] != nil {
                    self.reserved = dict["Reserved"] as! Int64
                }
                if dict.keys.contains("SignedSkillGroupIdList") && dict["SignedSkillGroupIdList"] != nil {
                    self.signedSkillGroupIdList = dict["SignedSkillGroupIdList"] as! [String]
                }
                if dict.keys.contains("UserId") && dict["UserId"] != nil {
                    self.userId = dict["UserId"] as! String
                }
                if dict.keys.contains("UserState") && dict["UserState"] != nil {
                    self.userState = dict["UserState"] as! String
                }
                if dict.keys.contains("WorkMode") && dict["WorkMode"] != nil {
                    self.workMode = dict["WorkMode"] as! String
                }
            }
        }
        public var callContext: StartPredictiveCallResponseBody.Data.CallContext?

        public var userContext: StartPredictiveCallResponseBody.Data.UserContext?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.callContext?.validate()
            try self.userContext?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.callContext != nil {
                map["CallContext"] = self.callContext?.toMap()
            }
            if self.userContext != nil {
                map["UserContext"] = self.userContext?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CallContext") && dict["CallContext"] != nil {
                var model = StartPredictiveCallResponseBody.Data.CallContext()
                model.fromMap(dict["CallContext"] as! [String: Any])
                self.callContext = model
            }
            if dict.keys.contains("UserContext") && dict["UserContext"] != nil {
                var model = StartPredictiveCallResponseBody.Data.UserContext()
                model.fromMap(dict["UserContext"] as! [String: Any])
                self.userContext = model
            }
        }
    }
    public var code: String?

    public var data: StartPredictiveCallResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var params: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.params != nil {
            map["Params"] = self.params!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = StartPredictiveCallResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Params") && dict["Params"] != nil {
            self.params = dict["Params"] as! [String]
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class StartPredictiveCallResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StartPredictiveCallResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = StartPredictiveCallResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class StartPrivacyCallRequest : Tea.TeaModel {
    public var appId: String?

    public var callee: String?

    public var caller: String?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.callee != nil {
            map["Callee"] = self.callee!
        }
        if self.caller != nil {
            map["Caller"] = self.caller!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("Callee") && dict["Callee"] != nil {
            self.callee = dict["Callee"] as! String
        }
        if dict.keys.contains("Caller") && dict["Caller"] != nil {
            self.caller = dict["Caller"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
    }
}

public class StartPrivacyCallResponseBody : Tea.TeaModel {
    public var code: String?

    public var data: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var params: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.params != nil {
            map["Params"] = self.params!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Params") && dict["Params"] != nil {
            self.params = dict["Params"] as! [String]
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class StartPrivacyCallResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StartPrivacyCallResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = StartPrivacyCallResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SubmitCampaignRequest : Tea.TeaModel {
    public var campaignId: String?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.campaignId != nil {
            map["CampaignId"] = self.campaignId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CampaignId") && dict["CampaignId"] != nil {
            self.campaignId = dict["CampaignId"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
    }
}

public class SubmitCampaignResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpStatusCode: String?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! String
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SubmitCampaignResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SubmitCampaignResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = SubmitCampaignResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SwitchToConferenceRequest : Tea.TeaModel {
    public var deviceId: String?

    public var instanceId: String?

    public var jobId: String?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.deviceId != nil {
            map["DeviceId"] = self.deviceId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DeviceId") && dict["DeviceId"] != nil {
            self.deviceId = dict["DeviceId"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("JobId") && dict["JobId"] != nil {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("UserId") && dict["UserId"] != nil {
            self.userId = dict["UserId"] as! String
        }
    }
}

public class SwitchToConferenceResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class CallContext : Tea.TeaModel {
            public class ChannelContexts : Tea.TeaModel {
                public var callType: String?

                public var channelFlags: String?

                public var channelId: String?

                public var channelState: String?

                public var destination: String?

                public var index: Int32?

                public var jobId: String?

                public var originator: String?

                public var releaseInitiator: String?

                public var releaseReason: String?

                public var skillGroupId: String?

                public var timestamp: Int64?

                public var userExtension: String?

                public var userId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.callType != nil {
                        map["CallType"] = self.callType!
                    }
                    if self.channelFlags != nil {
                        map["ChannelFlags"] = self.channelFlags!
                    }
                    if self.channelId != nil {
                        map["ChannelId"] = self.channelId!
                    }
                    if self.channelState != nil {
                        map["ChannelState"] = self.channelState!
                    }
                    if self.destination != nil {
                        map["Destination"] = self.destination!
                    }
                    if self.index != nil {
                        map["Index"] = self.index!
                    }
                    if self.jobId != nil {
                        map["JobId"] = self.jobId!
                    }
                    if self.originator != nil {
                        map["Originator"] = self.originator!
                    }
                    if self.releaseInitiator != nil {
                        map["ReleaseInitiator"] = self.releaseInitiator!
                    }
                    if self.releaseReason != nil {
                        map["ReleaseReason"] = self.releaseReason!
                    }
                    if self.skillGroupId != nil {
                        map["SkillGroupId"] = self.skillGroupId!
                    }
                    if self.timestamp != nil {
                        map["Timestamp"] = self.timestamp!
                    }
                    if self.userExtension != nil {
                        map["UserExtension"] = self.userExtension!
                    }
                    if self.userId != nil {
                        map["UserId"] = self.userId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("CallType") && dict["CallType"] != nil {
                        self.callType = dict["CallType"] as! String
                    }
                    if dict.keys.contains("ChannelFlags") && dict["ChannelFlags"] != nil {
                        self.channelFlags = dict["ChannelFlags"] as! String
                    }
                    if dict.keys.contains("ChannelId") && dict["ChannelId"] != nil {
                        self.channelId = dict["ChannelId"] as! String
                    }
                    if dict.keys.contains("ChannelState") && dict["ChannelState"] != nil {
                        self.channelState = dict["ChannelState"] as! String
                    }
                    if dict.keys.contains("Destination") && dict["Destination"] != nil {
                        self.destination = dict["Destination"] as! String
                    }
                    if dict.keys.contains("Index") && dict["Index"] != nil {
                        self.index = dict["Index"] as! Int32
                    }
                    if dict.keys.contains("JobId") && dict["JobId"] != nil {
                        self.jobId = dict["JobId"] as! String
                    }
                    if dict.keys.contains("Originator") && dict["Originator"] != nil {
                        self.originator = dict["Originator"] as! String
                    }
                    if dict.keys.contains("ReleaseInitiator") && dict["ReleaseInitiator"] != nil {
                        self.releaseInitiator = dict["ReleaseInitiator"] as! String
                    }
                    if dict.keys.contains("ReleaseReason") && dict["ReleaseReason"] != nil {
                        self.releaseReason = dict["ReleaseReason"] as! String
                    }
                    if dict.keys.contains("SkillGroupId") && dict["SkillGroupId"] != nil {
                        self.skillGroupId = dict["SkillGroupId"] as! String
                    }
                    if dict.keys.contains("Timestamp") && dict["Timestamp"] != nil {
                        self.timestamp = dict["Timestamp"] as! Int64
                    }
                    if dict.keys.contains("UserExtension") && dict["UserExtension"] != nil {
                        self.userExtension = dict["UserExtension"] as! String
                    }
                    if dict.keys.contains("UserId") && dict["UserId"] != nil {
                        self.userId = dict["UserId"] as! String
                    }
                }
            }
            public var callType: String?

            public var channelContexts: [SwitchToConferenceResponseBody.Data.CallContext.ChannelContexts]?

            public var instanceId: String?

            public var jobId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.callType != nil {
                    map["CallType"] = self.callType!
                }
                if self.channelContexts != nil {
                    var tmp : [Any] = []
                    for k in self.channelContexts! {
                        tmp.append(k.toMap())
                    }
                    map["ChannelContexts"] = tmp
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.jobId != nil {
                    map["JobId"] = self.jobId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CallType") && dict["CallType"] != nil {
                    self.callType = dict["CallType"] as! String
                }
                if dict.keys.contains("ChannelContexts") && dict["ChannelContexts"] != nil {
                    var tmp : [SwitchToConferenceResponseBody.Data.CallContext.ChannelContexts] = []
                    for v in dict["ChannelContexts"] as! [Any] {
                        var model = SwitchToConferenceResponseBody.Data.CallContext.ChannelContexts()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.channelContexts = tmp
                }
                if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("JobId") && dict["JobId"] != nil {
                    self.jobId = dict["JobId"] as! String
                }
            }
        }
        public class UserContext : Tea.TeaModel {
            public var breakCode: String?

            public var deviceId: String?

            public var deviceState: String?

            public var extension_: String?

            public var heartbeat: Int64?

            public var instanceId: String?

            public var jobId: String?

            public var mobile: String?

            public var outboundScenario: Bool?

            public var signedSkillGroupIdList: [String]?

            public var userId: String?

            public var userState: String?

            public var workMode: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.breakCode != nil {
                    map["BreakCode"] = self.breakCode!
                }
                if self.deviceId != nil {
                    map["DeviceId"] = self.deviceId!
                }
                if self.deviceState != nil {
                    map["DeviceState"] = self.deviceState!
                }
                if self.extension_ != nil {
                    map["Extension"] = self.extension_!
                }
                if self.heartbeat != nil {
                    map["Heartbeat"] = self.heartbeat!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.jobId != nil {
                    map["JobId"] = self.jobId!
                }
                if self.mobile != nil {
                    map["Mobile"] = self.mobile!
                }
                if self.outboundScenario != nil {
                    map["OutboundScenario"] = self.outboundScenario!
                }
                if self.signedSkillGroupIdList != nil {
                    map["SignedSkillGroupIdList"] = self.signedSkillGroupIdList!
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                if self.userState != nil {
                    map["UserState"] = self.userState!
                }
                if self.workMode != nil {
                    map["WorkMode"] = self.workMode!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BreakCode") && dict["BreakCode"] != nil {
                    self.breakCode = dict["BreakCode"] as! String
                }
                if dict.keys.contains("DeviceId") && dict["DeviceId"] != nil {
                    self.deviceId = dict["DeviceId"] as! String
                }
                if dict.keys.contains("DeviceState") && dict["DeviceState"] != nil {
                    self.deviceState = dict["DeviceState"] as! String
                }
                if dict.keys.contains("Extension") && dict["Extension"] != nil {
                    self.extension_ = dict["Extension"] as! String
                }
                if dict.keys.contains("Heartbeat") && dict["Heartbeat"] != nil {
                    self.heartbeat = dict["Heartbeat"] as! Int64
                }
                if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("JobId") && dict["JobId"] != nil {
                    self.jobId = dict["JobId"] as! String
                }
                if dict.keys.contains("Mobile") && dict["Mobile"] != nil {
                    self.mobile = dict["Mobile"] as! String
                }
                if dict.keys.contains("OutboundScenario") && dict["OutboundScenario"] != nil {
                    self.outboundScenario = dict["OutboundScenario"] as! Bool
                }
                if dict.keys.contains("SignedSkillGroupIdList") && dict["SignedSkillGroupIdList"] != nil {
                    self.signedSkillGroupIdList = dict["SignedSkillGroupIdList"] as! [String]
                }
                if dict.keys.contains("UserId") && dict["UserId"] != nil {
                    self.userId = dict["UserId"] as! String
                }
                if dict.keys.contains("UserState") && dict["UserState"] != nil {
                    self.userState = dict["UserState"] as! String
                }
                if dict.keys.contains("WorkMode") && dict["WorkMode"] != nil {
                    self.workMode = dict["WorkMode"] as! String
                }
            }
        }
        public var callContext: SwitchToConferenceResponseBody.Data.CallContext?

        public var userContext: SwitchToConferenceResponseBody.Data.UserContext?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.callContext?.validate()
            try self.userContext?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.callContext != nil {
                map["CallContext"] = self.callContext?.toMap()
            }
            if self.userContext != nil {
                map["UserContext"] = self.userContext?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CallContext") && dict["CallContext"] != nil {
                var model = SwitchToConferenceResponseBody.Data.CallContext()
                model.fromMap(dict["CallContext"] as! [String: Any])
                self.callContext = model
            }
            if dict.keys.contains("UserContext") && dict["UserContext"] != nil {
                var model = SwitchToConferenceResponseBody.Data.UserContext()
                model.fromMap(dict["UserContext"] as! [String: Any])
                self.userContext = model
            }
        }
    }
    public var code: String?

    public var data: SwitchToConferenceResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var params: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.params != nil {
            map["Params"] = self.params!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = SwitchToConferenceResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Params") && dict["Params"] != nil {
            self.params = dict["Params"] as! [String]
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SwitchToConferenceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SwitchToConferenceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = SwitchToConferenceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class TakeBreakRequest : Tea.TeaModel {
    public var code: String?

    public var deviceId: String?

    public var instanceId: String?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.deviceId != nil {
            map["DeviceId"] = self.deviceId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("DeviceId") && dict["DeviceId"] != nil {
            self.deviceId = dict["DeviceId"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("UserId") && dict["UserId"] != nil {
            self.userId = dict["UserId"] as! String
        }
    }
}

public class TakeBreakResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public var breakCode: String?

        public var deviceId: String?

        public var extension_: String?

        public var heartbeat: Int64?

        public var instanceId: String?

        public var jobId: String?

        public var mobile: String?

        public var outboundScenario: Bool?

        public var reserved: Int64?

        public var signedSkillGroupIdList: [String]?

        public var userId: String?

        public var userState: String?

        public var workMode: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.breakCode != nil {
                map["BreakCode"] = self.breakCode!
            }
            if self.deviceId != nil {
                map["DeviceId"] = self.deviceId!
            }
            if self.extension_ != nil {
                map["Extension"] = self.extension_!
            }
            if self.heartbeat != nil {
                map["Heartbeat"] = self.heartbeat!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.jobId != nil {
                map["JobId"] = self.jobId!
            }
            if self.mobile != nil {
                map["Mobile"] = self.mobile!
            }
            if self.outboundScenario != nil {
                map["OutboundScenario"] = self.outboundScenario!
            }
            if self.reserved != nil {
                map["Reserved"] = self.reserved!
            }
            if self.signedSkillGroupIdList != nil {
                map["SignedSkillGroupIdList"] = self.signedSkillGroupIdList!
            }
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            if self.userState != nil {
                map["UserState"] = self.userState!
            }
            if self.workMode != nil {
                map["WorkMode"] = self.workMode!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BreakCode") && dict["BreakCode"] != nil {
                self.breakCode = dict["BreakCode"] as! String
            }
            if dict.keys.contains("DeviceId") && dict["DeviceId"] != nil {
                self.deviceId = dict["DeviceId"] as! String
            }
            if dict.keys.contains("Extension") && dict["Extension"] != nil {
                self.extension_ = dict["Extension"] as! String
            }
            if dict.keys.contains("Heartbeat") && dict["Heartbeat"] != nil {
                self.heartbeat = dict["Heartbeat"] as! Int64
            }
            if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("JobId") && dict["JobId"] != nil {
                self.jobId = dict["JobId"] as! String
            }
            if dict.keys.contains("Mobile") && dict["Mobile"] != nil {
                self.mobile = dict["Mobile"] as! String
            }
            if dict.keys.contains("OutboundScenario") && dict["OutboundScenario"] != nil {
                self.outboundScenario = dict["OutboundScenario"] as! Bool
            }
            if dict.keys.contains("Reserved") && dict["Reserved"] != nil {
                self.reserved = dict["Reserved"] as! Int64
            }
            if dict.keys.contains("SignedSkillGroupIdList") && dict["SignedSkillGroupIdList"] != nil {
                self.signedSkillGroupIdList = dict["SignedSkillGroupIdList"] as! [String]
            }
            if dict.keys.contains("UserId") && dict["UserId"] != nil {
                self.userId = dict["UserId"] as! String
            }
            if dict.keys.contains("UserState") && dict["UserState"] != nil {
                self.userState = dict["UserState"] as! String
            }
            if dict.keys.contains("WorkMode") && dict["WorkMode"] != nil {
                self.workMode = dict["WorkMode"] as! String
            }
        }
    }
    public var code: String?

    public var data: TakeBreakResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var params: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.params != nil {
            map["Params"] = self.params!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = TakeBreakResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Params") && dict["Params"] != nil {
            self.params = dict["Params"] as! [String]
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class TakeBreakResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: TakeBreakResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = TakeBreakResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UnmuteCallRequest : Tea.TeaModel {
    public var channelId: String?

    public var deviceId: String?

    public var instanceId: String?

    public var jobId: String?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.channelId != nil {
            map["ChannelId"] = self.channelId!
        }
        if self.deviceId != nil {
            map["DeviceId"] = self.deviceId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ChannelId") && dict["ChannelId"] != nil {
            self.channelId = dict["ChannelId"] as! String
        }
        if dict.keys.contains("DeviceId") && dict["DeviceId"] != nil {
            self.deviceId = dict["DeviceId"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("JobId") && dict["JobId"] != nil {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("UserId") && dict["UserId"] != nil {
            self.userId = dict["UserId"] as! String
        }
    }
}

public class UnmuteCallResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class CallContext : Tea.TeaModel {
            public class ChannelContexts : Tea.TeaModel {
                public var callType: String?

                public var channelFlags: String?

                public var channelId: String?

                public var channelState: String?

                public var destination: String?

                public var index: Int32?

                public var jobId: String?

                public var originator: String?

                public var releaseInitiator: String?

                public var releaseReason: String?

                public var skillGroupId: String?

                public var timestamp: Int64?

                public var userExtension: String?

                public var userId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.callType != nil {
                        map["CallType"] = self.callType!
                    }
                    if self.channelFlags != nil {
                        map["ChannelFlags"] = self.channelFlags!
                    }
                    if self.channelId != nil {
                        map["ChannelId"] = self.channelId!
                    }
                    if self.channelState != nil {
                        map["ChannelState"] = self.channelState!
                    }
                    if self.destination != nil {
                        map["Destination"] = self.destination!
                    }
                    if self.index != nil {
                        map["Index"] = self.index!
                    }
                    if self.jobId != nil {
                        map["JobId"] = self.jobId!
                    }
                    if self.originator != nil {
                        map["Originator"] = self.originator!
                    }
                    if self.releaseInitiator != nil {
                        map["ReleaseInitiator"] = self.releaseInitiator!
                    }
                    if self.releaseReason != nil {
                        map["ReleaseReason"] = self.releaseReason!
                    }
                    if self.skillGroupId != nil {
                        map["SkillGroupId"] = self.skillGroupId!
                    }
                    if self.timestamp != nil {
                        map["Timestamp"] = self.timestamp!
                    }
                    if self.userExtension != nil {
                        map["UserExtension"] = self.userExtension!
                    }
                    if self.userId != nil {
                        map["UserId"] = self.userId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("CallType") && dict["CallType"] != nil {
                        self.callType = dict["CallType"] as! String
                    }
                    if dict.keys.contains("ChannelFlags") && dict["ChannelFlags"] != nil {
                        self.channelFlags = dict["ChannelFlags"] as! String
                    }
                    if dict.keys.contains("ChannelId") && dict["ChannelId"] != nil {
                        self.channelId = dict["ChannelId"] as! String
                    }
                    if dict.keys.contains("ChannelState") && dict["ChannelState"] != nil {
                        self.channelState = dict["ChannelState"] as! String
                    }
                    if dict.keys.contains("Destination") && dict["Destination"] != nil {
                        self.destination = dict["Destination"] as! String
                    }
                    if dict.keys.contains("Index") && dict["Index"] != nil {
                        self.index = dict["Index"] as! Int32
                    }
                    if dict.keys.contains("JobId") && dict["JobId"] != nil {
                        self.jobId = dict["JobId"] as! String
                    }
                    if dict.keys.contains("Originator") && dict["Originator"] != nil {
                        self.originator = dict["Originator"] as! String
                    }
                    if dict.keys.contains("ReleaseInitiator") && dict["ReleaseInitiator"] != nil {
                        self.releaseInitiator = dict["ReleaseInitiator"] as! String
                    }
                    if dict.keys.contains("ReleaseReason") && dict["ReleaseReason"] != nil {
                        self.releaseReason = dict["ReleaseReason"] as! String
                    }
                    if dict.keys.contains("SkillGroupId") && dict["SkillGroupId"] != nil {
                        self.skillGroupId = dict["SkillGroupId"] as! String
                    }
                    if dict.keys.contains("Timestamp") && dict["Timestamp"] != nil {
                        self.timestamp = dict["Timestamp"] as! Int64
                    }
                    if dict.keys.contains("UserExtension") && dict["UserExtension"] != nil {
                        self.userExtension = dict["UserExtension"] as! String
                    }
                    if dict.keys.contains("UserId") && dict["UserId"] != nil {
                        self.userId = dict["UserId"] as! String
                    }
                }
            }
            public var callType: String?

            public var channelContexts: [UnmuteCallResponseBody.Data.CallContext.ChannelContexts]?

            public var instanceId: String?

            public var jobId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.callType != nil {
                    map["CallType"] = self.callType!
                }
                if self.channelContexts != nil {
                    var tmp : [Any] = []
                    for k in self.channelContexts! {
                        tmp.append(k.toMap())
                    }
                    map["ChannelContexts"] = tmp
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.jobId != nil {
                    map["JobId"] = self.jobId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CallType") && dict["CallType"] != nil {
                    self.callType = dict["CallType"] as! String
                }
                if dict.keys.contains("ChannelContexts") && dict["ChannelContexts"] != nil {
                    var tmp : [UnmuteCallResponseBody.Data.CallContext.ChannelContexts] = []
                    for v in dict["ChannelContexts"] as! [Any] {
                        var model = UnmuteCallResponseBody.Data.CallContext.ChannelContexts()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.channelContexts = tmp
                }
                if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("JobId") && dict["JobId"] != nil {
                    self.jobId = dict["JobId"] as! String
                }
            }
        }
        public class UserContext : Tea.TeaModel {
            public var breakCode: String?

            public var deviceId: String?

            public var extension_: String?

            public var heartbeat: Int64?

            public var instanceId: String?

            public var jobId: String?

            public var mobile: String?

            public var outboundScenario: Bool?

            public var signedSkillGroupIdList: [String]?

            public var userId: String?

            public var userState: String?

            public var workMode: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.breakCode != nil {
                    map["BreakCode"] = self.breakCode!
                }
                if self.deviceId != nil {
                    map["DeviceId"] = self.deviceId!
                }
                if self.extension_ != nil {
                    map["Extension"] = self.extension_!
                }
                if self.heartbeat != nil {
                    map["Heartbeat"] = self.heartbeat!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.jobId != nil {
                    map["JobId"] = self.jobId!
                }
                if self.mobile != nil {
                    map["Mobile"] = self.mobile!
                }
                if self.outboundScenario != nil {
                    map["OutboundScenario"] = self.outboundScenario!
                }
                if self.signedSkillGroupIdList != nil {
                    map["SignedSkillGroupIdList"] = self.signedSkillGroupIdList!
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                if self.userState != nil {
                    map["UserState"] = self.userState!
                }
                if self.workMode != nil {
                    map["WorkMode"] = self.workMode!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BreakCode") && dict["BreakCode"] != nil {
                    self.breakCode = dict["BreakCode"] as! String
                }
                if dict.keys.contains("DeviceId") && dict["DeviceId"] != nil {
                    self.deviceId = dict["DeviceId"] as! String
                }
                if dict.keys.contains("Extension") && dict["Extension"] != nil {
                    self.extension_ = dict["Extension"] as! String
                }
                if dict.keys.contains("Heartbeat") && dict["Heartbeat"] != nil {
                    self.heartbeat = dict["Heartbeat"] as! Int64
                }
                if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("JobId") && dict["JobId"] != nil {
                    self.jobId = dict["JobId"] as! String
                }
                if dict.keys.contains("Mobile") && dict["Mobile"] != nil {
                    self.mobile = dict["Mobile"] as! String
                }
                if dict.keys.contains("OutboundScenario") && dict["OutboundScenario"] != nil {
                    self.outboundScenario = dict["OutboundScenario"] as! Bool
                }
                if dict.keys.contains("SignedSkillGroupIdList") && dict["SignedSkillGroupIdList"] != nil {
                    self.signedSkillGroupIdList = dict["SignedSkillGroupIdList"] as! [String]
                }
                if dict.keys.contains("UserId") && dict["UserId"] != nil {
                    self.userId = dict["UserId"] as! String
                }
                if dict.keys.contains("UserState") && dict["UserState"] != nil {
                    self.userState = dict["UserState"] as! String
                }
                if dict.keys.contains("WorkMode") && dict["WorkMode"] != nil {
                    self.workMode = dict["WorkMode"] as! String
                }
            }
        }
        public var callContext: UnmuteCallResponseBody.Data.CallContext?

        public var userContext: UnmuteCallResponseBody.Data.UserContext?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.callContext?.validate()
            try self.userContext?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.callContext != nil {
                map["CallContext"] = self.callContext?.toMap()
            }
            if self.userContext != nil {
                map["UserContext"] = self.userContext?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CallContext") && dict["CallContext"] != nil {
                var model = UnmuteCallResponseBody.Data.CallContext()
                model.fromMap(dict["CallContext"] as! [String: Any])
                self.callContext = model
            }
            if dict.keys.contains("UserContext") && dict["UserContext"] != nil {
                var model = UnmuteCallResponseBody.Data.UserContext()
                model.fromMap(dict["UserContext"] as! [String: Any])
                self.userContext = model
            }
        }
    }
    public var code: String?

    public var data: UnmuteCallResponseBody.Data?

    public var httpStatusCode: Int32?

    public var message: String?

    public var params: [String]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.params != nil {
            map["Params"] = self.params!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Data") && dict["Data"] != nil {
            var model = UnmuteCallResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("Params") && dict["Params"] != nil {
            self.params = dict["Params"] as! [String]
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UnmuteCallResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UnmuteCallResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UnmuteCallResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UnregisterDeviceRequest : Tea.TeaModel {
    public var instanceId: String?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("UserId") && dict["UserId"] != nil {
            self.userId = dict["UserId"] as! String
        }
    }
}

public class UnregisterDeviceResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UnregisterDeviceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UnregisterDeviceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UnregisterDeviceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateConfigItemsRequest : Tea.TeaModel {
    public var configItems: String?

    public var instanceId: String?

    public var objectId: String?

    public var objectType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.configItems != nil {
            map["ConfigItems"] = self.configItems!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.objectId != nil {
            map["ObjectId"] = self.objectId!
        }
        if self.objectType != nil {
            map["ObjectType"] = self.objectType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ConfigItems") && dict["ConfigItems"] != nil {
            self.configItems = dict["ConfigItems"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("ObjectId") && dict["ObjectId"] != nil {
            self.objectId = dict["ObjectId"] as! String
        }
        if dict.keys.contains("ObjectType") && dict["ObjectType"] != nil {
            self.objectType = dict["ObjectType"] as! String
        }
    }
}

public class UpdateConfigItemsResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") && dict["Code"] != nil {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") && dict["HttpStatusCode"] != nil {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") && dict["Message"] != nil {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateConfigItemsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateConfigItemsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.validateRequired(self.headers, "headers")
        try self.validateRequired(self.statusCode, "statusCode")
        try self.validateRequired(self.body, "body")
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UpdateConfigItemsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}
