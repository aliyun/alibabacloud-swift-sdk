import Foundation
import Tea
import TeaUtils
import AlibabacloudOpenApi
import AlibabaCloudOpenApiUtil
import AlibabacloudEndpointUtil

public class AddUserToOrganizationalUnitsRequest : Tea.TeaModel {
    public var instanceId: String?

    public var organizationalUnitIds: [String]?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.organizationalUnitIds != nil {
            map["OrganizationalUnitIds"] = self.organizationalUnitIds!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["OrganizationalUnitIds"] as? [String] {
            self.organizationalUnitIds = value
        }
        if let value = dict["UserId"] as? String {
            self.userId = value
        }
    }
}

public class AddUserToOrganizationalUnitsResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class AddUserToOrganizationalUnitsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddUserToOrganizationalUnitsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = AddUserToOrganizationalUnitsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class AddUsersToGroupRequest : Tea.TeaModel {
    public var groupId: String?

    public var instanceId: String?

    public var userIds: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.userIds != nil {
            map["UserIds"] = self.userIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["GroupId"] as? String {
            self.groupId = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["UserIds"] as? [String] {
            self.userIds = value
        }
    }
}

public class AddUsersToGroupResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class AddUsersToGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddUsersToGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = AddUsersToGroupResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class AuthorizeApplicationToGroupsRequest : Tea.TeaModel {
    public var applicationId: String?

    public var groupIds: [String]?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.applicationId != nil {
            map["ApplicationId"] = self.applicationId!
        }
        if self.groupIds != nil {
            map["GroupIds"] = self.groupIds!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ApplicationId"] as? String {
            self.applicationId = value
        }
        if let value = dict["GroupIds"] as? [String] {
            self.groupIds = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
    }
}

public class AuthorizeApplicationToGroupsResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class AuthorizeApplicationToGroupsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AuthorizeApplicationToGroupsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = AuthorizeApplicationToGroupsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class AuthorizeApplicationToOrganizationalUnitsRequest : Tea.TeaModel {
    public var applicationId: String?

    public var instanceId: String?

    public var organizationalUnitIds: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.applicationId != nil {
            map["ApplicationId"] = self.applicationId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.organizationalUnitIds != nil {
            map["OrganizationalUnitIds"] = self.organizationalUnitIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ApplicationId"] as? String {
            self.applicationId = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["OrganizationalUnitIds"] as? [String] {
            self.organizationalUnitIds = value
        }
    }
}

public class AuthorizeApplicationToOrganizationalUnitsResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class AuthorizeApplicationToOrganizationalUnitsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AuthorizeApplicationToOrganizationalUnitsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = AuthorizeApplicationToOrganizationalUnitsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class AuthorizeApplicationToUsersRequest : Tea.TeaModel {
    public var applicationId: String?

    public var instanceId: String?

    public var userIds: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.applicationId != nil {
            map["ApplicationId"] = self.applicationId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.userIds != nil {
            map["UserIds"] = self.userIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ApplicationId"] as? String {
            self.applicationId = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["UserIds"] as? [String] {
            self.userIds = value
        }
    }
}

public class AuthorizeApplicationToUsersResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class AuthorizeApplicationToUsersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AuthorizeApplicationToUsersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = AuthorizeApplicationToUsersResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateApplicationRequest : Tea.TeaModel {
    public var applicationName: String?

    public var applicationSourceType: String?

    public var applicationTemplateId: String?

    public var description_: String?

    public var instanceId: String?

    public var logoUrl: String?

    public var ssoType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.applicationName != nil {
            map["ApplicationName"] = self.applicationName!
        }
        if self.applicationSourceType != nil {
            map["ApplicationSourceType"] = self.applicationSourceType!
        }
        if self.applicationTemplateId != nil {
            map["ApplicationTemplateId"] = self.applicationTemplateId!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.logoUrl != nil {
            map["LogoUrl"] = self.logoUrl!
        }
        if self.ssoType != nil {
            map["SsoType"] = self.ssoType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ApplicationName"] as? String {
            self.applicationName = value
        }
        if let value = dict["ApplicationSourceType"] as? String {
            self.applicationSourceType = value
        }
        if let value = dict["ApplicationTemplateId"] as? String {
            self.applicationTemplateId = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["LogoUrl"] as? String {
            self.logoUrl = value
        }
        if let value = dict["SsoType"] as? String {
            self.ssoType = value
        }
    }
}

public class CreateApplicationResponseBody : Tea.TeaModel {
    public var applicationId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.applicationId != nil {
            map["ApplicationId"] = self.applicationId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ApplicationId"] as? String {
            self.applicationId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class CreateApplicationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateApplicationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateApplicationResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateApplicationClientSecretRequest : Tea.TeaModel {
    public var applicationId: String?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.applicationId != nil {
            map["ApplicationId"] = self.applicationId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ApplicationId"] as? String {
            self.applicationId = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
    }
}

public class CreateApplicationClientSecretResponseBody : Tea.TeaModel {
    public class ApplicationClientSecret : Tea.TeaModel {
        public var clientId: String?

        public var clientSecret: String?

        public var secretId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.clientId != nil {
                map["ClientId"] = self.clientId!
            }
            if self.clientSecret != nil {
                map["ClientSecret"] = self.clientSecret!
            }
            if self.secretId != nil {
                map["SecretId"] = self.secretId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ClientId"] as? String {
                self.clientId = value
            }
            if let value = dict["ClientSecret"] as? String {
                self.clientSecret = value
            }
            if let value = dict["SecretId"] as? String {
                self.secretId = value
            }
        }
    }
    public var applicationClientSecret: CreateApplicationClientSecretResponseBody.ApplicationClientSecret?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.applicationClientSecret?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.applicationClientSecret != nil {
            map["ApplicationClientSecret"] = self.applicationClientSecret?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ApplicationClientSecret"] as? [String: Any?] {
            var model = CreateApplicationClientSecretResponseBody.ApplicationClientSecret()
            model.fromMap(value)
            self.applicationClientSecret = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class CreateApplicationClientSecretResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateApplicationClientSecretResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateApplicationClientSecretResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateConditionalAccessPolicyRequest : Tea.TeaModel {
    public class ConditionsConfig : Tea.TeaModel {
        public class Applications : Tea.TeaModel {
            public var excludeApplications: [String]?

            public var includeApplications: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.excludeApplications != nil {
                    map["ExcludeApplications"] = self.excludeApplications!
                }
                if self.includeApplications != nil {
                    map["IncludeApplications"] = self.includeApplications!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ExcludeApplications"] as? [String] {
                    self.excludeApplications = value
                }
                if let value = dict["IncludeApplications"] as? [String] {
                    self.includeApplications = value
                }
            }
        }
        public class NetworkZones : Tea.TeaModel {
            public var excludeNetworkZones: [String]?

            public var includeNetworkZones: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.excludeNetworkZones != nil {
                    map["ExcludeNetworkZones"] = self.excludeNetworkZones!
                }
                if self.includeNetworkZones != nil {
                    map["IncludeNetworkZones"] = self.includeNetworkZones!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ExcludeNetworkZones"] as? [String] {
                    self.excludeNetworkZones = value
                }
                if let value = dict["IncludeNetworkZones"] as? [String] {
                    self.includeNetworkZones = value
                }
            }
        }
        public class Users : Tea.TeaModel {
            public var excludeGroups: [String]?

            public var excludeOrganizationalUnits: [String]?

            public var excludeUsers: [String]?

            public var includeGroups: [String]?

            public var includeOrganizationalUnits: [String]?

            public var includeUsers: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.excludeGroups != nil {
                    map["ExcludeGroups"] = self.excludeGroups!
                }
                if self.excludeOrganizationalUnits != nil {
                    map["ExcludeOrganizationalUnits"] = self.excludeOrganizationalUnits!
                }
                if self.excludeUsers != nil {
                    map["ExcludeUsers"] = self.excludeUsers!
                }
                if self.includeGroups != nil {
                    map["IncludeGroups"] = self.includeGroups!
                }
                if self.includeOrganizationalUnits != nil {
                    map["IncludeOrganizationalUnits"] = self.includeOrganizationalUnits!
                }
                if self.includeUsers != nil {
                    map["IncludeUsers"] = self.includeUsers!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ExcludeGroups"] as? [String] {
                    self.excludeGroups = value
                }
                if let value = dict["ExcludeOrganizationalUnits"] as? [String] {
                    self.excludeOrganizationalUnits = value
                }
                if let value = dict["ExcludeUsers"] as? [String] {
                    self.excludeUsers = value
                }
                if let value = dict["IncludeGroups"] as? [String] {
                    self.includeGroups = value
                }
                if let value = dict["IncludeOrganizationalUnits"] as? [String] {
                    self.includeOrganizationalUnits = value
                }
                if let value = dict["IncludeUsers"] as? [String] {
                    self.includeUsers = value
                }
            }
        }
        public var applications: CreateConditionalAccessPolicyRequest.ConditionsConfig.Applications?

        public var networkZones: CreateConditionalAccessPolicyRequest.ConditionsConfig.NetworkZones?

        public var users: CreateConditionalAccessPolicyRequest.ConditionsConfig.Users?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.applications?.validate()
            try self.networkZones?.validate()
            try self.users?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.applications != nil {
                map["Applications"] = self.applications?.toMap()
            }
            if self.networkZones != nil {
                map["NetworkZones"] = self.networkZones?.toMap()
            }
            if self.users != nil {
                map["Users"] = self.users?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Applications"] as? [String: Any?] {
                var model = CreateConditionalAccessPolicyRequest.ConditionsConfig.Applications()
                model.fromMap(value)
                self.applications = model
            }
            if let value = dict["NetworkZones"] as? [String: Any?] {
                var model = CreateConditionalAccessPolicyRequest.ConditionsConfig.NetworkZones()
                model.fromMap(value)
                self.networkZones = model
            }
            if let value = dict["Users"] as? [String: Any?] {
                var model = CreateConditionalAccessPolicyRequest.ConditionsConfig.Users()
                model.fromMap(value)
                self.users = model
            }
        }
    }
    public class DecisionConfig : Tea.TeaModel {
        public var activeSessionReuseStatus: String?

        public var effect: String?

        public var mfaAuthenticationIntervalSeconds: Int64?

        public var mfaAuthenticationMethods: [String]?

        public var mfaType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.activeSessionReuseStatus != nil {
                map["ActiveSessionReuseStatus"] = self.activeSessionReuseStatus!
            }
            if self.effect != nil {
                map["Effect"] = self.effect!
            }
            if self.mfaAuthenticationIntervalSeconds != nil {
                map["MfaAuthenticationIntervalSeconds"] = self.mfaAuthenticationIntervalSeconds!
            }
            if self.mfaAuthenticationMethods != nil {
                map["MfaAuthenticationMethods"] = self.mfaAuthenticationMethods!
            }
            if self.mfaType != nil {
                map["MfaType"] = self.mfaType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ActiveSessionReuseStatus"] as? String {
                self.activeSessionReuseStatus = value
            }
            if let value = dict["Effect"] as? String {
                self.effect = value
            }
            if let value = dict["MfaAuthenticationIntervalSeconds"] as? Int64 {
                self.mfaAuthenticationIntervalSeconds = value
            }
            if let value = dict["MfaAuthenticationMethods"] as? [String] {
                self.mfaAuthenticationMethods = value
            }
            if let value = dict["MfaType"] as? String {
                self.mfaType = value
            }
        }
    }
    public var clientToken: String?

    public var conditionalAccessPolicyName: String?

    public var conditionalAccessPolicyType: String?

    public var conditionsConfig: CreateConditionalAccessPolicyRequest.ConditionsConfig?

    public var decisionConfig: CreateConditionalAccessPolicyRequest.DecisionConfig?

    public var decisionType: String?

    public var description_: String?

    public var evaluateAt: String?

    public var instanceId: String?

    public var priority: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.conditionsConfig?.validate()
        try self.decisionConfig?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.conditionalAccessPolicyName != nil {
            map["ConditionalAccessPolicyName"] = self.conditionalAccessPolicyName!
        }
        if self.conditionalAccessPolicyType != nil {
            map["ConditionalAccessPolicyType"] = self.conditionalAccessPolicyType!
        }
        if self.conditionsConfig != nil {
            map["ConditionsConfig"] = self.conditionsConfig?.toMap()
        }
        if self.decisionConfig != nil {
            map["DecisionConfig"] = self.decisionConfig?.toMap()
        }
        if self.decisionType != nil {
            map["DecisionType"] = self.decisionType!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.evaluateAt != nil {
            map["EvaluateAt"] = self.evaluateAt!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.priority != nil {
            map["Priority"] = self.priority!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["ConditionalAccessPolicyName"] as? String {
            self.conditionalAccessPolicyName = value
        }
        if let value = dict["ConditionalAccessPolicyType"] as? String {
            self.conditionalAccessPolicyType = value
        }
        if let value = dict["ConditionsConfig"] as? [String: Any?] {
            var model = CreateConditionalAccessPolicyRequest.ConditionsConfig()
            model.fromMap(value)
            self.conditionsConfig = model
        }
        if let value = dict["DecisionConfig"] as? [String: Any?] {
            var model = CreateConditionalAccessPolicyRequest.DecisionConfig()
            model.fromMap(value)
            self.decisionConfig = model
        }
        if let value = dict["DecisionType"] as? String {
            self.decisionType = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["EvaluateAt"] as? String {
            self.evaluateAt = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["Priority"] as? Int32 {
            self.priority = value
        }
    }
}

public class CreateConditionalAccessPolicyResponseBody : Tea.TeaModel {
    public var conditionalAccessPolicyId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.conditionalAccessPolicyId != nil {
            map["ConditionalAccessPolicyId"] = self.conditionalAccessPolicyId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ConditionalAccessPolicyId"] as? String {
            self.conditionalAccessPolicyId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class CreateConditionalAccessPolicyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateConditionalAccessPolicyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateConditionalAccessPolicyResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateDomainRequest : Tea.TeaModel {
    public class Filing : Tea.TeaModel {
        public var icpNumber: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.icpNumber != nil {
                map["IcpNumber"] = self.icpNumber!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["IcpNumber"] as? String {
                self.icpNumber = value
            }
        }
    }
    public var domain: String?

    public var filing: CreateDomainRequest.Filing?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.filing?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domain != nil {
            map["Domain"] = self.domain!
        }
        if self.filing != nil {
            map["Filing"] = self.filing?.toMap()
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Domain"] as? String {
            self.domain = value
        }
        if let value = dict["Filing"] as? [String: Any?] {
            var model = CreateDomainRequest.Filing()
            model.fromMap(value)
            self.filing = model
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
    }
}

public class CreateDomainResponseBody : Tea.TeaModel {
    public var domainId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainId != nil {
            map["DomainId"] = self.domainId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DomainId"] as? String {
            self.domainId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class CreateDomainResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateDomainResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateDomainResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateDomainProxyTokenRequest : Tea.TeaModel {
    public var domainId: String?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainId != nil {
            map["DomainId"] = self.domainId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DomainId"] as? String {
            self.domainId = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
    }
}

public class CreateDomainProxyTokenResponseBody : Tea.TeaModel {
    public var domainProxyTokenId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainProxyTokenId != nil {
            map["DomainProxyTokenId"] = self.domainProxyTokenId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DomainProxyTokenId"] as? String {
            self.domainProxyTokenId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class CreateDomainProxyTokenResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateDomainProxyTokenResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateDomainProxyTokenResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateGroupRequest : Tea.TeaModel {
    public var description_: String?

    public var groupExternalId: String?

    public var groupName: String?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.groupExternalId != nil {
            map["GroupExternalId"] = self.groupExternalId!
        }
        if self.groupName != nil {
            map["GroupName"] = self.groupName!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["GroupExternalId"] as? String {
            self.groupExternalId = value
        }
        if let value = dict["GroupName"] as? String {
            self.groupName = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
    }
}

public class CreateGroupResponseBody : Tea.TeaModel {
    public var groupId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["GroupId"] as? String {
            self.groupId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class CreateGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateGroupResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateIdentityProviderRequest : Tea.TeaModel {
    public class AuthnConfig : Tea.TeaModel {
        public var authnStatus: String?

        public var autoUpdatePasswordStatus: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.authnStatus != nil {
                map["AuthnStatus"] = self.authnStatus!
            }
            if self.autoUpdatePasswordStatus != nil {
                map["AutoUpdatePasswordStatus"] = self.autoUpdatePasswordStatus!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AuthnStatus"] as? String {
                self.authnStatus = value
            }
            if let value = dict["AutoUpdatePasswordStatus"] as? String {
                self.autoUpdatePasswordStatus = value
            }
        }
    }
    public class AutoCreateUserConfig : Tea.TeaModel {
        public var autoCreateUserStatus: String?

        public var targetOrganizationalUnitIds: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.autoCreateUserStatus != nil {
                map["AutoCreateUserStatus"] = self.autoCreateUserStatus!
            }
            if self.targetOrganizationalUnitIds != nil {
                map["TargetOrganizationalUnitIds"] = self.targetOrganizationalUnitIds!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AutoCreateUserStatus"] as? String {
                self.autoCreateUserStatus = value
            }
            if let value = dict["TargetOrganizationalUnitIds"] as? [String] {
                self.targetOrganizationalUnitIds = value
            }
        }
    }
    public class AutoUpdateUserConfig : Tea.TeaModel {
        public var autoUpdateUserStatus: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.autoUpdateUserStatus != nil {
                map["AutoUpdateUserStatus"] = self.autoUpdateUserStatus!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AutoUpdateUserStatus"] as? String {
                self.autoUpdateUserStatus = value
            }
        }
    }
    public class BindingConfig : Tea.TeaModel {
        public class AutoMatchUserProfileExpressions : Tea.TeaModel {
            public var expressionMappingType: String?

            public var sourceValueExpression: String?

            public var targetField: String?

            public var targetFieldDescription: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.expressionMappingType != nil {
                    map["ExpressionMappingType"] = self.expressionMappingType!
                }
                if self.sourceValueExpression != nil {
                    map["SourceValueExpression"] = self.sourceValueExpression!
                }
                if self.targetField != nil {
                    map["TargetField"] = self.targetField!
                }
                if self.targetFieldDescription != nil {
                    map["TargetFieldDescription"] = self.targetFieldDescription!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ExpressionMappingType"] as? String {
                    self.expressionMappingType = value
                }
                if let value = dict["SourceValueExpression"] as? String {
                    self.sourceValueExpression = value
                }
                if let value = dict["TargetField"] as? String {
                    self.targetField = value
                }
                if let value = dict["TargetFieldDescription"] as? String {
                    self.targetFieldDescription = value
                }
            }
        }
        public var autoMatchUserProfileExpressions: [CreateIdentityProviderRequest.BindingConfig.AutoMatchUserProfileExpressions]?

        public var autoMatchUserStatus: String?

        public var mappingBindingStatus: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.autoMatchUserProfileExpressions != nil {
                var tmp : [Any] = []
                for k in self.autoMatchUserProfileExpressions! {
                    tmp.append(k.toMap())
                }
                map["AutoMatchUserProfileExpressions"] = tmp
            }
            if self.autoMatchUserStatus != nil {
                map["AutoMatchUserStatus"] = self.autoMatchUserStatus!
            }
            if self.mappingBindingStatus != nil {
                map["MappingBindingStatus"] = self.mappingBindingStatus!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AutoMatchUserProfileExpressions"] as? [Any?] {
                var tmp : [CreateIdentityProviderRequest.BindingConfig.AutoMatchUserProfileExpressions] = []
                for v in value {
                    if v != nil {
                        var model = CreateIdentityProviderRequest.BindingConfig.AutoMatchUserProfileExpressions()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.autoMatchUserProfileExpressions = tmp
            }
            if let value = dict["AutoMatchUserStatus"] as? String {
                self.autoMatchUserStatus = value
            }
            if let value = dict["MappingBindingStatus"] as? String {
                self.mappingBindingStatus = value
            }
        }
    }
    public class DingtalkAppConfig : Tea.TeaModel {
        public var appKey: String?

        public var appSecret: String?

        public var corpId: String?

        public var dingtalkVersion: String?

        public var encryptKey: String?

        public var verificationToken: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appKey != nil {
                map["AppKey"] = self.appKey!
            }
            if self.appSecret != nil {
                map["AppSecret"] = self.appSecret!
            }
            if self.corpId != nil {
                map["CorpId"] = self.corpId!
            }
            if self.dingtalkVersion != nil {
                map["DingtalkVersion"] = self.dingtalkVersion!
            }
            if self.encryptKey != nil {
                map["EncryptKey"] = self.encryptKey!
            }
            if self.verificationToken != nil {
                map["VerificationToken"] = self.verificationToken!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AppKey"] as? String {
                self.appKey = value
            }
            if let value = dict["AppSecret"] as? String {
                self.appSecret = value
            }
            if let value = dict["CorpId"] as? String {
                self.corpId = value
            }
            if let value = dict["DingtalkVersion"] as? String {
                self.dingtalkVersion = value
            }
            if let value = dict["EncryptKey"] as? String {
                self.encryptKey = value
            }
            if let value = dict["VerificationToken"] as? String {
                self.verificationToken = value
            }
        }
    }
    public class LarkConfig : Tea.TeaModel {
        public var appId: String?

        public var appSecret: String?

        public var encryptKey: String?

        public var enterpriseNumber: String?

        public var verificationToken: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appId != nil {
                map["AppId"] = self.appId!
            }
            if self.appSecret != nil {
                map["AppSecret"] = self.appSecret!
            }
            if self.encryptKey != nil {
                map["EncryptKey"] = self.encryptKey!
            }
            if self.enterpriseNumber != nil {
                map["EnterpriseNumber"] = self.enterpriseNumber!
            }
            if self.verificationToken != nil {
                map["VerificationToken"] = self.verificationToken!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AppId"] as? String {
                self.appId = value
            }
            if let value = dict["AppSecret"] as? String {
                self.appSecret = value
            }
            if let value = dict["EncryptKey"] as? String {
                self.encryptKey = value
            }
            if let value = dict["EnterpriseNumber"] as? String {
                self.enterpriseNumber = value
            }
            if let value = dict["VerificationToken"] as? String {
                self.verificationToken = value
            }
        }
    }
    public class LdapConfig : Tea.TeaModel {
        public var administratorPassword: String?

        public var administratorUsername: String?

        public var certificateFingerprintStatus: String?

        public var certificateFingerprints: [String]?

        public var groupMemberAttributeName: String?

        public var groupObjectClass: String?

        public var groupObjectClassCustomFilter: String?

        public var ldapProtocol: String?

        public var ldapServerHost: String?

        public var ldapServerPort: Int32?

        public var organizationUnitObjectClass: String?

        public var startTlsStatus: String?

        public var userLoginIdentifier: String?

        public var userObjectClass: String?

        public var userObjectClassCustomFilter: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.administratorPassword != nil {
                map["AdministratorPassword"] = self.administratorPassword!
            }
            if self.administratorUsername != nil {
                map["AdministratorUsername"] = self.administratorUsername!
            }
            if self.certificateFingerprintStatus != nil {
                map["CertificateFingerprintStatus"] = self.certificateFingerprintStatus!
            }
            if self.certificateFingerprints != nil {
                map["CertificateFingerprints"] = self.certificateFingerprints!
            }
            if self.groupMemberAttributeName != nil {
                map["GroupMemberAttributeName"] = self.groupMemberAttributeName!
            }
            if self.groupObjectClass != nil {
                map["GroupObjectClass"] = self.groupObjectClass!
            }
            if self.groupObjectClassCustomFilter != nil {
                map["GroupObjectClassCustomFilter"] = self.groupObjectClassCustomFilter!
            }
            if self.ldapProtocol != nil {
                map["LdapProtocol"] = self.ldapProtocol!
            }
            if self.ldapServerHost != nil {
                map["LdapServerHost"] = self.ldapServerHost!
            }
            if self.ldapServerPort != nil {
                map["LdapServerPort"] = self.ldapServerPort!
            }
            if self.organizationUnitObjectClass != nil {
                map["OrganizationUnitObjectClass"] = self.organizationUnitObjectClass!
            }
            if self.startTlsStatus != nil {
                map["StartTlsStatus"] = self.startTlsStatus!
            }
            if self.userLoginIdentifier != nil {
                map["UserLoginIdentifier"] = self.userLoginIdentifier!
            }
            if self.userObjectClass != nil {
                map["UserObjectClass"] = self.userObjectClass!
            }
            if self.userObjectClassCustomFilter != nil {
                map["UserObjectClassCustomFilter"] = self.userObjectClassCustomFilter!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AdministratorPassword"] as? String {
                self.administratorPassword = value
            }
            if let value = dict["AdministratorUsername"] as? String {
                self.administratorUsername = value
            }
            if let value = dict["CertificateFingerprintStatus"] as? String {
                self.certificateFingerprintStatus = value
            }
            if let value = dict["CertificateFingerprints"] as? [String] {
                self.certificateFingerprints = value
            }
            if let value = dict["GroupMemberAttributeName"] as? String {
                self.groupMemberAttributeName = value
            }
            if let value = dict["GroupObjectClass"] as? String {
                self.groupObjectClass = value
            }
            if let value = dict["GroupObjectClassCustomFilter"] as? String {
                self.groupObjectClassCustomFilter = value
            }
            if let value = dict["LdapProtocol"] as? String {
                self.ldapProtocol = value
            }
            if let value = dict["LdapServerHost"] as? String {
                self.ldapServerHost = value
            }
            if let value = dict["LdapServerPort"] as? Int32 {
                self.ldapServerPort = value
            }
            if let value = dict["OrganizationUnitObjectClass"] as? String {
                self.organizationUnitObjectClass = value
            }
            if let value = dict["StartTlsStatus"] as? String {
                self.startTlsStatus = value
            }
            if let value = dict["UserLoginIdentifier"] as? String {
                self.userLoginIdentifier = value
            }
            if let value = dict["UserObjectClass"] as? String {
                self.userObjectClass = value
            }
            if let value = dict["UserObjectClassCustomFilter"] as? String {
                self.userObjectClassCustomFilter = value
            }
        }
    }
    public class OidcConfig : Tea.TeaModel {
        public class AuthnParam : Tea.TeaModel {
            public var authnMethod: String?

            public var clientId: String?

            public var clientSecret: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.authnMethod != nil {
                    map["AuthnMethod"] = self.authnMethod!
                }
                if self.clientId != nil {
                    map["ClientId"] = self.clientId!
                }
                if self.clientSecret != nil {
                    map["ClientSecret"] = self.clientSecret!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AuthnMethod"] as? String {
                    self.authnMethod = value
                }
                if let value = dict["ClientId"] as? String {
                    self.clientId = value
                }
                if let value = dict["ClientSecret"] as? String {
                    self.clientSecret = value
                }
            }
        }
        public class EndpointConfig : Tea.TeaModel {
            public var authorizationEndpoint: String?

            public var issuer: String?

            public var jwksUri: String?

            public var tokenEndpoint: String?

            public var userinfoEndpoint: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.authorizationEndpoint != nil {
                    map["AuthorizationEndpoint"] = self.authorizationEndpoint!
                }
                if self.issuer != nil {
                    map["Issuer"] = self.issuer!
                }
                if self.jwksUri != nil {
                    map["JwksUri"] = self.jwksUri!
                }
                if self.tokenEndpoint != nil {
                    map["TokenEndpoint"] = self.tokenEndpoint!
                }
                if self.userinfoEndpoint != nil {
                    map["UserinfoEndpoint"] = self.userinfoEndpoint!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AuthorizationEndpoint"] as? String {
                    self.authorizationEndpoint = value
                }
                if let value = dict["Issuer"] as? String {
                    self.issuer = value
                }
                if let value = dict["JwksUri"] as? String {
                    self.jwksUri = value
                }
                if let value = dict["TokenEndpoint"] as? String {
                    self.tokenEndpoint = value
                }
                if let value = dict["UserinfoEndpoint"] as? String {
                    self.userinfoEndpoint = value
                }
            }
        }
        public var authnParam: CreateIdentityProviderRequest.OidcConfig.AuthnParam?

        public var endpointConfig: CreateIdentityProviderRequest.OidcConfig.EndpointConfig?

        public var grantScopes: [String]?

        public var grantType: String?

        public var pkceChallengeMethod: String?

        public var pkceRequired: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.authnParam?.validate()
            try self.endpointConfig?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.authnParam != nil {
                map["AuthnParam"] = self.authnParam?.toMap()
            }
            if self.endpointConfig != nil {
                map["EndpointConfig"] = self.endpointConfig?.toMap()
            }
            if self.grantScopes != nil {
                map["GrantScopes"] = self.grantScopes!
            }
            if self.grantType != nil {
                map["GrantType"] = self.grantType!
            }
            if self.pkceChallengeMethod != nil {
                map["PkceChallengeMethod"] = self.pkceChallengeMethod!
            }
            if self.pkceRequired != nil {
                map["PkceRequired"] = self.pkceRequired!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AuthnParam"] as? [String: Any?] {
                var model = CreateIdentityProviderRequest.OidcConfig.AuthnParam()
                model.fromMap(value)
                self.authnParam = model
            }
            if let value = dict["EndpointConfig"] as? [String: Any?] {
                var model = CreateIdentityProviderRequest.OidcConfig.EndpointConfig()
                model.fromMap(value)
                self.endpointConfig = model
            }
            if let value = dict["GrantScopes"] as? [String] {
                self.grantScopes = value
            }
            if let value = dict["GrantType"] as? String {
                self.grantType = value
            }
            if let value = dict["PkceChallengeMethod"] as? String {
                self.pkceChallengeMethod = value
            }
            if let value = dict["PkceRequired"] as? Bool {
                self.pkceRequired = value
            }
        }
    }
    public class UdPullConfig : Tea.TeaModel {
        public class PeriodicSyncConfig : Tea.TeaModel {
            public var periodicSyncCron: String?

            public var periodicSyncTimes: [Int32]?

            public var periodicSyncType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.periodicSyncCron != nil {
                    map["PeriodicSyncCron"] = self.periodicSyncCron!
                }
                if self.periodicSyncTimes != nil {
                    map["PeriodicSyncTimes"] = self.periodicSyncTimes!
                }
                if self.periodicSyncType != nil {
                    map["PeriodicSyncType"] = self.periodicSyncType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["PeriodicSyncCron"] as? String {
                    self.periodicSyncCron = value
                }
                if let value = dict["PeriodicSyncTimes"] as? [Int32] {
                    self.periodicSyncTimes = value
                }
                if let value = dict["PeriodicSyncType"] as? String {
                    self.periodicSyncType = value
                }
            }
        }
        public class UdSyncScopeConfig : Tea.TeaModel {
            public var sourceScopes: [String]?

            public var targetScope: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.sourceScopes != nil {
                    map["SourceScopes"] = self.sourceScopes!
                }
                if self.targetScope != nil {
                    map["TargetScope"] = self.targetScope!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["SourceScopes"] as? [String] {
                    self.sourceScopes = value
                }
                if let value = dict["TargetScope"] as? String {
                    self.targetScope = value
                }
            }
        }
        public var groupSyncStatus: String?

        public var incrementalCallbackStatus: String?

        public var periodicSyncConfig: CreateIdentityProviderRequest.UdPullConfig.PeriodicSyncConfig?

        public var periodicSyncStatus: String?

        public var udSyncScopeConfig: CreateIdentityProviderRequest.UdPullConfig.UdSyncScopeConfig?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.periodicSyncConfig?.validate()
            try self.udSyncScopeConfig?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.groupSyncStatus != nil {
                map["GroupSyncStatus"] = self.groupSyncStatus!
            }
            if self.incrementalCallbackStatus != nil {
                map["IncrementalCallbackStatus"] = self.incrementalCallbackStatus!
            }
            if self.periodicSyncConfig != nil {
                map["PeriodicSyncConfig"] = self.periodicSyncConfig?.toMap()
            }
            if self.periodicSyncStatus != nil {
                map["PeriodicSyncStatus"] = self.periodicSyncStatus!
            }
            if self.udSyncScopeConfig != nil {
                map["UdSyncScopeConfig"] = self.udSyncScopeConfig?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["GroupSyncStatus"] as? String {
                self.groupSyncStatus = value
            }
            if let value = dict["IncrementalCallbackStatus"] as? String {
                self.incrementalCallbackStatus = value
            }
            if let value = dict["PeriodicSyncConfig"] as? [String: Any?] {
                var model = CreateIdentityProviderRequest.UdPullConfig.PeriodicSyncConfig()
                model.fromMap(value)
                self.periodicSyncConfig = model
            }
            if let value = dict["PeriodicSyncStatus"] as? String {
                self.periodicSyncStatus = value
            }
            if let value = dict["UdSyncScopeConfig"] as? [String: Any?] {
                var model = CreateIdentityProviderRequest.UdPullConfig.UdSyncScopeConfig()
                model.fromMap(value)
                self.udSyncScopeConfig = model
            }
        }
    }
    public class UdPushConfig : Tea.TeaModel {
        public class UdSyncScopeConfigs : Tea.TeaModel {
            public var sourceScopes: [String]?

            public var targetScope: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.sourceScopes != nil {
                    map["SourceScopes"] = self.sourceScopes!
                }
                if self.targetScope != nil {
                    map["TargetScope"] = self.targetScope!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["SourceScopes"] as? [String] {
                    self.sourceScopes = value
                }
                if let value = dict["TargetScope"] as? String {
                    self.targetScope = value
                }
            }
        }
        public var incrementalCallbackStatus: String?

        public var periodicSyncStatus: String?

        public var udSyncScopeConfigs: [CreateIdentityProviderRequest.UdPushConfig.UdSyncScopeConfigs]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.incrementalCallbackStatus != nil {
                map["IncrementalCallbackStatus"] = self.incrementalCallbackStatus!
            }
            if self.periodicSyncStatus != nil {
                map["PeriodicSyncStatus"] = self.periodicSyncStatus!
            }
            if self.udSyncScopeConfigs != nil {
                var tmp : [Any] = []
                for k in self.udSyncScopeConfigs! {
                    tmp.append(k.toMap())
                }
                map["UdSyncScopeConfigs"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["IncrementalCallbackStatus"] as? String {
                self.incrementalCallbackStatus = value
            }
            if let value = dict["PeriodicSyncStatus"] as? String {
                self.periodicSyncStatus = value
            }
            if let value = dict["UdSyncScopeConfigs"] as? [Any?] {
                var tmp : [CreateIdentityProviderRequest.UdPushConfig.UdSyncScopeConfigs] = []
                for v in value {
                    if v != nil {
                        var model = CreateIdentityProviderRequest.UdPushConfig.UdSyncScopeConfigs()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.udSyncScopeConfigs = tmp
            }
        }
    }
    public class WeComConfig : Tea.TeaModel {
        public var agentId: String?

        public var authorizeCallbackDomain: String?

        public var corpId: String?

        public var corpSecret: String?

        public var trustableDomain: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.agentId != nil {
                map["AgentId"] = self.agentId!
            }
            if self.authorizeCallbackDomain != nil {
                map["AuthorizeCallbackDomain"] = self.authorizeCallbackDomain!
            }
            if self.corpId != nil {
                map["CorpId"] = self.corpId!
            }
            if self.corpSecret != nil {
                map["CorpSecret"] = self.corpSecret!
            }
            if self.trustableDomain != nil {
                map["TrustableDomain"] = self.trustableDomain!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AgentId"] as? String {
                self.agentId = value
            }
            if let value = dict["AuthorizeCallbackDomain"] as? String {
                self.authorizeCallbackDomain = value
            }
            if let value = dict["CorpId"] as? String {
                self.corpId = value
            }
            if let value = dict["CorpSecret"] as? String {
                self.corpSecret = value
            }
            if let value = dict["TrustableDomain"] as? String {
                self.trustableDomain = value
            }
        }
    }
    public var authnConfig: CreateIdentityProviderRequest.AuthnConfig?

    public var autoCreateUserConfig: CreateIdentityProviderRequest.AutoCreateUserConfig?

    public var autoUpdateUserConfig: CreateIdentityProviderRequest.AutoUpdateUserConfig?

    public var bindingConfig: CreateIdentityProviderRequest.BindingConfig?

    public var clientToken: String?

    public var dingtalkAppConfig: CreateIdentityProviderRequest.DingtalkAppConfig?

    public var identityProviderName: String?

    public var identityProviderType: String?

    public var instanceId: String?

    public var larkConfig: CreateIdentityProviderRequest.LarkConfig?

    public var ldapConfig: CreateIdentityProviderRequest.LdapConfig?

    public var logoUrl: String?

    public var networkAccessEndpointId: String?

    public var oidcConfig: CreateIdentityProviderRequest.OidcConfig?

    public var udPullConfig: CreateIdentityProviderRequest.UdPullConfig?

    public var udPushConfig: CreateIdentityProviderRequest.UdPushConfig?

    public var weComConfig: CreateIdentityProviderRequest.WeComConfig?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.authnConfig?.validate()
        try self.autoCreateUserConfig?.validate()
        try self.autoUpdateUserConfig?.validate()
        try self.bindingConfig?.validate()
        try self.dingtalkAppConfig?.validate()
        try self.larkConfig?.validate()
        try self.ldapConfig?.validate()
        try self.oidcConfig?.validate()
        try self.udPullConfig?.validate()
        try self.udPushConfig?.validate()
        try self.weComConfig?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.authnConfig != nil {
            map["AuthnConfig"] = self.authnConfig?.toMap()
        }
        if self.autoCreateUserConfig != nil {
            map["AutoCreateUserConfig"] = self.autoCreateUserConfig?.toMap()
        }
        if self.autoUpdateUserConfig != nil {
            map["AutoUpdateUserConfig"] = self.autoUpdateUserConfig?.toMap()
        }
        if self.bindingConfig != nil {
            map["BindingConfig"] = self.bindingConfig?.toMap()
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dingtalkAppConfig != nil {
            map["DingtalkAppConfig"] = self.dingtalkAppConfig?.toMap()
        }
        if self.identityProviderName != nil {
            map["IdentityProviderName"] = self.identityProviderName!
        }
        if self.identityProviderType != nil {
            map["IdentityProviderType"] = self.identityProviderType!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.larkConfig != nil {
            map["LarkConfig"] = self.larkConfig?.toMap()
        }
        if self.ldapConfig != nil {
            map["LdapConfig"] = self.ldapConfig?.toMap()
        }
        if self.logoUrl != nil {
            map["LogoUrl"] = self.logoUrl!
        }
        if self.networkAccessEndpointId != nil {
            map["NetworkAccessEndpointId"] = self.networkAccessEndpointId!
        }
        if self.oidcConfig != nil {
            map["OidcConfig"] = self.oidcConfig?.toMap()
        }
        if self.udPullConfig != nil {
            map["UdPullConfig"] = self.udPullConfig?.toMap()
        }
        if self.udPushConfig != nil {
            map["UdPushConfig"] = self.udPushConfig?.toMap()
        }
        if self.weComConfig != nil {
            map["WeComConfig"] = self.weComConfig?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AuthnConfig"] as? [String: Any?] {
            var model = CreateIdentityProviderRequest.AuthnConfig()
            model.fromMap(value)
            self.authnConfig = model
        }
        if let value = dict["AutoCreateUserConfig"] as? [String: Any?] {
            var model = CreateIdentityProviderRequest.AutoCreateUserConfig()
            model.fromMap(value)
            self.autoCreateUserConfig = model
        }
        if let value = dict["AutoUpdateUserConfig"] as? [String: Any?] {
            var model = CreateIdentityProviderRequest.AutoUpdateUserConfig()
            model.fromMap(value)
            self.autoUpdateUserConfig = model
        }
        if let value = dict["BindingConfig"] as? [String: Any?] {
            var model = CreateIdentityProviderRequest.BindingConfig()
            model.fromMap(value)
            self.bindingConfig = model
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DingtalkAppConfig"] as? [String: Any?] {
            var model = CreateIdentityProviderRequest.DingtalkAppConfig()
            model.fromMap(value)
            self.dingtalkAppConfig = model
        }
        if let value = dict["IdentityProviderName"] as? String {
            self.identityProviderName = value
        }
        if let value = dict["IdentityProviderType"] as? String {
            self.identityProviderType = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["LarkConfig"] as? [String: Any?] {
            var model = CreateIdentityProviderRequest.LarkConfig()
            model.fromMap(value)
            self.larkConfig = model
        }
        if let value = dict["LdapConfig"] as? [String: Any?] {
            var model = CreateIdentityProviderRequest.LdapConfig()
            model.fromMap(value)
            self.ldapConfig = model
        }
        if let value = dict["LogoUrl"] as? String {
            self.logoUrl = value
        }
        if let value = dict["NetworkAccessEndpointId"] as? String {
            self.networkAccessEndpointId = value
        }
        if let value = dict["OidcConfig"] as? [String: Any?] {
            var model = CreateIdentityProviderRequest.OidcConfig()
            model.fromMap(value)
            self.oidcConfig = model
        }
        if let value = dict["UdPullConfig"] as? [String: Any?] {
            var model = CreateIdentityProviderRequest.UdPullConfig()
            model.fromMap(value)
            self.udPullConfig = model
        }
        if let value = dict["UdPushConfig"] as? [String: Any?] {
            var model = CreateIdentityProviderRequest.UdPushConfig()
            model.fromMap(value)
            self.udPushConfig = model
        }
        if let value = dict["WeComConfig"] as? [String: Any?] {
            var model = CreateIdentityProviderRequest.WeComConfig()
            model.fromMap(value)
            self.weComConfig = model
        }
    }
}

public class CreateIdentityProviderResponseBody : Tea.TeaModel {
    public var identityProviderId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.identityProviderId != nil {
            map["IdentityProviderId"] = self.identityProviderId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["IdentityProviderId"] as? String {
            self.identityProviderId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class CreateIdentityProviderResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateIdentityProviderResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateIdentityProviderResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateInstanceRequest : Tea.TeaModel {
    public var description_: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
    }
}

public class CreateInstanceResponseBody : Tea.TeaModel {
    public var instanceId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class CreateInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateInstanceResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateNetworkAccessEndpointRequest : Tea.TeaModel {
    public var clientToken: String?

    public var instanceId: String?

    public var networkAccessEndpointName: String?

    public var vSwitchIds: [String]?

    public var vpcId: String?

    public var vpcRegionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.networkAccessEndpointName != nil {
            map["NetworkAccessEndpointName"] = self.networkAccessEndpointName!
        }
        if self.vSwitchIds != nil {
            map["VSwitchIds"] = self.vSwitchIds!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        if self.vpcRegionId != nil {
            map["VpcRegionId"] = self.vpcRegionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["NetworkAccessEndpointName"] as? String {
            self.networkAccessEndpointName = value
        }
        if let value = dict["VSwitchIds"] as? [String] {
            self.vSwitchIds = value
        }
        if let value = dict["VpcId"] as? String {
            self.vpcId = value
        }
        if let value = dict["VpcRegionId"] as? String {
            self.vpcRegionId = value
        }
    }
}

public class CreateNetworkAccessEndpointResponseBody : Tea.TeaModel {
    public var networkAccessEndpointId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.networkAccessEndpointId != nil {
            map["NetworkAccessEndpointId"] = self.networkAccessEndpointId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["NetworkAccessEndpointId"] as? String {
            self.networkAccessEndpointId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class CreateNetworkAccessEndpointResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateNetworkAccessEndpointResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateNetworkAccessEndpointResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateOrganizationalUnitRequest : Tea.TeaModel {
    public var description_: String?

    public var instanceId: String?

    public var organizationalUnitExternalId: String?

    public var organizationalUnitName: String?

    public var parentId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.organizationalUnitExternalId != nil {
            map["OrganizationalUnitExternalId"] = self.organizationalUnitExternalId!
        }
        if self.organizationalUnitName != nil {
            map["OrganizationalUnitName"] = self.organizationalUnitName!
        }
        if self.parentId != nil {
            map["ParentId"] = self.parentId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["OrganizationalUnitExternalId"] as? String {
            self.organizationalUnitExternalId = value
        }
        if let value = dict["OrganizationalUnitName"] as? String {
            self.organizationalUnitName = value
        }
        if let value = dict["ParentId"] as? String {
            self.parentId = value
        }
    }
}

public class CreateOrganizationalUnitResponseBody : Tea.TeaModel {
    public var organizationalUnitId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.organizationalUnitId != nil {
            map["OrganizationalUnitId"] = self.organizationalUnitId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["OrganizationalUnitId"] as? String {
            self.organizationalUnitId = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class CreateOrganizationalUnitResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateOrganizationalUnitResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateOrganizationalUnitResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateUserRequest : Tea.TeaModel {
    public class CustomFields : Tea.TeaModel {
        public var fieldName: String?

        public var fieldValue: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.fieldName != nil {
                map["FieldName"] = self.fieldName!
            }
            if self.fieldValue != nil {
                map["FieldValue"] = self.fieldValue!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["FieldName"] as? String {
                self.fieldName = value
            }
            if let value = dict["FieldValue"] as? String {
                self.fieldValue = value
            }
        }
    }
    public class PasswordInitializationConfig : Tea.TeaModel {
        public var passwordForcedUpdateStatus: String?

        public var passwordInitializationPolicyPriority: String?

        public var passwordInitializationType: String?

        public var userNotificationChannels: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.passwordForcedUpdateStatus != nil {
                map["PasswordForcedUpdateStatus"] = self.passwordForcedUpdateStatus!
            }
            if self.passwordInitializationPolicyPriority != nil {
                map["PasswordInitializationPolicyPriority"] = self.passwordInitializationPolicyPriority!
            }
            if self.passwordInitializationType != nil {
                map["PasswordInitializationType"] = self.passwordInitializationType!
            }
            if self.userNotificationChannels != nil {
                map["UserNotificationChannels"] = self.userNotificationChannels!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["PasswordForcedUpdateStatus"] as? String {
                self.passwordForcedUpdateStatus = value
            }
            if let value = dict["PasswordInitializationPolicyPriority"] as? String {
                self.passwordInitializationPolicyPriority = value
            }
            if let value = dict["PasswordInitializationType"] as? String {
                self.passwordInitializationType = value
            }
            if let value = dict["UserNotificationChannels"] as? [String] {
                self.userNotificationChannels = value
            }
        }
    }
    public var clientToken: String?

    public var customFields: [CreateUserRequest.CustomFields]?

    public var description_: String?

    public var displayName: String?

    public var email: String?

    public var emailVerified: Bool?

    public var instanceId: String?

    public var organizationalUnitIds: [String]?

    public var password: String?

    public var passwordInitializationConfig: CreateUserRequest.PasswordInitializationConfig?

    public var phoneNumber: String?

    public var phoneNumberVerified: Bool?

    public var phoneRegion: String?

    public var primaryOrganizationalUnitId: String?

    public var userExternalId: String?

    public var username: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.passwordInitializationConfig?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.customFields != nil {
            var tmp : [Any] = []
            for k in self.customFields! {
                tmp.append(k.toMap())
            }
            map["CustomFields"] = tmp
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.displayName != nil {
            map["DisplayName"] = self.displayName!
        }
        if self.email != nil {
            map["Email"] = self.email!
        }
        if self.emailVerified != nil {
            map["EmailVerified"] = self.emailVerified!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.organizationalUnitIds != nil {
            map["OrganizationalUnitIds"] = self.organizationalUnitIds!
        }
        if self.password != nil {
            map["Password"] = self.password!
        }
        if self.passwordInitializationConfig != nil {
            map["PasswordInitializationConfig"] = self.passwordInitializationConfig?.toMap()
        }
        if self.phoneNumber != nil {
            map["PhoneNumber"] = self.phoneNumber!
        }
        if self.phoneNumberVerified != nil {
            map["PhoneNumberVerified"] = self.phoneNumberVerified!
        }
        if self.phoneRegion != nil {
            map["PhoneRegion"] = self.phoneRegion!
        }
        if self.primaryOrganizationalUnitId != nil {
            map["PrimaryOrganizationalUnitId"] = self.primaryOrganizationalUnitId!
        }
        if self.userExternalId != nil {
            map["UserExternalId"] = self.userExternalId!
        }
        if self.username != nil {
            map["Username"] = self.username!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["CustomFields"] as? [Any?] {
            var tmp : [CreateUserRequest.CustomFields] = []
            for v in value {
                if v != nil {
                    var model = CreateUserRequest.CustomFields()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.customFields = tmp
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["DisplayName"] as? String {
            self.displayName = value
        }
        if let value = dict["Email"] as? String {
            self.email = value
        }
        if let value = dict["EmailVerified"] as? Bool {
            self.emailVerified = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["OrganizationalUnitIds"] as? [String] {
            self.organizationalUnitIds = value
        }
        if let value = dict["Password"] as? String {
            self.password = value
        }
        if let value = dict["PasswordInitializationConfig"] as? [String: Any?] {
            var model = CreateUserRequest.PasswordInitializationConfig()
            model.fromMap(value)
            self.passwordInitializationConfig = model
        }
        if let value = dict["PhoneNumber"] as? String {
            self.phoneNumber = value
        }
        if let value = dict["PhoneNumberVerified"] as? Bool {
            self.phoneNumberVerified = value
        }
        if let value = dict["PhoneRegion"] as? String {
            self.phoneRegion = value
        }
        if let value = dict["PrimaryOrganizationalUnitId"] as? String {
            self.primaryOrganizationalUnitId = value
        }
        if let value = dict["UserExternalId"] as? String {
            self.userExternalId = value
        }
        if let value = dict["Username"] as? String {
            self.username = value
        }
    }
}

public class CreateUserResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["UserId"] as? String {
            self.userId = value
        }
    }
}

public class CreateUserResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateUserResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateUserResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteApplicationRequest : Tea.TeaModel {
    public var applicationId: String?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.applicationId != nil {
            map["ApplicationId"] = self.applicationId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ApplicationId"] as? String {
            self.applicationId = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
    }
}

public class DeleteApplicationResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteApplicationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteApplicationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteApplicationResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteApplicationClientSecretRequest : Tea.TeaModel {
    public var applicationId: String?

    public var instanceId: String?

    public var secretId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.applicationId != nil {
            map["ApplicationId"] = self.applicationId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.secretId != nil {
            map["SecretId"] = self.secretId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ApplicationId"] as? String {
            self.applicationId = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["SecretId"] as? String {
            self.secretId = value
        }
    }
}

public class DeleteApplicationClientSecretResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteApplicationClientSecretResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteApplicationClientSecretResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteApplicationClientSecretResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteConditionalAccessPolicyRequest : Tea.TeaModel {
    public var conditionalAccessPolicyId: String?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.conditionalAccessPolicyId != nil {
            map["ConditionalAccessPolicyId"] = self.conditionalAccessPolicyId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ConditionalAccessPolicyId"] as? String {
            self.conditionalAccessPolicyId = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
    }
}

public class DeleteConditionalAccessPolicyResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteConditionalAccessPolicyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteConditionalAccessPolicyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteConditionalAccessPolicyResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteDomainRequest : Tea.TeaModel {
    public var domainId: String?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainId != nil {
            map["DomainId"] = self.domainId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DomainId"] as? String {
            self.domainId = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
    }
}

public class DeleteDomainResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteDomainResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteDomainResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteDomainResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteDomainProxyTokenRequest : Tea.TeaModel {
    public var domainId: String?

    public var domainProxyTokenId: String?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainId != nil {
            map["DomainId"] = self.domainId!
        }
        if self.domainProxyTokenId != nil {
            map["DomainProxyTokenId"] = self.domainProxyTokenId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DomainId"] as? String {
            self.domainId = value
        }
        if let value = dict["DomainProxyTokenId"] as? String {
            self.domainProxyTokenId = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
    }
}

public class DeleteDomainProxyTokenResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteDomainProxyTokenResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteDomainProxyTokenResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteDomainProxyTokenResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteGroupRequest : Tea.TeaModel {
    public var groupId: String?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["GroupId"] as? String {
            self.groupId = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
    }
}

public class DeleteGroupResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteGroupResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteIdentityProviderRequest : Tea.TeaModel {
    public var identityProviderId: String?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.identityProviderId != nil {
            map["IdentityProviderId"] = self.identityProviderId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["IdentityProviderId"] as? String {
            self.identityProviderId = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
    }
}

public class DeleteIdentityProviderResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteIdentityProviderResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteIdentityProviderResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteIdentityProviderResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteInstanceRequest : Tea.TeaModel {
    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
    }
}

public class DeleteInstanceResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteInstanceResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteNetworkAccessEndpointRequest : Tea.TeaModel {
    public var instanceId: String?

    public var networkAccessEndpointId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.networkAccessEndpointId != nil {
            map["NetworkAccessEndpointId"] = self.networkAccessEndpointId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["NetworkAccessEndpointId"] as? String {
            self.networkAccessEndpointId = value
        }
    }
}

public class DeleteNetworkAccessEndpointResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteNetworkAccessEndpointResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteNetworkAccessEndpointResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteNetworkAccessEndpointResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteOrganizationalUnitRequest : Tea.TeaModel {
    public var instanceId: String?

    public var organizationalUnitId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.organizationalUnitId != nil {
            map["OrganizationalUnitId"] = self.organizationalUnitId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["OrganizationalUnitId"] as? String {
            self.organizationalUnitId = value
        }
    }
}

public class DeleteOrganizationalUnitResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteOrganizationalUnitResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteOrganizationalUnitResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteOrganizationalUnitResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteOrganizationalUnitChildrenRequest : Tea.TeaModel {
    public var instanceId: String?

    public var organizationalUnitId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.organizationalUnitId != nil {
            map["OrganizationalUnitId"] = self.organizationalUnitId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["OrganizationalUnitId"] as? String {
            self.organizationalUnitId = value
        }
    }
}

public class DeleteOrganizationalUnitChildrenResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteOrganizationalUnitChildrenResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteOrganizationalUnitChildrenResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteOrganizationalUnitChildrenResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteUserRequest : Tea.TeaModel {
    public var instanceId: String?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["UserId"] as? String {
            self.userId = value
        }
    }
}

public class DeleteUserResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteUserResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteUserResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteUserResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DisableApplicationRequest : Tea.TeaModel {
    public var applicationId: String?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.applicationId != nil {
            map["ApplicationId"] = self.applicationId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ApplicationId"] as? String {
            self.applicationId = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
    }
}

public class DisableApplicationResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DisableApplicationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DisableApplicationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DisableApplicationResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DisableApplicationApiInvokeRequest : Tea.TeaModel {
    public var applicationId: String?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.applicationId != nil {
            map["ApplicationId"] = self.applicationId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ApplicationId"] as? String {
            self.applicationId = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
    }
}

public class DisableApplicationApiInvokeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DisableApplicationApiInvokeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DisableApplicationApiInvokeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DisableApplicationApiInvokeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DisableApplicationClientSecretRequest : Tea.TeaModel {
    public var applicationId: String?

    public var instanceId: String?

    public var secretId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.applicationId != nil {
            map["ApplicationId"] = self.applicationId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.secretId != nil {
            map["SecretId"] = self.secretId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ApplicationId"] as? String {
            self.applicationId = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["SecretId"] as? String {
            self.secretId = value
        }
    }
}

public class DisableApplicationClientSecretResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DisableApplicationClientSecretResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DisableApplicationClientSecretResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DisableApplicationClientSecretResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DisableApplicationProvisioningRequest : Tea.TeaModel {
    public var applicationId: String?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.applicationId != nil {
            map["ApplicationId"] = self.applicationId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ApplicationId"] as? String {
            self.applicationId = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
    }
}

public class DisableApplicationProvisioningResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DisableApplicationProvisioningResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DisableApplicationProvisioningResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DisableApplicationProvisioningResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DisableApplicationSsoRequest : Tea.TeaModel {
    public var applicationId: String?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.applicationId != nil {
            map["ApplicationId"] = self.applicationId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ApplicationId"] as? String {
            self.applicationId = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
    }
}

public class DisableApplicationSsoResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DisableApplicationSsoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DisableApplicationSsoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DisableApplicationSsoResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DisableConditionalAccessPolicyRequest : Tea.TeaModel {
    public var conditionalAccessPolicyId: String?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.conditionalAccessPolicyId != nil {
            map["ConditionalAccessPolicyId"] = self.conditionalAccessPolicyId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ConditionalAccessPolicyId"] as? String {
            self.conditionalAccessPolicyId = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
    }
}

public class DisableConditionalAccessPolicyResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DisableConditionalAccessPolicyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DisableConditionalAccessPolicyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DisableConditionalAccessPolicyResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DisableDomainProxyTokenRequest : Tea.TeaModel {
    public var domainId: String?

    public var domainProxyTokenId: String?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainId != nil {
            map["DomainId"] = self.domainId!
        }
        if self.domainProxyTokenId != nil {
            map["DomainProxyTokenId"] = self.domainProxyTokenId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DomainId"] as? String {
            self.domainId = value
        }
        if let value = dict["DomainProxyTokenId"] as? String {
            self.domainProxyTokenId = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
    }
}

public class DisableDomainProxyTokenResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DisableDomainProxyTokenResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DisableDomainProxyTokenResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DisableDomainProxyTokenResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DisableIdentityProviderUdPullRequest : Tea.TeaModel {
    public var identityProviderId: String?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.identityProviderId != nil {
            map["IdentityProviderId"] = self.identityProviderId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["IdentityProviderId"] as? String {
            self.identityProviderId = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
    }
}

public class DisableIdentityProviderUdPullResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DisableIdentityProviderUdPullResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DisableIdentityProviderUdPullResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DisableIdentityProviderUdPullResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DisableInitDomainAutoRedirectRequest : Tea.TeaModel {
    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
    }
}

public class DisableInitDomainAutoRedirectResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DisableInitDomainAutoRedirectResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DisableInitDomainAutoRedirectResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DisableInitDomainAutoRedirectResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DisableUserRequest : Tea.TeaModel {
    public var instanceId: String?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["UserId"] as? String {
            self.userId = value
        }
    }
}

public class DisableUserResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DisableUserResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DisableUserResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DisableUserResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class EnableApplicationRequest : Tea.TeaModel {
    public var applicationId: String?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.applicationId != nil {
            map["ApplicationId"] = self.applicationId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ApplicationId"] as? String {
            self.applicationId = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
    }
}

public class EnableApplicationResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class EnableApplicationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: EnableApplicationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = EnableApplicationResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class EnableApplicationApiInvokeRequest : Tea.TeaModel {
    public var applicationId: String?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.applicationId != nil {
            map["ApplicationId"] = self.applicationId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ApplicationId"] as? String {
            self.applicationId = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
    }
}

public class EnableApplicationApiInvokeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class EnableApplicationApiInvokeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: EnableApplicationApiInvokeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = EnableApplicationApiInvokeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class EnableApplicationClientSecretRequest : Tea.TeaModel {
    public var applicationId: String?

    public var instanceId: String?

    public var secretId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.applicationId != nil {
            map["ApplicationId"] = self.applicationId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.secretId != nil {
            map["SecretId"] = self.secretId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ApplicationId"] as? String {
            self.applicationId = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["SecretId"] as? String {
            self.secretId = value
        }
    }
}

public class EnableApplicationClientSecretResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class EnableApplicationClientSecretResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: EnableApplicationClientSecretResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = EnableApplicationClientSecretResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class EnableApplicationProvisioningRequest : Tea.TeaModel {
    public var applicationId: String?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.applicationId != nil {
            map["ApplicationId"] = self.applicationId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ApplicationId"] as? String {
            self.applicationId = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
    }
}

public class EnableApplicationProvisioningResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class EnableApplicationProvisioningResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: EnableApplicationProvisioningResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = EnableApplicationProvisioningResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class EnableApplicationSsoRequest : Tea.TeaModel {
    public var applicationId: String?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.applicationId != nil {
            map["ApplicationId"] = self.applicationId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ApplicationId"] as? String {
            self.applicationId = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
    }
}

public class EnableApplicationSsoResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class EnableApplicationSsoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: EnableApplicationSsoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = EnableApplicationSsoResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class EnableConditionalAccessPolicyRequest : Tea.TeaModel {
    public var conditionalAccessPolicyId: String?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.conditionalAccessPolicyId != nil {
            map["ConditionalAccessPolicyId"] = self.conditionalAccessPolicyId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ConditionalAccessPolicyId"] as? String {
            self.conditionalAccessPolicyId = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
    }
}

public class EnableConditionalAccessPolicyResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class EnableConditionalAccessPolicyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: EnableConditionalAccessPolicyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = EnableConditionalAccessPolicyResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class EnableDomainProxyTokenRequest : Tea.TeaModel {
    public var domainId: String?

    public var domainProxyTokenId: String?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainId != nil {
            map["DomainId"] = self.domainId!
        }
        if self.domainProxyTokenId != nil {
            map["DomainProxyTokenId"] = self.domainProxyTokenId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DomainId"] as? String {
            self.domainId = value
        }
        if let value = dict["DomainProxyTokenId"] as? String {
            self.domainProxyTokenId = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
    }
}

public class EnableDomainProxyTokenResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class EnableDomainProxyTokenResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: EnableDomainProxyTokenResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = EnableDomainProxyTokenResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class EnableIdentityProviderUdPullRequest : Tea.TeaModel {
    public var identityProviderId: String?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.identityProviderId != nil {
            map["IdentityProviderId"] = self.identityProviderId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["IdentityProviderId"] as? String {
            self.identityProviderId = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
    }
}

public class EnableIdentityProviderUdPullResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class EnableIdentityProviderUdPullResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: EnableIdentityProviderUdPullResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = EnableIdentityProviderUdPullResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class EnableInitDomainAutoRedirectRequest : Tea.TeaModel {
    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
    }
}

public class EnableInitDomainAutoRedirectResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class EnableInitDomainAutoRedirectResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: EnableInitDomainAutoRedirectResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = EnableInitDomainAutoRedirectResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class EnableUserRequest : Tea.TeaModel {
    public var instanceId: String?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["UserId"] as? String {
            self.userId = value
        }
    }
}

public class EnableUserResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class EnableUserResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: EnableUserResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = EnableUserResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetApplicationRequest : Tea.TeaModel {
    public var applicationId: String?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.applicationId != nil {
            map["ApplicationId"] = self.applicationId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ApplicationId"] as? String {
            self.applicationId = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
    }
}

public class GetApplicationResponseBody : Tea.TeaModel {
    public class Application : Tea.TeaModel {
        public var apiInvokeStatus: String?

        public var applicationId: String?

        public var applicationName: String?

        public var applicationSourceType: String?

        public var applicationTemplateId: String?

        public var applicationVisibility: [String]?

        public var authorizationType: String?

        public var clientId: String?

        public var createTime: Int64?

        public var customSubjectStatus: String?

        public var description_: String?

        public var features: String?

        public var instanceId: String?

        public var logoUrl: String?

        public var m2MClientStatus: String?

        public var managedServiceCode: String?

        public var resourceServerIdentifier: String?

        public var resourceServerStatus: String?

        public var serviceManaged: Bool?

        public var ssoType: String?

        public var status: String?

        public var updateTime: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.apiInvokeStatus != nil {
                map["ApiInvokeStatus"] = self.apiInvokeStatus!
            }
            if self.applicationId != nil {
                map["ApplicationId"] = self.applicationId!
            }
            if self.applicationName != nil {
                map["ApplicationName"] = self.applicationName!
            }
            if self.applicationSourceType != nil {
                map["ApplicationSourceType"] = self.applicationSourceType!
            }
            if self.applicationTemplateId != nil {
                map["ApplicationTemplateId"] = self.applicationTemplateId!
            }
            if self.applicationVisibility != nil {
                map["ApplicationVisibility"] = self.applicationVisibility!
            }
            if self.authorizationType != nil {
                map["AuthorizationType"] = self.authorizationType!
            }
            if self.clientId != nil {
                map["ClientId"] = self.clientId!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.customSubjectStatus != nil {
                map["CustomSubjectStatus"] = self.customSubjectStatus!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.features != nil {
                map["Features"] = self.features!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.logoUrl != nil {
                map["LogoUrl"] = self.logoUrl!
            }
            if self.m2MClientStatus != nil {
                map["M2MClientStatus"] = self.m2MClientStatus!
            }
            if self.managedServiceCode != nil {
                map["ManagedServiceCode"] = self.managedServiceCode!
            }
            if self.resourceServerIdentifier != nil {
                map["ResourceServerIdentifier"] = self.resourceServerIdentifier!
            }
            if self.resourceServerStatus != nil {
                map["ResourceServerStatus"] = self.resourceServerStatus!
            }
            if self.serviceManaged != nil {
                map["ServiceManaged"] = self.serviceManaged!
            }
            if self.ssoType != nil {
                map["SsoType"] = self.ssoType!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.updateTime != nil {
                map["UpdateTime"] = self.updateTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ApiInvokeStatus"] as? String {
                self.apiInvokeStatus = value
            }
            if let value = dict["ApplicationId"] as? String {
                self.applicationId = value
            }
            if let value = dict["ApplicationName"] as? String {
                self.applicationName = value
            }
            if let value = dict["ApplicationSourceType"] as? String {
                self.applicationSourceType = value
            }
            if let value = dict["ApplicationTemplateId"] as? String {
                self.applicationTemplateId = value
            }
            if let value = dict["ApplicationVisibility"] as? [String] {
                self.applicationVisibility = value
            }
            if let value = dict["AuthorizationType"] as? String {
                self.authorizationType = value
            }
            if let value = dict["ClientId"] as? String {
                self.clientId = value
            }
            if let value = dict["CreateTime"] as? Int64 {
                self.createTime = value
            }
            if let value = dict["CustomSubjectStatus"] as? String {
                self.customSubjectStatus = value
            }
            if let value = dict["Description"] as? String {
                self.description_ = value
            }
            if let value = dict["Features"] as? String {
                self.features = value
            }
            if let value = dict["InstanceId"] as? String {
                self.instanceId = value
            }
            if let value = dict["LogoUrl"] as? String {
                self.logoUrl = value
            }
            if let value = dict["M2MClientStatus"] as? String {
                self.m2MClientStatus = value
            }
            if let value = dict["ManagedServiceCode"] as? String {
                self.managedServiceCode = value
            }
            if let value = dict["ResourceServerIdentifier"] as? String {
                self.resourceServerIdentifier = value
            }
            if let value = dict["ResourceServerStatus"] as? String {
                self.resourceServerStatus = value
            }
            if let value = dict["ServiceManaged"] as? Bool {
                self.serviceManaged = value
            }
            if let value = dict["SsoType"] as? String {
                self.ssoType = value
            }
            if let value = dict["Status"] as? String {
                self.status = value
            }
            if let value = dict["UpdateTime"] as? Int64 {
                self.updateTime = value
            }
        }
    }
    public var application: GetApplicationResponseBody.Application?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.application?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.application != nil {
            map["Application"] = self.application?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Application"] as? [String: Any?] {
            var model = GetApplicationResponseBody.Application()
            model.fromMap(value)
            self.application = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class GetApplicationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetApplicationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetApplicationResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetApplicationGrantScopeRequest : Tea.TeaModel {
    public var applicationId: String?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.applicationId != nil {
            map["ApplicationId"] = self.applicationId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ApplicationId"] as? String {
            self.applicationId = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
    }
}

public class GetApplicationGrantScopeResponseBody : Tea.TeaModel {
    public class ApplicationGrantScope : Tea.TeaModel {
        public var grantScopes: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.grantScopes != nil {
                map["GrantScopes"] = self.grantScopes!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["GrantScopes"] as? [String] {
                self.grantScopes = value
            }
        }
    }
    public var applicationGrantScope: GetApplicationGrantScopeResponseBody.ApplicationGrantScope?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.applicationGrantScope?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.applicationGrantScope != nil {
            map["ApplicationGrantScope"] = self.applicationGrantScope?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ApplicationGrantScope"] as? [String: Any?] {
            var model = GetApplicationGrantScopeResponseBody.ApplicationGrantScope()
            model.fromMap(value)
            self.applicationGrantScope = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class GetApplicationGrantScopeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetApplicationGrantScopeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetApplicationGrantScopeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetApplicationProvisioningConfigRequest : Tea.TeaModel {
    public var applicationId: String?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.applicationId != nil {
            map["ApplicationId"] = self.applicationId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ApplicationId"] as? String {
            self.applicationId = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
    }
}

public class GetApplicationProvisioningConfigResponseBody : Tea.TeaModel {
    public class ApplicationProvisioningConfig : Tea.TeaModel {
        public class CallbackProvisioningConfig : Tea.TeaModel {
            public var callbackUrl: String?

            public var encryptKey: String?

            public var encryptRequired: Bool?

            public var listenEventScopes: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.callbackUrl != nil {
                    map["CallbackUrl"] = self.callbackUrl!
                }
                if self.encryptKey != nil {
                    map["EncryptKey"] = self.encryptKey!
                }
                if self.encryptRequired != nil {
                    map["EncryptRequired"] = self.encryptRequired!
                }
                if self.listenEventScopes != nil {
                    map["ListenEventScopes"] = self.listenEventScopes!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["CallbackUrl"] as? String {
                    self.callbackUrl = value
                }
                if let value = dict["EncryptKey"] as? String {
                    self.encryptKey = value
                }
                if let value = dict["EncryptRequired"] as? Bool {
                    self.encryptRequired = value
                }
                if let value = dict["ListenEventScopes"] as? [String] {
                    self.listenEventScopes = value
                }
            }
        }
        public class ScimProvisioningConfig : Tea.TeaModel {
            public class AuthnConfiguration : Tea.TeaModel {
                public class AuthnParam : Tea.TeaModel {
                    public var accessToken: String?

                    public var authnMethod: String?

                    public var clientId: String?

                    public var clientSecret: String?

                    public var tokenEndpoint: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.accessToken != nil {
                            map["AccessToken"] = self.accessToken!
                        }
                        if self.authnMethod != nil {
                            map["AuthnMethod"] = self.authnMethod!
                        }
                        if self.clientId != nil {
                            map["ClientId"] = self.clientId!
                        }
                        if self.clientSecret != nil {
                            map["ClientSecret"] = self.clientSecret!
                        }
                        if self.tokenEndpoint != nil {
                            map["TokenEndpoint"] = self.tokenEndpoint!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["AccessToken"] as? String {
                            self.accessToken = value
                        }
                        if let value = dict["AuthnMethod"] as? String {
                            self.authnMethod = value
                        }
                        if let value = dict["ClientId"] as? String {
                            self.clientId = value
                        }
                        if let value = dict["ClientSecret"] as? String {
                            self.clientSecret = value
                        }
                        if let value = dict["TokenEndpoint"] as? String {
                            self.tokenEndpoint = value
                        }
                    }
                }
                public var authnMode: String?

                public var authnParam: GetApplicationProvisioningConfigResponseBody.ApplicationProvisioningConfig.ScimProvisioningConfig.AuthnConfiguration.AuthnParam?

                public var grantType: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.authnParam?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.authnMode != nil {
                        map["AuthnMode"] = self.authnMode!
                    }
                    if self.authnParam != nil {
                        map["AuthnParam"] = self.authnParam?.toMap()
                    }
                    if self.grantType != nil {
                        map["GrantType"] = self.grantType!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["AuthnMode"] as? String {
                        self.authnMode = value
                    }
                    if let value = dict["AuthnParam"] as? [String: Any?] {
                        var model = GetApplicationProvisioningConfigResponseBody.ApplicationProvisioningConfig.ScimProvisioningConfig.AuthnConfiguration.AuthnParam()
                        model.fromMap(value)
                        self.authnParam = model
                    }
                    if let value = dict["GrantType"] as? String {
                        self.grantType = value
                    }
                }
            }
            public var authnConfiguration: GetApplicationProvisioningConfigResponseBody.ApplicationProvisioningConfig.ScimProvisioningConfig.AuthnConfiguration?

            public var fullPushScopes: [String]?

            public var provisioningActions: [String]?

            public var scimBaseUrl: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.authnConfiguration?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.authnConfiguration != nil {
                    map["AuthnConfiguration"] = self.authnConfiguration?.toMap()
                }
                if self.fullPushScopes != nil {
                    map["FullPushScopes"] = self.fullPushScopes!
                }
                if self.provisioningActions != nil {
                    map["ProvisioningActions"] = self.provisioningActions!
                }
                if self.scimBaseUrl != nil {
                    map["ScimBaseUrl"] = self.scimBaseUrl!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AuthnConfiguration"] as? [String: Any?] {
                    var model = GetApplicationProvisioningConfigResponseBody.ApplicationProvisioningConfig.ScimProvisioningConfig.AuthnConfiguration()
                    model.fromMap(value)
                    self.authnConfiguration = model
                }
                if let value = dict["FullPushScopes"] as? [String] {
                    self.fullPushScopes = value
                }
                if let value = dict["ProvisioningActions"] as? [String] {
                    self.provisioningActions = value
                }
                if let value = dict["ScimBaseUrl"] as? String {
                    self.scimBaseUrl = value
                }
            }
        }
        public var applicationId: String?

        public var callbackProvisioningConfig: GetApplicationProvisioningConfigResponseBody.ApplicationProvisioningConfig.CallbackProvisioningConfig?

        public var configOperateMode: String?

        public var instanceId: String?

        public var networkAccessEndpointId: String?

        public var provisionJwksEndpoint: String?

        public var provisionPassword: Bool?

        public var provisionProtocolType: String?

        public var scimProvisioningConfig: GetApplicationProvisioningConfigResponseBody.ApplicationProvisioningConfig.ScimProvisioningConfig?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.callbackProvisioningConfig?.validate()
            try self.scimProvisioningConfig?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.applicationId != nil {
                map["ApplicationId"] = self.applicationId!
            }
            if self.callbackProvisioningConfig != nil {
                map["CallbackProvisioningConfig"] = self.callbackProvisioningConfig?.toMap()
            }
            if self.configOperateMode != nil {
                map["ConfigOperateMode"] = self.configOperateMode!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.networkAccessEndpointId != nil {
                map["NetworkAccessEndpointId"] = self.networkAccessEndpointId!
            }
            if self.provisionJwksEndpoint != nil {
                map["ProvisionJwksEndpoint"] = self.provisionJwksEndpoint!
            }
            if self.provisionPassword != nil {
                map["ProvisionPassword"] = self.provisionPassword!
            }
            if self.provisionProtocolType != nil {
                map["ProvisionProtocolType"] = self.provisionProtocolType!
            }
            if self.scimProvisioningConfig != nil {
                map["ScimProvisioningConfig"] = self.scimProvisioningConfig?.toMap()
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ApplicationId"] as? String {
                self.applicationId = value
            }
            if let value = dict["CallbackProvisioningConfig"] as? [String: Any?] {
                var model = GetApplicationProvisioningConfigResponseBody.ApplicationProvisioningConfig.CallbackProvisioningConfig()
                model.fromMap(value)
                self.callbackProvisioningConfig = model
            }
            if let value = dict["ConfigOperateMode"] as? String {
                self.configOperateMode = value
            }
            if let value = dict["InstanceId"] as? String {
                self.instanceId = value
            }
            if let value = dict["NetworkAccessEndpointId"] as? String {
                self.networkAccessEndpointId = value
            }
            if let value = dict["ProvisionJwksEndpoint"] as? String {
                self.provisionJwksEndpoint = value
            }
            if let value = dict["ProvisionPassword"] as? Bool {
                self.provisionPassword = value
            }
            if let value = dict["ProvisionProtocolType"] as? String {
                self.provisionProtocolType = value
            }
            if let value = dict["ScimProvisioningConfig"] as? [String: Any?] {
                var model = GetApplicationProvisioningConfigResponseBody.ApplicationProvisioningConfig.ScimProvisioningConfig()
                model.fromMap(value)
                self.scimProvisioningConfig = model
            }
            if let value = dict["Status"] as? String {
                self.status = value
            }
        }
    }
    public var applicationProvisioningConfig: GetApplicationProvisioningConfigResponseBody.ApplicationProvisioningConfig?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.applicationProvisioningConfig?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.applicationProvisioningConfig != nil {
            map["ApplicationProvisioningConfig"] = self.applicationProvisioningConfig?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ApplicationProvisioningConfig"] as? [String: Any?] {
            var model = GetApplicationProvisioningConfigResponseBody.ApplicationProvisioningConfig()
            model.fromMap(value)
            self.applicationProvisioningConfig = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class GetApplicationProvisioningConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetApplicationProvisioningConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetApplicationProvisioningConfigResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetApplicationProvisioningScopeRequest : Tea.TeaModel {
    public var applicationId: String?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.applicationId != nil {
            map["ApplicationId"] = self.applicationId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ApplicationId"] as? String {
            self.applicationId = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
    }
}

public class GetApplicationProvisioningScopeResponseBody : Tea.TeaModel {
    public class ApplicationProvisioningScope : Tea.TeaModel {
        public var groupIds: [String]?

        public var maxQuota: Int32?

        public var organizationalUnitIds: [String]?

        public var usedQuota: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.groupIds != nil {
                map["GroupIds"] = self.groupIds!
            }
            if self.maxQuota != nil {
                map["MaxQuota"] = self.maxQuota!
            }
            if self.organizationalUnitIds != nil {
                map["OrganizationalUnitIds"] = self.organizationalUnitIds!
            }
            if self.usedQuota != nil {
                map["UsedQuota"] = self.usedQuota!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["GroupIds"] as? [String] {
                self.groupIds = value
            }
            if let value = dict["MaxQuota"] as? Int32 {
                self.maxQuota = value
            }
            if let value = dict["OrganizationalUnitIds"] as? [String] {
                self.organizationalUnitIds = value
            }
            if let value = dict["UsedQuota"] as? Int32 {
                self.usedQuota = value
            }
        }
    }
    public var applicationProvisioningScope: GetApplicationProvisioningScopeResponseBody.ApplicationProvisioningScope?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.applicationProvisioningScope?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.applicationProvisioningScope != nil {
            map["ApplicationProvisioningScope"] = self.applicationProvisioningScope?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ApplicationProvisioningScope"] as? [String: Any?] {
            var model = GetApplicationProvisioningScopeResponseBody.ApplicationProvisioningScope()
            model.fromMap(value)
            self.applicationProvisioningScope = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class GetApplicationProvisioningScopeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetApplicationProvisioningScopeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetApplicationProvisioningScopeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetApplicationSsoConfigRequest : Tea.TeaModel {
    public var applicationId: String?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.applicationId != nil {
            map["ApplicationId"] = self.applicationId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ApplicationId"] as? String {
            self.applicationId = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
    }
}

public class GetApplicationSsoConfigResponseBody : Tea.TeaModel {
    public class ApplicationSsoConfig : Tea.TeaModel {
        public class OidcSsoConfig : Tea.TeaModel {
            public class CustomClaims : Tea.TeaModel {
                public var claimName: String?

                public var claimValueExpression: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.claimName != nil {
                        map["ClaimName"] = self.claimName!
                    }
                    if self.claimValueExpression != nil {
                        map["ClaimValueExpression"] = self.claimValueExpression!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["ClaimName"] as? String {
                        self.claimName = value
                    }
                    if let value = dict["ClaimValueExpression"] as? String {
                        self.claimValueExpression = value
                    }
                }
            }
            public var accessTokenEffectiveTime: Int64?

            public var codeEffectiveTime: Int64?

            public var customClaims: [GetApplicationSsoConfigResponseBody.ApplicationSsoConfig.OidcSsoConfig.CustomClaims]?

            public var grantScopes: [String]?

            public var grantTypes: [String]?

            public var idTokenEffectiveTime: Int64?

            public var passwordAuthenticationSourceId: String?

            public var passwordTotpMfaRequired: Bool?

            public var pkceChallengeMethods: [String]?

            public var pkceRequired: Bool?

            public var postLogoutRedirectUris: [String]?

            public var redirectUris: [String]?

            public var refreshTokenEffective: Int64?

            public var responseTypes: [String]?

            public var subjectIdExpression: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.accessTokenEffectiveTime != nil {
                    map["AccessTokenEffectiveTime"] = self.accessTokenEffectiveTime!
                }
                if self.codeEffectiveTime != nil {
                    map["CodeEffectiveTime"] = self.codeEffectiveTime!
                }
                if self.customClaims != nil {
                    var tmp : [Any] = []
                    for k in self.customClaims! {
                        tmp.append(k.toMap())
                    }
                    map["CustomClaims"] = tmp
                }
                if self.grantScopes != nil {
                    map["GrantScopes"] = self.grantScopes!
                }
                if self.grantTypes != nil {
                    map["GrantTypes"] = self.grantTypes!
                }
                if self.idTokenEffectiveTime != nil {
                    map["IdTokenEffectiveTime"] = self.idTokenEffectiveTime!
                }
                if self.passwordAuthenticationSourceId != nil {
                    map["PasswordAuthenticationSourceId"] = self.passwordAuthenticationSourceId!
                }
                if self.passwordTotpMfaRequired != nil {
                    map["PasswordTotpMfaRequired"] = self.passwordTotpMfaRequired!
                }
                if self.pkceChallengeMethods != nil {
                    map["PkceChallengeMethods"] = self.pkceChallengeMethods!
                }
                if self.pkceRequired != nil {
                    map["PkceRequired"] = self.pkceRequired!
                }
                if self.postLogoutRedirectUris != nil {
                    map["PostLogoutRedirectUris"] = self.postLogoutRedirectUris!
                }
                if self.redirectUris != nil {
                    map["RedirectUris"] = self.redirectUris!
                }
                if self.refreshTokenEffective != nil {
                    map["RefreshTokenEffective"] = self.refreshTokenEffective!
                }
                if self.responseTypes != nil {
                    map["ResponseTypes"] = self.responseTypes!
                }
                if self.subjectIdExpression != nil {
                    map["SubjectIdExpression"] = self.subjectIdExpression!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AccessTokenEffectiveTime"] as? Int64 {
                    self.accessTokenEffectiveTime = value
                }
                if let value = dict["CodeEffectiveTime"] as? Int64 {
                    self.codeEffectiveTime = value
                }
                if let value = dict["CustomClaims"] as? [Any?] {
                    var tmp : [GetApplicationSsoConfigResponseBody.ApplicationSsoConfig.OidcSsoConfig.CustomClaims] = []
                    for v in value {
                        if v != nil {
                            var model = GetApplicationSsoConfigResponseBody.ApplicationSsoConfig.OidcSsoConfig.CustomClaims()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.customClaims = tmp
                }
                if let value = dict["GrantScopes"] as? [String] {
                    self.grantScopes = value
                }
                if let value = dict["GrantTypes"] as? [String] {
                    self.grantTypes = value
                }
                if let value = dict["IdTokenEffectiveTime"] as? Int64 {
                    self.idTokenEffectiveTime = value
                }
                if let value = dict["PasswordAuthenticationSourceId"] as? String {
                    self.passwordAuthenticationSourceId = value
                }
                if let value = dict["PasswordTotpMfaRequired"] as? Bool {
                    self.passwordTotpMfaRequired = value
                }
                if let value = dict["PkceChallengeMethods"] as? [String] {
                    self.pkceChallengeMethods = value
                }
                if let value = dict["PkceRequired"] as? Bool {
                    self.pkceRequired = value
                }
                if let value = dict["PostLogoutRedirectUris"] as? [String] {
                    self.postLogoutRedirectUris = value
                }
                if let value = dict["RedirectUris"] as? [String] {
                    self.redirectUris = value
                }
                if let value = dict["RefreshTokenEffective"] as? Int64 {
                    self.refreshTokenEffective = value
                }
                if let value = dict["ResponseTypes"] as? [String] {
                    self.responseTypes = value
                }
                if let value = dict["SubjectIdExpression"] as? String {
                    self.subjectIdExpression = value
                }
            }
        }
        public class ProtocolEndpointDomain : Tea.TeaModel {
            public var oauth2AuthorizationEndpoint: String?

            public var oauth2DeviceAuthorizationEndpoint: String?

            public var oauth2RevokeEndpoint: String?

            public var oauth2TokenEndpoint: String?

            public var oauth2UserinfoEndpoint: String?

            public var oidcIssuer: String?

            public var oidcJwksEndpoint: String?

            public var oidcLogoutEndpoint: String?

            public var samlMetaEndpoint: String?

            public var samlSsoEndpoint: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.oauth2AuthorizationEndpoint != nil {
                    map["Oauth2AuthorizationEndpoint"] = self.oauth2AuthorizationEndpoint!
                }
                if self.oauth2DeviceAuthorizationEndpoint != nil {
                    map["Oauth2DeviceAuthorizationEndpoint"] = self.oauth2DeviceAuthorizationEndpoint!
                }
                if self.oauth2RevokeEndpoint != nil {
                    map["Oauth2RevokeEndpoint"] = self.oauth2RevokeEndpoint!
                }
                if self.oauth2TokenEndpoint != nil {
                    map["Oauth2TokenEndpoint"] = self.oauth2TokenEndpoint!
                }
                if self.oauth2UserinfoEndpoint != nil {
                    map["Oauth2UserinfoEndpoint"] = self.oauth2UserinfoEndpoint!
                }
                if self.oidcIssuer != nil {
                    map["OidcIssuer"] = self.oidcIssuer!
                }
                if self.oidcJwksEndpoint != nil {
                    map["OidcJwksEndpoint"] = self.oidcJwksEndpoint!
                }
                if self.oidcLogoutEndpoint != nil {
                    map["OidcLogoutEndpoint"] = self.oidcLogoutEndpoint!
                }
                if self.samlMetaEndpoint != nil {
                    map["SamlMetaEndpoint"] = self.samlMetaEndpoint!
                }
                if self.samlSsoEndpoint != nil {
                    map["SamlSsoEndpoint"] = self.samlSsoEndpoint!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Oauth2AuthorizationEndpoint"] as? String {
                    self.oauth2AuthorizationEndpoint = value
                }
                if let value = dict["Oauth2DeviceAuthorizationEndpoint"] as? String {
                    self.oauth2DeviceAuthorizationEndpoint = value
                }
                if let value = dict["Oauth2RevokeEndpoint"] as? String {
                    self.oauth2RevokeEndpoint = value
                }
                if let value = dict["Oauth2TokenEndpoint"] as? String {
                    self.oauth2TokenEndpoint = value
                }
                if let value = dict["Oauth2UserinfoEndpoint"] as? String {
                    self.oauth2UserinfoEndpoint = value
                }
                if let value = dict["OidcIssuer"] as? String {
                    self.oidcIssuer = value
                }
                if let value = dict["OidcJwksEndpoint"] as? String {
                    self.oidcJwksEndpoint = value
                }
                if let value = dict["OidcLogoutEndpoint"] as? String {
                    self.oidcLogoutEndpoint = value
                }
                if let value = dict["SamlMetaEndpoint"] as? String {
                    self.samlMetaEndpoint = value
                }
                if let value = dict["SamlSsoEndpoint"] as? String {
                    self.samlSsoEndpoint = value
                }
            }
        }
        public class SamlSsoConfig : Tea.TeaModel {
            public class AttributeStatements : Tea.TeaModel {
                public var attributeName: String?

                public var attributeValueExpression: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.attributeName != nil {
                        map["AttributeName"] = self.attributeName!
                    }
                    if self.attributeValueExpression != nil {
                        map["AttributeValueExpression"] = self.attributeValueExpression!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["AttributeName"] as? String {
                        self.attributeName = value
                    }
                    if let value = dict["AttributeValueExpression"] as? String {
                        self.attributeValueExpression = value
                    }
                }
            }
            public class OptionalRelayStates : Tea.TeaModel {
                public var displayName: String?

                public var relayState: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.displayName != nil {
                        map["DisplayName"] = self.displayName!
                    }
                    if self.relayState != nil {
                        map["RelayState"] = self.relayState!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["DisplayName"] as? String {
                        self.displayName = value
                    }
                    if let value = dict["RelayState"] as? String {
                        self.relayState = value
                    }
                }
            }
            public var assertionSigned: Bool?

            public var attributeStatements: [GetApplicationSsoConfigResponseBody.ApplicationSsoConfig.SamlSsoConfig.AttributeStatements]?

            public var defaultRelayState: String?

            public var idPEntityId: String?

            public var nameIdFormat: String?

            public var nameIdValueExpression: String?

            public var optionalRelayStates: [GetApplicationSsoConfigResponseBody.ApplicationSsoConfig.SamlSsoConfig.OptionalRelayStates]?

            public var responseSigned: Bool?

            public var signatureAlgorithm: String?

            public var spEntityId: String?

            public var spSsoAcsUrl: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.assertionSigned != nil {
                    map["AssertionSigned"] = self.assertionSigned!
                }
                if self.attributeStatements != nil {
                    var tmp : [Any] = []
                    for k in self.attributeStatements! {
                        tmp.append(k.toMap())
                    }
                    map["AttributeStatements"] = tmp
                }
                if self.defaultRelayState != nil {
                    map["DefaultRelayState"] = self.defaultRelayState!
                }
                if self.idPEntityId != nil {
                    map["IdPEntityId"] = self.idPEntityId!
                }
                if self.nameIdFormat != nil {
                    map["NameIdFormat"] = self.nameIdFormat!
                }
                if self.nameIdValueExpression != nil {
                    map["NameIdValueExpression"] = self.nameIdValueExpression!
                }
                if self.optionalRelayStates != nil {
                    var tmp : [Any] = []
                    for k in self.optionalRelayStates! {
                        tmp.append(k.toMap())
                    }
                    map["OptionalRelayStates"] = tmp
                }
                if self.responseSigned != nil {
                    map["ResponseSigned"] = self.responseSigned!
                }
                if self.signatureAlgorithm != nil {
                    map["SignatureAlgorithm"] = self.signatureAlgorithm!
                }
                if self.spEntityId != nil {
                    map["SpEntityId"] = self.spEntityId!
                }
                if self.spSsoAcsUrl != nil {
                    map["SpSsoAcsUrl"] = self.spSsoAcsUrl!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AssertionSigned"] as? Bool {
                    self.assertionSigned = value
                }
                if let value = dict["AttributeStatements"] as? [Any?] {
                    var tmp : [GetApplicationSsoConfigResponseBody.ApplicationSsoConfig.SamlSsoConfig.AttributeStatements] = []
                    for v in value {
                        if v != nil {
                            var model = GetApplicationSsoConfigResponseBody.ApplicationSsoConfig.SamlSsoConfig.AttributeStatements()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.attributeStatements = tmp
                }
                if let value = dict["DefaultRelayState"] as? String {
                    self.defaultRelayState = value
                }
                if let value = dict["IdPEntityId"] as? String {
                    self.idPEntityId = value
                }
                if let value = dict["NameIdFormat"] as? String {
                    self.nameIdFormat = value
                }
                if let value = dict["NameIdValueExpression"] as? String {
                    self.nameIdValueExpression = value
                }
                if let value = dict["OptionalRelayStates"] as? [Any?] {
                    var tmp : [GetApplicationSsoConfigResponseBody.ApplicationSsoConfig.SamlSsoConfig.OptionalRelayStates] = []
                    for v in value {
                        if v != nil {
                            var model = GetApplicationSsoConfigResponseBody.ApplicationSsoConfig.SamlSsoConfig.OptionalRelayStates()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.optionalRelayStates = tmp
                }
                if let value = dict["ResponseSigned"] as? Bool {
                    self.responseSigned = value
                }
                if let value = dict["SignatureAlgorithm"] as? String {
                    self.signatureAlgorithm = value
                }
                if let value = dict["SpEntityId"] as? String {
                    self.spEntityId = value
                }
                if let value = dict["SpSsoAcsUrl"] as? String {
                    self.spSsoAcsUrl = value
                }
            }
        }
        public var initLoginType: String?

        public var initLoginUrl: String?

        public var oidcSsoConfig: GetApplicationSsoConfigResponseBody.ApplicationSsoConfig.OidcSsoConfig?

        public var protocolEndpointDomain: GetApplicationSsoConfigResponseBody.ApplicationSsoConfig.ProtocolEndpointDomain?

        public var samlSsoConfig: GetApplicationSsoConfigResponseBody.ApplicationSsoConfig.SamlSsoConfig?

        public var ssoStatus: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.oidcSsoConfig?.validate()
            try self.protocolEndpointDomain?.validate()
            try self.samlSsoConfig?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.initLoginType != nil {
                map["InitLoginType"] = self.initLoginType!
            }
            if self.initLoginUrl != nil {
                map["InitLoginUrl"] = self.initLoginUrl!
            }
            if self.oidcSsoConfig != nil {
                map["OidcSsoConfig"] = self.oidcSsoConfig?.toMap()
            }
            if self.protocolEndpointDomain != nil {
                map["ProtocolEndpointDomain"] = self.protocolEndpointDomain?.toMap()
            }
            if self.samlSsoConfig != nil {
                map["SamlSsoConfig"] = self.samlSsoConfig?.toMap()
            }
            if self.ssoStatus != nil {
                map["SsoStatus"] = self.ssoStatus!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["InitLoginType"] as? String {
                self.initLoginType = value
            }
            if let value = dict["InitLoginUrl"] as? String {
                self.initLoginUrl = value
            }
            if let value = dict["OidcSsoConfig"] as? [String: Any?] {
                var model = GetApplicationSsoConfigResponseBody.ApplicationSsoConfig.OidcSsoConfig()
                model.fromMap(value)
                self.oidcSsoConfig = model
            }
            if let value = dict["ProtocolEndpointDomain"] as? [String: Any?] {
                var model = GetApplicationSsoConfigResponseBody.ApplicationSsoConfig.ProtocolEndpointDomain()
                model.fromMap(value)
                self.protocolEndpointDomain = model
            }
            if let value = dict["SamlSsoConfig"] as? [String: Any?] {
                var model = GetApplicationSsoConfigResponseBody.ApplicationSsoConfig.SamlSsoConfig()
                model.fromMap(value)
                self.samlSsoConfig = model
            }
            if let value = dict["SsoStatus"] as? String {
                self.ssoStatus = value
            }
        }
    }
    public var applicationSsoConfig: GetApplicationSsoConfigResponseBody.ApplicationSsoConfig?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.applicationSsoConfig?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.applicationSsoConfig != nil {
            map["ApplicationSsoConfig"] = self.applicationSsoConfig?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ApplicationSsoConfig"] as? [String: Any?] {
            var model = GetApplicationSsoConfigResponseBody.ApplicationSsoConfig()
            model.fromMap(value)
            self.applicationSsoConfig = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class GetApplicationSsoConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetApplicationSsoConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetApplicationSsoConfigResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetConditionalAccessPolicyRequest : Tea.TeaModel {
    public var conditionalAccessPolicyId: String?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.conditionalAccessPolicyId != nil {
            map["ConditionalAccessPolicyId"] = self.conditionalAccessPolicyId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ConditionalAccessPolicyId"] as? String {
            self.conditionalAccessPolicyId = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
    }
}

public class GetConditionalAccessPolicyResponseBody : Tea.TeaModel {
    public class ConditionalAccessPolicy : Tea.TeaModel {
        public class ConditionsConfig : Tea.TeaModel {
            public class Applications : Tea.TeaModel {
                public var excludeApplications: [String]?

                public var includeApplications: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.excludeApplications != nil {
                        map["ExcludeApplications"] = self.excludeApplications!
                    }
                    if self.includeApplications != nil {
                        map["IncludeApplications"] = self.includeApplications!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["ExcludeApplications"] as? [String] {
                        self.excludeApplications = value
                    }
                    if let value = dict["IncludeApplications"] as? [String] {
                        self.includeApplications = value
                    }
                }
            }
            public class NetworkZones : Tea.TeaModel {
                public var excludeNetworkZones: [String]?

                public var includeNetworkZones: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.excludeNetworkZones != nil {
                        map["ExcludeNetworkZones"] = self.excludeNetworkZones!
                    }
                    if self.includeNetworkZones != nil {
                        map["IncludeNetworkZones"] = self.includeNetworkZones!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["ExcludeNetworkZones"] as? [String] {
                        self.excludeNetworkZones = value
                    }
                    if let value = dict["IncludeNetworkZones"] as? [String] {
                        self.includeNetworkZones = value
                    }
                }
            }
            public class Users : Tea.TeaModel {
                public var excludeGroups: [String]?

                public var excludeOrganizationalUnits: [String]?

                public var excludeUsers: [String]?

                public var includeGroups: [String]?

                public var includeOrganizationalUnits: [String]?

                public var includeUsers: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.excludeGroups != nil {
                        map["ExcludeGroups"] = self.excludeGroups!
                    }
                    if self.excludeOrganizationalUnits != nil {
                        map["ExcludeOrganizationalUnits"] = self.excludeOrganizationalUnits!
                    }
                    if self.excludeUsers != nil {
                        map["ExcludeUsers"] = self.excludeUsers!
                    }
                    if self.includeGroups != nil {
                        map["IncludeGroups"] = self.includeGroups!
                    }
                    if self.includeOrganizationalUnits != nil {
                        map["IncludeOrganizationalUnits"] = self.includeOrganizationalUnits!
                    }
                    if self.includeUsers != nil {
                        map["IncludeUsers"] = self.includeUsers!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["ExcludeGroups"] as? [String] {
                        self.excludeGroups = value
                    }
                    if let value = dict["ExcludeOrganizationalUnits"] as? [String] {
                        self.excludeOrganizationalUnits = value
                    }
                    if let value = dict["ExcludeUsers"] as? [String] {
                        self.excludeUsers = value
                    }
                    if let value = dict["IncludeGroups"] as? [String] {
                        self.includeGroups = value
                    }
                    if let value = dict["IncludeOrganizationalUnits"] as? [String] {
                        self.includeOrganizationalUnits = value
                    }
                    if let value = dict["IncludeUsers"] as? [String] {
                        self.includeUsers = value
                    }
                }
            }
            public var applications: GetConditionalAccessPolicyResponseBody.ConditionalAccessPolicy.ConditionsConfig.Applications?

            public var networkZones: GetConditionalAccessPolicyResponseBody.ConditionalAccessPolicy.ConditionsConfig.NetworkZones?

            public var users: GetConditionalAccessPolicyResponseBody.ConditionalAccessPolicy.ConditionsConfig.Users?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.applications?.validate()
                try self.networkZones?.validate()
                try self.users?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.applications != nil {
                    map["Applications"] = self.applications?.toMap()
                }
                if self.networkZones != nil {
                    map["NetworkZones"] = self.networkZones?.toMap()
                }
                if self.users != nil {
                    map["Users"] = self.users?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Applications"] as? [String: Any?] {
                    var model = GetConditionalAccessPolicyResponseBody.ConditionalAccessPolicy.ConditionsConfig.Applications()
                    model.fromMap(value)
                    self.applications = model
                }
                if let value = dict["NetworkZones"] as? [String: Any?] {
                    var model = GetConditionalAccessPolicyResponseBody.ConditionalAccessPolicy.ConditionsConfig.NetworkZones()
                    model.fromMap(value)
                    self.networkZones = model
                }
                if let value = dict["Users"] as? [String: Any?] {
                    var model = GetConditionalAccessPolicyResponseBody.ConditionalAccessPolicy.ConditionsConfig.Users()
                    model.fromMap(value)
                    self.users = model
                }
            }
        }
        public class DecisionConfig : Tea.TeaModel {
            public var activeSessionReuseStatus: String?

            public var effect: String?

            public var mfaAuthenticationIntervalSeconds: Int64?

            public var mfaAuthenticationMethods: [String]?

            public var mfaType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.activeSessionReuseStatus != nil {
                    map["ActiveSessionReuseStatus"] = self.activeSessionReuseStatus!
                }
                if self.effect != nil {
                    map["Effect"] = self.effect!
                }
                if self.mfaAuthenticationIntervalSeconds != nil {
                    map["MfaAuthenticationIntervalSeconds"] = self.mfaAuthenticationIntervalSeconds!
                }
                if self.mfaAuthenticationMethods != nil {
                    map["MfaAuthenticationMethods"] = self.mfaAuthenticationMethods!
                }
                if self.mfaType != nil {
                    map["MfaType"] = self.mfaType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ActiveSessionReuseStatus"] as? String {
                    self.activeSessionReuseStatus = value
                }
                if let value = dict["Effect"] as? String {
                    self.effect = value
                }
                if let value = dict["MfaAuthenticationIntervalSeconds"] as? Int64 {
                    self.mfaAuthenticationIntervalSeconds = value
                }
                if let value = dict["MfaAuthenticationMethods"] as? [String] {
                    self.mfaAuthenticationMethods = value
                }
                if let value = dict["MfaType"] as? String {
                    self.mfaType = value
                }
            }
        }
        public var conditionalAccessPolicyId: String?

        public var conditionalAccessPolicyName: String?

        public var conditionalAccessPolicyType: String?

        public var conditionsConfig: GetConditionalAccessPolicyResponseBody.ConditionalAccessPolicy.ConditionsConfig?

        public var createTime: Int64?

        public var decisionConfig: GetConditionalAccessPolicyResponseBody.ConditionalAccessPolicy.DecisionConfig?

        public var decisionType: String?

        public var description_: String?

        public var evaluateAt: String?

        public var instanceId: String?

        public var lastUpdatedTime: Int64?

        public var priority: Int32?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.conditionsConfig?.validate()
            try self.decisionConfig?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.conditionalAccessPolicyId != nil {
                map["ConditionalAccessPolicyId"] = self.conditionalAccessPolicyId!
            }
            if self.conditionalAccessPolicyName != nil {
                map["ConditionalAccessPolicyName"] = self.conditionalAccessPolicyName!
            }
            if self.conditionalAccessPolicyType != nil {
                map["ConditionalAccessPolicyType"] = self.conditionalAccessPolicyType!
            }
            if self.conditionsConfig != nil {
                map["ConditionsConfig"] = self.conditionsConfig?.toMap()
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.decisionConfig != nil {
                map["DecisionConfig"] = self.decisionConfig?.toMap()
            }
            if self.decisionType != nil {
                map["DecisionType"] = self.decisionType!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.evaluateAt != nil {
                map["EvaluateAt"] = self.evaluateAt!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.lastUpdatedTime != nil {
                map["LastUpdatedTime"] = self.lastUpdatedTime!
            }
            if self.priority != nil {
                map["Priority"] = self.priority!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ConditionalAccessPolicyId"] as? String {
                self.conditionalAccessPolicyId = value
            }
            if let value = dict["ConditionalAccessPolicyName"] as? String {
                self.conditionalAccessPolicyName = value
            }
            if let value = dict["ConditionalAccessPolicyType"] as? String {
                self.conditionalAccessPolicyType = value
            }
            if let value = dict["ConditionsConfig"] as? [String: Any?] {
                var model = GetConditionalAccessPolicyResponseBody.ConditionalAccessPolicy.ConditionsConfig()
                model.fromMap(value)
                self.conditionsConfig = model
            }
            if let value = dict["CreateTime"] as? Int64 {
                self.createTime = value
            }
            if let value = dict["DecisionConfig"] as? [String: Any?] {
                var model = GetConditionalAccessPolicyResponseBody.ConditionalAccessPolicy.DecisionConfig()
                model.fromMap(value)
                self.decisionConfig = model
            }
            if let value = dict["DecisionType"] as? String {
                self.decisionType = value
            }
            if let value = dict["Description"] as? String {
                self.description_ = value
            }
            if let value = dict["EvaluateAt"] as? String {
                self.evaluateAt = value
            }
            if let value = dict["InstanceId"] as? String {
                self.instanceId = value
            }
            if let value = dict["LastUpdatedTime"] as? Int64 {
                self.lastUpdatedTime = value
            }
            if let value = dict["Priority"] as? Int32 {
                self.priority = value
            }
            if let value = dict["Status"] as? String {
                self.status = value
            }
        }
    }
    public var conditionalAccessPolicy: GetConditionalAccessPolicyResponseBody.ConditionalAccessPolicy?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.conditionalAccessPolicy?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.conditionalAccessPolicy != nil {
            map["ConditionalAccessPolicy"] = self.conditionalAccessPolicy?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ConditionalAccessPolicy"] as? [String: Any?] {
            var model = GetConditionalAccessPolicyResponseBody.ConditionalAccessPolicy()
            model.fromMap(value)
            self.conditionalAccessPolicy = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class GetConditionalAccessPolicyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetConditionalAccessPolicyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetConditionalAccessPolicyResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetDomainRequest : Tea.TeaModel {
    public var domainId: String?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainId != nil {
            map["DomainId"] = self.domainId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DomainId"] as? String {
            self.domainId = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
    }
}

public class GetDomainResponseBody : Tea.TeaModel {
    public class Domain : Tea.TeaModel {
        public class Filing : Tea.TeaModel {
            public var icpNumber: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.icpNumber != nil {
                    map["IcpNumber"] = self.icpNumber!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["IcpNumber"] as? String {
                    self.icpNumber = value
                }
            }
        }
        public var createTime: Int64?

        public var defaultDomain: Bool?

        public var domain: String?

        public var domainId: String?

        public var domainType: String?

        public var filing: GetDomainResponseBody.Domain.Filing?

        public var instanceId: String?

        public var lockMode: String?

        public var updateTime: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.filing?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.defaultDomain != nil {
                map["DefaultDomain"] = self.defaultDomain!
            }
            if self.domain != nil {
                map["Domain"] = self.domain!
            }
            if self.domainId != nil {
                map["DomainId"] = self.domainId!
            }
            if self.domainType != nil {
                map["DomainType"] = self.domainType!
            }
            if self.filing != nil {
                map["Filing"] = self.filing?.toMap()
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.lockMode != nil {
                map["LockMode"] = self.lockMode!
            }
            if self.updateTime != nil {
                map["UpdateTime"] = self.updateTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["CreateTime"] as? Int64 {
                self.createTime = value
            }
            if let value = dict["DefaultDomain"] as? Bool {
                self.defaultDomain = value
            }
            if let value = dict["Domain"] as? String {
                self.domain = value
            }
            if let value = dict["DomainId"] as? String {
                self.domainId = value
            }
            if let value = dict["DomainType"] as? String {
                self.domainType = value
            }
            if let value = dict["Filing"] as? [String: Any?] {
                var model = GetDomainResponseBody.Domain.Filing()
                model.fromMap(value)
                self.filing = model
            }
            if let value = dict["InstanceId"] as? String {
                self.instanceId = value
            }
            if let value = dict["LockMode"] as? String {
                self.lockMode = value
            }
            if let value = dict["UpdateTime"] as? Int64 {
                self.updateTime = value
            }
        }
    }
    public var domain: GetDomainResponseBody.Domain?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.domain?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domain != nil {
            map["Domain"] = self.domain?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Domain"] as? [String: Any?] {
            var model = GetDomainResponseBody.Domain()
            model.fromMap(value)
            self.domain = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class GetDomainResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetDomainResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetDomainResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetDomainDnsChallengeRequest : Tea.TeaModel {
    public var domain: String?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domain != nil {
            map["Domain"] = self.domain!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Domain"] as? String {
            self.domain = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
    }
}

public class GetDomainDnsChallengeResponseBody : Tea.TeaModel {
    public class DomainDnsChallenge : Tea.TeaModel {
        public var dnsChallengeName: String?

        public var dnsChallengeValue: String?

        public var dnsType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dnsChallengeName != nil {
                map["DnsChallengeName"] = self.dnsChallengeName!
            }
            if self.dnsChallengeValue != nil {
                map["DnsChallengeValue"] = self.dnsChallengeValue!
            }
            if self.dnsType != nil {
                map["DnsType"] = self.dnsType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["DnsChallengeName"] as? String {
                self.dnsChallengeName = value
            }
            if let value = dict["DnsChallengeValue"] as? String {
                self.dnsChallengeValue = value
            }
            if let value = dict["DnsType"] as? String {
                self.dnsType = value
            }
        }
    }
    public var domainDnsChallenge: GetDomainDnsChallengeResponseBody.DomainDnsChallenge?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.domainDnsChallenge?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainDnsChallenge != nil {
            map["DomainDnsChallenge"] = self.domainDnsChallenge?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DomainDnsChallenge"] as? [String: Any?] {
            var model = GetDomainDnsChallengeResponseBody.DomainDnsChallenge()
            model.fromMap(value)
            self.domainDnsChallenge = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class GetDomainDnsChallengeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetDomainDnsChallengeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetDomainDnsChallengeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetForgetPasswordConfigurationRequest : Tea.TeaModel {
    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
    }
}

public class GetForgetPasswordConfigurationResponseBody : Tea.TeaModel {
    public class OpenForgetPasswordConfiguration : Tea.TeaModel {
        public var authenticationChannels: [String]?

        public var enable: Bool?

        public var enableEmail: Bool?

        public var enableSms: Bool?

        public var forgetPasswordStatus: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.authenticationChannels != nil {
                map["AuthenticationChannels"] = self.authenticationChannels!
            }
            if self.enable != nil {
                map["Enable"] = self.enable!
            }
            if self.enableEmail != nil {
                map["EnableEmail"] = self.enableEmail!
            }
            if self.enableSms != nil {
                map["EnableSms"] = self.enableSms!
            }
            if self.forgetPasswordStatus != nil {
                map["ForgetPasswordStatus"] = self.forgetPasswordStatus!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AuthenticationChannels"] as? [String] {
                self.authenticationChannels = value
            }
            if let value = dict["Enable"] as? Bool {
                self.enable = value
            }
            if let value = dict["EnableEmail"] as? Bool {
                self.enableEmail = value
            }
            if let value = dict["EnableSms"] as? Bool {
                self.enableSms = value
            }
            if let value = dict["ForgetPasswordStatus"] as? String {
                self.forgetPasswordStatus = value
            }
        }
    }
    public var openForgetPasswordConfiguration: GetForgetPasswordConfigurationResponseBody.OpenForgetPasswordConfiguration?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.openForgetPasswordConfiguration?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.openForgetPasswordConfiguration != nil {
            map["OpenForgetPasswordConfiguration"] = self.openForgetPasswordConfiguration?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["OpenForgetPasswordConfiguration"] as? [String: Any?] {
            var model = GetForgetPasswordConfigurationResponseBody.OpenForgetPasswordConfiguration()
            model.fromMap(value)
            self.openForgetPasswordConfiguration = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class GetForgetPasswordConfigurationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetForgetPasswordConfigurationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetForgetPasswordConfigurationResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetGroupRequest : Tea.TeaModel {
    public var groupId: String?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["GroupId"] as? String {
            self.groupId = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
    }
}

public class GetGroupResponseBody : Tea.TeaModel {
    public class Group : Tea.TeaModel {
        public var createTime: Int64?

        public var description_: String?

        public var groupExternalId: String?

        public var groupId: String?

        public var groupName: String?

        public var groupSourceId: String?

        public var groupSourceType: String?

        public var instanceId: String?

        public var updateTime: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.groupExternalId != nil {
                map["GroupExternalId"] = self.groupExternalId!
            }
            if self.groupId != nil {
                map["GroupId"] = self.groupId!
            }
            if self.groupName != nil {
                map["GroupName"] = self.groupName!
            }
            if self.groupSourceId != nil {
                map["GroupSourceId"] = self.groupSourceId!
            }
            if self.groupSourceType != nil {
                map["GroupSourceType"] = self.groupSourceType!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.updateTime != nil {
                map["UpdateTime"] = self.updateTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["CreateTime"] as? Int64 {
                self.createTime = value
            }
            if let value = dict["Description"] as? String {
                self.description_ = value
            }
            if let value = dict["GroupExternalId"] as? String {
                self.groupExternalId = value
            }
            if let value = dict["GroupId"] as? String {
                self.groupId = value
            }
            if let value = dict["GroupName"] as? String {
                self.groupName = value
            }
            if let value = dict["GroupSourceId"] as? String {
                self.groupSourceId = value
            }
            if let value = dict["GroupSourceType"] as? String {
                self.groupSourceType = value
            }
            if let value = dict["InstanceId"] as? String {
                self.instanceId = value
            }
            if let value = dict["UpdateTime"] as? Int64 {
                self.updateTime = value
            }
        }
    }
    public var group: GetGroupResponseBody.Group?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.group?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.group != nil {
            map["Group"] = self.group?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Group"] as? [String: Any?] {
            var model = GetGroupResponseBody.Group()
            model.fromMap(value)
            self.group = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class GetGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetGroupResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetIdentityProviderRequest : Tea.TeaModel {
    public var identityProviderId: String?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.identityProviderId != nil {
            map["IdentityProviderId"] = self.identityProviderId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["IdentityProviderId"] as? String {
            self.identityProviderId = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
    }
}

public class GetIdentityProviderResponseBody : Tea.TeaModel {
    public class IdentityProviderDetail : Tea.TeaModel {
        public class DingtalkAppConfig : Tea.TeaModel {
            public var appKey: String?

            public var appSecret: String?

            public var corpId: String?

            public var dingtalkVersion: String?

            public var encryptKey: String?

            public var verificationToken: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.appKey != nil {
                    map["AppKey"] = self.appKey!
                }
                if self.appSecret != nil {
                    map["AppSecret"] = self.appSecret!
                }
                if self.corpId != nil {
                    map["CorpId"] = self.corpId!
                }
                if self.dingtalkVersion != nil {
                    map["DingtalkVersion"] = self.dingtalkVersion!
                }
                if self.encryptKey != nil {
                    map["EncryptKey"] = self.encryptKey!
                }
                if self.verificationToken != nil {
                    map["VerificationToken"] = self.verificationToken!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AppKey"] as? String {
                    self.appKey = value
                }
                if let value = dict["AppSecret"] as? String {
                    self.appSecret = value
                }
                if let value = dict["CorpId"] as? String {
                    self.corpId = value
                }
                if let value = dict["DingtalkVersion"] as? String {
                    self.dingtalkVersion = value
                }
                if let value = dict["EncryptKey"] as? String {
                    self.encryptKey = value
                }
                if let value = dict["VerificationToken"] as? String {
                    self.verificationToken = value
                }
            }
        }
        public class DingtalkProvisioningConfig : Tea.TeaModel {
            public class AuthedDepartmentIds : Tea.TeaModel {
                public var deptId: String?

                public var deptName: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.deptId != nil {
                        map["DeptId"] = self.deptId!
                    }
                    if self.deptName != nil {
                        map["DeptName"] = self.deptName!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["DeptId"] as? String {
                        self.deptId = value
                    }
                    if let value = dict["DeptName"] as? String {
                        self.deptName = value
                    }
                }
            }
            public class AuthedUsers : Tea.TeaModel {
                public var name: String?

                public var userId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.userId != nil {
                        map["UserId"] = self.userId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Name"] as? String {
                        self.name = value
                    }
                    if let value = dict["UserId"] as? String {
                        self.userId = value
                    }
                }
            }
            public var authedDepartmentIds: [GetIdentityProviderResponseBody.IdentityProviderDetail.DingtalkProvisioningConfig.AuthedDepartmentIds]?

            public var authedUsers: [GetIdentityProviderResponseBody.IdentityProviderDetail.DingtalkProvisioningConfig.AuthedUsers]?

            public var corpId: String?

            public var corpName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.authedDepartmentIds != nil {
                    var tmp : [Any] = []
                    for k in self.authedDepartmentIds! {
                        tmp.append(k.toMap())
                    }
                    map["AuthedDepartmentIds"] = tmp
                }
                if self.authedUsers != nil {
                    var tmp : [Any] = []
                    for k in self.authedUsers! {
                        tmp.append(k.toMap())
                    }
                    map["AuthedUsers"] = tmp
                }
                if self.corpId != nil {
                    map["CorpId"] = self.corpId!
                }
                if self.corpName != nil {
                    map["CorpName"] = self.corpName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AuthedDepartmentIds"] as? [Any?] {
                    var tmp : [GetIdentityProviderResponseBody.IdentityProviderDetail.DingtalkProvisioningConfig.AuthedDepartmentIds] = []
                    for v in value {
                        if v != nil {
                            var model = GetIdentityProviderResponseBody.IdentityProviderDetail.DingtalkProvisioningConfig.AuthedDepartmentIds()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.authedDepartmentIds = tmp
                }
                if let value = dict["AuthedUsers"] as? [Any?] {
                    var tmp : [GetIdentityProviderResponseBody.IdentityProviderDetail.DingtalkProvisioningConfig.AuthedUsers] = []
                    for v in value {
                        if v != nil {
                            var model = GetIdentityProviderResponseBody.IdentityProviderDetail.DingtalkProvisioningConfig.AuthedUsers()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.authedUsers = tmp
                }
                if let value = dict["CorpId"] as? String {
                    self.corpId = value
                }
                if let value = dict["CorpName"] as? String {
                    self.corpName = value
                }
            }
        }
        public class LarkConfig : Tea.TeaModel {
            public var appId: String?

            public var appSecret: String?

            public var encryptKey: String?

            public var enterpriseNumber: String?

            public var verificationToken: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.appId != nil {
                    map["AppId"] = self.appId!
                }
                if self.appSecret != nil {
                    map["AppSecret"] = self.appSecret!
                }
                if self.encryptKey != nil {
                    map["EncryptKey"] = self.encryptKey!
                }
                if self.enterpriseNumber != nil {
                    map["EnterpriseNumber"] = self.enterpriseNumber!
                }
                if self.verificationToken != nil {
                    map["VerificationToken"] = self.verificationToken!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AppId"] as? String {
                    self.appId = value
                }
                if let value = dict["AppSecret"] as? String {
                    self.appSecret = value
                }
                if let value = dict["EncryptKey"] as? String {
                    self.encryptKey = value
                }
                if let value = dict["EnterpriseNumber"] as? String {
                    self.enterpriseNumber = value
                }
                if let value = dict["VerificationToken"] as? String {
                    self.verificationToken = value
                }
            }
        }
        public class LdapConfig : Tea.TeaModel {
            public var administratorPassword: String?

            public var administratorUsername: String?

            public var certificateFingerprintStatus: String?

            public var certificateFingerprints: [String]?

            public var ldapProtocol: String?

            public var ldapServerHost: String?

            public var ldapServerPort: Int32?

            public var startTlsStatus: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.administratorPassword != nil {
                    map["AdministratorPassword"] = self.administratorPassword!
                }
                if self.administratorUsername != nil {
                    map["AdministratorUsername"] = self.administratorUsername!
                }
                if self.certificateFingerprintStatus != nil {
                    map["CertificateFingerprintStatus"] = self.certificateFingerprintStatus!
                }
                if self.certificateFingerprints != nil {
                    map["CertificateFingerprints"] = self.certificateFingerprints!
                }
                if self.ldapProtocol != nil {
                    map["LdapProtocol"] = self.ldapProtocol!
                }
                if self.ldapServerHost != nil {
                    map["LdapServerHost"] = self.ldapServerHost!
                }
                if self.ldapServerPort != nil {
                    map["LdapServerPort"] = self.ldapServerPort!
                }
                if self.startTlsStatus != nil {
                    map["StartTlsStatus"] = self.startTlsStatus!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AdministratorPassword"] as? String {
                    self.administratorPassword = value
                }
                if let value = dict["AdministratorUsername"] as? String {
                    self.administratorUsername = value
                }
                if let value = dict["CertificateFingerprintStatus"] as? String {
                    self.certificateFingerprintStatus = value
                }
                if let value = dict["CertificateFingerprints"] as? [String] {
                    self.certificateFingerprints = value
                }
                if let value = dict["LdapProtocol"] as? String {
                    self.ldapProtocol = value
                }
                if let value = dict["LdapServerHost"] as? String {
                    self.ldapServerHost = value
                }
                if let value = dict["LdapServerPort"] as? Int32 {
                    self.ldapServerPort = value
                }
                if let value = dict["StartTlsStatus"] as? String {
                    self.startTlsStatus = value
                }
            }
        }
        public class OidcConfig : Tea.TeaModel {
            public class AuthnParam : Tea.TeaModel {
                public var authnMethod: String?

                public var clientId: String?

                public var clientSecret: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.authnMethod != nil {
                        map["AuthnMethod"] = self.authnMethod!
                    }
                    if self.clientId != nil {
                        map["ClientId"] = self.clientId!
                    }
                    if self.clientSecret != nil {
                        map["ClientSecret"] = self.clientSecret!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["AuthnMethod"] as? String {
                        self.authnMethod = value
                    }
                    if let value = dict["ClientId"] as? String {
                        self.clientId = value
                    }
                    if let value = dict["ClientSecret"] as? String {
                        self.clientSecret = value
                    }
                }
            }
            public class EndpointConfig : Tea.TeaModel {
                public var authorizationEndpoint: String?

                public var issuer: String?

                public var jwksUri: String?

                public var tokenEndpoint: String?

                public var userinfoEndpoint: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.authorizationEndpoint != nil {
                        map["AuthorizationEndpoint"] = self.authorizationEndpoint!
                    }
                    if self.issuer != nil {
                        map["Issuer"] = self.issuer!
                    }
                    if self.jwksUri != nil {
                        map["JwksUri"] = self.jwksUri!
                    }
                    if self.tokenEndpoint != nil {
                        map["TokenEndpoint"] = self.tokenEndpoint!
                    }
                    if self.userinfoEndpoint != nil {
                        map["UserinfoEndpoint"] = self.userinfoEndpoint!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["AuthorizationEndpoint"] as? String {
                        self.authorizationEndpoint = value
                    }
                    if let value = dict["Issuer"] as? String {
                        self.issuer = value
                    }
                    if let value = dict["JwksUri"] as? String {
                        self.jwksUri = value
                    }
                    if let value = dict["TokenEndpoint"] as? String {
                        self.tokenEndpoint = value
                    }
                    if let value = dict["UserinfoEndpoint"] as? String {
                        self.userinfoEndpoint = value
                    }
                }
            }
            public var authnParam: GetIdentityProviderResponseBody.IdentityProviderDetail.OidcConfig.AuthnParam?

            public var endpointConfig: GetIdentityProviderResponseBody.IdentityProviderDetail.OidcConfig.EndpointConfig?

            public var grantScopes: [String]?

            public var grantType: String?

            public var pkceChallengeMethod: String?

            public var pkceRequired: Bool?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.authnParam?.validate()
                try self.endpointConfig?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.authnParam != nil {
                    map["AuthnParam"] = self.authnParam?.toMap()
                }
                if self.endpointConfig != nil {
                    map["EndpointConfig"] = self.endpointConfig?.toMap()
                }
                if self.grantScopes != nil {
                    map["GrantScopes"] = self.grantScopes!
                }
                if self.grantType != nil {
                    map["GrantType"] = self.grantType!
                }
                if self.pkceChallengeMethod != nil {
                    map["PkceChallengeMethod"] = self.pkceChallengeMethod!
                }
                if self.pkceRequired != nil {
                    map["PkceRequired"] = self.pkceRequired!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AuthnParam"] as? [String: Any?] {
                    var model = GetIdentityProviderResponseBody.IdentityProviderDetail.OidcConfig.AuthnParam()
                    model.fromMap(value)
                    self.authnParam = model
                }
                if let value = dict["EndpointConfig"] as? [String: Any?] {
                    var model = GetIdentityProviderResponseBody.IdentityProviderDetail.OidcConfig.EndpointConfig()
                    model.fromMap(value)
                    self.endpointConfig = model
                }
                if let value = dict["GrantScopes"] as? [String] {
                    self.grantScopes = value
                }
                if let value = dict["GrantType"] as? String {
                    self.grantType = value
                }
                if let value = dict["PkceChallengeMethod"] as? String {
                    self.pkceChallengeMethod = value
                }
                if let value = dict["PkceRequired"] as? Bool {
                    self.pkceRequired = value
                }
            }
        }
        public class UdPullConfig : Tea.TeaModel {
            public class UdSyncScopeConfig : Tea.TeaModel {
                public var sourceScopes: [String]?

                public var targetScope: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.sourceScopes != nil {
                        map["SourceScopes"] = self.sourceScopes!
                    }
                    if self.targetScope != nil {
                        map["TargetScope"] = self.targetScope!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["SourceScopes"] as? [String] {
                        self.sourceScopes = value
                    }
                    if let value = dict["TargetScope"] as? String {
                        self.targetScope = value
                    }
                }
            }
            public var groupSyncStatus: String?

            public var incrementalCallbackStatus: String?

            public var udSyncScopeConfig: GetIdentityProviderResponseBody.IdentityProviderDetail.UdPullConfig.UdSyncScopeConfig?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.udSyncScopeConfig?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.groupSyncStatus != nil {
                    map["GroupSyncStatus"] = self.groupSyncStatus!
                }
                if self.incrementalCallbackStatus != nil {
                    map["IncrementalCallbackStatus"] = self.incrementalCallbackStatus!
                }
                if self.udSyncScopeConfig != nil {
                    map["UdSyncScopeConfig"] = self.udSyncScopeConfig?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["GroupSyncStatus"] as? String {
                    self.groupSyncStatus = value
                }
                if let value = dict["IncrementalCallbackStatus"] as? String {
                    self.incrementalCallbackStatus = value
                }
                if let value = dict["UdSyncScopeConfig"] as? [String: Any?] {
                    var model = GetIdentityProviderResponseBody.IdentityProviderDetail.UdPullConfig.UdSyncScopeConfig()
                    model.fromMap(value)
                    self.udSyncScopeConfig = model
                }
            }
        }
        public class UdPushConfig : Tea.TeaModel {
            public class UdSyncScopeConfigs : Tea.TeaModel {
                public var sourceScopes: [String]?

                public var targetScope: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.sourceScopes != nil {
                        map["SourceScopes"] = self.sourceScopes!
                    }
                    if self.targetScope != nil {
                        map["TargetScope"] = self.targetScope!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["SourceScopes"] as? [String] {
                        self.sourceScopes = value
                    }
                    if let value = dict["TargetScope"] as? String {
                        self.targetScope = value
                    }
                }
            }
            public var incrementalCallbackStatus: String?

            public var udSyncScopeConfigs: [GetIdentityProviderResponseBody.IdentityProviderDetail.UdPushConfig.UdSyncScopeConfigs]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.incrementalCallbackStatus != nil {
                    map["IncrementalCallbackStatus"] = self.incrementalCallbackStatus!
                }
                if self.udSyncScopeConfigs != nil {
                    var tmp : [Any] = []
                    for k in self.udSyncScopeConfigs! {
                        tmp.append(k.toMap())
                    }
                    map["UdSyncScopeConfigs"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["IncrementalCallbackStatus"] as? String {
                    self.incrementalCallbackStatus = value
                }
                if let value = dict["UdSyncScopeConfigs"] as? [Any?] {
                    var tmp : [GetIdentityProviderResponseBody.IdentityProviderDetail.UdPushConfig.UdSyncScopeConfigs] = []
                    for v in value {
                        if v != nil {
                            var model = GetIdentityProviderResponseBody.IdentityProviderDetail.UdPushConfig.UdSyncScopeConfigs()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.udSyncScopeConfigs = tmp
                }
            }
        }
        public class WeComConfig : Tea.TeaModel {
            public var agentId: String?

            public var authorizeCallbackDomain: String?

            public var corpId: String?

            public var corpSecret: String?

            public var trustableDomain: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.agentId != nil {
                    map["AgentId"] = self.agentId!
                }
                if self.authorizeCallbackDomain != nil {
                    map["AuthorizeCallbackDomain"] = self.authorizeCallbackDomain!
                }
                if self.corpId != nil {
                    map["CorpId"] = self.corpId!
                }
                if self.corpSecret != nil {
                    map["CorpSecret"] = self.corpSecret!
                }
                if self.trustableDomain != nil {
                    map["TrustableDomain"] = self.trustableDomain!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AgentId"] as? String {
                    self.agentId = value
                }
                if let value = dict["AuthorizeCallbackDomain"] as? String {
                    self.authorizeCallbackDomain = value
                }
                if let value = dict["CorpId"] as? String {
                    self.corpId = value
                }
                if let value = dict["CorpSecret"] as? String {
                    self.corpSecret = value
                }
                if let value = dict["TrustableDomain"] as? String {
                    self.trustableDomain = value
                }
            }
        }
        public var advancedStatus: String?

        public var authnSourceSupplier: String?

        public var authnSourceType: String?

        public var authnStatus: String?

        public var createTime: Int64?

        public var description_: String?

        public var dingtalkAppConfig: GetIdentityProviderResponseBody.IdentityProviderDetail.DingtalkAppConfig?

        public var dingtalkProvisioningConfig: GetIdentityProviderResponseBody.IdentityProviderDetail.DingtalkProvisioningConfig?

        public var identityProviderExternalId: String?

        public var identityProviderId: String?

        public var identityProviderName: String?

        public var identityProviderType: String?

        public var instanceId: String?

        public var larkConfig: GetIdentityProviderResponseBody.IdentityProviderDetail.LarkConfig?

        public var lastStatusCheckJobResult: String?

        public var ldapConfig: GetIdentityProviderResponseBody.IdentityProviderDetail.LdapConfig?

        public var lockReason: String?

        public var logoUrl: String?

        public var networkAccessEndpointId: String?

        public var oidcConfig: GetIdentityProviderResponseBody.IdentityProviderDetail.OidcConfig?

        public var udPullConfig: GetIdentityProviderResponseBody.IdentityProviderDetail.UdPullConfig?

        public var udPullStatus: String?

        public var udPushConfig: GetIdentityProviderResponseBody.IdentityProviderDetail.UdPushConfig?

        public var udPushStatus: String?

        public var updateTime: Int64?

        public var weComConfig: GetIdentityProviderResponseBody.IdentityProviderDetail.WeComConfig?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.dingtalkAppConfig?.validate()
            try self.dingtalkProvisioningConfig?.validate()
            try self.larkConfig?.validate()
            try self.ldapConfig?.validate()
            try self.oidcConfig?.validate()
            try self.udPullConfig?.validate()
            try self.udPushConfig?.validate()
            try self.weComConfig?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.advancedStatus != nil {
                map["AdvancedStatus"] = self.advancedStatus!
            }
            if self.authnSourceSupplier != nil {
                map["AuthnSourceSupplier"] = self.authnSourceSupplier!
            }
            if self.authnSourceType != nil {
                map["AuthnSourceType"] = self.authnSourceType!
            }
            if self.authnStatus != nil {
                map["AuthnStatus"] = self.authnStatus!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.dingtalkAppConfig != nil {
                map["DingtalkAppConfig"] = self.dingtalkAppConfig?.toMap()
            }
            if self.dingtalkProvisioningConfig != nil {
                map["DingtalkProvisioningConfig"] = self.dingtalkProvisioningConfig?.toMap()
            }
            if self.identityProviderExternalId != nil {
                map["IdentityProviderExternalId"] = self.identityProviderExternalId!
            }
            if self.identityProviderId != nil {
                map["IdentityProviderId"] = self.identityProviderId!
            }
            if self.identityProviderName != nil {
                map["IdentityProviderName"] = self.identityProviderName!
            }
            if self.identityProviderType != nil {
                map["IdentityProviderType"] = self.identityProviderType!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.larkConfig != nil {
                map["LarkConfig"] = self.larkConfig?.toMap()
            }
            if self.lastStatusCheckJobResult != nil {
                map["LastStatusCheckJobResult"] = self.lastStatusCheckJobResult!
            }
            if self.ldapConfig != nil {
                map["LdapConfig"] = self.ldapConfig?.toMap()
            }
            if self.lockReason != nil {
                map["LockReason"] = self.lockReason!
            }
            if self.logoUrl != nil {
                map["LogoUrl"] = self.logoUrl!
            }
            if self.networkAccessEndpointId != nil {
                map["NetworkAccessEndpointId"] = self.networkAccessEndpointId!
            }
            if self.oidcConfig != nil {
                map["OidcConfig"] = self.oidcConfig?.toMap()
            }
            if self.udPullConfig != nil {
                map["UdPullConfig"] = self.udPullConfig?.toMap()
            }
            if self.udPullStatus != nil {
                map["UdPullStatus"] = self.udPullStatus!
            }
            if self.udPushConfig != nil {
                map["UdPushConfig"] = self.udPushConfig?.toMap()
            }
            if self.udPushStatus != nil {
                map["UdPushStatus"] = self.udPushStatus!
            }
            if self.updateTime != nil {
                map["UpdateTime"] = self.updateTime!
            }
            if self.weComConfig != nil {
                map["WeComConfig"] = self.weComConfig?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AdvancedStatus"] as? String {
                self.advancedStatus = value
            }
            if let value = dict["AuthnSourceSupplier"] as? String {
                self.authnSourceSupplier = value
            }
            if let value = dict["AuthnSourceType"] as? String {
                self.authnSourceType = value
            }
            if let value = dict["AuthnStatus"] as? String {
                self.authnStatus = value
            }
            if let value = dict["CreateTime"] as? Int64 {
                self.createTime = value
            }
            if let value = dict["Description"] as? String {
                self.description_ = value
            }
            if let value = dict["DingtalkAppConfig"] as? [String: Any?] {
                var model = GetIdentityProviderResponseBody.IdentityProviderDetail.DingtalkAppConfig()
                model.fromMap(value)
                self.dingtalkAppConfig = model
            }
            if let value = dict["DingtalkProvisioningConfig"] as? [String: Any?] {
                var model = GetIdentityProviderResponseBody.IdentityProviderDetail.DingtalkProvisioningConfig()
                model.fromMap(value)
                self.dingtalkProvisioningConfig = model
            }
            if let value = dict["IdentityProviderExternalId"] as? String {
                self.identityProviderExternalId = value
            }
            if let value = dict["IdentityProviderId"] as? String {
                self.identityProviderId = value
            }
            if let value = dict["IdentityProviderName"] as? String {
                self.identityProviderName = value
            }
            if let value = dict["IdentityProviderType"] as? String {
                self.identityProviderType = value
            }
            if let value = dict["InstanceId"] as? String {
                self.instanceId = value
            }
            if let value = dict["LarkConfig"] as? [String: Any?] {
                var model = GetIdentityProviderResponseBody.IdentityProviderDetail.LarkConfig()
                model.fromMap(value)
                self.larkConfig = model
            }
            if let value = dict["LastStatusCheckJobResult"] as? String {
                self.lastStatusCheckJobResult = value
            }
            if let value = dict["LdapConfig"] as? [String: Any?] {
                var model = GetIdentityProviderResponseBody.IdentityProviderDetail.LdapConfig()
                model.fromMap(value)
                self.ldapConfig = model
            }
            if let value = dict["LockReason"] as? String {
                self.lockReason = value
            }
            if let value = dict["LogoUrl"] as? String {
                self.logoUrl = value
            }
            if let value = dict["NetworkAccessEndpointId"] as? String {
                self.networkAccessEndpointId = value
            }
            if let value = dict["OidcConfig"] as? [String: Any?] {
                var model = GetIdentityProviderResponseBody.IdentityProviderDetail.OidcConfig()
                model.fromMap(value)
                self.oidcConfig = model
            }
            if let value = dict["UdPullConfig"] as? [String: Any?] {
                var model = GetIdentityProviderResponseBody.IdentityProviderDetail.UdPullConfig()
                model.fromMap(value)
                self.udPullConfig = model
            }
            if let value = dict["UdPullStatus"] as? String {
                self.udPullStatus = value
            }
            if let value = dict["UdPushConfig"] as? [String: Any?] {
                var model = GetIdentityProviderResponseBody.IdentityProviderDetail.UdPushConfig()
                model.fromMap(value)
                self.udPushConfig = model
            }
            if let value = dict["UdPushStatus"] as? String {
                self.udPushStatus = value
            }
            if let value = dict["UpdateTime"] as? Int64 {
                self.updateTime = value
            }
            if let value = dict["WeComConfig"] as? [String: Any?] {
                var model = GetIdentityProviderResponseBody.IdentityProviderDetail.WeComConfig()
                model.fromMap(value)
                self.weComConfig = model
            }
        }
    }
    public var identityProviderDetail: GetIdentityProviderResponseBody.IdentityProviderDetail?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.identityProviderDetail?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.identityProviderDetail != nil {
            map["IdentityProviderDetail"] = self.identityProviderDetail?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["IdentityProviderDetail"] as? [String: Any?] {
            var model = GetIdentityProviderResponseBody.IdentityProviderDetail()
            model.fromMap(value)
            self.identityProviderDetail = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class GetIdentityProviderResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetIdentityProviderResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetIdentityProviderResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetIdentityProviderUdPullConfigurationRequest : Tea.TeaModel {
    public var identityProviderId: String?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.identityProviderId != nil {
            map["IdentityProviderId"] = self.identityProviderId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["IdentityProviderId"] as? String {
            self.identityProviderId = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
    }
}

public class GetIdentityProviderUdPullConfigurationResponseBody : Tea.TeaModel {
    public class UdPullConfiguration : Tea.TeaModel {
        public class LdapUdPullConfig : Tea.TeaModel {
            public var groupMemberAttributeName: String?

            public var groupObjectClass: String?

            public var groupObjectClassCustomFilter: String?

            public var organizationUnitObjectClass: String?

            public var userObjectClass: String?

            public var userObjectClassCustomFilter: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.groupMemberAttributeName != nil {
                    map["GroupMemberAttributeName"] = self.groupMemberAttributeName!
                }
                if self.groupObjectClass != nil {
                    map["GroupObjectClass"] = self.groupObjectClass!
                }
                if self.groupObjectClassCustomFilter != nil {
                    map["GroupObjectClassCustomFilter"] = self.groupObjectClassCustomFilter!
                }
                if self.organizationUnitObjectClass != nil {
                    map["OrganizationUnitObjectClass"] = self.organizationUnitObjectClass!
                }
                if self.userObjectClass != nil {
                    map["UserObjectClass"] = self.userObjectClass!
                }
                if self.userObjectClassCustomFilter != nil {
                    map["UserObjectClassCustomFilter"] = self.userObjectClassCustomFilter!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["GroupMemberAttributeName"] as? String {
                    self.groupMemberAttributeName = value
                }
                if let value = dict["GroupObjectClass"] as? String {
                    self.groupObjectClass = value
                }
                if let value = dict["GroupObjectClassCustomFilter"] as? String {
                    self.groupObjectClassCustomFilter = value
                }
                if let value = dict["OrganizationUnitObjectClass"] as? String {
                    self.organizationUnitObjectClass = value
                }
                if let value = dict["UserObjectClass"] as? String {
                    self.userObjectClass = value
                }
                if let value = dict["UserObjectClassCustomFilter"] as? String {
                    self.userObjectClassCustomFilter = value
                }
            }
        }
        public class PeriodicSyncConfig : Tea.TeaModel {
            public var periodicSyncCron: String?

            public var periodicSyncTimes: Int32?

            public var periodicSyncType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.periodicSyncCron != nil {
                    map["PeriodicSyncCron"] = self.periodicSyncCron!
                }
                if self.periodicSyncTimes != nil {
                    map["PeriodicSyncTimes"] = self.periodicSyncTimes!
                }
                if self.periodicSyncType != nil {
                    map["PeriodicSyncType"] = self.periodicSyncType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["PeriodicSyncCron"] as? String {
                    self.periodicSyncCron = value
                }
                if let value = dict["PeriodicSyncTimes"] as? Int32 {
                    self.periodicSyncTimes = value
                }
                if let value = dict["PeriodicSyncType"] as? String {
                    self.periodicSyncType = value
                }
            }
        }
        public class PullProtectedRule : Tea.TeaModel {
            public var groupDeletedThreshold: Int32?

            public var organizationalUnitDeletedThreshold: Int32?

            public var userDeletedThreshold: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.groupDeletedThreshold != nil {
                    map["GroupDeletedThreshold"] = self.groupDeletedThreshold!
                }
                if self.organizationalUnitDeletedThreshold != nil {
                    map["OrganizationalUnitDeletedThreshold"] = self.organizationalUnitDeletedThreshold!
                }
                if self.userDeletedThreshold != nil {
                    map["UserDeletedThreshold"] = self.userDeletedThreshold!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["GroupDeletedThreshold"] as? Int32 {
                    self.groupDeletedThreshold = value
                }
                if let value = dict["OrganizationalUnitDeletedThreshold"] as? Int32 {
                    self.organizationalUnitDeletedThreshold = value
                }
                if let value = dict["UserDeletedThreshold"] as? Int32 {
                    self.userDeletedThreshold = value
                }
            }
        }
        public class UdSyncScopeConfig : Tea.TeaModel {
            public var sourceScopes: [String]?

            public var targetScope: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.sourceScopes != nil {
                    map["SourceScopes"] = self.sourceScopes!
                }
                if self.targetScope != nil {
                    map["TargetScope"] = self.targetScope!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["SourceScopes"] as? [String] {
                    self.sourceScopes = value
                }
                if let value = dict["TargetScope"] as? String {
                    self.targetScope = value
                }
            }
        }
        public var groupSyncStatus: String?

        public var identityProviderId: String?

        public var incrementalCallbackStatus: String?

        public var instanceId: String?

        public var ldapUdPullConfig: GetIdentityProviderUdPullConfigurationResponseBody.UdPullConfiguration.LdapUdPullConfig?

        public var periodicSyncConfig: GetIdentityProviderUdPullConfigurationResponseBody.UdPullConfiguration.PeriodicSyncConfig?

        public var periodicSyncStatus: String?

        public var pullProtectedRule: GetIdentityProviderUdPullConfigurationResponseBody.UdPullConfiguration.PullProtectedRule?

        public var udSyncScopeConfig: GetIdentityProviderUdPullConfigurationResponseBody.UdPullConfiguration.UdSyncScopeConfig?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.ldapUdPullConfig?.validate()
            try self.periodicSyncConfig?.validate()
            try self.pullProtectedRule?.validate()
            try self.udSyncScopeConfig?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.groupSyncStatus != nil {
                map["GroupSyncStatus"] = self.groupSyncStatus!
            }
            if self.identityProviderId != nil {
                map["IdentityProviderId"] = self.identityProviderId!
            }
            if self.incrementalCallbackStatus != nil {
                map["IncrementalCallbackStatus"] = self.incrementalCallbackStatus!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.ldapUdPullConfig != nil {
                map["LdapUdPullConfig"] = self.ldapUdPullConfig?.toMap()
            }
            if self.periodicSyncConfig != nil {
                map["PeriodicSyncConfig"] = self.periodicSyncConfig?.toMap()
            }
            if self.periodicSyncStatus != nil {
                map["PeriodicSyncStatus"] = self.periodicSyncStatus!
            }
            if self.pullProtectedRule != nil {
                map["PullProtectedRule"] = self.pullProtectedRule?.toMap()
            }
            if self.udSyncScopeConfig != nil {
                map["UdSyncScopeConfig"] = self.udSyncScopeConfig?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["GroupSyncStatus"] as? String {
                self.groupSyncStatus = value
            }
            if let value = dict["IdentityProviderId"] as? String {
                self.identityProviderId = value
            }
            if let value = dict["IncrementalCallbackStatus"] as? String {
                self.incrementalCallbackStatus = value
            }
            if let value = dict["InstanceId"] as? String {
                self.instanceId = value
            }
            if let value = dict["LdapUdPullConfig"] as? [String: Any?] {
                var model = GetIdentityProviderUdPullConfigurationResponseBody.UdPullConfiguration.LdapUdPullConfig()
                model.fromMap(value)
                self.ldapUdPullConfig = model
            }
            if let value = dict["PeriodicSyncConfig"] as? [String: Any?] {
                var model = GetIdentityProviderUdPullConfigurationResponseBody.UdPullConfiguration.PeriodicSyncConfig()
                model.fromMap(value)
                self.periodicSyncConfig = model
            }
            if let value = dict["PeriodicSyncStatus"] as? String {
                self.periodicSyncStatus = value
            }
            if let value = dict["PullProtectedRule"] as? [String: Any?] {
                var model = GetIdentityProviderUdPullConfigurationResponseBody.UdPullConfiguration.PullProtectedRule()
                model.fromMap(value)
                self.pullProtectedRule = model
            }
            if let value = dict["UdSyncScopeConfig"] as? [String: Any?] {
                var model = GetIdentityProviderUdPullConfigurationResponseBody.UdPullConfiguration.UdSyncScopeConfig()
                model.fromMap(value)
                self.udSyncScopeConfig = model
            }
        }
    }
    public var requestId: String?

    public var udPullConfiguration: GetIdentityProviderUdPullConfigurationResponseBody.UdPullConfiguration?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.udPullConfiguration?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.udPullConfiguration != nil {
            map["UdPullConfiguration"] = self.udPullConfiguration?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["UdPullConfiguration"] as? [String: Any?] {
            var model = GetIdentityProviderUdPullConfigurationResponseBody.UdPullConfiguration()
            model.fromMap(value)
            self.udPullConfiguration = model
        }
    }
}

public class GetIdentityProviderUdPullConfigurationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetIdentityProviderUdPullConfigurationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetIdentityProviderUdPullConfigurationResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetInstanceRequest : Tea.TeaModel {
    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
    }
}

public class GetInstanceResponseBody : Tea.TeaModel {
    public class Instance : Tea.TeaModel {
        public class DefaultEndpoint : Tea.TeaModel {
            public var endpoint: String?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.endpoint != nil {
                    map["Endpoint"] = self.endpoint!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Endpoint"] as? String {
                    self.endpoint = value
                }
                if let value = dict["Status"] as? String {
                    self.status = value
                }
            }
        }
        public class DomainConfig : Tea.TeaModel {
            public var defaultDomain: String?

            public var initDomain: String?

            public var initDomainAutoRedirectStatus: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.defaultDomain != nil {
                    map["DefaultDomain"] = self.defaultDomain!
                }
                if self.initDomain != nil {
                    map["InitDomain"] = self.initDomain!
                }
                if self.initDomainAutoRedirectStatus != nil {
                    map["InitDomainAutoRedirectStatus"] = self.initDomainAutoRedirectStatus!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["DefaultDomain"] as? String {
                    self.defaultDomain = value
                }
                if let value = dict["InitDomain"] as? String {
                    self.initDomain = value
                }
                if let value = dict["InitDomainAutoRedirectStatus"] as? String {
                    self.initDomainAutoRedirectStatus = value
                }
            }
        }
        public var createTime: Int64?

        public var defaultEndpoint: GetInstanceResponseBody.Instance.DefaultEndpoint?

        public var description_: String?

        public var domainConfig: GetInstanceResponseBody.Instance.DomainConfig?

        public var egressAddresses: [String]?

        public var instanceId: String?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.defaultEndpoint?.validate()
            try self.domainConfig?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.defaultEndpoint != nil {
                map["DefaultEndpoint"] = self.defaultEndpoint?.toMap()
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.domainConfig != nil {
                map["DomainConfig"] = self.domainConfig?.toMap()
            }
            if self.egressAddresses != nil {
                map["EgressAddresses"] = self.egressAddresses!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["CreateTime"] as? Int64 {
                self.createTime = value
            }
            if let value = dict["DefaultEndpoint"] as? [String: Any?] {
                var model = GetInstanceResponseBody.Instance.DefaultEndpoint()
                model.fromMap(value)
                self.defaultEndpoint = model
            }
            if let value = dict["Description"] as? String {
                self.description_ = value
            }
            if let value = dict["DomainConfig"] as? [String: Any?] {
                var model = GetInstanceResponseBody.Instance.DomainConfig()
                model.fromMap(value)
                self.domainConfig = model
            }
            if let value = dict["EgressAddresses"] as? [String] {
                self.egressAddresses = value
            }
            if let value = dict["InstanceId"] as? String {
                self.instanceId = value
            }
            if let value = dict["Status"] as? String {
                self.status = value
            }
        }
    }
    public var instance: GetInstanceResponseBody.Instance?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.instance?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instance != nil {
            map["Instance"] = self.instance?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Instance"] as? [String: Any?] {
            var model = GetInstanceResponseBody.Instance()
            model.fromMap(value)
            self.instance = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class GetInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetInstanceResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetInstanceLicenseRequest : Tea.TeaModel {
    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
    }
}

public class GetInstanceLicenseResponseBody : Tea.TeaModel {
    public class License : Tea.TeaModel {
        public var edition: String?

        public var endTime: Int64?

        public var licenseChargeType: String?

        public var licenseConfigJson: String?

        public var licenseCreateTime: Int64?

        public var licenseId: String?

        public var licenseStatus: String?

        public var purchaseChannel: String?

        public var purchaseInstanceId: String?

        public var startTime: Int64?

        public var userQuota: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.edition != nil {
                map["Edition"] = self.edition!
            }
            if self.endTime != nil {
                map["EndTime"] = self.endTime!
            }
            if self.licenseChargeType != nil {
                map["LicenseChargeType"] = self.licenseChargeType!
            }
            if self.licenseConfigJson != nil {
                map["LicenseConfigJson"] = self.licenseConfigJson!
            }
            if self.licenseCreateTime != nil {
                map["LicenseCreateTime"] = self.licenseCreateTime!
            }
            if self.licenseId != nil {
                map["LicenseId"] = self.licenseId!
            }
            if self.licenseStatus != nil {
                map["LicenseStatus"] = self.licenseStatus!
            }
            if self.purchaseChannel != nil {
                map["PurchaseChannel"] = self.purchaseChannel!
            }
            if self.purchaseInstanceId != nil {
                map["PurchaseInstanceId"] = self.purchaseInstanceId!
            }
            if self.startTime != nil {
                map["StartTime"] = self.startTime!
            }
            if self.userQuota != nil {
                map["UserQuota"] = self.userQuota!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Edition"] as? String {
                self.edition = value
            }
            if let value = dict["EndTime"] as? Int64 {
                self.endTime = value
            }
            if let value = dict["LicenseChargeType"] as? String {
                self.licenseChargeType = value
            }
            if let value = dict["LicenseConfigJson"] as? String {
                self.licenseConfigJson = value
            }
            if let value = dict["LicenseCreateTime"] as? Int64 {
                self.licenseCreateTime = value
            }
            if let value = dict["LicenseId"] as? String {
                self.licenseId = value
            }
            if let value = dict["LicenseStatus"] as? String {
                self.licenseStatus = value
            }
            if let value = dict["PurchaseChannel"] as? String {
                self.purchaseChannel = value
            }
            if let value = dict["PurchaseInstanceId"] as? String {
                self.purchaseInstanceId = value
            }
            if let value = dict["StartTime"] as? Int64 {
                self.startTime = value
            }
            if let value = dict["UserQuota"] as? Int64 {
                self.userQuota = value
            }
        }
    }
    public var license: GetInstanceLicenseResponseBody.License?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.license?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.license != nil {
            map["License"] = self.license?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["License"] as? [String: Any?] {
            var model = GetInstanceLicenseResponseBody.License()
            model.fromMap(value)
            self.license = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class GetInstanceLicenseResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetInstanceLicenseResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetInstanceLicenseResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetNetworkAccessEndpointRequest : Tea.TeaModel {
    public var instanceId: String?

    public var networkAccessEndpointId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.networkAccessEndpointId != nil {
            map["NetworkAccessEndpointId"] = self.networkAccessEndpointId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["NetworkAccessEndpointId"] as? String {
            self.networkAccessEndpointId = value
        }
    }
}

public class GetNetworkAccessEndpointResponseBody : Tea.TeaModel {
    public class NetworkAccessEndpoint : Tea.TeaModel {
        public var createTime: Int64?

        public var egressPrivateIpAddresses: [String]?

        public var egressPublicIpAddresses: [String]?

        public var instanceId: String?

        public var networkAccessEndpointId: String?

        public var networkAccessEndpointName: String?

        public var networkAccessEndpointType: String?

        public var securityGroupId: String?

        public var status: String?

        public var updateTime: Int64?

        public var vSwitchIds: [String]?

        public var vpcId: String?

        public var vpcRegionId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.egressPrivateIpAddresses != nil {
                map["EgressPrivateIpAddresses"] = self.egressPrivateIpAddresses!
            }
            if self.egressPublicIpAddresses != nil {
                map["EgressPublicIpAddresses"] = self.egressPublicIpAddresses!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.networkAccessEndpointId != nil {
                map["NetworkAccessEndpointId"] = self.networkAccessEndpointId!
            }
            if self.networkAccessEndpointName != nil {
                map["NetworkAccessEndpointName"] = self.networkAccessEndpointName!
            }
            if self.networkAccessEndpointType != nil {
                map["NetworkAccessEndpointType"] = self.networkAccessEndpointType!
            }
            if self.securityGroupId != nil {
                map["SecurityGroupId"] = self.securityGroupId!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.updateTime != nil {
                map["UpdateTime"] = self.updateTime!
            }
            if self.vSwitchIds != nil {
                map["VSwitchIds"] = self.vSwitchIds!
            }
            if self.vpcId != nil {
                map["VpcId"] = self.vpcId!
            }
            if self.vpcRegionId != nil {
                map["VpcRegionId"] = self.vpcRegionId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["CreateTime"] as? Int64 {
                self.createTime = value
            }
            if let value = dict["EgressPrivateIpAddresses"] as? [String] {
                self.egressPrivateIpAddresses = value
            }
            if let value = dict["EgressPublicIpAddresses"] as? [String] {
                self.egressPublicIpAddresses = value
            }
            if let value = dict["InstanceId"] as? String {
                self.instanceId = value
            }
            if let value = dict["NetworkAccessEndpointId"] as? String {
                self.networkAccessEndpointId = value
            }
            if let value = dict["NetworkAccessEndpointName"] as? String {
                self.networkAccessEndpointName = value
            }
            if let value = dict["NetworkAccessEndpointType"] as? String {
                self.networkAccessEndpointType = value
            }
            if let value = dict["SecurityGroupId"] as? String {
                self.securityGroupId = value
            }
            if let value = dict["Status"] as? String {
                self.status = value
            }
            if let value = dict["UpdateTime"] as? Int64 {
                self.updateTime = value
            }
            if let value = dict["VSwitchIds"] as? [String] {
                self.vSwitchIds = value
            }
            if let value = dict["VpcId"] as? String {
                self.vpcId = value
            }
            if let value = dict["VpcRegionId"] as? String {
                self.vpcRegionId = value
            }
        }
    }
    public var networkAccessEndpoint: GetNetworkAccessEndpointResponseBody.NetworkAccessEndpoint?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.networkAccessEndpoint?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.networkAccessEndpoint != nil {
            map["NetworkAccessEndpoint"] = self.networkAccessEndpoint?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["NetworkAccessEndpoint"] as? [String: Any?] {
            var model = GetNetworkAccessEndpointResponseBody.NetworkAccessEndpoint()
            model.fromMap(value)
            self.networkAccessEndpoint = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class GetNetworkAccessEndpointResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetNetworkAccessEndpointResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetNetworkAccessEndpointResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetOrganizationalUnitRequest : Tea.TeaModel {
    public var instanceId: String?

    public var organizationalUnitId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.organizationalUnitId != nil {
            map["OrganizationalUnitId"] = self.organizationalUnitId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["OrganizationalUnitId"] as? String {
            self.organizationalUnitId = value
        }
    }
}

public class GetOrganizationalUnitResponseBody : Tea.TeaModel {
    public class OrganizationalUnit : Tea.TeaModel {
        public var createTime: Int64?

        public var description_: String?

        public var instanceId: String?

        public var leaf: Bool?

        public var organizationalUnitExternalId: String?

        public var organizationalUnitId: String?

        public var organizationalUnitName: String?

        public var organizationalUnitSourceId: String?

        public var organizationalUnitSourceType: String?

        public var parentId: String?

        public var updateTime: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.leaf != nil {
                map["Leaf"] = self.leaf!
            }
            if self.organizationalUnitExternalId != nil {
                map["OrganizationalUnitExternalId"] = self.organizationalUnitExternalId!
            }
            if self.organizationalUnitId != nil {
                map["OrganizationalUnitId"] = self.organizationalUnitId!
            }
            if self.organizationalUnitName != nil {
                map["OrganizationalUnitName"] = self.organizationalUnitName!
            }
            if self.organizationalUnitSourceId != nil {
                map["OrganizationalUnitSourceId"] = self.organizationalUnitSourceId!
            }
            if self.organizationalUnitSourceType != nil {
                map["OrganizationalUnitSourceType"] = self.organizationalUnitSourceType!
            }
            if self.parentId != nil {
                map["ParentId"] = self.parentId!
            }
            if self.updateTime != nil {
                map["UpdateTime"] = self.updateTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["CreateTime"] as? Int64 {
                self.createTime = value
            }
            if let value = dict["Description"] as? String {
                self.description_ = value
            }
            if let value = dict["InstanceId"] as? String {
                self.instanceId = value
            }
            if let value = dict["Leaf"] as? Bool {
                self.leaf = value
            }
            if let value = dict["OrganizationalUnitExternalId"] as? String {
                self.organizationalUnitExternalId = value
            }
            if let value = dict["OrganizationalUnitId"] as? String {
                self.organizationalUnitId = value
            }
            if let value = dict["OrganizationalUnitName"] as? String {
                self.organizationalUnitName = value
            }
            if let value = dict["OrganizationalUnitSourceId"] as? String {
                self.organizationalUnitSourceId = value
            }
            if let value = dict["OrganizationalUnitSourceType"] as? String {
                self.organizationalUnitSourceType = value
            }
            if let value = dict["ParentId"] as? String {
                self.parentId = value
            }
            if let value = dict["UpdateTime"] as? Int64 {
                self.updateTime = value
            }
        }
    }
    public var organizationalUnit: GetOrganizationalUnitResponseBody.OrganizationalUnit?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.organizationalUnit?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.organizationalUnit != nil {
            map["OrganizationalUnit"] = self.organizationalUnit?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["OrganizationalUnit"] as? [String: Any?] {
            var model = GetOrganizationalUnitResponseBody.OrganizationalUnit()
            model.fromMap(value)
            self.organizationalUnit = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class GetOrganizationalUnitResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetOrganizationalUnitResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetOrganizationalUnitResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetPasswordComplexityConfigurationRequest : Tea.TeaModel {
    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
    }
}

public class GetPasswordComplexityConfigurationResponseBody : Tea.TeaModel {
    public class PasswordComplexityConfiguration : Tea.TeaModel {
        public class PasswordComplexityRules : Tea.TeaModel {
            public var passwordCheckType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.passwordCheckType != nil {
                    map["PasswordCheckType"] = self.passwordCheckType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["PasswordCheckType"] as? String {
                    self.passwordCheckType = value
                }
            }
        }
        public var passwordComplexityRules: [GetPasswordComplexityConfigurationResponseBody.PasswordComplexityConfiguration.PasswordComplexityRules]?

        public var passwordMinLength: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.passwordComplexityRules != nil {
                var tmp : [Any] = []
                for k in self.passwordComplexityRules! {
                    tmp.append(k.toMap())
                }
                map["PasswordComplexityRules"] = tmp
            }
            if self.passwordMinLength != nil {
                map["PasswordMinLength"] = self.passwordMinLength!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["PasswordComplexityRules"] as? [Any?] {
                var tmp : [GetPasswordComplexityConfigurationResponseBody.PasswordComplexityConfiguration.PasswordComplexityRules] = []
                for v in value {
                    if v != nil {
                        var model = GetPasswordComplexityConfigurationResponseBody.PasswordComplexityConfiguration.PasswordComplexityRules()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.passwordComplexityRules = tmp
            }
            if let value = dict["PasswordMinLength"] as? Int32 {
                self.passwordMinLength = value
            }
        }
    }
    public var passwordComplexityConfiguration: GetPasswordComplexityConfigurationResponseBody.PasswordComplexityConfiguration?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.passwordComplexityConfiguration?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.passwordComplexityConfiguration != nil {
            map["PasswordComplexityConfiguration"] = self.passwordComplexityConfiguration?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["PasswordComplexityConfiguration"] as? [String: Any?] {
            var model = GetPasswordComplexityConfigurationResponseBody.PasswordComplexityConfiguration()
            model.fromMap(value)
            self.passwordComplexityConfiguration = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class GetPasswordComplexityConfigurationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetPasswordComplexityConfigurationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetPasswordComplexityConfigurationResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetPasswordExpirationConfigurationRequest : Tea.TeaModel {
    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
    }
}

public class GetPasswordExpirationConfigurationResponseBody : Tea.TeaModel {
    public class PasswordExpirationConfiguration : Tea.TeaModel {
        public var effectiveAuthenticationSourceIds: [String]?

        public var passwordExpirationAction: String?

        public var passwordExpirationNotificationChannels: [String]?

        public var passwordExpirationNotificationDuration: Int32?

        public var passwordExpirationNotificationStatus: String?

        public var passwordExpirationStatus: String?

        public var passwordForcedUpdateDuration: Int32?

        public var passwordValidMaxDay: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.effectiveAuthenticationSourceIds != nil {
                map["EffectiveAuthenticationSourceIds"] = self.effectiveAuthenticationSourceIds!
            }
            if self.passwordExpirationAction != nil {
                map["PasswordExpirationAction"] = self.passwordExpirationAction!
            }
            if self.passwordExpirationNotificationChannels != nil {
                map["PasswordExpirationNotificationChannels"] = self.passwordExpirationNotificationChannels!
            }
            if self.passwordExpirationNotificationDuration != nil {
                map["PasswordExpirationNotificationDuration"] = self.passwordExpirationNotificationDuration!
            }
            if self.passwordExpirationNotificationStatus != nil {
                map["PasswordExpirationNotificationStatus"] = self.passwordExpirationNotificationStatus!
            }
            if self.passwordExpirationStatus != nil {
                map["PasswordExpirationStatus"] = self.passwordExpirationStatus!
            }
            if self.passwordForcedUpdateDuration != nil {
                map["PasswordForcedUpdateDuration"] = self.passwordForcedUpdateDuration!
            }
            if self.passwordValidMaxDay != nil {
                map["PasswordValidMaxDay"] = self.passwordValidMaxDay!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["EffectiveAuthenticationSourceIds"] as? [String] {
                self.effectiveAuthenticationSourceIds = value
            }
            if let value = dict["PasswordExpirationAction"] as? String {
                self.passwordExpirationAction = value
            }
            if let value = dict["PasswordExpirationNotificationChannels"] as? [String] {
                self.passwordExpirationNotificationChannels = value
            }
            if let value = dict["PasswordExpirationNotificationDuration"] as? Int32 {
                self.passwordExpirationNotificationDuration = value
            }
            if let value = dict["PasswordExpirationNotificationStatus"] as? String {
                self.passwordExpirationNotificationStatus = value
            }
            if let value = dict["PasswordExpirationStatus"] as? String {
                self.passwordExpirationStatus = value
            }
            if let value = dict["PasswordForcedUpdateDuration"] as? Int32 {
                self.passwordForcedUpdateDuration = value
            }
            if let value = dict["PasswordValidMaxDay"] as? Int32 {
                self.passwordValidMaxDay = value
            }
        }
    }
    public var passwordExpirationConfiguration: GetPasswordExpirationConfigurationResponseBody.PasswordExpirationConfiguration?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.passwordExpirationConfiguration?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.passwordExpirationConfiguration != nil {
            map["PasswordExpirationConfiguration"] = self.passwordExpirationConfiguration?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["PasswordExpirationConfiguration"] as? [String: Any?] {
            var model = GetPasswordExpirationConfigurationResponseBody.PasswordExpirationConfiguration()
            model.fromMap(value)
            self.passwordExpirationConfiguration = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class GetPasswordExpirationConfigurationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetPasswordExpirationConfigurationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetPasswordExpirationConfigurationResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetPasswordHistoryConfigurationRequest : Tea.TeaModel {
    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
    }
}

public class GetPasswordHistoryConfigurationResponseBody : Tea.TeaModel {
    public class PasswordHistoryConfiguration : Tea.TeaModel {
        public var passwordHistoryMaxRetention: Int32?

        public var passwordHistoryStatus: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.passwordHistoryMaxRetention != nil {
                map["PasswordHistoryMaxRetention"] = self.passwordHistoryMaxRetention!
            }
            if self.passwordHistoryStatus != nil {
                map["PasswordHistoryStatus"] = self.passwordHistoryStatus!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["PasswordHistoryMaxRetention"] as? Int32 {
                self.passwordHistoryMaxRetention = value
            }
            if let value = dict["PasswordHistoryStatus"] as? String {
                self.passwordHistoryStatus = value
            }
        }
    }
    public var passwordHistoryConfiguration: GetPasswordHistoryConfigurationResponseBody.PasswordHistoryConfiguration?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.passwordHistoryConfiguration?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.passwordHistoryConfiguration != nil {
            map["PasswordHistoryConfiguration"] = self.passwordHistoryConfiguration?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["PasswordHistoryConfiguration"] as? [String: Any?] {
            var model = GetPasswordHistoryConfigurationResponseBody.PasswordHistoryConfiguration()
            model.fromMap(value)
            self.passwordHistoryConfiguration = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class GetPasswordHistoryConfigurationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetPasswordHistoryConfigurationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetPasswordHistoryConfigurationResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetPasswordInitializationConfigurationRequest : Tea.TeaModel {
    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
    }
}

public class GetPasswordInitializationConfigurationResponseBody : Tea.TeaModel {
    public class PasswordInitializationConfiguration : Tea.TeaModel {
        public var passwordForcedUpdateStatus: String?

        public var passwordInitializationNotificationChannels: [String]?

        public var passwordInitializationStatus: String?

        public var passwordInitializationType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.passwordForcedUpdateStatus != nil {
                map["PasswordForcedUpdateStatus"] = self.passwordForcedUpdateStatus!
            }
            if self.passwordInitializationNotificationChannels != nil {
                map["PasswordInitializationNotificationChannels"] = self.passwordInitializationNotificationChannels!
            }
            if self.passwordInitializationStatus != nil {
                map["PasswordInitializationStatus"] = self.passwordInitializationStatus!
            }
            if self.passwordInitializationType != nil {
                map["PasswordInitializationType"] = self.passwordInitializationType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["PasswordForcedUpdateStatus"] as? String {
                self.passwordForcedUpdateStatus = value
            }
            if let value = dict["PasswordInitializationNotificationChannels"] as? [String] {
                self.passwordInitializationNotificationChannels = value
            }
            if let value = dict["PasswordInitializationStatus"] as? String {
                self.passwordInitializationStatus = value
            }
            if let value = dict["PasswordInitializationType"] as? String {
                self.passwordInitializationType = value
            }
        }
    }
    public var passwordInitializationConfiguration: GetPasswordInitializationConfigurationResponseBody.PasswordInitializationConfiguration?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.passwordInitializationConfiguration?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.passwordInitializationConfiguration != nil {
            map["PasswordInitializationConfiguration"] = self.passwordInitializationConfiguration?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["PasswordInitializationConfiguration"] as? [String: Any?] {
            var model = GetPasswordInitializationConfigurationResponseBody.PasswordInitializationConfiguration()
            model.fromMap(value)
            self.passwordInitializationConfiguration = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class GetPasswordInitializationConfigurationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetPasswordInitializationConfigurationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetPasswordInitializationConfigurationResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetRootOrganizationalUnitRequest : Tea.TeaModel {
    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
    }
}

public class GetRootOrganizationalUnitResponseBody : Tea.TeaModel {
    public class OrganizationalUnit : Tea.TeaModel {
        public var createTime: Int64?

        public var description_: String?

        public var instanceId: String?

        public var organizationalUnitId: String?

        public var organizationalUnitName: String?

        public var updateTime: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.organizationalUnitId != nil {
                map["OrganizationalUnitId"] = self.organizationalUnitId!
            }
            if self.organizationalUnitName != nil {
                map["OrganizationalUnitName"] = self.organizationalUnitName!
            }
            if self.updateTime != nil {
                map["UpdateTime"] = self.updateTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["CreateTime"] as? Int64 {
                self.createTime = value
            }
            if let value = dict["Description"] as? String {
                self.description_ = value
            }
            if let value = dict["InstanceId"] as? String {
                self.instanceId = value
            }
            if let value = dict["OrganizationalUnitId"] as? String {
                self.organizationalUnitId = value
            }
            if let value = dict["OrganizationalUnitName"] as? String {
                self.organizationalUnitName = value
            }
            if let value = dict["UpdateTime"] as? Int64 {
                self.updateTime = value
            }
        }
    }
    public var organizationalUnit: GetRootOrganizationalUnitResponseBody.OrganizationalUnit?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.organizationalUnit?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.organizationalUnit != nil {
            map["OrganizationalUnit"] = self.organizationalUnit?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["OrganizationalUnit"] as? [String: Any?] {
            var model = GetRootOrganizationalUnitResponseBody.OrganizationalUnit()
            model.fromMap(value)
            self.organizationalUnit = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class GetRootOrganizationalUnitResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetRootOrganizationalUnitResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetRootOrganizationalUnitResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetSynchronizationJobRequest : Tea.TeaModel {
    public var instanceId: String?

    public var synchronizationJobId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.synchronizationJobId != nil {
            map["SynchronizationJobId"] = self.synchronizationJobId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["SynchronizationJobId"] as? String {
            self.synchronizationJobId = value
        }
    }
}

public class GetSynchronizationJobResponseBody : Tea.TeaModel {
    public class SynchronizationJob : Tea.TeaModel {
        public class Result : Tea.TeaModel {
            public class GroupMemberStatistics : Tea.TeaModel {
                public class Binded : Tea.TeaModel {
                    public var failed: Int64?

                    public var skipped: Int64?

                    public var success: Int64?

                    public var total: Int64?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.failed != nil {
                            map["Failed"] = self.failed!
                        }
                        if self.skipped != nil {
                            map["Skipped"] = self.skipped!
                        }
                        if self.success != nil {
                            map["Success"] = self.success!
                        }
                        if self.total != nil {
                            map["Total"] = self.total!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Failed"] as? Int64 {
                            self.failed = value
                        }
                        if let value = dict["Skipped"] as? Int64 {
                            self.skipped = value
                        }
                        if let value = dict["Success"] as? Int64 {
                            self.success = value
                        }
                        if let value = dict["Total"] as? Int64 {
                            self.total = value
                        }
                    }
                }
                public class Created : Tea.TeaModel {
                    public var failed: Int64?

                    public var skipped: Int64?

                    public var success: Int64?

                    public var total: Int64?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.failed != nil {
                            map["Failed"] = self.failed!
                        }
                        if self.skipped != nil {
                            map["Skipped"] = self.skipped!
                        }
                        if self.success != nil {
                            map["Success"] = self.success!
                        }
                        if self.total != nil {
                            map["Total"] = self.total!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Failed"] as? Int64 {
                            self.failed = value
                        }
                        if let value = dict["Skipped"] as? Int64 {
                            self.skipped = value
                        }
                        if let value = dict["Success"] as? Int64 {
                            self.success = value
                        }
                        if let value = dict["Total"] as? Int64 {
                            self.total = value
                        }
                    }
                }
                public class Deleted : Tea.TeaModel {
                    public var failed: Int64?

                    public var skipped: Int64?

                    public var success: Int64?

                    public var total: Int64?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.failed != nil {
                            map["Failed"] = self.failed!
                        }
                        if self.skipped != nil {
                            map["Skipped"] = self.skipped!
                        }
                        if self.success != nil {
                            map["Success"] = self.success!
                        }
                        if self.total != nil {
                            map["Total"] = self.total!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Failed"] as? Int64 {
                            self.failed = value
                        }
                        if let value = dict["Skipped"] as? Int64 {
                            self.skipped = value
                        }
                        if let value = dict["Success"] as? Int64 {
                            self.success = value
                        }
                        if let value = dict["Total"] as? Int64 {
                            self.total = value
                        }
                    }
                }
                public class Pushed : Tea.TeaModel {
                    public var failed: Int64?

                    public var skipped: Int64?

                    public var success: Int64?

                    public var total: Int64?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.failed != nil {
                            map["Failed"] = self.failed!
                        }
                        if self.skipped != nil {
                            map["Skipped"] = self.skipped!
                        }
                        if self.success != nil {
                            map["Success"] = self.success!
                        }
                        if self.total != nil {
                            map["Total"] = self.total!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Failed"] as? Int64 {
                            self.failed = value
                        }
                        if let value = dict["Skipped"] as? Int64 {
                            self.skipped = value
                        }
                        if let value = dict["Success"] as? Int64 {
                            self.success = value
                        }
                        if let value = dict["Total"] as? Int64 {
                            self.total = value
                        }
                    }
                }
                public class Same : Tea.TeaModel {
                    public var failed: Int64?

                    public var skipped: Int64?

                    public var success: Int64?

                    public var total: Int64?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.failed != nil {
                            map["Failed"] = self.failed!
                        }
                        if self.skipped != nil {
                            map["Skipped"] = self.skipped!
                        }
                        if self.success != nil {
                            map["Success"] = self.success!
                        }
                        if self.total != nil {
                            map["Total"] = self.total!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Failed"] as? Int64 {
                            self.failed = value
                        }
                        if let value = dict["Skipped"] as? Int64 {
                            self.skipped = value
                        }
                        if let value = dict["Success"] as? Int64 {
                            self.success = value
                        }
                        if let value = dict["Total"] as? Int64 {
                            self.total = value
                        }
                    }
                }
                public class Updated : Tea.TeaModel {
                    public var failed: Int64?

                    public var skipped: Int64?

                    public var success: Int64?

                    public var total: Int64?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.failed != nil {
                            map["Failed"] = self.failed!
                        }
                        if self.skipped != nil {
                            map["Skipped"] = self.skipped!
                        }
                        if self.success != nil {
                            map["Success"] = self.success!
                        }
                        if self.total != nil {
                            map["Total"] = self.total!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Failed"] as? Int64 {
                            self.failed = value
                        }
                        if let value = dict["Skipped"] as? Int64 {
                            self.skipped = value
                        }
                        if let value = dict["Success"] as? Int64 {
                            self.success = value
                        }
                        if let value = dict["Total"] as? Int64 {
                            self.total = value
                        }
                    }
                }
                public var binded: GetSynchronizationJobResponseBody.SynchronizationJob.Result.GroupMemberStatistics.Binded?

                public var created: GetSynchronizationJobResponseBody.SynchronizationJob.Result.GroupMemberStatistics.Created?

                public var deleted: GetSynchronizationJobResponseBody.SynchronizationJob.Result.GroupMemberStatistics.Deleted?

                public var pushed: GetSynchronizationJobResponseBody.SynchronizationJob.Result.GroupMemberStatistics.Pushed?

                public var same: GetSynchronizationJobResponseBody.SynchronizationJob.Result.GroupMemberStatistics.Same?

                public var updated: GetSynchronizationJobResponseBody.SynchronizationJob.Result.GroupMemberStatistics.Updated?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.binded?.validate()
                    try self.created?.validate()
                    try self.deleted?.validate()
                    try self.pushed?.validate()
                    try self.same?.validate()
                    try self.updated?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.binded != nil {
                        map["Binded"] = self.binded?.toMap()
                    }
                    if self.created != nil {
                        map["Created"] = self.created?.toMap()
                    }
                    if self.deleted != nil {
                        map["Deleted"] = self.deleted?.toMap()
                    }
                    if self.pushed != nil {
                        map["Pushed"] = self.pushed?.toMap()
                    }
                    if self.same != nil {
                        map["Same"] = self.same?.toMap()
                    }
                    if self.updated != nil {
                        map["Updated"] = self.updated?.toMap()
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Binded"] as? [String: Any?] {
                        var model = GetSynchronizationJobResponseBody.SynchronizationJob.Result.GroupMemberStatistics.Binded()
                        model.fromMap(value)
                        self.binded = model
                    }
                    if let value = dict["Created"] as? [String: Any?] {
                        var model = GetSynchronizationJobResponseBody.SynchronizationJob.Result.GroupMemberStatistics.Created()
                        model.fromMap(value)
                        self.created = model
                    }
                    if let value = dict["Deleted"] as? [String: Any?] {
                        var model = GetSynchronizationJobResponseBody.SynchronizationJob.Result.GroupMemberStatistics.Deleted()
                        model.fromMap(value)
                        self.deleted = model
                    }
                    if let value = dict["Pushed"] as? [String: Any?] {
                        var model = GetSynchronizationJobResponseBody.SynchronizationJob.Result.GroupMemberStatistics.Pushed()
                        model.fromMap(value)
                        self.pushed = model
                    }
                    if let value = dict["Same"] as? [String: Any?] {
                        var model = GetSynchronizationJobResponseBody.SynchronizationJob.Result.GroupMemberStatistics.Same()
                        model.fromMap(value)
                        self.same = model
                    }
                    if let value = dict["Updated"] as? [String: Any?] {
                        var model = GetSynchronizationJobResponseBody.SynchronizationJob.Result.GroupMemberStatistics.Updated()
                        model.fromMap(value)
                        self.updated = model
                    }
                }
            }
            public class GroupStatistics : Tea.TeaModel {
                public class Binded : Tea.TeaModel {
                    public var failed: Int64?

                    public var skipped: Int64?

                    public var success: Int64?

                    public var total: Int64?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.failed != nil {
                            map["Failed"] = self.failed!
                        }
                        if self.skipped != nil {
                            map["Skipped"] = self.skipped!
                        }
                        if self.success != nil {
                            map["Success"] = self.success!
                        }
                        if self.total != nil {
                            map["Total"] = self.total!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Failed"] as? Int64 {
                            self.failed = value
                        }
                        if let value = dict["Skipped"] as? Int64 {
                            self.skipped = value
                        }
                        if let value = dict["Success"] as? Int64 {
                            self.success = value
                        }
                        if let value = dict["Total"] as? Int64 {
                            self.total = value
                        }
                    }
                }
                public class Created : Tea.TeaModel {
                    public var failed: Int64?

                    public var skipped: Int64?

                    public var success: Int64?

                    public var total: Int64?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.failed != nil {
                            map["Failed"] = self.failed!
                        }
                        if self.skipped != nil {
                            map["Skipped"] = self.skipped!
                        }
                        if self.success != nil {
                            map["Success"] = self.success!
                        }
                        if self.total != nil {
                            map["Total"] = self.total!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Failed"] as? Int64 {
                            self.failed = value
                        }
                        if let value = dict["Skipped"] as? Int64 {
                            self.skipped = value
                        }
                        if let value = dict["Success"] as? Int64 {
                            self.success = value
                        }
                        if let value = dict["Total"] as? Int64 {
                            self.total = value
                        }
                    }
                }
                public class Deleted : Tea.TeaModel {
                    public var failed: Int64?

                    public var skipped: Int64?

                    public var success: Int64?

                    public var total: Int64?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.failed != nil {
                            map["Failed"] = self.failed!
                        }
                        if self.skipped != nil {
                            map["Skipped"] = self.skipped!
                        }
                        if self.success != nil {
                            map["Success"] = self.success!
                        }
                        if self.total != nil {
                            map["Total"] = self.total!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Failed"] as? Int64 {
                            self.failed = value
                        }
                        if let value = dict["Skipped"] as? Int64 {
                            self.skipped = value
                        }
                        if let value = dict["Success"] as? Int64 {
                            self.success = value
                        }
                        if let value = dict["Total"] as? Int64 {
                            self.total = value
                        }
                    }
                }
                public class Pushed : Tea.TeaModel {
                    public var failed: Int64?

                    public var skipped: Int64?

                    public var success: Int64?

                    public var total: Int64?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.failed != nil {
                            map["Failed"] = self.failed!
                        }
                        if self.skipped != nil {
                            map["Skipped"] = self.skipped!
                        }
                        if self.success != nil {
                            map["Success"] = self.success!
                        }
                        if self.total != nil {
                            map["Total"] = self.total!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Failed"] as? Int64 {
                            self.failed = value
                        }
                        if let value = dict["Skipped"] as? Int64 {
                            self.skipped = value
                        }
                        if let value = dict["Success"] as? Int64 {
                            self.success = value
                        }
                        if let value = dict["Total"] as? Int64 {
                            self.total = value
                        }
                    }
                }
                public class Same : Tea.TeaModel {
                    public var failed: Int64?

                    public var skipped: Int64?

                    public var success: Int64?

                    public var total: Int64?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.failed != nil {
                            map["Failed"] = self.failed!
                        }
                        if self.skipped != nil {
                            map["Skipped"] = self.skipped!
                        }
                        if self.success != nil {
                            map["Success"] = self.success!
                        }
                        if self.total != nil {
                            map["Total"] = self.total!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Failed"] as? Int64 {
                            self.failed = value
                        }
                        if let value = dict["Skipped"] as? Int64 {
                            self.skipped = value
                        }
                        if let value = dict["Success"] as? Int64 {
                            self.success = value
                        }
                        if let value = dict["Total"] as? Int64 {
                            self.total = value
                        }
                    }
                }
                public class Updated : Tea.TeaModel {
                    public var failed: Int64?

                    public var skipped: Int64?

                    public var success: Int64?

                    public var total: Int64?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.failed != nil {
                            map["Failed"] = self.failed!
                        }
                        if self.skipped != nil {
                            map["Skipped"] = self.skipped!
                        }
                        if self.success != nil {
                            map["Success"] = self.success!
                        }
                        if self.total != nil {
                            map["Total"] = self.total!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Failed"] as? Int64 {
                            self.failed = value
                        }
                        if let value = dict["Skipped"] as? Int64 {
                            self.skipped = value
                        }
                        if let value = dict["Success"] as? Int64 {
                            self.success = value
                        }
                        if let value = dict["Total"] as? Int64 {
                            self.total = value
                        }
                    }
                }
                public var binded: GetSynchronizationJobResponseBody.SynchronizationJob.Result.GroupStatistics.Binded?

                public var created: GetSynchronizationJobResponseBody.SynchronizationJob.Result.GroupStatistics.Created?

                public var deleted: GetSynchronizationJobResponseBody.SynchronizationJob.Result.GroupStatistics.Deleted?

                public var pushed: GetSynchronizationJobResponseBody.SynchronizationJob.Result.GroupStatistics.Pushed?

                public var same: GetSynchronizationJobResponseBody.SynchronizationJob.Result.GroupStatistics.Same?

                public var updated: GetSynchronizationJobResponseBody.SynchronizationJob.Result.GroupStatistics.Updated?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.binded?.validate()
                    try self.created?.validate()
                    try self.deleted?.validate()
                    try self.pushed?.validate()
                    try self.same?.validate()
                    try self.updated?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.binded != nil {
                        map["Binded"] = self.binded?.toMap()
                    }
                    if self.created != nil {
                        map["Created"] = self.created?.toMap()
                    }
                    if self.deleted != nil {
                        map["Deleted"] = self.deleted?.toMap()
                    }
                    if self.pushed != nil {
                        map["Pushed"] = self.pushed?.toMap()
                    }
                    if self.same != nil {
                        map["Same"] = self.same?.toMap()
                    }
                    if self.updated != nil {
                        map["Updated"] = self.updated?.toMap()
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Binded"] as? [String: Any?] {
                        var model = GetSynchronizationJobResponseBody.SynchronizationJob.Result.GroupStatistics.Binded()
                        model.fromMap(value)
                        self.binded = model
                    }
                    if let value = dict["Created"] as? [String: Any?] {
                        var model = GetSynchronizationJobResponseBody.SynchronizationJob.Result.GroupStatistics.Created()
                        model.fromMap(value)
                        self.created = model
                    }
                    if let value = dict["Deleted"] as? [String: Any?] {
                        var model = GetSynchronizationJobResponseBody.SynchronizationJob.Result.GroupStatistics.Deleted()
                        model.fromMap(value)
                        self.deleted = model
                    }
                    if let value = dict["Pushed"] as? [String: Any?] {
                        var model = GetSynchronizationJobResponseBody.SynchronizationJob.Result.GroupStatistics.Pushed()
                        model.fromMap(value)
                        self.pushed = model
                    }
                    if let value = dict["Same"] as? [String: Any?] {
                        var model = GetSynchronizationJobResponseBody.SynchronizationJob.Result.GroupStatistics.Same()
                        model.fromMap(value)
                        self.same = model
                    }
                    if let value = dict["Updated"] as? [String: Any?] {
                        var model = GetSynchronizationJobResponseBody.SynchronizationJob.Result.GroupStatistics.Updated()
                        model.fromMap(value)
                        self.updated = model
                    }
                }
            }
            public class OrganizationalUnitStatistics : Tea.TeaModel {
                public class Binded : Tea.TeaModel {
                    public var failed: Int64?

                    public var skipped: Int64?

                    public var success: Int64?

                    public var total: Int64?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.failed != nil {
                            map["Failed"] = self.failed!
                        }
                        if self.skipped != nil {
                            map["Skipped"] = self.skipped!
                        }
                        if self.success != nil {
                            map["Success"] = self.success!
                        }
                        if self.total != nil {
                            map["Total"] = self.total!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Failed"] as? Int64 {
                            self.failed = value
                        }
                        if let value = dict["Skipped"] as? Int64 {
                            self.skipped = value
                        }
                        if let value = dict["Success"] as? Int64 {
                            self.success = value
                        }
                        if let value = dict["Total"] as? Int64 {
                            self.total = value
                        }
                    }
                }
                public class Created : Tea.TeaModel {
                    public var failed: Int64?

                    public var skipped: Int64?

                    public var success: Int64?

                    public var total: Int64?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.failed != nil {
                            map["Failed"] = self.failed!
                        }
                        if self.skipped != nil {
                            map["Skipped"] = self.skipped!
                        }
                        if self.success != nil {
                            map["Success"] = self.success!
                        }
                        if self.total != nil {
                            map["Total"] = self.total!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Failed"] as? Int64 {
                            self.failed = value
                        }
                        if let value = dict["Skipped"] as? Int64 {
                            self.skipped = value
                        }
                        if let value = dict["Success"] as? Int64 {
                            self.success = value
                        }
                        if let value = dict["Total"] as? Int64 {
                            self.total = value
                        }
                    }
                }
                public class Deleted : Tea.TeaModel {
                    public var failed: Int64?

                    public var skipped: Int64?

                    public var success: Int64?

                    public var total: Int64?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.failed != nil {
                            map["Failed"] = self.failed!
                        }
                        if self.skipped != nil {
                            map["Skipped"] = self.skipped!
                        }
                        if self.success != nil {
                            map["Success"] = self.success!
                        }
                        if self.total != nil {
                            map["Total"] = self.total!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Failed"] as? Int64 {
                            self.failed = value
                        }
                        if let value = dict["Skipped"] as? Int64 {
                            self.skipped = value
                        }
                        if let value = dict["Success"] as? Int64 {
                            self.success = value
                        }
                        if let value = dict["Total"] as? Int64 {
                            self.total = value
                        }
                    }
                }
                public class Pushed : Tea.TeaModel {
                    public var failed: Int64?

                    public var skipped: Int64?

                    public var success: Int64?

                    public var total: Int64?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.failed != nil {
                            map["Failed"] = self.failed!
                        }
                        if self.skipped != nil {
                            map["Skipped"] = self.skipped!
                        }
                        if self.success != nil {
                            map["Success"] = self.success!
                        }
                        if self.total != nil {
                            map["Total"] = self.total!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Failed"] as? Int64 {
                            self.failed = value
                        }
                        if let value = dict["Skipped"] as? Int64 {
                            self.skipped = value
                        }
                        if let value = dict["Success"] as? Int64 {
                            self.success = value
                        }
                        if let value = dict["Total"] as? Int64 {
                            self.total = value
                        }
                    }
                }
                public class Same : Tea.TeaModel {
                    public var failed: Int64?

                    public var skipped: Int64?

                    public var success: Int64?

                    public var total: Int64?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.failed != nil {
                            map["Failed"] = self.failed!
                        }
                        if self.skipped != nil {
                            map["Skipped"] = self.skipped!
                        }
                        if self.success != nil {
                            map["Success"] = self.success!
                        }
                        if self.total != nil {
                            map["Total"] = self.total!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Failed"] as? Int64 {
                            self.failed = value
                        }
                        if let value = dict["Skipped"] as? Int64 {
                            self.skipped = value
                        }
                        if let value = dict["Success"] as? Int64 {
                            self.success = value
                        }
                        if let value = dict["Total"] as? Int64 {
                            self.total = value
                        }
                    }
                }
                public class Updated : Tea.TeaModel {
                    public var failed: Int64?

                    public var skipped: Int64?

                    public var success: Int64?

                    public var total: Int64?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.failed != nil {
                            map["Failed"] = self.failed!
                        }
                        if self.skipped != nil {
                            map["Skipped"] = self.skipped!
                        }
                        if self.success != nil {
                            map["Success"] = self.success!
                        }
                        if self.total != nil {
                            map["Total"] = self.total!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Failed"] as? Int64 {
                            self.failed = value
                        }
                        if let value = dict["Skipped"] as? Int64 {
                            self.skipped = value
                        }
                        if let value = dict["Success"] as? Int64 {
                            self.success = value
                        }
                        if let value = dict["Total"] as? Int64 {
                            self.total = value
                        }
                    }
                }
                public var binded: GetSynchronizationJobResponseBody.SynchronizationJob.Result.OrganizationalUnitStatistics.Binded?

                public var created: GetSynchronizationJobResponseBody.SynchronizationJob.Result.OrganizationalUnitStatistics.Created?

                public var deleted: GetSynchronizationJobResponseBody.SynchronizationJob.Result.OrganizationalUnitStatistics.Deleted?

                public var pushed: GetSynchronizationJobResponseBody.SynchronizationJob.Result.OrganizationalUnitStatistics.Pushed?

                public var same: GetSynchronizationJobResponseBody.SynchronizationJob.Result.OrganizationalUnitStatistics.Same?

                public var updated: GetSynchronizationJobResponseBody.SynchronizationJob.Result.OrganizationalUnitStatistics.Updated?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.binded?.validate()
                    try self.created?.validate()
                    try self.deleted?.validate()
                    try self.pushed?.validate()
                    try self.same?.validate()
                    try self.updated?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.binded != nil {
                        map["Binded"] = self.binded?.toMap()
                    }
                    if self.created != nil {
                        map["Created"] = self.created?.toMap()
                    }
                    if self.deleted != nil {
                        map["Deleted"] = self.deleted?.toMap()
                    }
                    if self.pushed != nil {
                        map["Pushed"] = self.pushed?.toMap()
                    }
                    if self.same != nil {
                        map["Same"] = self.same?.toMap()
                    }
                    if self.updated != nil {
                        map["Updated"] = self.updated?.toMap()
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Binded"] as? [String: Any?] {
                        var model = GetSynchronizationJobResponseBody.SynchronizationJob.Result.OrganizationalUnitStatistics.Binded()
                        model.fromMap(value)
                        self.binded = model
                    }
                    if let value = dict["Created"] as? [String: Any?] {
                        var model = GetSynchronizationJobResponseBody.SynchronizationJob.Result.OrganizationalUnitStatistics.Created()
                        model.fromMap(value)
                        self.created = model
                    }
                    if let value = dict["Deleted"] as? [String: Any?] {
                        var model = GetSynchronizationJobResponseBody.SynchronizationJob.Result.OrganizationalUnitStatistics.Deleted()
                        model.fromMap(value)
                        self.deleted = model
                    }
                    if let value = dict["Pushed"] as? [String: Any?] {
                        var model = GetSynchronizationJobResponseBody.SynchronizationJob.Result.OrganizationalUnitStatistics.Pushed()
                        model.fromMap(value)
                        self.pushed = model
                    }
                    if let value = dict["Same"] as? [String: Any?] {
                        var model = GetSynchronizationJobResponseBody.SynchronizationJob.Result.OrganizationalUnitStatistics.Same()
                        model.fromMap(value)
                        self.same = model
                    }
                    if let value = dict["Updated"] as? [String: Any?] {
                        var model = GetSynchronizationJobResponseBody.SynchronizationJob.Result.OrganizationalUnitStatistics.Updated()
                        model.fromMap(value)
                        self.updated = model
                    }
                }
            }
            public class UserStatistics : Tea.TeaModel {
                public class Binded : Tea.TeaModel {
                    public var failed: Int64?

                    public var skipped: Int64?

                    public var success: Int64?

                    public var total: Int64?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.failed != nil {
                            map["Failed"] = self.failed!
                        }
                        if self.skipped != nil {
                            map["Skipped"] = self.skipped!
                        }
                        if self.success != nil {
                            map["Success"] = self.success!
                        }
                        if self.total != nil {
                            map["Total"] = self.total!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Failed"] as? Int64 {
                            self.failed = value
                        }
                        if let value = dict["Skipped"] as? Int64 {
                            self.skipped = value
                        }
                        if let value = dict["Success"] as? Int64 {
                            self.success = value
                        }
                        if let value = dict["Total"] as? Int64 {
                            self.total = value
                        }
                    }
                }
                public class Created : Tea.TeaModel {
                    public var failed: Int64?

                    public var skipped: Int64?

                    public var success: Int64?

                    public var total: Int64?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.failed != nil {
                            map["Failed"] = self.failed!
                        }
                        if self.skipped != nil {
                            map["Skipped"] = self.skipped!
                        }
                        if self.success != nil {
                            map["Success"] = self.success!
                        }
                        if self.total != nil {
                            map["Total"] = self.total!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Failed"] as? Int64 {
                            self.failed = value
                        }
                        if let value = dict["Skipped"] as? Int64 {
                            self.skipped = value
                        }
                        if let value = dict["Success"] as? Int64 {
                            self.success = value
                        }
                        if let value = dict["Total"] as? Int64 {
                            self.total = value
                        }
                    }
                }
                public class Deleted : Tea.TeaModel {
                    public var failed: Int64?

                    public var skipped: Int64?

                    public var success: Int64?

                    public var total: Int64?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.failed != nil {
                            map["Failed"] = self.failed!
                        }
                        if self.skipped != nil {
                            map["Skipped"] = self.skipped!
                        }
                        if self.success != nil {
                            map["Success"] = self.success!
                        }
                        if self.total != nil {
                            map["Total"] = self.total!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Failed"] as? Int64 {
                            self.failed = value
                        }
                        if let value = dict["Skipped"] as? Int64 {
                            self.skipped = value
                        }
                        if let value = dict["Success"] as? Int64 {
                            self.success = value
                        }
                        if let value = dict["Total"] as? Int64 {
                            self.total = value
                        }
                    }
                }
                public class Pushed : Tea.TeaModel {
                    public var failed: Int64?

                    public var skipped: Int64?

                    public var success: Int64?

                    public var total: Int64?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.failed != nil {
                            map["Failed"] = self.failed!
                        }
                        if self.skipped != nil {
                            map["Skipped"] = self.skipped!
                        }
                        if self.success != nil {
                            map["Success"] = self.success!
                        }
                        if self.total != nil {
                            map["Total"] = self.total!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Failed"] as? Int64 {
                            self.failed = value
                        }
                        if let value = dict["Skipped"] as? Int64 {
                            self.skipped = value
                        }
                        if let value = dict["Success"] as? Int64 {
                            self.success = value
                        }
                        if let value = dict["Total"] as? Int64 {
                            self.total = value
                        }
                    }
                }
                public class Same : Tea.TeaModel {
                    public var failed: Int64?

                    public var skipped: Int64?

                    public var success: Int64?

                    public var total: Int64?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.failed != nil {
                            map["Failed"] = self.failed!
                        }
                        if self.skipped != nil {
                            map["Skipped"] = self.skipped!
                        }
                        if self.success != nil {
                            map["Success"] = self.success!
                        }
                        if self.total != nil {
                            map["Total"] = self.total!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Failed"] as? Int64 {
                            self.failed = value
                        }
                        if let value = dict["Skipped"] as? Int64 {
                            self.skipped = value
                        }
                        if let value = dict["Success"] as? Int64 {
                            self.success = value
                        }
                        if let value = dict["Total"] as? Int64 {
                            self.total = value
                        }
                    }
                }
                public class Updated : Tea.TeaModel {
                    public var failed: Int64?

                    public var skipped: Int64?

                    public var success: Int64?

                    public var total: Int64?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.failed != nil {
                            map["Failed"] = self.failed!
                        }
                        if self.skipped != nil {
                            map["Skipped"] = self.skipped!
                        }
                        if self.success != nil {
                            map["Success"] = self.success!
                        }
                        if self.total != nil {
                            map["Total"] = self.total!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Failed"] as? Int64 {
                            self.failed = value
                        }
                        if let value = dict["Skipped"] as? Int64 {
                            self.skipped = value
                        }
                        if let value = dict["Success"] as? Int64 {
                            self.success = value
                        }
                        if let value = dict["Total"] as? Int64 {
                            self.total = value
                        }
                    }
                }
                public var binded: GetSynchronizationJobResponseBody.SynchronizationJob.Result.UserStatistics.Binded?

                public var created: GetSynchronizationJobResponseBody.SynchronizationJob.Result.UserStatistics.Created?

                public var deleted: GetSynchronizationJobResponseBody.SynchronizationJob.Result.UserStatistics.Deleted?

                public var pushed: GetSynchronizationJobResponseBody.SynchronizationJob.Result.UserStatistics.Pushed?

                public var same: GetSynchronizationJobResponseBody.SynchronizationJob.Result.UserStatistics.Same?

                public var updated: GetSynchronizationJobResponseBody.SynchronizationJob.Result.UserStatistics.Updated?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.binded?.validate()
                    try self.created?.validate()
                    try self.deleted?.validate()
                    try self.pushed?.validate()
                    try self.same?.validate()
                    try self.updated?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.binded != nil {
                        map["Binded"] = self.binded?.toMap()
                    }
                    if self.created != nil {
                        map["Created"] = self.created?.toMap()
                    }
                    if self.deleted != nil {
                        map["Deleted"] = self.deleted?.toMap()
                    }
                    if self.pushed != nil {
                        map["Pushed"] = self.pushed?.toMap()
                    }
                    if self.same != nil {
                        map["Same"] = self.same?.toMap()
                    }
                    if self.updated != nil {
                        map["Updated"] = self.updated?.toMap()
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Binded"] as? [String: Any?] {
                        var model = GetSynchronizationJobResponseBody.SynchronizationJob.Result.UserStatistics.Binded()
                        model.fromMap(value)
                        self.binded = model
                    }
                    if let value = dict["Created"] as? [String: Any?] {
                        var model = GetSynchronizationJobResponseBody.SynchronizationJob.Result.UserStatistics.Created()
                        model.fromMap(value)
                        self.created = model
                    }
                    if let value = dict["Deleted"] as? [String: Any?] {
                        var model = GetSynchronizationJobResponseBody.SynchronizationJob.Result.UserStatistics.Deleted()
                        model.fromMap(value)
                        self.deleted = model
                    }
                    if let value = dict["Pushed"] as? [String: Any?] {
                        var model = GetSynchronizationJobResponseBody.SynchronizationJob.Result.UserStatistics.Pushed()
                        model.fromMap(value)
                        self.pushed = model
                    }
                    if let value = dict["Same"] as? [String: Any?] {
                        var model = GetSynchronizationJobResponseBody.SynchronizationJob.Result.UserStatistics.Same()
                        model.fromMap(value)
                        self.same = model
                    }
                    if let value = dict["Updated"] as? [String: Any?] {
                        var model = GetSynchronizationJobResponseBody.SynchronizationJob.Result.UserStatistics.Updated()
                        model.fromMap(value)
                        self.updated = model
                    }
                }
            }
            public var errorCode: String?

            public var errorMessage: String?

            public var groupMemberStatistics: GetSynchronizationJobResponseBody.SynchronizationJob.Result.GroupMemberStatistics?

            public var groupStatistics: GetSynchronizationJobResponseBody.SynchronizationJob.Result.GroupStatistics?

            public var organizationalUnitStatistics: GetSynchronizationJobResponseBody.SynchronizationJob.Result.OrganizationalUnitStatistics?

            public var userStatistics: GetSynchronizationJobResponseBody.SynchronizationJob.Result.UserStatistics?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.groupMemberStatistics?.validate()
                try self.groupStatistics?.validate()
                try self.organizationalUnitStatistics?.validate()
                try self.userStatistics?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.errorCode != nil {
                    map["ErrorCode"] = self.errorCode!
                }
                if self.errorMessage != nil {
                    map["ErrorMessage"] = self.errorMessage!
                }
                if self.groupMemberStatistics != nil {
                    map["GroupMemberStatistics"] = self.groupMemberStatistics?.toMap()
                }
                if self.groupStatistics != nil {
                    map["GroupStatistics"] = self.groupStatistics?.toMap()
                }
                if self.organizationalUnitStatistics != nil {
                    map["OrganizationalUnitStatistics"] = self.organizationalUnitStatistics?.toMap()
                }
                if self.userStatistics != nil {
                    map["UserStatistics"] = self.userStatistics?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ErrorCode"] as? String {
                    self.errorCode = value
                }
                if let value = dict["ErrorMessage"] as? String {
                    self.errorMessage = value
                }
                if let value = dict["GroupMemberStatistics"] as? [String: Any?] {
                    var model = GetSynchronizationJobResponseBody.SynchronizationJob.Result.GroupMemberStatistics()
                    model.fromMap(value)
                    self.groupMemberStatistics = model
                }
                if let value = dict["GroupStatistics"] as? [String: Any?] {
                    var model = GetSynchronizationJobResponseBody.SynchronizationJob.Result.GroupStatistics()
                    model.fromMap(value)
                    self.groupStatistics = model
                }
                if let value = dict["OrganizationalUnitStatistics"] as? [String: Any?] {
                    var model = GetSynchronizationJobResponseBody.SynchronizationJob.Result.OrganizationalUnitStatistics()
                    model.fromMap(value)
                    self.organizationalUnitStatistics = model
                }
                if let value = dict["UserStatistics"] as? [String: Any?] {
                    var model = GetSynchronizationJobResponseBody.SynchronizationJob.Result.UserStatistics()
                    model.fromMap(value)
                    self.userStatistics = model
                }
            }
        }
        public var direction: String?

        public var endTime: Int64?

        public var result: GetSynchronizationJobResponseBody.SynchronizationJob.Result?

        public var startTime: Int64?

        public var status: String?

        public var synchronizationJobId: String?

        public var targetId: String?

        public var targetType: String?

        public var triggerType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.result?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.direction != nil {
                map["Direction"] = self.direction!
            }
            if self.endTime != nil {
                map["EndTime"] = self.endTime!
            }
            if self.result != nil {
                map["Result"] = self.result?.toMap()
            }
            if self.startTime != nil {
                map["StartTime"] = self.startTime!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.synchronizationJobId != nil {
                map["SynchronizationJobId"] = self.synchronizationJobId!
            }
            if self.targetId != nil {
                map["TargetId"] = self.targetId!
            }
            if self.targetType != nil {
                map["TargetType"] = self.targetType!
            }
            if self.triggerType != nil {
                map["TriggerType"] = self.triggerType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Direction"] as? String {
                self.direction = value
            }
            if let value = dict["EndTime"] as? Int64 {
                self.endTime = value
            }
            if let value = dict["Result"] as? [String: Any?] {
                var model = GetSynchronizationJobResponseBody.SynchronizationJob.Result()
                model.fromMap(value)
                self.result = model
            }
            if let value = dict["StartTime"] as? Int64 {
                self.startTime = value
            }
            if let value = dict["Status"] as? String {
                self.status = value
            }
            if let value = dict["SynchronizationJobId"] as? String {
                self.synchronizationJobId = value
            }
            if let value = dict["TargetId"] as? String {
                self.targetId = value
            }
            if let value = dict["TargetType"] as? String {
                self.targetType = value
            }
            if let value = dict["TriggerType"] as? String {
                self.triggerType = value
            }
        }
    }
    public var requestId: String?

    public var synchronizationJob: GetSynchronizationJobResponseBody.SynchronizationJob?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.synchronizationJob?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.synchronizationJob != nil {
            map["SynchronizationJob"] = self.synchronizationJob?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["SynchronizationJob"] as? [String: Any?] {
            var model = GetSynchronizationJobResponseBody.SynchronizationJob()
            model.fromMap(value)
            self.synchronizationJob = model
        }
    }
}

public class GetSynchronizationJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetSynchronizationJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetSynchronizationJobResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetUserRequest : Tea.TeaModel {
    public var instanceId: String?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["UserId"] as? String {
            self.userId = value
        }
    }
}

public class GetUserResponseBody : Tea.TeaModel {
    public class User : Tea.TeaModel {
        public class CustomFields : Tea.TeaModel {
            public var fieldName: String?

            public var fieldValue: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.fieldName != nil {
                    map["FieldName"] = self.fieldName!
                }
                if self.fieldValue != nil {
                    map["FieldValue"] = self.fieldValue!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["FieldName"] as? String {
                    self.fieldName = value
                }
                if let value = dict["FieldValue"] as? String {
                    self.fieldValue = value
                }
            }
        }
        public class Groups : Tea.TeaModel {
            public var description_: String?

            public var groupId: String?

            public var groupName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.groupId != nil {
                    map["GroupId"] = self.groupId!
                }
                if self.groupName != nil {
                    map["GroupName"] = self.groupName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Description"] as? String {
                    self.description_ = value
                }
                if let value = dict["GroupId"] as? String {
                    self.groupId = value
                }
                if let value = dict["GroupName"] as? String {
                    self.groupName = value
                }
            }
        }
        public class OrganizationalUnits : Tea.TeaModel {
            public var organizationalUnitId: String?

            public var organizationalUnitName: String?

            public var primary: Bool?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.organizationalUnitId != nil {
                    map["OrganizationalUnitId"] = self.organizationalUnitId!
                }
                if self.organizationalUnitName != nil {
                    map["OrganizationalUnitName"] = self.organizationalUnitName!
                }
                if self.primary != nil {
                    map["Primary"] = self.primary!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["OrganizationalUnitId"] as? String {
                    self.organizationalUnitId = value
                }
                if let value = dict["OrganizationalUnitName"] as? String {
                    self.organizationalUnitName = value
                }
                if let value = dict["Primary"] as? Bool {
                    self.primary = value
                }
            }
        }
        public var accountExpireTime: Int64?

        public var createTime: Int64?

        public var customFields: [GetUserResponseBody.User.CustomFields]?

        public var description_: String?

        public var displayName: String?

        public var email: String?

        public var emailVerified: Bool?

        public var groups: [GetUserResponseBody.User.Groups]?

        public var instanceId: String?

        public var lockExpireTime: Int64?

        public var organizationalUnits: [GetUserResponseBody.User.OrganizationalUnits]?

        public var passwordExpireTime: Int64?

        public var passwordSet: Bool?

        public var phoneNumber: String?

        public var phoneNumberVerified: Bool?

        public var phoneRegion: String?

        public var preferredLanguage: String?

        public var primaryOrganizationalUnitId: String?

        public var registerTime: Int64?

        public var status: String?

        public var updateTime: Int64?

        public var userExternalId: String?

        public var userId: String?

        public var userSourceId: String?

        public var userSourceType: String?

        public var username: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountExpireTime != nil {
                map["AccountExpireTime"] = self.accountExpireTime!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.customFields != nil {
                var tmp : [Any] = []
                for k in self.customFields! {
                    tmp.append(k.toMap())
                }
                map["CustomFields"] = tmp
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.displayName != nil {
                map["DisplayName"] = self.displayName!
            }
            if self.email != nil {
                map["Email"] = self.email!
            }
            if self.emailVerified != nil {
                map["EmailVerified"] = self.emailVerified!
            }
            if self.groups != nil {
                var tmp : [Any] = []
                for k in self.groups! {
                    tmp.append(k.toMap())
                }
                map["Groups"] = tmp
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.lockExpireTime != nil {
                map["LockExpireTime"] = self.lockExpireTime!
            }
            if self.organizationalUnits != nil {
                var tmp : [Any] = []
                for k in self.organizationalUnits! {
                    tmp.append(k.toMap())
                }
                map["OrganizationalUnits"] = tmp
            }
            if self.passwordExpireTime != nil {
                map["PasswordExpireTime"] = self.passwordExpireTime!
            }
            if self.passwordSet != nil {
                map["PasswordSet"] = self.passwordSet!
            }
            if self.phoneNumber != nil {
                map["PhoneNumber"] = self.phoneNumber!
            }
            if self.phoneNumberVerified != nil {
                map["PhoneNumberVerified"] = self.phoneNumberVerified!
            }
            if self.phoneRegion != nil {
                map["PhoneRegion"] = self.phoneRegion!
            }
            if self.preferredLanguage != nil {
                map["PreferredLanguage"] = self.preferredLanguage!
            }
            if self.primaryOrganizationalUnitId != nil {
                map["PrimaryOrganizationalUnitId"] = self.primaryOrganizationalUnitId!
            }
            if self.registerTime != nil {
                map["RegisterTime"] = self.registerTime!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.updateTime != nil {
                map["UpdateTime"] = self.updateTime!
            }
            if self.userExternalId != nil {
                map["UserExternalId"] = self.userExternalId!
            }
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            if self.userSourceId != nil {
                map["UserSourceId"] = self.userSourceId!
            }
            if self.userSourceType != nil {
                map["UserSourceType"] = self.userSourceType!
            }
            if self.username != nil {
                map["Username"] = self.username!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AccountExpireTime"] as? Int64 {
                self.accountExpireTime = value
            }
            if let value = dict["CreateTime"] as? Int64 {
                self.createTime = value
            }
            if let value = dict["CustomFields"] as? [Any?] {
                var tmp : [GetUserResponseBody.User.CustomFields] = []
                for v in value {
                    if v != nil {
                        var model = GetUserResponseBody.User.CustomFields()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.customFields = tmp
            }
            if let value = dict["Description"] as? String {
                self.description_ = value
            }
            if let value = dict["DisplayName"] as? String {
                self.displayName = value
            }
            if let value = dict["Email"] as? String {
                self.email = value
            }
            if let value = dict["EmailVerified"] as? Bool {
                self.emailVerified = value
            }
            if let value = dict["Groups"] as? [Any?] {
                var tmp : [GetUserResponseBody.User.Groups] = []
                for v in value {
                    if v != nil {
                        var model = GetUserResponseBody.User.Groups()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.groups = tmp
            }
            if let value = dict["InstanceId"] as? String {
                self.instanceId = value
            }
            if let value = dict["LockExpireTime"] as? Int64 {
                self.lockExpireTime = value
            }
            if let value = dict["OrganizationalUnits"] as? [Any?] {
                var tmp : [GetUserResponseBody.User.OrganizationalUnits] = []
                for v in value {
                    if v != nil {
                        var model = GetUserResponseBody.User.OrganizationalUnits()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.organizationalUnits = tmp
            }
            if let value = dict["PasswordExpireTime"] as? Int64 {
                self.passwordExpireTime = value
            }
            if let value = dict["PasswordSet"] as? Bool {
                self.passwordSet = value
            }
            if let value = dict["PhoneNumber"] as? String {
                self.phoneNumber = value
            }
            if let value = dict["PhoneNumberVerified"] as? Bool {
                self.phoneNumberVerified = value
            }
            if let value = dict["PhoneRegion"] as? String {
                self.phoneRegion = value
            }
            if let value = dict["PreferredLanguage"] as? String {
                self.preferredLanguage = value
            }
            if let value = dict["PrimaryOrganizationalUnitId"] as? String {
                self.primaryOrganizationalUnitId = value
            }
            if let value = dict["RegisterTime"] as? Int64 {
                self.registerTime = value
            }
            if let value = dict["Status"] as? String {
                self.status = value
            }
            if let value = dict["UpdateTime"] as? Int64 {
                self.updateTime = value
            }
            if let value = dict["UserExternalId"] as? String {
                self.userExternalId = value
            }
            if let value = dict["UserId"] as? String {
                self.userId = value
            }
            if let value = dict["UserSourceId"] as? String {
                self.userSourceId = value
            }
            if let value = dict["UserSourceType"] as? String {
                self.userSourceType = value
            }
            if let value = dict["Username"] as? String {
                self.username = value
            }
        }
    }
    public var requestId: String?

    public var user: GetUserResponseBody.User?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.user?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.user != nil {
            map["User"] = self.user?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["User"] as? [String: Any?] {
            var model = GetUserResponseBody.User()
            model.fromMap(value)
            self.user = model
        }
    }
}

public class GetUserResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetUserResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetUserResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListApplicationClientSecretsRequest : Tea.TeaModel {
    public var applicationId: String?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.applicationId != nil {
            map["ApplicationId"] = self.applicationId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ApplicationId"] as? String {
            self.applicationId = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
    }
}

public class ListApplicationClientSecretsResponseBody : Tea.TeaModel {
    public class ApplicationClientSecrets : Tea.TeaModel {
        public var applicationId: String?

        public var clientId: String?

        public var clientSecret: String?

        public var instanceId: String?

        public var lastUsedTime: Int64?

        public var secretId: String?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.applicationId != nil {
                map["ApplicationId"] = self.applicationId!
            }
            if self.clientId != nil {
                map["ClientId"] = self.clientId!
            }
            if self.clientSecret != nil {
                map["ClientSecret"] = self.clientSecret!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.lastUsedTime != nil {
                map["LastUsedTime"] = self.lastUsedTime!
            }
            if self.secretId != nil {
                map["SecretId"] = self.secretId!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ApplicationId"] as? String {
                self.applicationId = value
            }
            if let value = dict["ClientId"] as? String {
                self.clientId = value
            }
            if let value = dict["ClientSecret"] as? String {
                self.clientSecret = value
            }
            if let value = dict["InstanceId"] as? String {
                self.instanceId = value
            }
            if let value = dict["LastUsedTime"] as? Int64 {
                self.lastUsedTime = value
            }
            if let value = dict["SecretId"] as? String {
                self.secretId = value
            }
            if let value = dict["Status"] as? String {
                self.status = value
            }
        }
    }
    public var applicationClientSecrets: [ListApplicationClientSecretsResponseBody.ApplicationClientSecrets]?

    public var requestId: String?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.applicationClientSecrets != nil {
            var tmp : [Any] = []
            for k in self.applicationClientSecrets! {
                tmp.append(k.toMap())
            }
            map["ApplicationClientSecrets"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ApplicationClientSecrets"] as? [Any?] {
            var tmp : [ListApplicationClientSecretsResponseBody.ApplicationClientSecrets] = []
            for v in value {
                if v != nil {
                    var model = ListApplicationClientSecretsResponseBody.ApplicationClientSecrets()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.applicationClientSecrets = tmp
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? Int64 {
            self.totalCount = value
        }
    }
}

public class ListApplicationClientSecretsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListApplicationClientSecretsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListApplicationClientSecretsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListApplicationsRequest : Tea.TeaModel {
    public var applicationIds: [String]?

    public var applicationName: String?

    public var authorizationType: String?

    public var instanceId: String?

    public var m2MClientStatus: String?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var resourceServerStatus: String?

    public var ssoType: String?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.applicationIds != nil {
            map["ApplicationIds"] = self.applicationIds!
        }
        if self.applicationName != nil {
            map["ApplicationName"] = self.applicationName!
        }
        if self.authorizationType != nil {
            map["AuthorizationType"] = self.authorizationType!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.m2MClientStatus != nil {
            map["M2MClientStatus"] = self.m2MClientStatus!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.resourceServerStatus != nil {
            map["ResourceServerStatus"] = self.resourceServerStatus!
        }
        if self.ssoType != nil {
            map["SsoType"] = self.ssoType!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ApplicationIds"] as? [String] {
            self.applicationIds = value
        }
        if let value = dict["ApplicationName"] as? String {
            self.applicationName = value
        }
        if let value = dict["AuthorizationType"] as? String {
            self.authorizationType = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["M2MClientStatus"] as? String {
            self.m2MClientStatus = value
        }
        if let value = dict["PageNumber"] as? Int64 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int64 {
            self.pageSize = value
        }
        if let value = dict["ResourceServerStatus"] as? String {
            self.resourceServerStatus = value
        }
        if let value = dict["SsoType"] as? String {
            self.ssoType = value
        }
        if let value = dict["Status"] as? String {
            self.status = value
        }
    }
}

public class ListApplicationsResponseBody : Tea.TeaModel {
    public class Applications : Tea.TeaModel {
        public var applicationId: String?

        public var applicationName: String?

        public var applicationSourceType: String?

        public var applicationTemplateId: String?

        public var clientId: String?

        public var createTime: Int64?

        public var description_: String?

        public var features: String?

        public var instanceId: String?

        public var logoUrl: String?

        public var managedServiceCode: String?

        public var serviceManaged: Bool?

        public var ssoType: String?

        public var status: String?

        public var updateTime: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.applicationId != nil {
                map["ApplicationId"] = self.applicationId!
            }
            if self.applicationName != nil {
                map["ApplicationName"] = self.applicationName!
            }
            if self.applicationSourceType != nil {
                map["ApplicationSourceType"] = self.applicationSourceType!
            }
            if self.applicationTemplateId != nil {
                map["ApplicationTemplateId"] = self.applicationTemplateId!
            }
            if self.clientId != nil {
                map["ClientId"] = self.clientId!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.features != nil {
                map["Features"] = self.features!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.logoUrl != nil {
                map["LogoUrl"] = self.logoUrl!
            }
            if self.managedServiceCode != nil {
                map["ManagedServiceCode"] = self.managedServiceCode!
            }
            if self.serviceManaged != nil {
                map["ServiceManaged"] = self.serviceManaged!
            }
            if self.ssoType != nil {
                map["SsoType"] = self.ssoType!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.updateTime != nil {
                map["UpdateTime"] = self.updateTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ApplicationId"] as? String {
                self.applicationId = value
            }
            if let value = dict["ApplicationName"] as? String {
                self.applicationName = value
            }
            if let value = dict["ApplicationSourceType"] as? String {
                self.applicationSourceType = value
            }
            if let value = dict["ApplicationTemplateId"] as? String {
                self.applicationTemplateId = value
            }
            if let value = dict["ClientId"] as? String {
                self.clientId = value
            }
            if let value = dict["CreateTime"] as? Int64 {
                self.createTime = value
            }
            if let value = dict["Description"] as? String {
                self.description_ = value
            }
            if let value = dict["Features"] as? String {
                self.features = value
            }
            if let value = dict["InstanceId"] as? String {
                self.instanceId = value
            }
            if let value = dict["LogoUrl"] as? String {
                self.logoUrl = value
            }
            if let value = dict["ManagedServiceCode"] as? String {
                self.managedServiceCode = value
            }
            if let value = dict["ServiceManaged"] as? Bool {
                self.serviceManaged = value
            }
            if let value = dict["SsoType"] as? String {
                self.ssoType = value
            }
            if let value = dict["Status"] as? String {
                self.status = value
            }
            if let value = dict["UpdateTime"] as? Int64 {
                self.updateTime = value
            }
        }
    }
    public var applications: [ListApplicationsResponseBody.Applications]?

    public var requestId: String?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.applications != nil {
            var tmp : [Any] = []
            for k in self.applications! {
                tmp.append(k.toMap())
            }
            map["Applications"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Applications"] as? [Any?] {
            var tmp : [ListApplicationsResponseBody.Applications] = []
            for v in value {
                if v != nil {
                    var model = ListApplicationsResponseBody.Applications()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.applications = tmp
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? Int64 {
            self.totalCount = value
        }
    }
}

public class ListApplicationsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListApplicationsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListApplicationsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListApplicationsForOrganizationalUnitRequest : Tea.TeaModel {
    public var applicationIds: [String]?

    public var instanceId: String?

    public var organizationalUnitId: String?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.applicationIds != nil {
            map["ApplicationIds"] = self.applicationIds!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.organizationalUnitId != nil {
            map["OrganizationalUnitId"] = self.organizationalUnitId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ApplicationIds"] as? [String] {
            self.applicationIds = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["OrganizationalUnitId"] as? String {
            self.organizationalUnitId = value
        }
        if let value = dict["PageNumber"] as? Int64 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int64 {
            self.pageSize = value
        }
    }
}

public class ListApplicationsForOrganizationalUnitResponseBody : Tea.TeaModel {
    public class Applications : Tea.TeaModel {
        public var applicationId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.applicationId != nil {
                map["ApplicationId"] = self.applicationId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ApplicationId"] as? String {
                self.applicationId = value
            }
        }
    }
    public var applications: [ListApplicationsForOrganizationalUnitResponseBody.Applications]?

    public var requestId: String?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.applications != nil {
            var tmp : [Any] = []
            for k in self.applications! {
                tmp.append(k.toMap())
            }
            map["Applications"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Applications"] as? [Any?] {
            var tmp : [ListApplicationsForOrganizationalUnitResponseBody.Applications] = []
            for v in value {
                if v != nil {
                    var model = ListApplicationsForOrganizationalUnitResponseBody.Applications()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.applications = tmp
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? Int64 {
            self.totalCount = value
        }
    }
}

public class ListApplicationsForOrganizationalUnitResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListApplicationsForOrganizationalUnitResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListApplicationsForOrganizationalUnitResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListApplicationsForUserRequest : Tea.TeaModel {
    public var applicationIds: [String]?

    public var instanceId: String?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var queryMode: String?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.applicationIds != nil {
            map["ApplicationIds"] = self.applicationIds!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.queryMode != nil {
            map["QueryMode"] = self.queryMode!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ApplicationIds"] as? [String] {
            self.applicationIds = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["PageNumber"] as? Int64 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int64 {
            self.pageSize = value
        }
        if let value = dict["QueryMode"] as? String {
            self.queryMode = value
        }
        if let value = dict["UserId"] as? String {
            self.userId = value
        }
    }
}

public class ListApplicationsForUserResponseBody : Tea.TeaModel {
    public class Applications : Tea.TeaModel {
        public var applicationId: String?

        public var hasDirectAuthorization: Bool?

        public var hasInheritAuthorization: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.applicationId != nil {
                map["ApplicationId"] = self.applicationId!
            }
            if self.hasDirectAuthorization != nil {
                map["HasDirectAuthorization"] = self.hasDirectAuthorization!
            }
            if self.hasInheritAuthorization != nil {
                map["HasInheritAuthorization"] = self.hasInheritAuthorization!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ApplicationId"] as? String {
                self.applicationId = value
            }
            if let value = dict["HasDirectAuthorization"] as? Bool {
                self.hasDirectAuthorization = value
            }
            if let value = dict["HasInheritAuthorization"] as? Bool {
                self.hasInheritAuthorization = value
            }
        }
    }
    public var applications: [ListApplicationsForUserResponseBody.Applications]?

    public var requestId: String?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.applications != nil {
            var tmp : [Any] = []
            for k in self.applications! {
                tmp.append(k.toMap())
            }
            map["Applications"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Applications"] as? [Any?] {
            var tmp : [ListApplicationsForUserResponseBody.Applications] = []
            for v in value {
                if v != nil {
                    var model = ListApplicationsForUserResponseBody.Applications()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.applications = tmp
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? Int64 {
            self.totalCount = value
        }
    }
}

public class ListApplicationsForUserResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListApplicationsForUserResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListApplicationsForUserResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListConditionalAccessPoliciesRequest : Tea.TeaModel {
    public var instanceId: String?

    public var maxResults: Int64?

    public var nextToken: String?

    public var previousToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.previousToken != nil {
            map["PreviousToken"] = self.previousToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["MaxResults"] as? Int64 {
            self.maxResults = value
        }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["PreviousToken"] as? String {
            self.previousToken = value
        }
    }
}

public class ListConditionalAccessPoliciesResponseBody : Tea.TeaModel {
    public class ConditionalAccessPolicies : Tea.TeaModel {
        public class ConditionsConfig : Tea.TeaModel {
            public class Applications : Tea.TeaModel {
                public var excludeApplications: [String]?

                public var includeApplications: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.excludeApplications != nil {
                        map["ExcludeApplications"] = self.excludeApplications!
                    }
                    if self.includeApplications != nil {
                        map["IncludeApplications"] = self.includeApplications!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["ExcludeApplications"] as? [String] {
                        self.excludeApplications = value
                    }
                    if let value = dict["IncludeApplications"] as? [String] {
                        self.includeApplications = value
                    }
                }
            }
            public class NetworkZones : Tea.TeaModel {
                public var excludeNetworkZones: [String]?

                public var includeNetworkZones: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.excludeNetworkZones != nil {
                        map["ExcludeNetworkZones"] = self.excludeNetworkZones!
                    }
                    if self.includeNetworkZones != nil {
                        map["IncludeNetworkZones"] = self.includeNetworkZones!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["ExcludeNetworkZones"] as? [String] {
                        self.excludeNetworkZones = value
                    }
                    if let value = dict["IncludeNetworkZones"] as? [String] {
                        self.includeNetworkZones = value
                    }
                }
            }
            public class Users : Tea.TeaModel {
                public var excludeGroups: [String]?

                public var excludeOrganizationalUnits: [String]?

                public var excludeUsers: [String]?

                public var includeGroups: [String]?

                public var includeOrganizationalUnits: [String]?

                public var includeUsers: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.excludeGroups != nil {
                        map["ExcludeGroups"] = self.excludeGroups!
                    }
                    if self.excludeOrganizationalUnits != nil {
                        map["ExcludeOrganizationalUnits"] = self.excludeOrganizationalUnits!
                    }
                    if self.excludeUsers != nil {
                        map["ExcludeUsers"] = self.excludeUsers!
                    }
                    if self.includeGroups != nil {
                        map["IncludeGroups"] = self.includeGroups!
                    }
                    if self.includeOrganizationalUnits != nil {
                        map["IncludeOrganizationalUnits"] = self.includeOrganizationalUnits!
                    }
                    if self.includeUsers != nil {
                        map["IncludeUsers"] = self.includeUsers!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["ExcludeGroups"] as? [String] {
                        self.excludeGroups = value
                    }
                    if let value = dict["ExcludeOrganizationalUnits"] as? [String] {
                        self.excludeOrganizationalUnits = value
                    }
                    if let value = dict["ExcludeUsers"] as? [String] {
                        self.excludeUsers = value
                    }
                    if let value = dict["IncludeGroups"] as? [String] {
                        self.includeGroups = value
                    }
                    if let value = dict["IncludeOrganizationalUnits"] as? [String] {
                        self.includeOrganizationalUnits = value
                    }
                    if let value = dict["IncludeUsers"] as? [String] {
                        self.includeUsers = value
                    }
                }
            }
            public var applications: ListConditionalAccessPoliciesResponseBody.ConditionalAccessPolicies.ConditionsConfig.Applications?

            public var networkZones: ListConditionalAccessPoliciesResponseBody.ConditionalAccessPolicies.ConditionsConfig.NetworkZones?

            public var users: ListConditionalAccessPoliciesResponseBody.ConditionalAccessPolicies.ConditionsConfig.Users?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.applications?.validate()
                try self.networkZones?.validate()
                try self.users?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.applications != nil {
                    map["Applications"] = self.applications?.toMap()
                }
                if self.networkZones != nil {
                    map["NetworkZones"] = self.networkZones?.toMap()
                }
                if self.users != nil {
                    map["Users"] = self.users?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Applications"] as? [String: Any?] {
                    var model = ListConditionalAccessPoliciesResponseBody.ConditionalAccessPolicies.ConditionsConfig.Applications()
                    model.fromMap(value)
                    self.applications = model
                }
                if let value = dict["NetworkZones"] as? [String: Any?] {
                    var model = ListConditionalAccessPoliciesResponseBody.ConditionalAccessPolicies.ConditionsConfig.NetworkZones()
                    model.fromMap(value)
                    self.networkZones = model
                }
                if let value = dict["Users"] as? [String: Any?] {
                    var model = ListConditionalAccessPoliciesResponseBody.ConditionalAccessPolicies.ConditionsConfig.Users()
                    model.fromMap(value)
                    self.users = model
                }
            }
        }
        public class DecisionConfig : Tea.TeaModel {
            public var activeSessionReuseStatus: String?

            public var effect: String?

            public var mfaAuthenticationIntervalSeconds: Int64?

            public var mfaAuthenticationMethods: [String]?

            public var mfaType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.activeSessionReuseStatus != nil {
                    map["ActiveSessionReuseStatus"] = self.activeSessionReuseStatus!
                }
                if self.effect != nil {
                    map["Effect"] = self.effect!
                }
                if self.mfaAuthenticationIntervalSeconds != nil {
                    map["MfaAuthenticationIntervalSeconds"] = self.mfaAuthenticationIntervalSeconds!
                }
                if self.mfaAuthenticationMethods != nil {
                    map["MfaAuthenticationMethods"] = self.mfaAuthenticationMethods!
                }
                if self.mfaType != nil {
                    map["MfaType"] = self.mfaType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ActiveSessionReuseStatus"] as? String {
                    self.activeSessionReuseStatus = value
                }
                if let value = dict["Effect"] as? String {
                    self.effect = value
                }
                if let value = dict["MfaAuthenticationIntervalSeconds"] as? Int64 {
                    self.mfaAuthenticationIntervalSeconds = value
                }
                if let value = dict["MfaAuthenticationMethods"] as? [String] {
                    self.mfaAuthenticationMethods = value
                }
                if let value = dict["MfaType"] as? String {
                    self.mfaType = value
                }
            }
        }
        public var conditionalAccessPolicyId: String?

        public var conditionalAccessPolicyName: String?

        public var conditionalAccessPolicyType: String?

        public var conditionsConfig: ListConditionalAccessPoliciesResponseBody.ConditionalAccessPolicies.ConditionsConfig?

        public var createTime: Int64?

        public var decisionConfig: ListConditionalAccessPoliciesResponseBody.ConditionalAccessPolicies.DecisionConfig?

        public var decisionType: String?

        public var description_: String?

        public var evaluateAt: String?

        public var instanceId: String?

        public var lastUpdatedTime: Int64?

        public var priority: Int32?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.conditionsConfig?.validate()
            try self.decisionConfig?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.conditionalAccessPolicyId != nil {
                map["ConditionalAccessPolicyId"] = self.conditionalAccessPolicyId!
            }
            if self.conditionalAccessPolicyName != nil {
                map["ConditionalAccessPolicyName"] = self.conditionalAccessPolicyName!
            }
            if self.conditionalAccessPolicyType != nil {
                map["ConditionalAccessPolicyType"] = self.conditionalAccessPolicyType!
            }
            if self.conditionsConfig != nil {
                map["ConditionsConfig"] = self.conditionsConfig?.toMap()
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.decisionConfig != nil {
                map["DecisionConfig"] = self.decisionConfig?.toMap()
            }
            if self.decisionType != nil {
                map["DecisionType"] = self.decisionType!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.evaluateAt != nil {
                map["EvaluateAt"] = self.evaluateAt!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.lastUpdatedTime != nil {
                map["LastUpdatedTime"] = self.lastUpdatedTime!
            }
            if self.priority != nil {
                map["Priority"] = self.priority!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ConditionalAccessPolicyId"] as? String {
                self.conditionalAccessPolicyId = value
            }
            if let value = dict["ConditionalAccessPolicyName"] as? String {
                self.conditionalAccessPolicyName = value
            }
            if let value = dict["ConditionalAccessPolicyType"] as? String {
                self.conditionalAccessPolicyType = value
            }
            if let value = dict["ConditionsConfig"] as? [String: Any?] {
                var model = ListConditionalAccessPoliciesResponseBody.ConditionalAccessPolicies.ConditionsConfig()
                model.fromMap(value)
                self.conditionsConfig = model
            }
            if let value = dict["CreateTime"] as? Int64 {
                self.createTime = value
            }
            if let value = dict["DecisionConfig"] as? [String: Any?] {
                var model = ListConditionalAccessPoliciesResponseBody.ConditionalAccessPolicies.DecisionConfig()
                model.fromMap(value)
                self.decisionConfig = model
            }
            if let value = dict["DecisionType"] as? String {
                self.decisionType = value
            }
            if let value = dict["Description"] as? String {
                self.description_ = value
            }
            if let value = dict["EvaluateAt"] as? String {
                self.evaluateAt = value
            }
            if let value = dict["InstanceId"] as? String {
                self.instanceId = value
            }
            if let value = dict["LastUpdatedTime"] as? Int64 {
                self.lastUpdatedTime = value
            }
            if let value = dict["Priority"] as? Int32 {
                self.priority = value
            }
            if let value = dict["Status"] as? String {
                self.status = value
            }
        }
    }
    public var conditionalAccessPolicies: [ListConditionalAccessPoliciesResponseBody.ConditionalAccessPolicies]?

    public var nextToken: String?

    public var previousToken: String?

    public var requestId: String?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.conditionalAccessPolicies != nil {
            var tmp : [Any] = []
            for k in self.conditionalAccessPolicies! {
                tmp.append(k.toMap())
            }
            map["ConditionalAccessPolicies"] = tmp
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.previousToken != nil {
            map["PreviousToken"] = self.previousToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ConditionalAccessPolicies"] as? [Any?] {
            var tmp : [ListConditionalAccessPoliciesResponseBody.ConditionalAccessPolicies] = []
            for v in value {
                if v != nil {
                    var model = ListConditionalAccessPoliciesResponseBody.ConditionalAccessPolicies()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.conditionalAccessPolicies = tmp
        }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["PreviousToken"] as? String {
            self.previousToken = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? Int64 {
            self.totalCount = value
        }
    }
}

public class ListConditionalAccessPoliciesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListConditionalAccessPoliciesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListConditionalAccessPoliciesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListConditionalAccessPoliciesForNetworkZoneRequest : Tea.TeaModel {
    public var instanceId: String?

    public var networkZoneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.networkZoneId != nil {
            map["NetworkZoneId"] = self.networkZoneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["NetworkZoneId"] as? String {
            self.networkZoneId = value
        }
    }
}

public class ListConditionalAccessPoliciesForNetworkZoneResponseBody : Tea.TeaModel {
    public class ConditionalAccessPolicies : Tea.TeaModel {
        public class ConditionsConfig : Tea.TeaModel {
            public class Applications : Tea.TeaModel {
                public var excludeApplications: [String]?

                public var includeApplications: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.excludeApplications != nil {
                        map["ExcludeApplications"] = self.excludeApplications!
                    }
                    if self.includeApplications != nil {
                        map["IncludeApplications"] = self.includeApplications!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["ExcludeApplications"] as? [String] {
                        self.excludeApplications = value
                    }
                    if let value = dict["IncludeApplications"] as? [String] {
                        self.includeApplications = value
                    }
                }
            }
            public class NetworkZones : Tea.TeaModel {
                public var excludeNetworkZones: [String]?

                public var includeNetworkZones: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.excludeNetworkZones != nil {
                        map["ExcludeNetworkZones"] = self.excludeNetworkZones!
                    }
                    if self.includeNetworkZones != nil {
                        map["IncludeNetworkZones"] = self.includeNetworkZones!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["ExcludeNetworkZones"] as? [String] {
                        self.excludeNetworkZones = value
                    }
                    if let value = dict["IncludeNetworkZones"] as? [String] {
                        self.includeNetworkZones = value
                    }
                }
            }
            public class Users : Tea.TeaModel {
                public var excludeGroups: [String]?

                public var excludeOrganizationalUnits: [String]?

                public var excludeUsers: [String]?

                public var includeGroups: [String]?

                public var includeOrganizationalUnits: [String]?

                public var includeUsers: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.excludeGroups != nil {
                        map["ExcludeGroups"] = self.excludeGroups!
                    }
                    if self.excludeOrganizationalUnits != nil {
                        map["ExcludeOrganizationalUnits"] = self.excludeOrganizationalUnits!
                    }
                    if self.excludeUsers != nil {
                        map["ExcludeUsers"] = self.excludeUsers!
                    }
                    if self.includeGroups != nil {
                        map["IncludeGroups"] = self.includeGroups!
                    }
                    if self.includeOrganizationalUnits != nil {
                        map["IncludeOrganizationalUnits"] = self.includeOrganizationalUnits!
                    }
                    if self.includeUsers != nil {
                        map["IncludeUsers"] = self.includeUsers!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["ExcludeGroups"] as? [String] {
                        self.excludeGroups = value
                    }
                    if let value = dict["ExcludeOrganizationalUnits"] as? [String] {
                        self.excludeOrganizationalUnits = value
                    }
                    if let value = dict["ExcludeUsers"] as? [String] {
                        self.excludeUsers = value
                    }
                    if let value = dict["IncludeGroups"] as? [String] {
                        self.includeGroups = value
                    }
                    if let value = dict["IncludeOrganizationalUnits"] as? [String] {
                        self.includeOrganizationalUnits = value
                    }
                    if let value = dict["IncludeUsers"] as? [String] {
                        self.includeUsers = value
                    }
                }
            }
            public var applications: ListConditionalAccessPoliciesForNetworkZoneResponseBody.ConditionalAccessPolicies.ConditionsConfig.Applications?

            public var networkZones: ListConditionalAccessPoliciesForNetworkZoneResponseBody.ConditionalAccessPolicies.ConditionsConfig.NetworkZones?

            public var users: ListConditionalAccessPoliciesForNetworkZoneResponseBody.ConditionalAccessPolicies.ConditionsConfig.Users?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.applications?.validate()
                try self.networkZones?.validate()
                try self.users?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.applications != nil {
                    map["Applications"] = self.applications?.toMap()
                }
                if self.networkZones != nil {
                    map["NetworkZones"] = self.networkZones?.toMap()
                }
                if self.users != nil {
                    map["Users"] = self.users?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Applications"] as? [String: Any?] {
                    var model = ListConditionalAccessPoliciesForNetworkZoneResponseBody.ConditionalAccessPolicies.ConditionsConfig.Applications()
                    model.fromMap(value)
                    self.applications = model
                }
                if let value = dict["NetworkZones"] as? [String: Any?] {
                    var model = ListConditionalAccessPoliciesForNetworkZoneResponseBody.ConditionalAccessPolicies.ConditionsConfig.NetworkZones()
                    model.fromMap(value)
                    self.networkZones = model
                }
                if let value = dict["Users"] as? [String: Any?] {
                    var model = ListConditionalAccessPoliciesForNetworkZoneResponseBody.ConditionalAccessPolicies.ConditionsConfig.Users()
                    model.fromMap(value)
                    self.users = model
                }
            }
        }
        public class DecisionConfig : Tea.TeaModel {
            public var activeSessionReuseStatus: String?

            public var effect: String?

            public var mfaAuthenticationIntervalSeconds: Int64?

            public var mfaAuthenticationMethods: [String]?

            public var mfaType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.activeSessionReuseStatus != nil {
                    map["ActiveSessionReuseStatus"] = self.activeSessionReuseStatus!
                }
                if self.effect != nil {
                    map["Effect"] = self.effect!
                }
                if self.mfaAuthenticationIntervalSeconds != nil {
                    map["MfaAuthenticationIntervalSeconds"] = self.mfaAuthenticationIntervalSeconds!
                }
                if self.mfaAuthenticationMethods != nil {
                    map["MfaAuthenticationMethods"] = self.mfaAuthenticationMethods!
                }
                if self.mfaType != nil {
                    map["MfaType"] = self.mfaType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ActiveSessionReuseStatus"] as? String {
                    self.activeSessionReuseStatus = value
                }
                if let value = dict["Effect"] as? String {
                    self.effect = value
                }
                if let value = dict["MfaAuthenticationIntervalSeconds"] as? Int64 {
                    self.mfaAuthenticationIntervalSeconds = value
                }
                if let value = dict["MfaAuthenticationMethods"] as? [String] {
                    self.mfaAuthenticationMethods = value
                }
                if let value = dict["MfaType"] as? String {
                    self.mfaType = value
                }
            }
        }
        public var conditionalAccessPolicyId: String?

        public var conditionalAccessPolicyName: String?

        public var conditionalAccessPolicyType: String?

        public var conditionsConfig: ListConditionalAccessPoliciesForNetworkZoneResponseBody.ConditionalAccessPolicies.ConditionsConfig?

        public var createTime: Int64?

        public var decisionConfig: ListConditionalAccessPoliciesForNetworkZoneResponseBody.ConditionalAccessPolicies.DecisionConfig?

        public var decisionType: String?

        public var description_: String?

        public var evaluateAt: String?

        public var instanceId: String?

        public var lastUpdatedTime: Int64?

        public var priority: Int32?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.conditionsConfig?.validate()
            try self.decisionConfig?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.conditionalAccessPolicyId != nil {
                map["ConditionalAccessPolicyId"] = self.conditionalAccessPolicyId!
            }
            if self.conditionalAccessPolicyName != nil {
                map["ConditionalAccessPolicyName"] = self.conditionalAccessPolicyName!
            }
            if self.conditionalAccessPolicyType != nil {
                map["ConditionalAccessPolicyType"] = self.conditionalAccessPolicyType!
            }
            if self.conditionsConfig != nil {
                map["ConditionsConfig"] = self.conditionsConfig?.toMap()
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.decisionConfig != nil {
                map["DecisionConfig"] = self.decisionConfig?.toMap()
            }
            if self.decisionType != nil {
                map["DecisionType"] = self.decisionType!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.evaluateAt != nil {
                map["EvaluateAt"] = self.evaluateAt!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.lastUpdatedTime != nil {
                map["LastUpdatedTime"] = self.lastUpdatedTime!
            }
            if self.priority != nil {
                map["Priority"] = self.priority!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ConditionalAccessPolicyId"] as? String {
                self.conditionalAccessPolicyId = value
            }
            if let value = dict["ConditionalAccessPolicyName"] as? String {
                self.conditionalAccessPolicyName = value
            }
            if let value = dict["ConditionalAccessPolicyType"] as? String {
                self.conditionalAccessPolicyType = value
            }
            if let value = dict["ConditionsConfig"] as? [String: Any?] {
                var model = ListConditionalAccessPoliciesForNetworkZoneResponseBody.ConditionalAccessPolicies.ConditionsConfig()
                model.fromMap(value)
                self.conditionsConfig = model
            }
            if let value = dict["CreateTime"] as? Int64 {
                self.createTime = value
            }
            if let value = dict["DecisionConfig"] as? [String: Any?] {
                var model = ListConditionalAccessPoliciesForNetworkZoneResponseBody.ConditionalAccessPolicies.DecisionConfig()
                model.fromMap(value)
                self.decisionConfig = model
            }
            if let value = dict["DecisionType"] as? String {
                self.decisionType = value
            }
            if let value = dict["Description"] as? String {
                self.description_ = value
            }
            if let value = dict["EvaluateAt"] as? String {
                self.evaluateAt = value
            }
            if let value = dict["InstanceId"] as? String {
                self.instanceId = value
            }
            if let value = dict["LastUpdatedTime"] as? Int64 {
                self.lastUpdatedTime = value
            }
            if let value = dict["Priority"] as? Int32 {
                self.priority = value
            }
            if let value = dict["Status"] as? String {
                self.status = value
            }
        }
    }
    public var conditionalAccessPolicies: [ListConditionalAccessPoliciesForNetworkZoneResponseBody.ConditionalAccessPolicies]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.conditionalAccessPolicies != nil {
            var tmp : [Any] = []
            for k in self.conditionalAccessPolicies! {
                tmp.append(k.toMap())
            }
            map["ConditionalAccessPolicies"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ConditionalAccessPolicies"] as? [Any?] {
            var tmp : [ListConditionalAccessPoliciesForNetworkZoneResponseBody.ConditionalAccessPolicies] = []
            for v in value {
                if v != nil {
                    var model = ListConditionalAccessPoliciesForNetworkZoneResponseBody.ConditionalAccessPolicies()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.conditionalAccessPolicies = tmp
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ListConditionalAccessPoliciesForNetworkZoneResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListConditionalAccessPoliciesForNetworkZoneResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListConditionalAccessPoliciesForNetworkZoneResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListDomainProxyTokensRequest : Tea.TeaModel {
    public var domainId: String?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainId != nil {
            map["DomainId"] = self.domainId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DomainId"] as? String {
            self.domainId = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
    }
}

public class ListDomainProxyTokensResponseBody : Tea.TeaModel {
    public class DomainProxyTokens : Tea.TeaModel {
        public var createTime: Int64?

        public var domainId: String?

        public var domainProxyToken: String?

        public var domainProxyTokenId: String?

        public var instanceId: String?

        public var lastUsedTime: Int64?

        public var status: String?

        public var updateTime: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.domainId != nil {
                map["DomainId"] = self.domainId!
            }
            if self.domainProxyToken != nil {
                map["DomainProxyToken"] = self.domainProxyToken!
            }
            if self.domainProxyTokenId != nil {
                map["DomainProxyTokenId"] = self.domainProxyTokenId!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.lastUsedTime != nil {
                map["LastUsedTime"] = self.lastUsedTime!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.updateTime != nil {
                map["UpdateTime"] = self.updateTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["CreateTime"] as? Int64 {
                self.createTime = value
            }
            if let value = dict["DomainId"] as? String {
                self.domainId = value
            }
            if let value = dict["DomainProxyToken"] as? String {
                self.domainProxyToken = value
            }
            if let value = dict["DomainProxyTokenId"] as? String {
                self.domainProxyTokenId = value
            }
            if let value = dict["InstanceId"] as? String {
                self.instanceId = value
            }
            if let value = dict["LastUsedTime"] as? Int64 {
                self.lastUsedTime = value
            }
            if let value = dict["Status"] as? String {
                self.status = value
            }
            if let value = dict["UpdateTime"] as? Int64 {
                self.updateTime = value
            }
        }
    }
    public var domainProxyTokens: [ListDomainProxyTokensResponseBody.DomainProxyTokens]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainProxyTokens != nil {
            var tmp : [Any] = []
            for k in self.domainProxyTokens! {
                tmp.append(k.toMap())
            }
            map["DomainProxyTokens"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DomainProxyTokens"] as? [Any?] {
            var tmp : [ListDomainProxyTokensResponseBody.DomainProxyTokens] = []
            for v in value {
                if v != nil {
                    var model = ListDomainProxyTokensResponseBody.DomainProxyTokens()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.domainProxyTokens = tmp
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ListDomainProxyTokensResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListDomainProxyTokensResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListDomainProxyTokensResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListDomainsRequest : Tea.TeaModel {
    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
    }
}

public class ListDomainsResponseBody : Tea.TeaModel {
    public class Domains : Tea.TeaModel {
        public class Filing : Tea.TeaModel {
            public var icpNumber: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.icpNumber != nil {
                    map["IcpNumber"] = self.icpNumber!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["IcpNumber"] as? String {
                    self.icpNumber = value
                }
            }
        }
        public var createTime: Int64?

        public var defaultDomain: Bool?

        public var domain: String?

        public var domainId: String?

        public var domainType: String?

        public var filing: ListDomainsResponseBody.Domains.Filing?

        public var instanceId: String?

        public var lockMode: String?

        public var updateTime: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.filing?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.defaultDomain != nil {
                map["DefaultDomain"] = self.defaultDomain!
            }
            if self.domain != nil {
                map["Domain"] = self.domain!
            }
            if self.domainId != nil {
                map["DomainId"] = self.domainId!
            }
            if self.domainType != nil {
                map["DomainType"] = self.domainType!
            }
            if self.filing != nil {
                map["Filing"] = self.filing?.toMap()
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.lockMode != nil {
                map["LockMode"] = self.lockMode!
            }
            if self.updateTime != nil {
                map["UpdateTime"] = self.updateTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["CreateTime"] as? Int64 {
                self.createTime = value
            }
            if let value = dict["DefaultDomain"] as? Bool {
                self.defaultDomain = value
            }
            if let value = dict["Domain"] as? String {
                self.domain = value
            }
            if let value = dict["DomainId"] as? String {
                self.domainId = value
            }
            if let value = dict["DomainType"] as? String {
                self.domainType = value
            }
            if let value = dict["Filing"] as? [String: Any?] {
                var model = ListDomainsResponseBody.Domains.Filing()
                model.fromMap(value)
                self.filing = model
            }
            if let value = dict["InstanceId"] as? String {
                self.instanceId = value
            }
            if let value = dict["LockMode"] as? String {
                self.lockMode = value
            }
            if let value = dict["UpdateTime"] as? Int64 {
                self.updateTime = value
            }
        }
    }
    public var domains: [ListDomainsResponseBody.Domains]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domains != nil {
            var tmp : [Any] = []
            for k in self.domains! {
                tmp.append(k.toMap())
            }
            map["Domains"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Domains"] as? [Any?] {
            var tmp : [ListDomainsResponseBody.Domains] = []
            for v in value {
                if v != nil {
                    var model = ListDomainsResponseBody.Domains()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.domains = tmp
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ListDomainsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListDomainsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListDomainsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListEiamInstancesRequest : Tea.TeaModel {
    public var instanceIds: [String]?

    public var instanceRegionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceIds != nil {
            map["InstanceIds"] = self.instanceIds!
        }
        if self.instanceRegionId != nil {
            map["InstanceRegionId"] = self.instanceRegionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceIds"] as? [String] {
            self.instanceIds = value
        }
        if let value = dict["InstanceRegionId"] as? String {
            self.instanceRegionId = value
        }
    }
}

public class ListEiamInstancesResponseBody : Tea.TeaModel {
    public class Instances : Tea.TeaModel {
        public var description_: String?

        public var developerAPIPrivateDomain: String?

        public var developerAPIPublicDomain: String?

        public var instanceId: String?

        public var instanceStatus: String?

        public var instanceVersion: String?

        public var openAPIPrivateDomain: String?

        public var openAPIPublicDomain: String?

        public var SSODomain: String?

        public var startTime: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.developerAPIPrivateDomain != nil {
                map["DeveloperAPIPrivateDomain"] = self.developerAPIPrivateDomain!
            }
            if self.developerAPIPublicDomain != nil {
                map["DeveloperAPIPublicDomain"] = self.developerAPIPublicDomain!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.instanceStatus != nil {
                map["InstanceStatus"] = self.instanceStatus!
            }
            if self.instanceVersion != nil {
                map["InstanceVersion"] = self.instanceVersion!
            }
            if self.openAPIPrivateDomain != nil {
                map["OpenAPIPrivateDomain"] = self.openAPIPrivateDomain!
            }
            if self.openAPIPublicDomain != nil {
                map["OpenAPIPublicDomain"] = self.openAPIPublicDomain!
            }
            if self.SSODomain != nil {
                map["SSODomain"] = self.SSODomain!
            }
            if self.startTime != nil {
                map["StartTime"] = self.startTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Description"] as? String {
                self.description_ = value
            }
            if let value = dict["DeveloperAPIPrivateDomain"] as? String {
                self.developerAPIPrivateDomain = value
            }
            if let value = dict["DeveloperAPIPublicDomain"] as? String {
                self.developerAPIPublicDomain = value
            }
            if let value = dict["InstanceId"] as? String {
                self.instanceId = value
            }
            if let value = dict["InstanceStatus"] as? String {
                self.instanceStatus = value
            }
            if let value = dict["InstanceVersion"] as? String {
                self.instanceVersion = value
            }
            if let value = dict["OpenAPIPrivateDomain"] as? String {
                self.openAPIPrivateDomain = value
            }
            if let value = dict["OpenAPIPublicDomain"] as? String {
                self.openAPIPublicDomain = value
            }
            if let value = dict["SSODomain"] as? String {
                self.SSODomain = value
            }
            if let value = dict["StartTime"] as? Int64 {
                self.startTime = value
            }
        }
    }
    public var instances: [ListEiamInstancesResponseBody.Instances]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instances != nil {
            var tmp : [Any] = []
            for k in self.instances! {
                tmp.append(k.toMap())
            }
            map["Instances"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Instances"] as? [Any?] {
            var tmp : [ListEiamInstancesResponseBody.Instances] = []
            for v in value {
                if v != nil {
                    var model = ListEiamInstancesResponseBody.Instances()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.instances = tmp
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ListEiamInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListEiamInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListEiamInstancesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListEiamRegionsResponseBody : Tea.TeaModel {
    public class Regions : Tea.TeaModel {
        public var localName: String?

        public var regionId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.localName != nil {
                map["LocalName"] = self.localName!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["LocalName"] as? String {
                self.localName = value
            }
            if let value = dict["RegionId"] as? String {
                self.regionId = value
            }
        }
    }
    public var regions: [ListEiamRegionsResponseBody.Regions]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.regions != nil {
            var tmp : [Any] = []
            for k in self.regions! {
                tmp.append(k.toMap())
            }
            map["Regions"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Regions"] as? [Any?] {
            var tmp : [ListEiamRegionsResponseBody.Regions] = []
            for v in value {
                if v != nil {
                    var model = ListEiamRegionsResponseBody.Regions()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.regions = tmp
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ListEiamRegionsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListEiamRegionsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListEiamRegionsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListGroupsRequest : Tea.TeaModel {
    public var groupExternalId: String?

    public var groupIds: [String]?

    public var groupName: String?

    public var groupNameStartsWith: String?

    public var instanceId: String?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupExternalId != nil {
            map["GroupExternalId"] = self.groupExternalId!
        }
        if self.groupIds != nil {
            map["GroupIds"] = self.groupIds!
        }
        if self.groupName != nil {
            map["GroupName"] = self.groupName!
        }
        if self.groupNameStartsWith != nil {
            map["GroupNameStartsWith"] = self.groupNameStartsWith!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["GroupExternalId"] as? String {
            self.groupExternalId = value
        }
        if let value = dict["GroupIds"] as? [String] {
            self.groupIds = value
        }
        if let value = dict["GroupName"] as? String {
            self.groupName = value
        }
        if let value = dict["GroupNameStartsWith"] as? String {
            self.groupNameStartsWith = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["PageNumber"] as? Int64 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int64 {
            self.pageSize = value
        }
    }
}

public class ListGroupsResponseBody : Tea.TeaModel {
    public class Groups : Tea.TeaModel {
        public var createTime: Int64?

        public var description_: String?

        public var groupExternalId: String?

        public var groupId: String?

        public var groupName: String?

        public var groupSourceId: String?

        public var groupSourceType: String?

        public var instanceId: String?

        public var updateTime: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.groupExternalId != nil {
                map["GroupExternalId"] = self.groupExternalId!
            }
            if self.groupId != nil {
                map["GroupId"] = self.groupId!
            }
            if self.groupName != nil {
                map["GroupName"] = self.groupName!
            }
            if self.groupSourceId != nil {
                map["GroupSourceId"] = self.groupSourceId!
            }
            if self.groupSourceType != nil {
                map["GroupSourceType"] = self.groupSourceType!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.updateTime != nil {
                map["UpdateTime"] = self.updateTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["CreateTime"] as? Int64 {
                self.createTime = value
            }
            if let value = dict["Description"] as? String {
                self.description_ = value
            }
            if let value = dict["GroupExternalId"] as? String {
                self.groupExternalId = value
            }
            if let value = dict["GroupId"] as? String {
                self.groupId = value
            }
            if let value = dict["GroupName"] as? String {
                self.groupName = value
            }
            if let value = dict["GroupSourceId"] as? String {
                self.groupSourceId = value
            }
            if let value = dict["GroupSourceType"] as? String {
                self.groupSourceType = value
            }
            if let value = dict["InstanceId"] as? String {
                self.instanceId = value
            }
            if let value = dict["UpdateTime"] as? Int64 {
                self.updateTime = value
            }
        }
    }
    public var groups: [ListGroupsResponseBody.Groups]?

    public var requestId: String?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groups != nil {
            var tmp : [Any] = []
            for k in self.groups! {
                tmp.append(k.toMap())
            }
            map["Groups"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Groups"] as? [Any?] {
            var tmp : [ListGroupsResponseBody.Groups] = []
            for v in value {
                if v != nil {
                    var model = ListGroupsResponseBody.Groups()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.groups = tmp
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? Int64 {
            self.totalCount = value
        }
    }
}

public class ListGroupsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListGroupsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListGroupsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListGroupsForApplicationRequest : Tea.TeaModel {
    public var applicationId: String?

    public var groupIds: [String]?

    public var instanceId: String?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.applicationId != nil {
            map["ApplicationId"] = self.applicationId!
        }
        if self.groupIds != nil {
            map["GroupIds"] = self.groupIds!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ApplicationId"] as? String {
            self.applicationId = value
        }
        if let value = dict["GroupIds"] as? [String] {
            self.groupIds = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["PageNumber"] as? Int64 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int64 {
            self.pageSize = value
        }
    }
}

public class ListGroupsForApplicationResponseBody : Tea.TeaModel {
    public class Groups : Tea.TeaModel {
        public var groupId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.groupId != nil {
                map["GroupId"] = self.groupId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["GroupId"] as? String {
                self.groupId = value
            }
        }
    }
    public var groups: [ListGroupsForApplicationResponseBody.Groups]?

    public var requestId: String?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groups != nil {
            var tmp : [Any] = []
            for k in self.groups! {
                tmp.append(k.toMap())
            }
            map["Groups"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Groups"] as? [Any?] {
            var tmp : [ListGroupsForApplicationResponseBody.Groups] = []
            for v in value {
                if v != nil {
                    var model = ListGroupsForApplicationResponseBody.Groups()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.groups = tmp
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? Int64 {
            self.totalCount = value
        }
    }
}

public class ListGroupsForApplicationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListGroupsForApplicationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListGroupsForApplicationResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListGroupsForUserRequest : Tea.TeaModel {
    public var instanceId: String?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["PageNumber"] as? Int64 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int64 {
            self.pageSize = value
        }
        if let value = dict["UserId"] as? String {
            self.userId = value
        }
    }
}

public class ListGroupsForUserResponseBody : Tea.TeaModel {
    public class Groups : Tea.TeaModel {
        public var groupId: String?

        public var groupMemberRelationSourceId: String?

        public var groupMemberRelationSourceType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.groupId != nil {
                map["GroupId"] = self.groupId!
            }
            if self.groupMemberRelationSourceId != nil {
                map["GroupMemberRelationSourceId"] = self.groupMemberRelationSourceId!
            }
            if self.groupMemberRelationSourceType != nil {
                map["GroupMemberRelationSourceType"] = self.groupMemberRelationSourceType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["GroupId"] as? String {
                self.groupId = value
            }
            if let value = dict["GroupMemberRelationSourceId"] as? String {
                self.groupMemberRelationSourceId = value
            }
            if let value = dict["GroupMemberRelationSourceType"] as? String {
                self.groupMemberRelationSourceType = value
            }
        }
    }
    public var groups: [ListGroupsForUserResponseBody.Groups]?

    public var requestId: String?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groups != nil {
            var tmp : [Any] = []
            for k in self.groups! {
                tmp.append(k.toMap())
            }
            map["Groups"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Groups"] as? [Any?] {
            var tmp : [ListGroupsForUserResponseBody.Groups] = []
            for v in value {
                if v != nil {
                    var model = ListGroupsForUserResponseBody.Groups()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.groups = tmp
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? Int64 {
            self.totalCount = value
        }
    }
}

public class ListGroupsForUserResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListGroupsForUserResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListGroupsForUserResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListIdentityProvidersRequest : Tea.TeaModel {
    public var instanceId: String?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["PageNumber"] as? Int64 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int64 {
            self.pageSize = value
        }
    }
}

public class ListIdentityProvidersResponseBody : Tea.TeaModel {
    public class IdentityProviders : Tea.TeaModel {
        public var advancedStatus: String?

        public var authnSourceSupplier: String?

        public var authnSourceType: String?

        public var authnStatus: String?

        public var createTime: Int64?

        public var description_: String?

        public var identityProviderExternalId: String?

        public var identityProviderId: String?

        public var identityProviderName: String?

        public var identityProviderType: String?

        public var incrementalCallbackStatus: String?

        public var instanceId: String?

        public var lastStatusCheckJobResult: String?

        public var lockReason: String?

        public var logoUrl: String?

        public var periodicSyncStatus: String?

        public var udPullStatus: String?

        public var udPullTargetScope: String?

        public var udPushStatus: String?

        public var updateTime: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.advancedStatus != nil {
                map["AdvancedStatus"] = self.advancedStatus!
            }
            if self.authnSourceSupplier != nil {
                map["AuthnSourceSupplier"] = self.authnSourceSupplier!
            }
            if self.authnSourceType != nil {
                map["AuthnSourceType"] = self.authnSourceType!
            }
            if self.authnStatus != nil {
                map["AuthnStatus"] = self.authnStatus!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.identityProviderExternalId != nil {
                map["IdentityProviderExternalId"] = self.identityProviderExternalId!
            }
            if self.identityProviderId != nil {
                map["IdentityProviderId"] = self.identityProviderId!
            }
            if self.identityProviderName != nil {
                map["IdentityProviderName"] = self.identityProviderName!
            }
            if self.identityProviderType != nil {
                map["IdentityProviderType"] = self.identityProviderType!
            }
            if self.incrementalCallbackStatus != nil {
                map["IncrementalCallbackStatus"] = self.incrementalCallbackStatus!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.lastStatusCheckJobResult != nil {
                map["LastStatusCheckJobResult"] = self.lastStatusCheckJobResult!
            }
            if self.lockReason != nil {
                map["LockReason"] = self.lockReason!
            }
            if self.logoUrl != nil {
                map["LogoUrl"] = self.logoUrl!
            }
            if self.periodicSyncStatus != nil {
                map["PeriodicSyncStatus"] = self.periodicSyncStatus!
            }
            if self.udPullStatus != nil {
                map["UdPullStatus"] = self.udPullStatus!
            }
            if self.udPullTargetScope != nil {
                map["UdPullTargetScope"] = self.udPullTargetScope!
            }
            if self.udPushStatus != nil {
                map["UdPushStatus"] = self.udPushStatus!
            }
            if self.updateTime != nil {
                map["UpdateTime"] = self.updateTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AdvancedStatus"] as? String {
                self.advancedStatus = value
            }
            if let value = dict["AuthnSourceSupplier"] as? String {
                self.authnSourceSupplier = value
            }
            if let value = dict["AuthnSourceType"] as? String {
                self.authnSourceType = value
            }
            if let value = dict["AuthnStatus"] as? String {
                self.authnStatus = value
            }
            if let value = dict["CreateTime"] as? Int64 {
                self.createTime = value
            }
            if let value = dict["Description"] as? String {
                self.description_ = value
            }
            if let value = dict["IdentityProviderExternalId"] as? String {
                self.identityProviderExternalId = value
            }
            if let value = dict["IdentityProviderId"] as? String {
                self.identityProviderId = value
            }
            if let value = dict["IdentityProviderName"] as? String {
                self.identityProviderName = value
            }
            if let value = dict["IdentityProviderType"] as? String {
                self.identityProviderType = value
            }
            if let value = dict["IncrementalCallbackStatus"] as? String {
                self.incrementalCallbackStatus = value
            }
            if let value = dict["InstanceId"] as? String {
                self.instanceId = value
            }
            if let value = dict["LastStatusCheckJobResult"] as? String {
                self.lastStatusCheckJobResult = value
            }
            if let value = dict["LockReason"] as? String {
                self.lockReason = value
            }
            if let value = dict["LogoUrl"] as? String {
                self.logoUrl = value
            }
            if let value = dict["PeriodicSyncStatus"] as? String {
                self.periodicSyncStatus = value
            }
            if let value = dict["UdPullStatus"] as? String {
                self.udPullStatus = value
            }
            if let value = dict["UdPullTargetScope"] as? String {
                self.udPullTargetScope = value
            }
            if let value = dict["UdPushStatus"] as? String {
                self.udPushStatus = value
            }
            if let value = dict["UpdateTime"] as? Int64 {
                self.updateTime = value
            }
        }
    }
    public var identityProviders: [ListIdentityProvidersResponseBody.IdentityProviders]?

    public var requestId: String?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.identityProviders != nil {
            var tmp : [Any] = []
            for k in self.identityProviders! {
                tmp.append(k.toMap())
            }
            map["IdentityProviders"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["IdentityProviders"] as? [Any?] {
            var tmp : [ListIdentityProvidersResponseBody.IdentityProviders] = []
            for v in value {
                if v != nil {
                    var model = ListIdentityProvidersResponseBody.IdentityProviders()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.identityProviders = tmp
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? Int64 {
            self.totalCount = value
        }
    }
}

public class ListIdentityProvidersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListIdentityProvidersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListIdentityProvidersResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListInstancesRequest : Tea.TeaModel {
    public var instanceIds: [String]?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceIds != nil {
            map["InstanceIds"] = self.instanceIds!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceIds"] as? [String] {
            self.instanceIds = value
        }
        if let value = dict["PageNumber"] as? Int64 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int64 {
            self.pageSize = value
        }
        if let value = dict["Status"] as? String {
            self.status = value
        }
    }
}

public class ListInstancesResponseBody : Tea.TeaModel {
    public class Instances : Tea.TeaModel {
        public class DefaultEndpoint : Tea.TeaModel {
            public var endpoint: String?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.endpoint != nil {
                    map["Endpoint"] = self.endpoint!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Endpoint"] as? String {
                    self.endpoint = value
                }
                if let value = dict["Status"] as? String {
                    self.status = value
                }
            }
        }
        public var createTime: Int64?

        public var defaultEndpoint: ListInstancesResponseBody.Instances.DefaultEndpoint?

        public var description_: String?

        public var instanceId: String?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.defaultEndpoint?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.defaultEndpoint != nil {
                map["DefaultEndpoint"] = self.defaultEndpoint?.toMap()
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["CreateTime"] as? Int64 {
                self.createTime = value
            }
            if let value = dict["DefaultEndpoint"] as? [String: Any?] {
                var model = ListInstancesResponseBody.Instances.DefaultEndpoint()
                model.fromMap(value)
                self.defaultEndpoint = model
            }
            if let value = dict["Description"] as? String {
                self.description_ = value
            }
            if let value = dict["InstanceId"] as? String {
                self.instanceId = value
            }
            if let value = dict["Status"] as? String {
                self.status = value
            }
        }
    }
    public var instances: [ListInstancesResponseBody.Instances]?

    public var requestId: String?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instances != nil {
            var tmp : [Any] = []
            for k in self.instances! {
                tmp.append(k.toMap())
            }
            map["Instances"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Instances"] as? [Any?] {
            var tmp : [ListInstancesResponseBody.Instances] = []
            for v in value {
                if v != nil {
                    var model = ListInstancesResponseBody.Instances()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.instances = tmp
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? Int64 {
            self.totalCount = value
        }
    }
}

public class ListInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListInstancesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListNetworkAccessEndpointAvailableRegionsResponseBody : Tea.TeaModel {
    public class Regions : Tea.TeaModel {
        public var localName: String?

        public var regionId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.localName != nil {
                map["LocalName"] = self.localName!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["LocalName"] as? String {
                self.localName = value
            }
            if let value = dict["RegionId"] as? String {
                self.regionId = value
            }
        }
    }
    public var regions: [ListNetworkAccessEndpointAvailableRegionsResponseBody.Regions]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.regions != nil {
            var tmp : [Any] = []
            for k in self.regions! {
                tmp.append(k.toMap())
            }
            map["Regions"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Regions"] as? [Any?] {
            var tmp : [ListNetworkAccessEndpointAvailableRegionsResponseBody.Regions] = []
            for v in value {
                if v != nil {
                    var model = ListNetworkAccessEndpointAvailableRegionsResponseBody.Regions()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.regions = tmp
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ListNetworkAccessEndpointAvailableRegionsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListNetworkAccessEndpointAvailableRegionsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListNetworkAccessEndpointAvailableRegionsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListNetworkAccessEndpointAvailableZonesRequest : Tea.TeaModel {
    public var naeRegionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.naeRegionId != nil {
            map["NaeRegionId"] = self.naeRegionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["NaeRegionId"] as? String {
            self.naeRegionId = value
        }
    }
}

public class ListNetworkAccessEndpointAvailableZonesResponseBody : Tea.TeaModel {
    public class Zones : Tea.TeaModel {
        public var localName: String?

        public var zoneId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.localName != nil {
                map["LocalName"] = self.localName!
            }
            if self.zoneId != nil {
                map["ZoneId"] = self.zoneId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["LocalName"] as? String {
                self.localName = value
            }
            if let value = dict["ZoneId"] as? String {
                self.zoneId = value
            }
        }
    }
    public var requestId: String?

    public var zones: [ListNetworkAccessEndpointAvailableZonesResponseBody.Zones]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.zones != nil {
            var tmp : [Any] = []
            for k in self.zones! {
                tmp.append(k.toMap())
            }
            map["Zones"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Zones"] as? [Any?] {
            var tmp : [ListNetworkAccessEndpointAvailableZonesResponseBody.Zones] = []
            for v in value {
                if v != nil {
                    var model = ListNetworkAccessEndpointAvailableZonesResponseBody.Zones()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.zones = tmp
        }
    }
}

public class ListNetworkAccessEndpointAvailableZonesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListNetworkAccessEndpointAvailableZonesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListNetworkAccessEndpointAvailableZonesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListNetworkAccessEndpointsRequest : Tea.TeaModel {
    public var instanceId: String?

    public var maxResults: Int64?

    public var networkAccessEndpointStatus: String?

    public var networkAccessEndpointType: String?

    public var nextToken: String?

    public var vpcId: String?

    public var vpcRegionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.networkAccessEndpointStatus != nil {
            map["NetworkAccessEndpointStatus"] = self.networkAccessEndpointStatus!
        }
        if self.networkAccessEndpointType != nil {
            map["NetworkAccessEndpointType"] = self.networkAccessEndpointType!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        if self.vpcRegionId != nil {
            map["VpcRegionId"] = self.vpcRegionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["MaxResults"] as? Int64 {
            self.maxResults = value
        }
        if let value = dict["NetworkAccessEndpointStatus"] as? String {
            self.networkAccessEndpointStatus = value
        }
        if let value = dict["NetworkAccessEndpointType"] as? String {
            self.networkAccessEndpointType = value
        }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["VpcId"] as? String {
            self.vpcId = value
        }
        if let value = dict["VpcRegionId"] as? String {
            self.vpcRegionId = value
        }
    }
}

public class ListNetworkAccessEndpointsResponseBody : Tea.TeaModel {
    public class NetworkAccessEndpoints : Tea.TeaModel {
        public var createTime: Int64?

        public var instanceId: String?

        public var networkAccessEndpointId: String?

        public var networkAccessEndpointName: String?

        public var networkAccessEndpointType: String?

        public var securityGroupId: String?

        public var status: String?

        public var updateTime: Int64?

        public var vSwitchIds: [String]?

        public var vpcId: String?

        public var vpcRegionId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.networkAccessEndpointId != nil {
                map["NetworkAccessEndpointId"] = self.networkAccessEndpointId!
            }
            if self.networkAccessEndpointName != nil {
                map["NetworkAccessEndpointName"] = self.networkAccessEndpointName!
            }
            if self.networkAccessEndpointType != nil {
                map["NetworkAccessEndpointType"] = self.networkAccessEndpointType!
            }
            if self.securityGroupId != nil {
                map["SecurityGroupId"] = self.securityGroupId!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.updateTime != nil {
                map["UpdateTime"] = self.updateTime!
            }
            if self.vSwitchIds != nil {
                map["VSwitchIds"] = self.vSwitchIds!
            }
            if self.vpcId != nil {
                map["VpcId"] = self.vpcId!
            }
            if self.vpcRegionId != nil {
                map["VpcRegionId"] = self.vpcRegionId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["CreateTime"] as? Int64 {
                self.createTime = value
            }
            if let value = dict["InstanceId"] as? String {
                self.instanceId = value
            }
            if let value = dict["NetworkAccessEndpointId"] as? String {
                self.networkAccessEndpointId = value
            }
            if let value = dict["NetworkAccessEndpointName"] as? String {
                self.networkAccessEndpointName = value
            }
            if let value = dict["NetworkAccessEndpointType"] as? String {
                self.networkAccessEndpointType = value
            }
            if let value = dict["SecurityGroupId"] as? String {
                self.securityGroupId = value
            }
            if let value = dict["Status"] as? String {
                self.status = value
            }
            if let value = dict["UpdateTime"] as? Int64 {
                self.updateTime = value
            }
            if let value = dict["VSwitchIds"] as? [String] {
                self.vSwitchIds = value
            }
            if let value = dict["VpcId"] as? String {
                self.vpcId = value
            }
            if let value = dict["VpcRegionId"] as? String {
                self.vpcRegionId = value
            }
        }
    }
    public var networkAccessEndpoints: [ListNetworkAccessEndpointsResponseBody.NetworkAccessEndpoints]?

    public var nextToken: String?

    public var requestId: String?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.networkAccessEndpoints != nil {
            var tmp : [Any] = []
            for k in self.networkAccessEndpoints! {
                tmp.append(k.toMap())
            }
            map["NetworkAccessEndpoints"] = tmp
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["NetworkAccessEndpoints"] as? [Any?] {
            var tmp : [ListNetworkAccessEndpointsResponseBody.NetworkAccessEndpoints] = []
            for v in value {
                if v != nil {
                    var model = ListNetworkAccessEndpointsResponseBody.NetworkAccessEndpoints()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.networkAccessEndpoints = tmp
        }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? Int64 {
            self.totalCount = value
        }
    }
}

public class ListNetworkAccessEndpointsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListNetworkAccessEndpointsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListNetworkAccessEndpointsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListNetworkAccessPathsRequest : Tea.TeaModel {
    public var instanceId: String?

    public var networkAccessEndpointId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.networkAccessEndpointId != nil {
            map["NetworkAccessEndpointId"] = self.networkAccessEndpointId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["NetworkAccessEndpointId"] as? String {
            self.networkAccessEndpointId = value
        }
    }
}

public class ListNetworkAccessPathsResponseBody : Tea.TeaModel {
    public class NetworkAccessPaths : Tea.TeaModel {
        public var createTime: Int64?

        public var instanceId: String?

        public var networkAccessEndpointId: String?

        public var networkAccessPathId: String?

        public var networkInterfaceId: String?

        public var privateIpAddress: String?

        public var status: String?

        public var updateTime: Int64?

        public var vSwitchId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.networkAccessEndpointId != nil {
                map["NetworkAccessEndpointId"] = self.networkAccessEndpointId!
            }
            if self.networkAccessPathId != nil {
                map["NetworkAccessPathId"] = self.networkAccessPathId!
            }
            if self.networkInterfaceId != nil {
                map["NetworkInterfaceId"] = self.networkInterfaceId!
            }
            if self.privateIpAddress != nil {
                map["PrivateIpAddress"] = self.privateIpAddress!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.updateTime != nil {
                map["UpdateTime"] = self.updateTime!
            }
            if self.vSwitchId != nil {
                map["VSwitchId"] = self.vSwitchId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["CreateTime"] as? Int64 {
                self.createTime = value
            }
            if let value = dict["InstanceId"] as? String {
                self.instanceId = value
            }
            if let value = dict["NetworkAccessEndpointId"] as? String {
                self.networkAccessEndpointId = value
            }
            if let value = dict["NetworkAccessPathId"] as? String {
                self.networkAccessPathId = value
            }
            if let value = dict["NetworkInterfaceId"] as? String {
                self.networkInterfaceId = value
            }
            if let value = dict["PrivateIpAddress"] as? String {
                self.privateIpAddress = value
            }
            if let value = dict["Status"] as? String {
                self.status = value
            }
            if let value = dict["UpdateTime"] as? Int64 {
                self.updateTime = value
            }
            if let value = dict["VSwitchId"] as? String {
                self.vSwitchId = value
            }
        }
    }
    public var networkAccessPaths: [ListNetworkAccessPathsResponseBody.NetworkAccessPaths]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.networkAccessPaths != nil {
            var tmp : [Any] = []
            for k in self.networkAccessPaths! {
                tmp.append(k.toMap())
            }
            map["NetworkAccessPaths"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["NetworkAccessPaths"] as? [Any?] {
            var tmp : [ListNetworkAccessPathsResponseBody.NetworkAccessPaths] = []
            for v in value {
                if v != nil {
                    var model = ListNetworkAccessPathsResponseBody.NetworkAccessPaths()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.networkAccessPaths = tmp
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ListNetworkAccessPathsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListNetworkAccessPathsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListNetworkAccessPathsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListOrganizationalUnitParentsRequest : Tea.TeaModel {
    public var instanceId: String?

    public var organizationalUnitId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.organizationalUnitId != nil {
            map["OrganizationalUnitId"] = self.organizationalUnitId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["OrganizationalUnitId"] as? String {
            self.organizationalUnitId = value
        }
    }
}

public class ListOrganizationalUnitParentsResponseBody : Tea.TeaModel {
    public class Parents : Tea.TeaModel {
        public var organizationalUnitId: String?

        public var parentId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.organizationalUnitId != nil {
                map["OrganizationalUnitId"] = self.organizationalUnitId!
            }
            if self.parentId != nil {
                map["ParentId"] = self.parentId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["OrganizationalUnitId"] as? String {
                self.organizationalUnitId = value
            }
            if let value = dict["ParentId"] as? String {
                self.parentId = value
            }
        }
    }
    public var parents: [ListOrganizationalUnitParentsResponseBody.Parents]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.parents != nil {
            var tmp : [Any] = []
            for k in self.parents! {
                tmp.append(k.toMap())
            }
            map["Parents"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Parents"] as? [Any?] {
            var tmp : [ListOrganizationalUnitParentsResponseBody.Parents] = []
            for v in value {
                if v != nil {
                    var model = ListOrganizationalUnitParentsResponseBody.Parents()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.parents = tmp
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ListOrganizationalUnitParentsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListOrganizationalUnitParentsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListOrganizationalUnitParentsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListOrganizationalUnitsRequest : Tea.TeaModel {
    public var instanceId: String?

    public var organizationalUnitIds: [String]?

    public var organizationalUnitName: String?

    public var organizationalUnitNameStartsWith: String?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var parentId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.organizationalUnitIds != nil {
            map["OrganizationalUnitIds"] = self.organizationalUnitIds!
        }
        if self.organizationalUnitName != nil {
            map["OrganizationalUnitName"] = self.organizationalUnitName!
        }
        if self.organizationalUnitNameStartsWith != nil {
            map["OrganizationalUnitNameStartsWith"] = self.organizationalUnitNameStartsWith!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.parentId != nil {
            map["ParentId"] = self.parentId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["OrganizationalUnitIds"] as? [String] {
            self.organizationalUnitIds = value
        }
        if let value = dict["OrganizationalUnitName"] as? String {
            self.organizationalUnitName = value
        }
        if let value = dict["OrganizationalUnitNameStartsWith"] as? String {
            self.organizationalUnitNameStartsWith = value
        }
        if let value = dict["PageNumber"] as? Int64 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int64 {
            self.pageSize = value
        }
        if let value = dict["ParentId"] as? String {
            self.parentId = value
        }
    }
}

public class ListOrganizationalUnitsResponseBody : Tea.TeaModel {
    public class OrganizationalUnits : Tea.TeaModel {
        public var createTime: Int64?

        public var description_: String?

        public var instanceId: String?

        public var leaf: Bool?

        public var organizationalUnitExternalId: String?

        public var organizationalUnitId: String?

        public var organizationalUnitName: String?

        public var organizationalUnitSourceId: String?

        public var organizationalUnitSourceType: String?

        public var parentId: String?

        public var updateTime: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.leaf != nil {
                map["Leaf"] = self.leaf!
            }
            if self.organizationalUnitExternalId != nil {
                map["OrganizationalUnitExternalId"] = self.organizationalUnitExternalId!
            }
            if self.organizationalUnitId != nil {
                map["OrganizationalUnitId"] = self.organizationalUnitId!
            }
            if self.organizationalUnitName != nil {
                map["OrganizationalUnitName"] = self.organizationalUnitName!
            }
            if self.organizationalUnitSourceId != nil {
                map["OrganizationalUnitSourceId"] = self.organizationalUnitSourceId!
            }
            if self.organizationalUnitSourceType != nil {
                map["OrganizationalUnitSourceType"] = self.organizationalUnitSourceType!
            }
            if self.parentId != nil {
                map["ParentId"] = self.parentId!
            }
            if self.updateTime != nil {
                map["UpdateTime"] = self.updateTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["CreateTime"] as? Int64 {
                self.createTime = value
            }
            if let value = dict["Description"] as? String {
                self.description_ = value
            }
            if let value = dict["InstanceId"] as? String {
                self.instanceId = value
            }
            if let value = dict["Leaf"] as? Bool {
                self.leaf = value
            }
            if let value = dict["OrganizationalUnitExternalId"] as? String {
                self.organizationalUnitExternalId = value
            }
            if let value = dict["OrganizationalUnitId"] as? String {
                self.organizationalUnitId = value
            }
            if let value = dict["OrganizationalUnitName"] as? String {
                self.organizationalUnitName = value
            }
            if let value = dict["OrganizationalUnitSourceId"] as? String {
                self.organizationalUnitSourceId = value
            }
            if let value = dict["OrganizationalUnitSourceType"] as? String {
                self.organizationalUnitSourceType = value
            }
            if let value = dict["ParentId"] as? String {
                self.parentId = value
            }
            if let value = dict["UpdateTime"] as? Int64 {
                self.updateTime = value
            }
        }
    }
    public var organizationalUnits: [ListOrganizationalUnitsResponseBody.OrganizationalUnits]?

    public var requestId: String?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.organizationalUnits != nil {
            var tmp : [Any] = []
            for k in self.organizationalUnits! {
                tmp.append(k.toMap())
            }
            map["OrganizationalUnits"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["OrganizationalUnits"] as? [Any?] {
            var tmp : [ListOrganizationalUnitsResponseBody.OrganizationalUnits] = []
            for v in value {
                if v != nil {
                    var model = ListOrganizationalUnitsResponseBody.OrganizationalUnits()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.organizationalUnits = tmp
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? Int64 {
            self.totalCount = value
        }
    }
}

public class ListOrganizationalUnitsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListOrganizationalUnitsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListOrganizationalUnitsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListOrganizationalUnitsForApplicationRequest : Tea.TeaModel {
    public var applicationId: String?

    public var instanceId: String?

    public var organizationalUnitIds: [String]?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.applicationId != nil {
            map["ApplicationId"] = self.applicationId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.organizationalUnitIds != nil {
            map["OrganizationalUnitIds"] = self.organizationalUnitIds!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ApplicationId"] as? String {
            self.applicationId = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["OrganizationalUnitIds"] as? [String] {
            self.organizationalUnitIds = value
        }
        if let value = dict["PageNumber"] as? Int64 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int64 {
            self.pageSize = value
        }
    }
}

public class ListOrganizationalUnitsForApplicationResponseBody : Tea.TeaModel {
    public class OrganizationalUnits : Tea.TeaModel {
        public var organizationalUnitId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.organizationalUnitId != nil {
                map["OrganizationalUnitId"] = self.organizationalUnitId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["OrganizationalUnitId"] as? String {
                self.organizationalUnitId = value
            }
        }
    }
    public var organizationalUnits: [ListOrganizationalUnitsForApplicationResponseBody.OrganizationalUnits]?

    public var requestId: String?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.organizationalUnits != nil {
            var tmp : [Any] = []
            for k in self.organizationalUnits! {
                tmp.append(k.toMap())
            }
            map["OrganizationalUnits"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["OrganizationalUnits"] as? [Any?] {
            var tmp : [ListOrganizationalUnitsForApplicationResponseBody.OrganizationalUnits] = []
            for v in value {
                if v != nil {
                    var model = ListOrganizationalUnitsForApplicationResponseBody.OrganizationalUnits()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.organizationalUnits = tmp
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? Int64 {
            self.totalCount = value
        }
    }
}

public class ListOrganizationalUnitsForApplicationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListOrganizationalUnitsForApplicationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListOrganizationalUnitsForApplicationResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListRegionsResponseBody : Tea.TeaModel {
    public class Regions : Tea.TeaModel {
        public var localName: String?

        public var regionEndpoint: String?

        public var regionId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.localName != nil {
                map["LocalName"] = self.localName!
            }
            if self.regionEndpoint != nil {
                map["RegionEndpoint"] = self.regionEndpoint!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["LocalName"] as? String {
                self.localName = value
            }
            if let value = dict["RegionEndpoint"] as? String {
                self.regionEndpoint = value
            }
            if let value = dict["RegionId"] as? String {
                self.regionId = value
            }
        }
    }
    public var regions: [ListRegionsResponseBody.Regions]?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.regions != nil {
            var tmp : [Any] = []
            for k in self.regions! {
                tmp.append(k.toMap())
            }
            map["Regions"] = tmp
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Regions"] as? [Any?] {
            var tmp : [ListRegionsResponseBody.Regions] = []
            for v in value {
                if v != nil {
                    var model = ListRegionsResponseBody.Regions()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.regions = tmp
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ListRegionsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListRegionsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListRegionsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListSynchronizationJobsRequest : Tea.TeaModel {
    public class Filters : Tea.TeaModel {
        public var key: String?

        public var values: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.values != nil {
                map["Values"] = self.values!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Key"] as? String {
                self.key = value
            }
            if let value = dict["Values"] as? [String] {
                self.values = value
            }
        }
    }
    public var direction: String?

    public var endTime: Int64?

    public var filters: [ListSynchronizationJobsRequest.Filters]?

    public var instanceId: String?

    public var maxResults: Int64?

    public var nextToken: String?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var startTime: Int64?

    public var status: String?

    public var targetIds: [String]?

    public var targetType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.direction != nil {
            map["Direction"] = self.direction!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.filters != nil {
            var tmp : [Any] = []
            for k in self.filters! {
                tmp.append(k.toMap())
            }
            map["Filters"] = tmp
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.targetIds != nil {
            map["TargetIds"] = self.targetIds!
        }
        if self.targetType != nil {
            map["TargetType"] = self.targetType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Direction"] as? String {
            self.direction = value
        }
        if let value = dict["EndTime"] as? Int64 {
            self.endTime = value
        }
        if let value = dict["Filters"] as? [Any?] {
            var tmp : [ListSynchronizationJobsRequest.Filters] = []
            for v in value {
                if v != nil {
                    var model = ListSynchronizationJobsRequest.Filters()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.filters = tmp
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["MaxResults"] as? Int64 {
            self.maxResults = value
        }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["PageNumber"] as? Int64 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int64 {
            self.pageSize = value
        }
        if let value = dict["StartTime"] as? Int64 {
            self.startTime = value
        }
        if let value = dict["Status"] as? String {
            self.status = value
        }
        if let value = dict["TargetIds"] as? [String] {
            self.targetIds = value
        }
        if let value = dict["TargetType"] as? String {
            self.targetType = value
        }
    }
}

public class ListSynchronizationJobsResponseBody : Tea.TeaModel {
    public class SynchronizationJobs : Tea.TeaModel {
        public class Result : Tea.TeaModel {
            public class GroupMemberStatistics : Tea.TeaModel {
                public class Binded : Tea.TeaModel {
                    public var failed: Int64?

                    public var skipped: Int64?

                    public var success: Int64?

                    public var total: Int64?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.failed != nil {
                            map["Failed"] = self.failed!
                        }
                        if self.skipped != nil {
                            map["Skipped"] = self.skipped!
                        }
                        if self.success != nil {
                            map["Success"] = self.success!
                        }
                        if self.total != nil {
                            map["Total"] = self.total!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Failed"] as? Int64 {
                            self.failed = value
                        }
                        if let value = dict["Skipped"] as? Int64 {
                            self.skipped = value
                        }
                        if let value = dict["Success"] as? Int64 {
                            self.success = value
                        }
                        if let value = dict["Total"] as? Int64 {
                            self.total = value
                        }
                    }
                }
                public class Created : Tea.TeaModel {
                    public var failed: Int64?

                    public var skipped: Int64?

                    public var success: Int64?

                    public var total: Int64?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.failed != nil {
                            map["Failed"] = self.failed!
                        }
                        if self.skipped != nil {
                            map["Skipped"] = self.skipped!
                        }
                        if self.success != nil {
                            map["Success"] = self.success!
                        }
                        if self.total != nil {
                            map["Total"] = self.total!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Failed"] as? Int64 {
                            self.failed = value
                        }
                        if let value = dict["Skipped"] as? Int64 {
                            self.skipped = value
                        }
                        if let value = dict["Success"] as? Int64 {
                            self.success = value
                        }
                        if let value = dict["Total"] as? Int64 {
                            self.total = value
                        }
                    }
                }
                public class Deleted : Tea.TeaModel {
                    public var failed: Int64?

                    public var skipped: Int64?

                    public var success: Int64?

                    public var total: Int64?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.failed != nil {
                            map["Failed"] = self.failed!
                        }
                        if self.skipped != nil {
                            map["Skipped"] = self.skipped!
                        }
                        if self.success != nil {
                            map["Success"] = self.success!
                        }
                        if self.total != nil {
                            map["Total"] = self.total!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Failed"] as? Int64 {
                            self.failed = value
                        }
                        if let value = dict["Skipped"] as? Int64 {
                            self.skipped = value
                        }
                        if let value = dict["Success"] as? Int64 {
                            self.success = value
                        }
                        if let value = dict["Total"] as? Int64 {
                            self.total = value
                        }
                    }
                }
                public class Pushed : Tea.TeaModel {
                    public var failed: Int64?

                    public var skipped: Int64?

                    public var success: Int64?

                    public var total: Int64?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.failed != nil {
                            map["Failed"] = self.failed!
                        }
                        if self.skipped != nil {
                            map["Skipped"] = self.skipped!
                        }
                        if self.success != nil {
                            map["Success"] = self.success!
                        }
                        if self.total != nil {
                            map["Total"] = self.total!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Failed"] as? Int64 {
                            self.failed = value
                        }
                        if let value = dict["Skipped"] as? Int64 {
                            self.skipped = value
                        }
                        if let value = dict["Success"] as? Int64 {
                            self.success = value
                        }
                        if let value = dict["Total"] as? Int64 {
                            self.total = value
                        }
                    }
                }
                public class Same : Tea.TeaModel {
                    public var failed: Int64?

                    public var skipped: Int64?

                    public var success: Int64?

                    public var total: Int64?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.failed != nil {
                            map["Failed"] = self.failed!
                        }
                        if self.skipped != nil {
                            map["Skipped"] = self.skipped!
                        }
                        if self.success != nil {
                            map["Success"] = self.success!
                        }
                        if self.total != nil {
                            map["Total"] = self.total!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Failed"] as? Int64 {
                            self.failed = value
                        }
                        if let value = dict["Skipped"] as? Int64 {
                            self.skipped = value
                        }
                        if let value = dict["Success"] as? Int64 {
                            self.success = value
                        }
                        if let value = dict["Total"] as? Int64 {
                            self.total = value
                        }
                    }
                }
                public class Updated : Tea.TeaModel {
                    public var failed: Int64?

                    public var skipped: Int64?

                    public var success: Int64?

                    public var total: Int64?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.failed != nil {
                            map["Failed"] = self.failed!
                        }
                        if self.skipped != nil {
                            map["Skipped"] = self.skipped!
                        }
                        if self.success != nil {
                            map["Success"] = self.success!
                        }
                        if self.total != nil {
                            map["Total"] = self.total!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Failed"] as? Int64 {
                            self.failed = value
                        }
                        if let value = dict["Skipped"] as? Int64 {
                            self.skipped = value
                        }
                        if let value = dict["Success"] as? Int64 {
                            self.success = value
                        }
                        if let value = dict["Total"] as? Int64 {
                            self.total = value
                        }
                    }
                }
                public var binded: ListSynchronizationJobsResponseBody.SynchronizationJobs.Result.GroupMemberStatistics.Binded?

                public var created: ListSynchronizationJobsResponseBody.SynchronizationJobs.Result.GroupMemberStatistics.Created?

                public var deleted: ListSynchronizationJobsResponseBody.SynchronizationJobs.Result.GroupMemberStatistics.Deleted?

                public var pushed: ListSynchronizationJobsResponseBody.SynchronizationJobs.Result.GroupMemberStatistics.Pushed?

                public var same: ListSynchronizationJobsResponseBody.SynchronizationJobs.Result.GroupMemberStatistics.Same?

                public var updated: ListSynchronizationJobsResponseBody.SynchronizationJobs.Result.GroupMemberStatistics.Updated?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.binded?.validate()
                    try self.created?.validate()
                    try self.deleted?.validate()
                    try self.pushed?.validate()
                    try self.same?.validate()
                    try self.updated?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.binded != nil {
                        map["Binded"] = self.binded?.toMap()
                    }
                    if self.created != nil {
                        map["Created"] = self.created?.toMap()
                    }
                    if self.deleted != nil {
                        map["Deleted"] = self.deleted?.toMap()
                    }
                    if self.pushed != nil {
                        map["Pushed"] = self.pushed?.toMap()
                    }
                    if self.same != nil {
                        map["Same"] = self.same?.toMap()
                    }
                    if self.updated != nil {
                        map["Updated"] = self.updated?.toMap()
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Binded"] as? [String: Any?] {
                        var model = ListSynchronizationJobsResponseBody.SynchronizationJobs.Result.GroupMemberStatistics.Binded()
                        model.fromMap(value)
                        self.binded = model
                    }
                    if let value = dict["Created"] as? [String: Any?] {
                        var model = ListSynchronizationJobsResponseBody.SynchronizationJobs.Result.GroupMemberStatistics.Created()
                        model.fromMap(value)
                        self.created = model
                    }
                    if let value = dict["Deleted"] as? [String: Any?] {
                        var model = ListSynchronizationJobsResponseBody.SynchronizationJobs.Result.GroupMemberStatistics.Deleted()
                        model.fromMap(value)
                        self.deleted = model
                    }
                    if let value = dict["Pushed"] as? [String: Any?] {
                        var model = ListSynchronizationJobsResponseBody.SynchronizationJobs.Result.GroupMemberStatistics.Pushed()
                        model.fromMap(value)
                        self.pushed = model
                    }
                    if let value = dict["Same"] as? [String: Any?] {
                        var model = ListSynchronizationJobsResponseBody.SynchronizationJobs.Result.GroupMemberStatistics.Same()
                        model.fromMap(value)
                        self.same = model
                    }
                    if let value = dict["Updated"] as? [String: Any?] {
                        var model = ListSynchronizationJobsResponseBody.SynchronizationJobs.Result.GroupMemberStatistics.Updated()
                        model.fromMap(value)
                        self.updated = model
                    }
                }
            }
            public class GroupStatistics : Tea.TeaModel {
                public class Binded : Tea.TeaModel {
                    public var failed: Int64?

                    public var skipped: Int64?

                    public var success: Int64?

                    public var total: Int64?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.failed != nil {
                            map["Failed"] = self.failed!
                        }
                        if self.skipped != nil {
                            map["Skipped"] = self.skipped!
                        }
                        if self.success != nil {
                            map["Success"] = self.success!
                        }
                        if self.total != nil {
                            map["Total"] = self.total!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Failed"] as? Int64 {
                            self.failed = value
                        }
                        if let value = dict["Skipped"] as? Int64 {
                            self.skipped = value
                        }
                        if let value = dict["Success"] as? Int64 {
                            self.success = value
                        }
                        if let value = dict["Total"] as? Int64 {
                            self.total = value
                        }
                    }
                }
                public class Created : Tea.TeaModel {
                    public var failed: Int64?

                    public var skipped: Int64?

                    public var success: Int64?

                    public var total: Int64?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.failed != nil {
                            map["Failed"] = self.failed!
                        }
                        if self.skipped != nil {
                            map["Skipped"] = self.skipped!
                        }
                        if self.success != nil {
                            map["Success"] = self.success!
                        }
                        if self.total != nil {
                            map["Total"] = self.total!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Failed"] as? Int64 {
                            self.failed = value
                        }
                        if let value = dict["Skipped"] as? Int64 {
                            self.skipped = value
                        }
                        if let value = dict["Success"] as? Int64 {
                            self.success = value
                        }
                        if let value = dict["Total"] as? Int64 {
                            self.total = value
                        }
                    }
                }
                public class Deleted : Tea.TeaModel {
                    public var failed: Int64?

                    public var skipped: Int64?

                    public var success: Int64?

                    public var total: Int64?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.failed != nil {
                            map["Failed"] = self.failed!
                        }
                        if self.skipped != nil {
                            map["Skipped"] = self.skipped!
                        }
                        if self.success != nil {
                            map["Success"] = self.success!
                        }
                        if self.total != nil {
                            map["Total"] = self.total!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Failed"] as? Int64 {
                            self.failed = value
                        }
                        if let value = dict["Skipped"] as? Int64 {
                            self.skipped = value
                        }
                        if let value = dict["Success"] as? Int64 {
                            self.success = value
                        }
                        if let value = dict["Total"] as? Int64 {
                            self.total = value
                        }
                    }
                }
                public class Pushed : Tea.TeaModel {
                    public var failed: Int64?

                    public var skipped: Int64?

                    public var success: Int64?

                    public var total: Int64?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.failed != nil {
                            map["Failed"] = self.failed!
                        }
                        if self.skipped != nil {
                            map["Skipped"] = self.skipped!
                        }
                        if self.success != nil {
                            map["Success"] = self.success!
                        }
                        if self.total != nil {
                            map["Total"] = self.total!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Failed"] as? Int64 {
                            self.failed = value
                        }
                        if let value = dict["Skipped"] as? Int64 {
                            self.skipped = value
                        }
                        if let value = dict["Success"] as? Int64 {
                            self.success = value
                        }
                        if let value = dict["Total"] as? Int64 {
                            self.total = value
                        }
                    }
                }
                public class Same : Tea.TeaModel {
                    public var failed: Int64?

                    public var skipped: Int64?

                    public var success: Int64?

                    public var total: Int64?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.failed != nil {
                            map["Failed"] = self.failed!
                        }
                        if self.skipped != nil {
                            map["Skipped"] = self.skipped!
                        }
                        if self.success != nil {
                            map["Success"] = self.success!
                        }
                        if self.total != nil {
                            map["Total"] = self.total!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Failed"] as? Int64 {
                            self.failed = value
                        }
                        if let value = dict["Skipped"] as? Int64 {
                            self.skipped = value
                        }
                        if let value = dict["Success"] as? Int64 {
                            self.success = value
                        }
                        if let value = dict["Total"] as? Int64 {
                            self.total = value
                        }
                    }
                }
                public class Updated : Tea.TeaModel {
                    public var failed: Int64?

                    public var skipped: Int64?

                    public var success: Int64?

                    public var total: Int64?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.failed != nil {
                            map["Failed"] = self.failed!
                        }
                        if self.skipped != nil {
                            map["Skipped"] = self.skipped!
                        }
                        if self.success != nil {
                            map["Success"] = self.success!
                        }
                        if self.total != nil {
                            map["Total"] = self.total!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Failed"] as? Int64 {
                            self.failed = value
                        }
                        if let value = dict["Skipped"] as? Int64 {
                            self.skipped = value
                        }
                        if let value = dict["Success"] as? Int64 {
                            self.success = value
                        }
                        if let value = dict["Total"] as? Int64 {
                            self.total = value
                        }
                    }
                }
                public var binded: ListSynchronizationJobsResponseBody.SynchronizationJobs.Result.GroupStatistics.Binded?

                public var created: ListSynchronizationJobsResponseBody.SynchronizationJobs.Result.GroupStatistics.Created?

                public var deleted: ListSynchronizationJobsResponseBody.SynchronizationJobs.Result.GroupStatistics.Deleted?

                public var pushed: ListSynchronizationJobsResponseBody.SynchronizationJobs.Result.GroupStatistics.Pushed?

                public var same: ListSynchronizationJobsResponseBody.SynchronizationJobs.Result.GroupStatistics.Same?

                public var updated: ListSynchronizationJobsResponseBody.SynchronizationJobs.Result.GroupStatistics.Updated?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.binded?.validate()
                    try self.created?.validate()
                    try self.deleted?.validate()
                    try self.pushed?.validate()
                    try self.same?.validate()
                    try self.updated?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.binded != nil {
                        map["Binded"] = self.binded?.toMap()
                    }
                    if self.created != nil {
                        map["Created"] = self.created?.toMap()
                    }
                    if self.deleted != nil {
                        map["Deleted"] = self.deleted?.toMap()
                    }
                    if self.pushed != nil {
                        map["Pushed"] = self.pushed?.toMap()
                    }
                    if self.same != nil {
                        map["Same"] = self.same?.toMap()
                    }
                    if self.updated != nil {
                        map["Updated"] = self.updated?.toMap()
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Binded"] as? [String: Any?] {
                        var model = ListSynchronizationJobsResponseBody.SynchronizationJobs.Result.GroupStatistics.Binded()
                        model.fromMap(value)
                        self.binded = model
                    }
                    if let value = dict["Created"] as? [String: Any?] {
                        var model = ListSynchronizationJobsResponseBody.SynchronizationJobs.Result.GroupStatistics.Created()
                        model.fromMap(value)
                        self.created = model
                    }
                    if let value = dict["Deleted"] as? [String: Any?] {
                        var model = ListSynchronizationJobsResponseBody.SynchronizationJobs.Result.GroupStatistics.Deleted()
                        model.fromMap(value)
                        self.deleted = model
                    }
                    if let value = dict["Pushed"] as? [String: Any?] {
                        var model = ListSynchronizationJobsResponseBody.SynchronizationJobs.Result.GroupStatistics.Pushed()
                        model.fromMap(value)
                        self.pushed = model
                    }
                    if let value = dict["Same"] as? [String: Any?] {
                        var model = ListSynchronizationJobsResponseBody.SynchronizationJobs.Result.GroupStatistics.Same()
                        model.fromMap(value)
                        self.same = model
                    }
                    if let value = dict["Updated"] as? [String: Any?] {
                        var model = ListSynchronizationJobsResponseBody.SynchronizationJobs.Result.GroupStatistics.Updated()
                        model.fromMap(value)
                        self.updated = model
                    }
                }
            }
            public class OrganizationalUnitStatistics : Tea.TeaModel {
                public class Binded : Tea.TeaModel {
                    public var failed: Int64?

                    public var skipped: Int64?

                    public var success: Int64?

                    public var total: Int64?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.failed != nil {
                            map["Failed"] = self.failed!
                        }
                        if self.skipped != nil {
                            map["Skipped"] = self.skipped!
                        }
                        if self.success != nil {
                            map["Success"] = self.success!
                        }
                        if self.total != nil {
                            map["Total"] = self.total!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Failed"] as? Int64 {
                            self.failed = value
                        }
                        if let value = dict["Skipped"] as? Int64 {
                            self.skipped = value
                        }
                        if let value = dict["Success"] as? Int64 {
                            self.success = value
                        }
                        if let value = dict["Total"] as? Int64 {
                            self.total = value
                        }
                    }
                }
                public class Created : Tea.TeaModel {
                    public var failed: Int64?

                    public var skipped: Int64?

                    public var success: Int64?

                    public var total: Int64?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.failed != nil {
                            map["Failed"] = self.failed!
                        }
                        if self.skipped != nil {
                            map["Skipped"] = self.skipped!
                        }
                        if self.success != nil {
                            map["Success"] = self.success!
                        }
                        if self.total != nil {
                            map["Total"] = self.total!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Failed"] as? Int64 {
                            self.failed = value
                        }
                        if let value = dict["Skipped"] as? Int64 {
                            self.skipped = value
                        }
                        if let value = dict["Success"] as? Int64 {
                            self.success = value
                        }
                        if let value = dict["Total"] as? Int64 {
                            self.total = value
                        }
                    }
                }
                public class Deleted : Tea.TeaModel {
                    public var failed: Int64?

                    public var skipped: Int64?

                    public var success: Int64?

                    public var total: Int64?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.failed != nil {
                            map["Failed"] = self.failed!
                        }
                        if self.skipped != nil {
                            map["Skipped"] = self.skipped!
                        }
                        if self.success != nil {
                            map["Success"] = self.success!
                        }
                        if self.total != nil {
                            map["Total"] = self.total!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Failed"] as? Int64 {
                            self.failed = value
                        }
                        if let value = dict["Skipped"] as? Int64 {
                            self.skipped = value
                        }
                        if let value = dict["Success"] as? Int64 {
                            self.success = value
                        }
                        if let value = dict["Total"] as? Int64 {
                            self.total = value
                        }
                    }
                }
                public class Pushed : Tea.TeaModel {
                    public var failed: Int64?

                    public var skipped: Int64?

                    public var success: Int64?

                    public var total: Int64?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.failed != nil {
                            map["Failed"] = self.failed!
                        }
                        if self.skipped != nil {
                            map["Skipped"] = self.skipped!
                        }
                        if self.success != nil {
                            map["Success"] = self.success!
                        }
                        if self.total != nil {
                            map["Total"] = self.total!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Failed"] as? Int64 {
                            self.failed = value
                        }
                        if let value = dict["Skipped"] as? Int64 {
                            self.skipped = value
                        }
                        if let value = dict["Success"] as? Int64 {
                            self.success = value
                        }
                        if let value = dict["Total"] as? Int64 {
                            self.total = value
                        }
                    }
                }
                public class Same : Tea.TeaModel {
                    public var failed: Int64?

                    public var skipped: Int64?

                    public var success: Int64?

                    public var total: Int64?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.failed != nil {
                            map["Failed"] = self.failed!
                        }
                        if self.skipped != nil {
                            map["Skipped"] = self.skipped!
                        }
                        if self.success != nil {
                            map["Success"] = self.success!
                        }
                        if self.total != nil {
                            map["Total"] = self.total!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Failed"] as? Int64 {
                            self.failed = value
                        }
                        if let value = dict["Skipped"] as? Int64 {
                            self.skipped = value
                        }
                        if let value = dict["Success"] as? Int64 {
                            self.success = value
                        }
                        if let value = dict["Total"] as? Int64 {
                            self.total = value
                        }
                    }
                }
                public class Updated : Tea.TeaModel {
                    public var failed: Int64?

                    public var skipped: Int64?

                    public var success: Int64?

                    public var total: Int64?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.failed != nil {
                            map["Failed"] = self.failed!
                        }
                        if self.skipped != nil {
                            map["Skipped"] = self.skipped!
                        }
                        if self.success != nil {
                            map["Success"] = self.success!
                        }
                        if self.total != nil {
                            map["Total"] = self.total!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Failed"] as? Int64 {
                            self.failed = value
                        }
                        if let value = dict["Skipped"] as? Int64 {
                            self.skipped = value
                        }
                        if let value = dict["Success"] as? Int64 {
                            self.success = value
                        }
                        if let value = dict["Total"] as? Int64 {
                            self.total = value
                        }
                    }
                }
                public var binded: ListSynchronizationJobsResponseBody.SynchronizationJobs.Result.OrganizationalUnitStatistics.Binded?

                public var created: ListSynchronizationJobsResponseBody.SynchronizationJobs.Result.OrganizationalUnitStatistics.Created?

                public var deleted: ListSynchronizationJobsResponseBody.SynchronizationJobs.Result.OrganizationalUnitStatistics.Deleted?

                public var pushed: ListSynchronizationJobsResponseBody.SynchronizationJobs.Result.OrganizationalUnitStatistics.Pushed?

                public var same: ListSynchronizationJobsResponseBody.SynchronizationJobs.Result.OrganizationalUnitStatistics.Same?

                public var updated: ListSynchronizationJobsResponseBody.SynchronizationJobs.Result.OrganizationalUnitStatistics.Updated?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.binded?.validate()
                    try self.created?.validate()
                    try self.deleted?.validate()
                    try self.pushed?.validate()
                    try self.same?.validate()
                    try self.updated?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.binded != nil {
                        map["Binded"] = self.binded?.toMap()
                    }
                    if self.created != nil {
                        map["Created"] = self.created?.toMap()
                    }
                    if self.deleted != nil {
                        map["Deleted"] = self.deleted?.toMap()
                    }
                    if self.pushed != nil {
                        map["Pushed"] = self.pushed?.toMap()
                    }
                    if self.same != nil {
                        map["Same"] = self.same?.toMap()
                    }
                    if self.updated != nil {
                        map["Updated"] = self.updated?.toMap()
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Binded"] as? [String: Any?] {
                        var model = ListSynchronizationJobsResponseBody.SynchronizationJobs.Result.OrganizationalUnitStatistics.Binded()
                        model.fromMap(value)
                        self.binded = model
                    }
                    if let value = dict["Created"] as? [String: Any?] {
                        var model = ListSynchronizationJobsResponseBody.SynchronizationJobs.Result.OrganizationalUnitStatistics.Created()
                        model.fromMap(value)
                        self.created = model
                    }
                    if let value = dict["Deleted"] as? [String: Any?] {
                        var model = ListSynchronizationJobsResponseBody.SynchronizationJobs.Result.OrganizationalUnitStatistics.Deleted()
                        model.fromMap(value)
                        self.deleted = model
                    }
                    if let value = dict["Pushed"] as? [String: Any?] {
                        var model = ListSynchronizationJobsResponseBody.SynchronizationJobs.Result.OrganizationalUnitStatistics.Pushed()
                        model.fromMap(value)
                        self.pushed = model
                    }
                    if let value = dict["Same"] as? [String: Any?] {
                        var model = ListSynchronizationJobsResponseBody.SynchronizationJobs.Result.OrganizationalUnitStatistics.Same()
                        model.fromMap(value)
                        self.same = model
                    }
                    if let value = dict["Updated"] as? [String: Any?] {
                        var model = ListSynchronizationJobsResponseBody.SynchronizationJobs.Result.OrganizationalUnitStatistics.Updated()
                        model.fromMap(value)
                        self.updated = model
                    }
                }
            }
            public class UserStatistics : Tea.TeaModel {
                public class Binded : Tea.TeaModel {
                    public var failed: Int64?

                    public var skipped: Int64?

                    public var success: Int64?

                    public var total: Int64?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.failed != nil {
                            map["Failed"] = self.failed!
                        }
                        if self.skipped != nil {
                            map["Skipped"] = self.skipped!
                        }
                        if self.success != nil {
                            map["Success"] = self.success!
                        }
                        if self.total != nil {
                            map["Total"] = self.total!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Failed"] as? Int64 {
                            self.failed = value
                        }
                        if let value = dict["Skipped"] as? Int64 {
                            self.skipped = value
                        }
                        if let value = dict["Success"] as? Int64 {
                            self.success = value
                        }
                        if let value = dict["Total"] as? Int64 {
                            self.total = value
                        }
                    }
                }
                public class Created : Tea.TeaModel {
                    public var failed: Int64?

                    public var skipped: Int64?

                    public var success: Int64?

                    public var total: Int64?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.failed != nil {
                            map["Failed"] = self.failed!
                        }
                        if self.skipped != nil {
                            map["Skipped"] = self.skipped!
                        }
                        if self.success != nil {
                            map["Success"] = self.success!
                        }
                        if self.total != nil {
                            map["Total"] = self.total!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Failed"] as? Int64 {
                            self.failed = value
                        }
                        if let value = dict["Skipped"] as? Int64 {
                            self.skipped = value
                        }
                        if let value = dict["Success"] as? Int64 {
                            self.success = value
                        }
                        if let value = dict["Total"] as? Int64 {
                            self.total = value
                        }
                    }
                }
                public class Deleted : Tea.TeaModel {
                    public var failed: Int64?

                    public var skipped: Int64?

                    public var success: Int64?

                    public var total: Int64?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.failed != nil {
                            map["Failed"] = self.failed!
                        }
                        if self.skipped != nil {
                            map["Skipped"] = self.skipped!
                        }
                        if self.success != nil {
                            map["Success"] = self.success!
                        }
                        if self.total != nil {
                            map["Total"] = self.total!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Failed"] as? Int64 {
                            self.failed = value
                        }
                        if let value = dict["Skipped"] as? Int64 {
                            self.skipped = value
                        }
                        if let value = dict["Success"] as? Int64 {
                            self.success = value
                        }
                        if let value = dict["Total"] as? Int64 {
                            self.total = value
                        }
                    }
                }
                public class Exported : Tea.TeaModel {
                    public var failed: Int64?

                    public var skipped: Int64?

                    public var success: Int64?

                    public var total: Int64?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.failed != nil {
                            map["Failed"] = self.failed!
                        }
                        if self.skipped != nil {
                            map["Skipped"] = self.skipped!
                        }
                        if self.success != nil {
                            map["Success"] = self.success!
                        }
                        if self.total != nil {
                            map["Total"] = self.total!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Failed"] as? Int64 {
                            self.failed = value
                        }
                        if let value = dict["Skipped"] as? Int64 {
                            self.skipped = value
                        }
                        if let value = dict["Success"] as? Int64 {
                            self.success = value
                        }
                        if let value = dict["Total"] as? Int64 {
                            self.total = value
                        }
                    }
                }
                public class Pushed : Tea.TeaModel {
                    public var failed: Int64?

                    public var skipped: Int64?

                    public var success: Int64?

                    public var total: Int64?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.failed != nil {
                            map["Failed"] = self.failed!
                        }
                        if self.skipped != nil {
                            map["Skipped"] = self.skipped!
                        }
                        if self.success != nil {
                            map["Success"] = self.success!
                        }
                        if self.total != nil {
                            map["Total"] = self.total!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Failed"] as? Int64 {
                            self.failed = value
                        }
                        if let value = dict["Skipped"] as? Int64 {
                            self.skipped = value
                        }
                        if let value = dict["Success"] as? Int64 {
                            self.success = value
                        }
                        if let value = dict["Total"] as? Int64 {
                            self.total = value
                        }
                    }
                }
                public class Same : Tea.TeaModel {
                    public var failed: Int64?

                    public var skipped: Int64?

                    public var success: Int64?

                    public var total: Int64?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.failed != nil {
                            map["Failed"] = self.failed!
                        }
                        if self.skipped != nil {
                            map["Skipped"] = self.skipped!
                        }
                        if self.success != nil {
                            map["Success"] = self.success!
                        }
                        if self.total != nil {
                            map["Total"] = self.total!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Failed"] as? Int64 {
                            self.failed = value
                        }
                        if let value = dict["Skipped"] as? Int64 {
                            self.skipped = value
                        }
                        if let value = dict["Success"] as? Int64 {
                            self.success = value
                        }
                        if let value = dict["Total"] as? Int64 {
                            self.total = value
                        }
                    }
                }
                public class Updated : Tea.TeaModel {
                    public var failed: Int64?

                    public var skipped: Int64?

                    public var success: Int64?

                    public var total: Int64?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.failed != nil {
                            map["Failed"] = self.failed!
                        }
                        if self.skipped != nil {
                            map["Skipped"] = self.skipped!
                        }
                        if self.success != nil {
                            map["Success"] = self.success!
                        }
                        if self.total != nil {
                            map["Total"] = self.total!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["Failed"] as? Int64 {
                            self.failed = value
                        }
                        if let value = dict["Skipped"] as? Int64 {
                            self.skipped = value
                        }
                        if let value = dict["Success"] as? Int64 {
                            self.success = value
                        }
                        if let value = dict["Total"] as? Int64 {
                            self.total = value
                        }
                    }
                }
                public var binded: ListSynchronizationJobsResponseBody.SynchronizationJobs.Result.UserStatistics.Binded?

                public var created: ListSynchronizationJobsResponseBody.SynchronizationJobs.Result.UserStatistics.Created?

                public var deleted: ListSynchronizationJobsResponseBody.SynchronizationJobs.Result.UserStatistics.Deleted?

                public var exported: ListSynchronizationJobsResponseBody.SynchronizationJobs.Result.UserStatistics.Exported?

                public var pushed: ListSynchronizationJobsResponseBody.SynchronizationJobs.Result.UserStatistics.Pushed?

                public var same: ListSynchronizationJobsResponseBody.SynchronizationJobs.Result.UserStatistics.Same?

                public var updated: ListSynchronizationJobsResponseBody.SynchronizationJobs.Result.UserStatistics.Updated?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.binded?.validate()
                    try self.created?.validate()
                    try self.deleted?.validate()
                    try self.exported?.validate()
                    try self.pushed?.validate()
                    try self.same?.validate()
                    try self.updated?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.binded != nil {
                        map["Binded"] = self.binded?.toMap()
                    }
                    if self.created != nil {
                        map["Created"] = self.created?.toMap()
                    }
                    if self.deleted != nil {
                        map["Deleted"] = self.deleted?.toMap()
                    }
                    if self.exported != nil {
                        map["Exported"] = self.exported?.toMap()
                    }
                    if self.pushed != nil {
                        map["Pushed"] = self.pushed?.toMap()
                    }
                    if self.same != nil {
                        map["Same"] = self.same?.toMap()
                    }
                    if self.updated != nil {
                        map["Updated"] = self.updated?.toMap()
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["Binded"] as? [String: Any?] {
                        var model = ListSynchronizationJobsResponseBody.SynchronizationJobs.Result.UserStatistics.Binded()
                        model.fromMap(value)
                        self.binded = model
                    }
                    if let value = dict["Created"] as? [String: Any?] {
                        var model = ListSynchronizationJobsResponseBody.SynchronizationJobs.Result.UserStatistics.Created()
                        model.fromMap(value)
                        self.created = model
                    }
                    if let value = dict["Deleted"] as? [String: Any?] {
                        var model = ListSynchronizationJobsResponseBody.SynchronizationJobs.Result.UserStatistics.Deleted()
                        model.fromMap(value)
                        self.deleted = model
                    }
                    if let value = dict["Exported"] as? [String: Any?] {
                        var model = ListSynchronizationJobsResponseBody.SynchronizationJobs.Result.UserStatistics.Exported()
                        model.fromMap(value)
                        self.exported = model
                    }
                    if let value = dict["Pushed"] as? [String: Any?] {
                        var model = ListSynchronizationJobsResponseBody.SynchronizationJobs.Result.UserStatistics.Pushed()
                        model.fromMap(value)
                        self.pushed = model
                    }
                    if let value = dict["Same"] as? [String: Any?] {
                        var model = ListSynchronizationJobsResponseBody.SynchronizationJobs.Result.UserStatistics.Same()
                        model.fromMap(value)
                        self.same = model
                    }
                    if let value = dict["Updated"] as? [String: Any?] {
                        var model = ListSynchronizationJobsResponseBody.SynchronizationJobs.Result.UserStatistics.Updated()
                        model.fromMap(value)
                        self.updated = model
                    }
                }
            }
            public var errorCode: String?

            public var errorMessage: String?

            public var groupMemberStatistics: ListSynchronizationJobsResponseBody.SynchronizationJobs.Result.GroupMemberStatistics?

            public var groupStatistics: ListSynchronizationJobsResponseBody.SynchronizationJobs.Result.GroupStatistics?

            public var organizationalUnitStatistics: ListSynchronizationJobsResponseBody.SynchronizationJobs.Result.OrganizationalUnitStatistics?

            public var userStatistics: ListSynchronizationJobsResponseBody.SynchronizationJobs.Result.UserStatistics?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.groupMemberStatistics?.validate()
                try self.groupStatistics?.validate()
                try self.organizationalUnitStatistics?.validate()
                try self.userStatistics?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.errorCode != nil {
                    map["ErrorCode"] = self.errorCode!
                }
                if self.errorMessage != nil {
                    map["ErrorMessage"] = self.errorMessage!
                }
                if self.groupMemberStatistics != nil {
                    map["GroupMemberStatistics"] = self.groupMemberStatistics?.toMap()
                }
                if self.groupStatistics != nil {
                    map["GroupStatistics"] = self.groupStatistics?.toMap()
                }
                if self.organizationalUnitStatistics != nil {
                    map["OrganizationalUnitStatistics"] = self.organizationalUnitStatistics?.toMap()
                }
                if self.userStatistics != nil {
                    map["UserStatistics"] = self.userStatistics?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ErrorCode"] as? String {
                    self.errorCode = value
                }
                if let value = dict["ErrorMessage"] as? String {
                    self.errorMessage = value
                }
                if let value = dict["GroupMemberStatistics"] as? [String: Any?] {
                    var model = ListSynchronizationJobsResponseBody.SynchronizationJobs.Result.GroupMemberStatistics()
                    model.fromMap(value)
                    self.groupMemberStatistics = model
                }
                if let value = dict["GroupStatistics"] as? [String: Any?] {
                    var model = ListSynchronizationJobsResponseBody.SynchronizationJobs.Result.GroupStatistics()
                    model.fromMap(value)
                    self.groupStatistics = model
                }
                if let value = dict["OrganizationalUnitStatistics"] as? [String: Any?] {
                    var model = ListSynchronizationJobsResponseBody.SynchronizationJobs.Result.OrganizationalUnitStatistics()
                    model.fromMap(value)
                    self.organizationalUnitStatistics = model
                }
                if let value = dict["UserStatistics"] as? [String: Any?] {
                    var model = ListSynchronizationJobsResponseBody.SynchronizationJobs.Result.UserStatistics()
                    model.fromMap(value)
                    self.userStatistics = model
                }
            }
        }
        public var description_: String?

        public var direction: String?

        public var endTime: Int64?

        public var result: ListSynchronizationJobsResponseBody.SynchronizationJobs.Result?

        public var startTime: Int64?

        public var status: String?

        public var synchronizationJobId: String?

        public var targetId: String?

        public var targetType: String?

        public var triggerType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.result?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.direction != nil {
                map["Direction"] = self.direction!
            }
            if self.endTime != nil {
                map["EndTime"] = self.endTime!
            }
            if self.result != nil {
                map["Result"] = self.result?.toMap()
            }
            if self.startTime != nil {
                map["StartTime"] = self.startTime!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.synchronizationJobId != nil {
                map["SynchronizationJobId"] = self.synchronizationJobId!
            }
            if self.targetId != nil {
                map["TargetId"] = self.targetId!
            }
            if self.targetType != nil {
                map["TargetType"] = self.targetType!
            }
            if self.triggerType != nil {
                map["TriggerType"] = self.triggerType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Description"] as? String {
                self.description_ = value
            }
            if let value = dict["Direction"] as? String {
                self.direction = value
            }
            if let value = dict["EndTime"] as? Int64 {
                self.endTime = value
            }
            if let value = dict["Result"] as? [String: Any?] {
                var model = ListSynchronizationJobsResponseBody.SynchronizationJobs.Result()
                model.fromMap(value)
                self.result = model
            }
            if let value = dict["StartTime"] as? Int64 {
                self.startTime = value
            }
            if let value = dict["Status"] as? String {
                self.status = value
            }
            if let value = dict["SynchronizationJobId"] as? String {
                self.synchronizationJobId = value
            }
            if let value = dict["TargetId"] as? String {
                self.targetId = value
            }
            if let value = dict["TargetType"] as? String {
                self.targetType = value
            }
            if let value = dict["TriggerType"] as? String {
                self.triggerType = value
            }
        }
    }
    public var nextToken: String?

    public var requestId: String?

    public var synchronizationJobs: [ListSynchronizationJobsResponseBody.SynchronizationJobs]?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.synchronizationJobs != nil {
            var tmp : [Any] = []
            for k in self.synchronizationJobs! {
                tmp.append(k.toMap())
            }
            map["SynchronizationJobs"] = tmp
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["SynchronizationJobs"] as? [Any?] {
            var tmp : [ListSynchronizationJobsResponseBody.SynchronizationJobs] = []
            for v in value {
                if v != nil {
                    var model = ListSynchronizationJobsResponseBody.SynchronizationJobs()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.synchronizationJobs = tmp
        }
        if let value = dict["TotalCount"] as? Int64 {
            self.totalCount = value
        }
    }
}

public class ListSynchronizationJobsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListSynchronizationJobsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListSynchronizationJobsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListUsersRequest : Tea.TeaModel {
    public var displayNameStartsWith: String?

    public var email: String?

    public var instanceId: String?

    public var organizationalUnitId: String?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var phoneNumber: String?

    public var phoneRegion: String?

    public var status: String?

    public var userExternalId: String?

    public var userIds: [String]?

    public var userSourceId: String?

    public var userSourceType: String?

    public var usernameStartsWith: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.displayNameStartsWith != nil {
            map["DisplayNameStartsWith"] = self.displayNameStartsWith!
        }
        if self.email != nil {
            map["Email"] = self.email!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.organizationalUnitId != nil {
            map["OrganizationalUnitId"] = self.organizationalUnitId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.phoneNumber != nil {
            map["PhoneNumber"] = self.phoneNumber!
        }
        if self.phoneRegion != nil {
            map["PhoneRegion"] = self.phoneRegion!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.userExternalId != nil {
            map["UserExternalId"] = self.userExternalId!
        }
        if self.userIds != nil {
            map["UserIds"] = self.userIds!
        }
        if self.userSourceId != nil {
            map["UserSourceId"] = self.userSourceId!
        }
        if self.userSourceType != nil {
            map["UserSourceType"] = self.userSourceType!
        }
        if self.usernameStartsWith != nil {
            map["UsernameStartsWith"] = self.usernameStartsWith!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DisplayNameStartsWith"] as? String {
            self.displayNameStartsWith = value
        }
        if let value = dict["Email"] as? String {
            self.email = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["OrganizationalUnitId"] as? String {
            self.organizationalUnitId = value
        }
        if let value = dict["PageNumber"] as? Int64 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int64 {
            self.pageSize = value
        }
        if let value = dict["PhoneNumber"] as? String {
            self.phoneNumber = value
        }
        if let value = dict["PhoneRegion"] as? String {
            self.phoneRegion = value
        }
        if let value = dict["Status"] as? String {
            self.status = value
        }
        if let value = dict["UserExternalId"] as? String {
            self.userExternalId = value
        }
        if let value = dict["UserIds"] as? [String] {
            self.userIds = value
        }
        if let value = dict["UserSourceId"] as? String {
            self.userSourceId = value
        }
        if let value = dict["UserSourceType"] as? String {
            self.userSourceType = value
        }
        if let value = dict["UsernameStartsWith"] as? String {
            self.usernameStartsWith = value
        }
    }
}

public class ListUsersResponseBody : Tea.TeaModel {
    public class Users : Tea.TeaModel {
        public var accountExpireTime: Int64?

        public var createTime: Int64?

        public var description_: String?

        public var displayName: String?

        public var email: String?

        public var emailVerified: Bool?

        public var instanceId: String?

        public var lockExpireTime: Int64?

        public var passwordExpireTime: Int64?

        public var passwordSet: Bool?

        public var phoneNumber: String?

        public var phoneNumberVerified: Bool?

        public var phoneRegion: String?

        public var registerTime: Int64?

        public var status: String?

        public var updateTime: Int64?

        public var userExternalId: String?

        public var userId: String?

        public var userSourceId: String?

        public var userSourceType: String?

        public var username: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountExpireTime != nil {
                map["AccountExpireTime"] = self.accountExpireTime!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.displayName != nil {
                map["DisplayName"] = self.displayName!
            }
            if self.email != nil {
                map["Email"] = self.email!
            }
            if self.emailVerified != nil {
                map["EmailVerified"] = self.emailVerified!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.lockExpireTime != nil {
                map["LockExpireTime"] = self.lockExpireTime!
            }
            if self.passwordExpireTime != nil {
                map["PasswordExpireTime"] = self.passwordExpireTime!
            }
            if self.passwordSet != nil {
                map["PasswordSet"] = self.passwordSet!
            }
            if self.phoneNumber != nil {
                map["PhoneNumber"] = self.phoneNumber!
            }
            if self.phoneNumberVerified != nil {
                map["PhoneNumberVerified"] = self.phoneNumberVerified!
            }
            if self.phoneRegion != nil {
                map["PhoneRegion"] = self.phoneRegion!
            }
            if self.registerTime != nil {
                map["RegisterTime"] = self.registerTime!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.updateTime != nil {
                map["UpdateTime"] = self.updateTime!
            }
            if self.userExternalId != nil {
                map["UserExternalId"] = self.userExternalId!
            }
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            if self.userSourceId != nil {
                map["UserSourceId"] = self.userSourceId!
            }
            if self.userSourceType != nil {
                map["UserSourceType"] = self.userSourceType!
            }
            if self.username != nil {
                map["Username"] = self.username!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AccountExpireTime"] as? Int64 {
                self.accountExpireTime = value
            }
            if let value = dict["CreateTime"] as? Int64 {
                self.createTime = value
            }
            if let value = dict["Description"] as? String {
                self.description_ = value
            }
            if let value = dict["DisplayName"] as? String {
                self.displayName = value
            }
            if let value = dict["Email"] as? String {
                self.email = value
            }
            if let value = dict["EmailVerified"] as? Bool {
                self.emailVerified = value
            }
            if let value = dict["InstanceId"] as? String {
                self.instanceId = value
            }
            if let value = dict["LockExpireTime"] as? Int64 {
                self.lockExpireTime = value
            }
            if let value = dict["PasswordExpireTime"] as? Int64 {
                self.passwordExpireTime = value
            }
            if let value = dict["PasswordSet"] as? Bool {
                self.passwordSet = value
            }
            if let value = dict["PhoneNumber"] as? String {
                self.phoneNumber = value
            }
            if let value = dict["PhoneNumberVerified"] as? Bool {
                self.phoneNumberVerified = value
            }
            if let value = dict["PhoneRegion"] as? String {
                self.phoneRegion = value
            }
            if let value = dict["RegisterTime"] as? Int64 {
                self.registerTime = value
            }
            if let value = dict["Status"] as? String {
                self.status = value
            }
            if let value = dict["UpdateTime"] as? Int64 {
                self.updateTime = value
            }
            if let value = dict["UserExternalId"] as? String {
                self.userExternalId = value
            }
            if let value = dict["UserId"] as? String {
                self.userId = value
            }
            if let value = dict["UserSourceId"] as? String {
                self.userSourceId = value
            }
            if let value = dict["UserSourceType"] as? String {
                self.userSourceType = value
            }
            if let value = dict["Username"] as? String {
                self.username = value
            }
        }
    }
    public var requestId: String?

    public var totalCount: Int64?

    public var users: [ListUsersResponseBody.Users]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        if self.users != nil {
            var tmp : [Any] = []
            for k in self.users! {
                tmp.append(k.toMap())
            }
            map["Users"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? Int64 {
            self.totalCount = value
        }
        if let value = dict["Users"] as? [Any?] {
            var tmp : [ListUsersResponseBody.Users] = []
            for v in value {
                if v != nil {
                    var model = ListUsersResponseBody.Users()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.users = tmp
        }
    }
}

public class ListUsersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListUsersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListUsersResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListUsersForApplicationRequest : Tea.TeaModel {
    public var applicationId: String?

    public var instanceId: String?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var userIds: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.applicationId != nil {
            map["ApplicationId"] = self.applicationId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.userIds != nil {
            map["UserIds"] = self.userIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ApplicationId"] as? String {
            self.applicationId = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["PageNumber"] as? Int64 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int64 {
            self.pageSize = value
        }
        if let value = dict["UserIds"] as? [String] {
            self.userIds = value
        }
    }
}

public class ListUsersForApplicationResponseBody : Tea.TeaModel {
    public class Users : Tea.TeaModel {
        public var userId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["UserId"] as? String {
                self.userId = value
            }
        }
    }
    public var requestId: String?

    public var totalCount: Int64?

    public var users: [ListUsersForApplicationResponseBody.Users]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        if self.users != nil {
            var tmp : [Any] = []
            for k in self.users! {
                tmp.append(k.toMap())
            }
            map["Users"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? Int64 {
            self.totalCount = value
        }
        if let value = dict["Users"] as? [Any?] {
            var tmp : [ListUsersForApplicationResponseBody.Users] = []
            for v in value {
                if v != nil {
                    var model = ListUsersForApplicationResponseBody.Users()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.users = tmp
        }
    }
}

public class ListUsersForApplicationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListUsersForApplicationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListUsersForApplicationResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListUsersForGroupRequest : Tea.TeaModel {
    public var groupId: String?

    public var instanceId: String?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var userIds: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.userIds != nil {
            map["UserIds"] = self.userIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["GroupId"] as? String {
            self.groupId = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["PageNumber"] as? Int64 {
            self.pageNumber = value
        }
        if let value = dict["PageSize"] as? Int64 {
            self.pageSize = value
        }
        if let value = dict["UserIds"] as? [String] {
            self.userIds = value
        }
    }
}

public class ListUsersForGroupResponseBody : Tea.TeaModel {
    public class Users : Tea.TeaModel {
        public var groupMemberRelationSourceId: String?

        public var groupMemberRelationSourceType: String?

        public var userId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.groupMemberRelationSourceId != nil {
                map["GroupMemberRelationSourceId"] = self.groupMemberRelationSourceId!
            }
            if self.groupMemberRelationSourceType != nil {
                map["GroupMemberRelationSourceType"] = self.groupMemberRelationSourceType!
            }
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["GroupMemberRelationSourceId"] as? String {
                self.groupMemberRelationSourceId = value
            }
            if let value = dict["GroupMemberRelationSourceType"] as? String {
                self.groupMemberRelationSourceType = value
            }
            if let value = dict["UserId"] as? String {
                self.userId = value
            }
        }
    }
    public var requestId: String?

    public var totalCount: Int64?

    public var users: [ListUsersForGroupResponseBody.Users]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        if self.users != nil {
            var tmp : [Any] = []
            for k in self.users! {
                tmp.append(k.toMap())
            }
            map["Users"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TotalCount"] as? Int64 {
            self.totalCount = value
        }
        if let value = dict["Users"] as? [Any?] {
            var tmp : [ListUsersForGroupResponseBody.Users] = []
            for v in value {
                if v != nil {
                    var model = ListUsersForGroupResponseBody.Users()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.users = tmp
        }
    }
}

public class ListUsersForGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListUsersForGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListUsersForGroupResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ObtainApplicationClientSecretRequest : Tea.TeaModel {
    public var applicationId: String?

    public var instanceId: String?

    public var secretId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.applicationId != nil {
            map["ApplicationId"] = self.applicationId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.secretId != nil {
            map["SecretId"] = self.secretId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ApplicationId"] as? String {
            self.applicationId = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["SecretId"] as? String {
            self.secretId = value
        }
    }
}

public class ObtainApplicationClientSecretResponseBody : Tea.TeaModel {
    public class ApplicationClientSecret : Tea.TeaModel {
        public var applicationId: String?

        public var clientId: String?

        public var clientSecret: String?

        public var instanceId: String?

        public var lastUsedTime: Int64?

        public var secretId: String?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.applicationId != nil {
                map["ApplicationId"] = self.applicationId!
            }
            if self.clientId != nil {
                map["ClientId"] = self.clientId!
            }
            if self.clientSecret != nil {
                map["ClientSecret"] = self.clientSecret!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.lastUsedTime != nil {
                map["LastUsedTime"] = self.lastUsedTime!
            }
            if self.secretId != nil {
                map["SecretId"] = self.secretId!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ApplicationId"] as? String {
                self.applicationId = value
            }
            if let value = dict["ClientId"] as? String {
                self.clientId = value
            }
            if let value = dict["ClientSecret"] as? String {
                self.clientSecret = value
            }
            if let value = dict["InstanceId"] as? String {
                self.instanceId = value
            }
            if let value = dict["LastUsedTime"] as? Int64 {
                self.lastUsedTime = value
            }
            if let value = dict["SecretId"] as? String {
                self.secretId = value
            }
            if let value = dict["Status"] as? String {
                self.status = value
            }
        }
    }
    public var applicationClientSecret: ObtainApplicationClientSecretResponseBody.ApplicationClientSecret?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.applicationClientSecret?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.applicationClientSecret != nil {
            map["ApplicationClientSecret"] = self.applicationClientSecret?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ApplicationClientSecret"] as? [String: Any?] {
            var model = ObtainApplicationClientSecretResponseBody.ApplicationClientSecret()
            model.fromMap(value)
            self.applicationClientSecret = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ObtainApplicationClientSecretResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ObtainApplicationClientSecretResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ObtainApplicationClientSecretResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ObtainDomainProxyTokenRequest : Tea.TeaModel {
    public var domainId: String?

    public var domainProxyTokenId: String?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainId != nil {
            map["DomainId"] = self.domainId!
        }
        if self.domainProxyTokenId != nil {
            map["DomainProxyTokenId"] = self.domainProxyTokenId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DomainId"] as? String {
            self.domainId = value
        }
        if let value = dict["DomainProxyTokenId"] as? String {
            self.domainProxyTokenId = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
    }
}

public class ObtainDomainProxyTokenResponseBody : Tea.TeaModel {
    public class DomainProxyToken : Tea.TeaModel {
        public var createTime: Int64?

        public var domainId: String?

        public var domainProxyToken: String?

        public var domainProxyTokenId: String?

        public var instanceId: String?

        public var lastUsedTime: Int64?

        public var status: String?

        public var updateTime: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.domainId != nil {
                map["DomainId"] = self.domainId!
            }
            if self.domainProxyToken != nil {
                map["DomainProxyToken"] = self.domainProxyToken!
            }
            if self.domainProxyTokenId != nil {
                map["DomainProxyTokenId"] = self.domainProxyTokenId!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.lastUsedTime != nil {
                map["LastUsedTime"] = self.lastUsedTime!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.updateTime != nil {
                map["UpdateTime"] = self.updateTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["CreateTime"] as? Int64 {
                self.createTime = value
            }
            if let value = dict["DomainId"] as? String {
                self.domainId = value
            }
            if let value = dict["DomainProxyToken"] as? String {
                self.domainProxyToken = value
            }
            if let value = dict["DomainProxyTokenId"] as? String {
                self.domainProxyTokenId = value
            }
            if let value = dict["InstanceId"] as? String {
                self.instanceId = value
            }
            if let value = dict["LastUsedTime"] as? Int64 {
                self.lastUsedTime = value
            }
            if let value = dict["Status"] as? String {
                self.status = value
            }
            if let value = dict["UpdateTime"] as? Int64 {
                self.updateTime = value
            }
        }
    }
    public var domainProxyToken: ObtainDomainProxyTokenResponseBody.DomainProxyToken?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.domainProxyToken?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainProxyToken != nil {
            map["DomainProxyToken"] = self.domainProxyToken?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DomainProxyToken"] as? [String: Any?] {
            var model = ObtainDomainProxyTokenResponseBody.DomainProxyToken()
            model.fromMap(value)
            self.domainProxyToken = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class ObtainDomainProxyTokenResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ObtainDomainProxyTokenResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ObtainDomainProxyTokenResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class RemoveUserFromOrganizationalUnitsRequest : Tea.TeaModel {
    public var instanceId: String?

    public var organizationalUnitIds: [String]?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.organizationalUnitIds != nil {
            map["OrganizationalUnitIds"] = self.organizationalUnitIds!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["OrganizationalUnitIds"] as? [String] {
            self.organizationalUnitIds = value
        }
        if let value = dict["UserId"] as? String {
            self.userId = value
        }
    }
}

public class RemoveUserFromOrganizationalUnitsResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class RemoveUserFromOrganizationalUnitsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RemoveUserFromOrganizationalUnitsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = RemoveUserFromOrganizationalUnitsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class RemoveUsersFromGroupRequest : Tea.TeaModel {
    public var groupId: String?

    public var instanceId: String?

    public var userIds: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.userIds != nil {
            map["UserIds"] = self.userIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["GroupId"] as? String {
            self.groupId = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["UserIds"] as? [String] {
            self.userIds = value
        }
    }
}

public class RemoveUsersFromGroupResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class RemoveUsersFromGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RemoveUsersFromGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = RemoveUsersFromGroupResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class RevokeApplicationFromGroupsRequest : Tea.TeaModel {
    public var applicationId: String?

    public var groupIds: [String]?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.applicationId != nil {
            map["ApplicationId"] = self.applicationId!
        }
        if self.groupIds != nil {
            map["GroupIds"] = self.groupIds!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ApplicationId"] as? String {
            self.applicationId = value
        }
        if let value = dict["GroupIds"] as? [String] {
            self.groupIds = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
    }
}

public class RevokeApplicationFromGroupsResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class RevokeApplicationFromGroupsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RevokeApplicationFromGroupsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = RevokeApplicationFromGroupsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class RevokeApplicationFromOrganizationalUnitsRequest : Tea.TeaModel {
    public var applicationId: String?

    public var instanceId: String?

    public var organizationalUnitIds: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.applicationId != nil {
            map["ApplicationId"] = self.applicationId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.organizationalUnitIds != nil {
            map["OrganizationalUnitIds"] = self.organizationalUnitIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ApplicationId"] as? String {
            self.applicationId = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["OrganizationalUnitIds"] as? [String] {
            self.organizationalUnitIds = value
        }
    }
}

public class RevokeApplicationFromOrganizationalUnitsResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class RevokeApplicationFromOrganizationalUnitsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RevokeApplicationFromOrganizationalUnitsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = RevokeApplicationFromOrganizationalUnitsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class RevokeApplicationFromUsersRequest : Tea.TeaModel {
    public var applicationId: String?

    public var instanceId: String?

    public var userIds: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.applicationId != nil {
            map["ApplicationId"] = self.applicationId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.userIds != nil {
            map["UserIds"] = self.userIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ApplicationId"] as? String {
            self.applicationId = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["UserIds"] as? [String] {
            self.userIds = value
        }
    }
}

public class RevokeApplicationFromUsersResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class RevokeApplicationFromUsersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RevokeApplicationFromUsersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = RevokeApplicationFromUsersResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class RunSynchronizationJobRequest : Tea.TeaModel {
    public class SynchronizationScopeConfig : Tea.TeaModel {
        public var groupIds: [String]?

        public var organizationalUnitIds: [String]?

        public var userIds: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.groupIds != nil {
                map["GroupIds"] = self.groupIds!
            }
            if self.organizationalUnitIds != nil {
                map["OrganizationalUnitIds"] = self.organizationalUnitIds!
            }
            if self.userIds != nil {
                map["UserIds"] = self.userIds!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["GroupIds"] as? [String] {
                self.groupIds = value
            }
            if let value = dict["OrganizationalUnitIds"] as? [String] {
                self.organizationalUnitIds = value
            }
            if let value = dict["UserIds"] as? [String] {
                self.userIds = value
            }
        }
    }
    public var description_: String?

    public var instanceId: String?

    public var passwordInitialization: Bool?

    public var synchronizationScopeConfig: RunSynchronizationJobRequest.SynchronizationScopeConfig?

    public var targetId: String?

    public var targetType: String?

    public var userIdentityTypes: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.synchronizationScopeConfig?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.passwordInitialization != nil {
            map["PasswordInitialization"] = self.passwordInitialization!
        }
        if self.synchronizationScopeConfig != nil {
            map["SynchronizationScopeConfig"] = self.synchronizationScopeConfig?.toMap()
        }
        if self.targetId != nil {
            map["TargetId"] = self.targetId!
        }
        if self.targetType != nil {
            map["TargetType"] = self.targetType!
        }
        if self.userIdentityTypes != nil {
            map["UserIdentityTypes"] = self.userIdentityTypes!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["PasswordInitialization"] as? Bool {
            self.passwordInitialization = value
        }
        if let value = dict["SynchronizationScopeConfig"] as? [String: Any?] {
            var model = RunSynchronizationJobRequest.SynchronizationScopeConfig()
            model.fromMap(value)
            self.synchronizationScopeConfig = model
        }
        if let value = dict["TargetId"] as? String {
            self.targetId = value
        }
        if let value = dict["TargetType"] as? String {
            self.targetType = value
        }
        if let value = dict["UserIdentityTypes"] as? [String] {
            self.userIdentityTypes = value
        }
    }
}

public class RunSynchronizationJobResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var synchronizationJobId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.synchronizationJobId != nil {
            map["SynchronizationJobId"] = self.synchronizationJobId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["SynchronizationJobId"] as? String {
            self.synchronizationJobId = value
        }
    }
}

public class RunSynchronizationJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RunSynchronizationJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = RunSynchronizationJobResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class SetApplicationGrantScopeRequest : Tea.TeaModel {
    public var applicationId: String?

    public var grantScopes: [String]?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.applicationId != nil {
            map["ApplicationId"] = self.applicationId!
        }
        if self.grantScopes != nil {
            map["GrantScopes"] = self.grantScopes!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ApplicationId"] as? String {
            self.applicationId = value
        }
        if let value = dict["GrantScopes"] as? [String] {
            self.grantScopes = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
    }
}

public class SetApplicationGrantScopeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class SetApplicationGrantScopeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SetApplicationGrantScopeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = SetApplicationGrantScopeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class SetApplicationProvisioningConfigRequest : Tea.TeaModel {
    public class CallbackProvisioningConfig : Tea.TeaModel {
        public var callbackUrl: String?

        public var encryptKey: String?

        public var encryptRequired: Bool?

        public var listenEventScopes: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.callbackUrl != nil {
                map["CallbackUrl"] = self.callbackUrl!
            }
            if self.encryptKey != nil {
                map["EncryptKey"] = self.encryptKey!
            }
            if self.encryptRequired != nil {
                map["EncryptRequired"] = self.encryptRequired!
            }
            if self.listenEventScopes != nil {
                map["ListenEventScopes"] = self.listenEventScopes!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["CallbackUrl"] as? String {
                self.callbackUrl = value
            }
            if let value = dict["EncryptKey"] as? String {
                self.encryptKey = value
            }
            if let value = dict["EncryptRequired"] as? Bool {
                self.encryptRequired = value
            }
            if let value = dict["ListenEventScopes"] as? [String] {
                self.listenEventScopes = value
            }
        }
    }
    public class ScimProvisioningConfig : Tea.TeaModel {
        public class AuthnConfiguration : Tea.TeaModel {
            public class AuthnParam : Tea.TeaModel {
                public var accessToken: String?

                public var authnMethod: String?

                public var clientId: String?

                public var clientSecret: String?

                public var tokenEndpoint: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.accessToken != nil {
                        map["AccessToken"] = self.accessToken!
                    }
                    if self.authnMethod != nil {
                        map["AuthnMethod"] = self.authnMethod!
                    }
                    if self.clientId != nil {
                        map["ClientId"] = self.clientId!
                    }
                    if self.clientSecret != nil {
                        map["ClientSecret"] = self.clientSecret!
                    }
                    if self.tokenEndpoint != nil {
                        map["TokenEndpoint"] = self.tokenEndpoint!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["AccessToken"] as? String {
                        self.accessToken = value
                    }
                    if let value = dict["AuthnMethod"] as? String {
                        self.authnMethod = value
                    }
                    if let value = dict["ClientId"] as? String {
                        self.clientId = value
                    }
                    if let value = dict["ClientSecret"] as? String {
                        self.clientSecret = value
                    }
                    if let value = dict["TokenEndpoint"] as? String {
                        self.tokenEndpoint = value
                    }
                }
            }
            public var authnMode: String?

            public var authnParam: SetApplicationProvisioningConfigRequest.ScimProvisioningConfig.AuthnConfiguration.AuthnParam?

            public var grantType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.authnParam?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.authnMode != nil {
                    map["AuthnMode"] = self.authnMode!
                }
                if self.authnParam != nil {
                    map["AuthnParam"] = self.authnParam?.toMap()
                }
                if self.grantType != nil {
                    map["GrantType"] = self.grantType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AuthnMode"] as? String {
                    self.authnMode = value
                }
                if let value = dict["AuthnParam"] as? [String: Any?] {
                    var model = SetApplicationProvisioningConfigRequest.ScimProvisioningConfig.AuthnConfiguration.AuthnParam()
                    model.fromMap(value)
                    self.authnParam = model
                }
                if let value = dict["GrantType"] as? String {
                    self.grantType = value
                }
            }
        }
        public var authnConfiguration: SetApplicationProvisioningConfigRequest.ScimProvisioningConfig.AuthnConfiguration?

        public var fullPushScopes: [String]?

        public var provisioningActions: [String]?

        public var scimBaseUrl: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.authnConfiguration?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.authnConfiguration != nil {
                map["AuthnConfiguration"] = self.authnConfiguration?.toMap()
            }
            if self.fullPushScopes != nil {
                map["FullPushScopes"] = self.fullPushScopes!
            }
            if self.provisioningActions != nil {
                map["ProvisioningActions"] = self.provisioningActions!
            }
            if self.scimBaseUrl != nil {
                map["ScimBaseUrl"] = self.scimBaseUrl!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AuthnConfiguration"] as? [String: Any?] {
                var model = SetApplicationProvisioningConfigRequest.ScimProvisioningConfig.AuthnConfiguration()
                model.fromMap(value)
                self.authnConfiguration = model
            }
            if let value = dict["FullPushScopes"] as? [String] {
                self.fullPushScopes = value
            }
            if let value = dict["ProvisioningActions"] as? [String] {
                self.provisioningActions = value
            }
            if let value = dict["ScimBaseUrl"] as? String {
                self.scimBaseUrl = value
            }
        }
    }
    public var applicationId: String?

    public var callbackProvisioningConfig: SetApplicationProvisioningConfigRequest.CallbackProvisioningConfig?

    public var instanceId: String?

    public var networkAccessEndpointId: String?

    public var provisionPassword: Bool?

    public var provisionProtocolType: String?

    public var scimProvisioningConfig: SetApplicationProvisioningConfigRequest.ScimProvisioningConfig?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.callbackProvisioningConfig?.validate()
        try self.scimProvisioningConfig?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.applicationId != nil {
            map["ApplicationId"] = self.applicationId!
        }
        if self.callbackProvisioningConfig != nil {
            map["CallbackProvisioningConfig"] = self.callbackProvisioningConfig?.toMap()
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.networkAccessEndpointId != nil {
            map["NetworkAccessEndpointId"] = self.networkAccessEndpointId!
        }
        if self.provisionPassword != nil {
            map["ProvisionPassword"] = self.provisionPassword!
        }
        if self.provisionProtocolType != nil {
            map["ProvisionProtocolType"] = self.provisionProtocolType!
        }
        if self.scimProvisioningConfig != nil {
            map["ScimProvisioningConfig"] = self.scimProvisioningConfig?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ApplicationId"] as? String {
            self.applicationId = value
        }
        if let value = dict["CallbackProvisioningConfig"] as? [String: Any?] {
            var model = SetApplicationProvisioningConfigRequest.CallbackProvisioningConfig()
            model.fromMap(value)
            self.callbackProvisioningConfig = model
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["NetworkAccessEndpointId"] as? String {
            self.networkAccessEndpointId = value
        }
        if let value = dict["ProvisionPassword"] as? Bool {
            self.provisionPassword = value
        }
        if let value = dict["ProvisionProtocolType"] as? String {
            self.provisionProtocolType = value
        }
        if let value = dict["ScimProvisioningConfig"] as? [String: Any?] {
            var model = SetApplicationProvisioningConfigRequest.ScimProvisioningConfig()
            model.fromMap(value)
            self.scimProvisioningConfig = model
        }
    }
}

public class SetApplicationProvisioningConfigResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class SetApplicationProvisioningConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SetApplicationProvisioningConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = SetApplicationProvisioningConfigResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class SetApplicationProvisioningScopeRequest : Tea.TeaModel {
    public var applicationId: String?

    public var groupIds: [String]?

    public var instanceId: String?

    public var organizationalUnitIds: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.applicationId != nil {
            map["ApplicationId"] = self.applicationId!
        }
        if self.groupIds != nil {
            map["GroupIds"] = self.groupIds!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.organizationalUnitIds != nil {
            map["OrganizationalUnitIds"] = self.organizationalUnitIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ApplicationId"] as? String {
            self.applicationId = value
        }
        if let value = dict["GroupIds"] as? [String] {
            self.groupIds = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["OrganizationalUnitIds"] as? [String] {
            self.organizationalUnitIds = value
        }
    }
}

public class SetApplicationProvisioningScopeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class SetApplicationProvisioningScopeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SetApplicationProvisioningScopeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = SetApplicationProvisioningScopeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class SetApplicationSsoConfigRequest : Tea.TeaModel {
    public class OidcSsoConfig : Tea.TeaModel {
        public class CustomClaims : Tea.TeaModel {
            public var claimName: String?

            public var claimValueExpression: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.claimName != nil {
                    map["ClaimName"] = self.claimName!
                }
                if self.claimValueExpression != nil {
                    map["ClaimValueExpression"] = self.claimValueExpression!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ClaimName"] as? String {
                    self.claimName = value
                }
                if let value = dict["ClaimValueExpression"] as? String {
                    self.claimValueExpression = value
                }
            }
        }
        public var accessTokenEffectiveTime: Int64?

        public var codeEffectiveTime: Int64?

        public var customClaims: [SetApplicationSsoConfigRequest.OidcSsoConfig.CustomClaims]?

        public var grantScopes: [String]?

        public var grantTypes: [String]?

        public var idTokenEffectiveTime: Int64?

        public var passwordAuthenticationSourceId: String?

        public var passwordTotpMfaRequired: Bool?

        public var pkceChallengeMethods: [String]?

        public var pkceRequired: Bool?

        public var postLogoutRedirectUris: [String]?

        public var redirectUris: [String]?

        public var refreshTokenEffective: Int64?

        public var responseTypes: [String]?

        public var subjectIdExpression: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accessTokenEffectiveTime != nil {
                map["AccessTokenEffectiveTime"] = self.accessTokenEffectiveTime!
            }
            if self.codeEffectiveTime != nil {
                map["CodeEffectiveTime"] = self.codeEffectiveTime!
            }
            if self.customClaims != nil {
                var tmp : [Any] = []
                for k in self.customClaims! {
                    tmp.append(k.toMap())
                }
                map["CustomClaims"] = tmp
            }
            if self.grantScopes != nil {
                map["GrantScopes"] = self.grantScopes!
            }
            if self.grantTypes != nil {
                map["GrantTypes"] = self.grantTypes!
            }
            if self.idTokenEffectiveTime != nil {
                map["IdTokenEffectiveTime"] = self.idTokenEffectiveTime!
            }
            if self.passwordAuthenticationSourceId != nil {
                map["PasswordAuthenticationSourceId"] = self.passwordAuthenticationSourceId!
            }
            if self.passwordTotpMfaRequired != nil {
                map["PasswordTotpMfaRequired"] = self.passwordTotpMfaRequired!
            }
            if self.pkceChallengeMethods != nil {
                map["PkceChallengeMethods"] = self.pkceChallengeMethods!
            }
            if self.pkceRequired != nil {
                map["PkceRequired"] = self.pkceRequired!
            }
            if self.postLogoutRedirectUris != nil {
                map["PostLogoutRedirectUris"] = self.postLogoutRedirectUris!
            }
            if self.redirectUris != nil {
                map["RedirectUris"] = self.redirectUris!
            }
            if self.refreshTokenEffective != nil {
                map["RefreshTokenEffective"] = self.refreshTokenEffective!
            }
            if self.responseTypes != nil {
                map["ResponseTypes"] = self.responseTypes!
            }
            if self.subjectIdExpression != nil {
                map["SubjectIdExpression"] = self.subjectIdExpression!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AccessTokenEffectiveTime"] as? Int64 {
                self.accessTokenEffectiveTime = value
            }
            if let value = dict["CodeEffectiveTime"] as? Int64 {
                self.codeEffectiveTime = value
            }
            if let value = dict["CustomClaims"] as? [Any?] {
                var tmp : [SetApplicationSsoConfigRequest.OidcSsoConfig.CustomClaims] = []
                for v in value {
                    if v != nil {
                        var model = SetApplicationSsoConfigRequest.OidcSsoConfig.CustomClaims()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.customClaims = tmp
            }
            if let value = dict["GrantScopes"] as? [String] {
                self.grantScopes = value
            }
            if let value = dict["GrantTypes"] as? [String] {
                self.grantTypes = value
            }
            if let value = dict["IdTokenEffectiveTime"] as? Int64 {
                self.idTokenEffectiveTime = value
            }
            if let value = dict["PasswordAuthenticationSourceId"] as? String {
                self.passwordAuthenticationSourceId = value
            }
            if let value = dict["PasswordTotpMfaRequired"] as? Bool {
                self.passwordTotpMfaRequired = value
            }
            if let value = dict["PkceChallengeMethods"] as? [String] {
                self.pkceChallengeMethods = value
            }
            if let value = dict["PkceRequired"] as? Bool {
                self.pkceRequired = value
            }
            if let value = dict["PostLogoutRedirectUris"] as? [String] {
                self.postLogoutRedirectUris = value
            }
            if let value = dict["RedirectUris"] as? [String] {
                self.redirectUris = value
            }
            if let value = dict["RefreshTokenEffective"] as? Int64 {
                self.refreshTokenEffective = value
            }
            if let value = dict["ResponseTypes"] as? [String] {
                self.responseTypes = value
            }
            if let value = dict["SubjectIdExpression"] as? String {
                self.subjectIdExpression = value
            }
        }
    }
    public class SamlSsoConfig : Tea.TeaModel {
        public class AttributeStatements : Tea.TeaModel {
            public var attributeName: String?

            public var attributeValueExpression: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.attributeName != nil {
                    map["AttributeName"] = self.attributeName!
                }
                if self.attributeValueExpression != nil {
                    map["AttributeValueExpression"] = self.attributeValueExpression!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AttributeName"] as? String {
                    self.attributeName = value
                }
                if let value = dict["AttributeValueExpression"] as? String {
                    self.attributeValueExpression = value
                }
            }
        }
        public class OptionalRelayStates : Tea.TeaModel {
            public var displayName: String?

            public var relayState: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.displayName != nil {
                    map["DisplayName"] = self.displayName!
                }
                if self.relayState != nil {
                    map["RelayState"] = self.relayState!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["DisplayName"] as? String {
                    self.displayName = value
                }
                if let value = dict["RelayState"] as? String {
                    self.relayState = value
                }
            }
        }
        public var assertionSigned: Bool?

        public var attributeStatements: [SetApplicationSsoConfigRequest.SamlSsoConfig.AttributeStatements]?

        public var defaultRelayState: String?

        public var idPEntityId: String?

        public var nameIdFormat: String?

        public var nameIdValueExpression: String?

        public var optionalRelayStates: [SetApplicationSsoConfigRequest.SamlSsoConfig.OptionalRelayStates]?

        public var responseSigned: Bool?

        public var signatureAlgorithm: String?

        public var spEntityId: String?

        public var spSsoAcsUrl: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.assertionSigned != nil {
                map["AssertionSigned"] = self.assertionSigned!
            }
            if self.attributeStatements != nil {
                var tmp : [Any] = []
                for k in self.attributeStatements! {
                    tmp.append(k.toMap())
                }
                map["AttributeStatements"] = tmp
            }
            if self.defaultRelayState != nil {
                map["DefaultRelayState"] = self.defaultRelayState!
            }
            if self.idPEntityId != nil {
                map["IdPEntityId"] = self.idPEntityId!
            }
            if self.nameIdFormat != nil {
                map["NameIdFormat"] = self.nameIdFormat!
            }
            if self.nameIdValueExpression != nil {
                map["NameIdValueExpression"] = self.nameIdValueExpression!
            }
            if self.optionalRelayStates != nil {
                var tmp : [Any] = []
                for k in self.optionalRelayStates! {
                    tmp.append(k.toMap())
                }
                map["OptionalRelayStates"] = tmp
            }
            if self.responseSigned != nil {
                map["ResponseSigned"] = self.responseSigned!
            }
            if self.signatureAlgorithm != nil {
                map["SignatureAlgorithm"] = self.signatureAlgorithm!
            }
            if self.spEntityId != nil {
                map["SpEntityId"] = self.spEntityId!
            }
            if self.spSsoAcsUrl != nil {
                map["SpSsoAcsUrl"] = self.spSsoAcsUrl!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AssertionSigned"] as? Bool {
                self.assertionSigned = value
            }
            if let value = dict["AttributeStatements"] as? [Any?] {
                var tmp : [SetApplicationSsoConfigRequest.SamlSsoConfig.AttributeStatements] = []
                for v in value {
                    if v != nil {
                        var model = SetApplicationSsoConfigRequest.SamlSsoConfig.AttributeStatements()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.attributeStatements = tmp
            }
            if let value = dict["DefaultRelayState"] as? String {
                self.defaultRelayState = value
            }
            if let value = dict["IdPEntityId"] as? String {
                self.idPEntityId = value
            }
            if let value = dict["NameIdFormat"] as? String {
                self.nameIdFormat = value
            }
            if let value = dict["NameIdValueExpression"] as? String {
                self.nameIdValueExpression = value
            }
            if let value = dict["OptionalRelayStates"] as? [Any?] {
                var tmp : [SetApplicationSsoConfigRequest.SamlSsoConfig.OptionalRelayStates] = []
                for v in value {
                    if v != nil {
                        var model = SetApplicationSsoConfigRequest.SamlSsoConfig.OptionalRelayStates()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.optionalRelayStates = tmp
            }
            if let value = dict["ResponseSigned"] as? Bool {
                self.responseSigned = value
            }
            if let value = dict["SignatureAlgorithm"] as? String {
                self.signatureAlgorithm = value
            }
            if let value = dict["SpEntityId"] as? String {
                self.spEntityId = value
            }
            if let value = dict["SpSsoAcsUrl"] as? String {
                self.spSsoAcsUrl = value
            }
        }
    }
    public var applicationId: String?

    public var clientToken: String?

    public var initLoginType: String?

    public var initLoginUrl: String?

    public var instanceId: String?

    public var oidcSsoConfig: SetApplicationSsoConfigRequest.OidcSsoConfig?

    public var samlSsoConfig: SetApplicationSsoConfigRequest.SamlSsoConfig?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.oidcSsoConfig?.validate()
        try self.samlSsoConfig?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.applicationId != nil {
            map["ApplicationId"] = self.applicationId!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.initLoginType != nil {
            map["InitLoginType"] = self.initLoginType!
        }
        if self.initLoginUrl != nil {
            map["InitLoginUrl"] = self.initLoginUrl!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.oidcSsoConfig != nil {
            map["OidcSsoConfig"] = self.oidcSsoConfig?.toMap()
        }
        if self.samlSsoConfig != nil {
            map["SamlSsoConfig"] = self.samlSsoConfig?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ApplicationId"] as? String {
            self.applicationId = value
        }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["InitLoginType"] as? String {
            self.initLoginType = value
        }
        if let value = dict["InitLoginUrl"] as? String {
            self.initLoginUrl = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["OidcSsoConfig"] as? [String: Any?] {
            var model = SetApplicationSsoConfigRequest.OidcSsoConfig()
            model.fromMap(value)
            self.oidcSsoConfig = model
        }
        if let value = dict["SamlSsoConfig"] as? [String: Any?] {
            var model = SetApplicationSsoConfigRequest.SamlSsoConfig()
            model.fromMap(value)
            self.samlSsoConfig = model
        }
    }
}

public class SetApplicationSsoConfigResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class SetApplicationSsoConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SetApplicationSsoConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = SetApplicationSsoConfigResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class SetDefaultDomainRequest : Tea.TeaModel {
    public var domainId: String?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.domainId != nil {
            map["DomainId"] = self.domainId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["DomainId"] as? String {
            self.domainId = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
    }
}

public class SetDefaultDomainResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class SetDefaultDomainResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SetDefaultDomainResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = SetDefaultDomainResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class SetForgetPasswordConfigurationRequest : Tea.TeaModel {
    public var authenticationChannels: [String]?

    public var forgetPasswordStatus: String?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.authenticationChannels != nil {
            map["AuthenticationChannels"] = self.authenticationChannels!
        }
        if self.forgetPasswordStatus != nil {
            map["ForgetPasswordStatus"] = self.forgetPasswordStatus!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["AuthenticationChannels"] as? [String] {
            self.authenticationChannels = value
        }
        if let value = dict["ForgetPasswordStatus"] as? String {
            self.forgetPasswordStatus = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
    }
}

public class SetForgetPasswordConfigurationResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class SetForgetPasswordConfigurationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SetForgetPasswordConfigurationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = SetForgetPasswordConfigurationResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class SetIdentityProviderUdPullConfigurationRequest : Tea.TeaModel {
    public class LdapUdPullConfig : Tea.TeaModel {
        public var groupMemberAttributeName: String?

        public var groupObjectClass: String?

        public var groupObjectClassCustomFilter: String?

        public var organizationUnitObjectClass: String?

        public var userObjectClass: String?

        public var userObjectClassCustomFilter: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.groupMemberAttributeName != nil {
                map["GroupMemberAttributeName"] = self.groupMemberAttributeName!
            }
            if self.groupObjectClass != nil {
                map["GroupObjectClass"] = self.groupObjectClass!
            }
            if self.groupObjectClassCustomFilter != nil {
                map["GroupObjectClassCustomFilter"] = self.groupObjectClassCustomFilter!
            }
            if self.organizationUnitObjectClass != nil {
                map["OrganizationUnitObjectClass"] = self.organizationUnitObjectClass!
            }
            if self.userObjectClass != nil {
                map["UserObjectClass"] = self.userObjectClass!
            }
            if self.userObjectClassCustomFilter != nil {
                map["UserObjectClassCustomFilter"] = self.userObjectClassCustomFilter!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["GroupMemberAttributeName"] as? String {
                self.groupMemberAttributeName = value
            }
            if let value = dict["GroupObjectClass"] as? String {
                self.groupObjectClass = value
            }
            if let value = dict["GroupObjectClassCustomFilter"] as? String {
                self.groupObjectClassCustomFilter = value
            }
            if let value = dict["OrganizationUnitObjectClass"] as? String {
                self.organizationUnitObjectClass = value
            }
            if let value = dict["UserObjectClass"] as? String {
                self.userObjectClass = value
            }
            if let value = dict["UserObjectClassCustomFilter"] as? String {
                self.userObjectClassCustomFilter = value
            }
        }
    }
    public class PeriodicSyncConfig : Tea.TeaModel {
        public var periodicSyncCron: String?

        public var periodicSyncTimes: [Int32]?

        public var periodicSyncType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.periodicSyncCron != nil {
                map["PeriodicSyncCron"] = self.periodicSyncCron!
            }
            if self.periodicSyncTimes != nil {
                map["PeriodicSyncTimes"] = self.periodicSyncTimes!
            }
            if self.periodicSyncType != nil {
                map["PeriodicSyncType"] = self.periodicSyncType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["PeriodicSyncCron"] as? String {
                self.periodicSyncCron = value
            }
            if let value = dict["PeriodicSyncTimes"] as? [Int32] {
                self.periodicSyncTimes = value
            }
            if let value = dict["PeriodicSyncType"] as? String {
                self.periodicSyncType = value
            }
        }
    }
    public class PullProtectedRule : Tea.TeaModel {
        public var groupDeletedThreshold: Int32?

        public var organizationalUnitDeletedThreshold: Int32?

        public var userDeletedThreshold: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.groupDeletedThreshold != nil {
                map["GroupDeletedThreshold"] = self.groupDeletedThreshold!
            }
            if self.organizationalUnitDeletedThreshold != nil {
                map["OrganizationalUnitDeletedThreshold"] = self.organizationalUnitDeletedThreshold!
            }
            if self.userDeletedThreshold != nil {
                map["UserDeletedThreshold"] = self.userDeletedThreshold!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["GroupDeletedThreshold"] as? Int32 {
                self.groupDeletedThreshold = value
            }
            if let value = dict["OrganizationalUnitDeletedThreshold"] as? Int32 {
                self.organizationalUnitDeletedThreshold = value
            }
            if let value = dict["UserDeletedThreshold"] as? Int32 {
                self.userDeletedThreshold = value
            }
        }
    }
    public class UdSyncScopeConfig : Tea.TeaModel {
        public var sourceScopes: [String]?

        public var targetScope: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.sourceScopes != nil {
                map["SourceScopes"] = self.sourceScopes!
            }
            if self.targetScope != nil {
                map["TargetScope"] = self.targetScope!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["SourceScopes"] as? [String] {
                self.sourceScopes = value
            }
            if let value = dict["TargetScope"] as? String {
                self.targetScope = value
            }
        }
    }
    public var groupSyncStatus: String?

    public var identityProviderId: String?

    public var incrementalCallbackStatus: String?

    public var instanceId: String?

    public var ldapUdPullConfig: SetIdentityProviderUdPullConfigurationRequest.LdapUdPullConfig?

    public var periodicSyncConfig: SetIdentityProviderUdPullConfigurationRequest.PeriodicSyncConfig?

    public var periodicSyncStatus: String?

    public var pullProtectedRule: SetIdentityProviderUdPullConfigurationRequest.PullProtectedRule?

    public var udSyncScopeConfig: SetIdentityProviderUdPullConfigurationRequest.UdSyncScopeConfig?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.ldapUdPullConfig?.validate()
        try self.periodicSyncConfig?.validate()
        try self.pullProtectedRule?.validate()
        try self.udSyncScopeConfig?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupSyncStatus != nil {
            map["GroupSyncStatus"] = self.groupSyncStatus!
        }
        if self.identityProviderId != nil {
            map["IdentityProviderId"] = self.identityProviderId!
        }
        if self.incrementalCallbackStatus != nil {
            map["IncrementalCallbackStatus"] = self.incrementalCallbackStatus!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.ldapUdPullConfig != nil {
            map["LdapUdPullConfig"] = self.ldapUdPullConfig?.toMap()
        }
        if self.periodicSyncConfig != nil {
            map["PeriodicSyncConfig"] = self.periodicSyncConfig?.toMap()
        }
        if self.periodicSyncStatus != nil {
            map["PeriodicSyncStatus"] = self.periodicSyncStatus!
        }
        if self.pullProtectedRule != nil {
            map["PullProtectedRule"] = self.pullProtectedRule?.toMap()
        }
        if self.udSyncScopeConfig != nil {
            map["UdSyncScopeConfig"] = self.udSyncScopeConfig?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["GroupSyncStatus"] as? String {
            self.groupSyncStatus = value
        }
        if let value = dict["IdentityProviderId"] as? String {
            self.identityProviderId = value
        }
        if let value = dict["IncrementalCallbackStatus"] as? String {
            self.incrementalCallbackStatus = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["LdapUdPullConfig"] as? [String: Any?] {
            var model = SetIdentityProviderUdPullConfigurationRequest.LdapUdPullConfig()
            model.fromMap(value)
            self.ldapUdPullConfig = model
        }
        if let value = dict["PeriodicSyncConfig"] as? [String: Any?] {
            var model = SetIdentityProviderUdPullConfigurationRequest.PeriodicSyncConfig()
            model.fromMap(value)
            self.periodicSyncConfig = model
        }
        if let value = dict["PeriodicSyncStatus"] as? String {
            self.periodicSyncStatus = value
        }
        if let value = dict["PullProtectedRule"] as? [String: Any?] {
            var model = SetIdentityProviderUdPullConfigurationRequest.PullProtectedRule()
            model.fromMap(value)
            self.pullProtectedRule = model
        }
        if let value = dict["UdSyncScopeConfig"] as? [String: Any?] {
            var model = SetIdentityProviderUdPullConfigurationRequest.UdSyncScopeConfig()
            model.fromMap(value)
            self.udSyncScopeConfig = model
        }
    }
}

public class SetIdentityProviderUdPullConfigurationResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class SetIdentityProviderUdPullConfigurationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SetIdentityProviderUdPullConfigurationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = SetIdentityProviderUdPullConfigurationResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class SetPasswordComplexityConfigurationRequest : Tea.TeaModel {
    public class PasswordComplexityRules : Tea.TeaModel {
        public var passwordCheckType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.passwordCheckType != nil {
                map["PasswordCheckType"] = self.passwordCheckType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["PasswordCheckType"] as? String {
                self.passwordCheckType = value
            }
        }
    }
    public var instanceId: String?

    public var passwordComplexityRules: [SetPasswordComplexityConfigurationRequest.PasswordComplexityRules]?

    public var passwordMinLength: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.passwordComplexityRules != nil {
            var tmp : [Any] = []
            for k in self.passwordComplexityRules! {
                tmp.append(k.toMap())
            }
            map["PasswordComplexityRules"] = tmp
        }
        if self.passwordMinLength != nil {
            map["PasswordMinLength"] = self.passwordMinLength!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["PasswordComplexityRules"] as? [Any?] {
            var tmp : [SetPasswordComplexityConfigurationRequest.PasswordComplexityRules] = []
            for v in value {
                if v != nil {
                    var model = SetPasswordComplexityConfigurationRequest.PasswordComplexityRules()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.passwordComplexityRules = tmp
        }
        if let value = dict["PasswordMinLength"] as? Int32 {
            self.passwordMinLength = value
        }
    }
}

public class SetPasswordComplexityConfigurationResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class SetPasswordComplexityConfigurationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SetPasswordComplexityConfigurationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = SetPasswordComplexityConfigurationResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class SetPasswordExpirationConfigurationRequest : Tea.TeaModel {
    public var effectiveAuthenticationSourceIds: [String]?

    public var instanceId: String?

    public var passwordExpirationAction: String?

    public var passwordExpirationNotificationChannels: [String]?

    public var passwordExpirationNotificationDuration: Int32?

    public var passwordExpirationNotificationStatus: String?

    public var passwordExpirationStatus: String?

    public var passwordForcedUpdateDuration: Int32?

    public var passwordValidMaxDay: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.effectiveAuthenticationSourceIds != nil {
            map["EffectiveAuthenticationSourceIds"] = self.effectiveAuthenticationSourceIds!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.passwordExpirationAction != nil {
            map["PasswordExpirationAction"] = self.passwordExpirationAction!
        }
        if self.passwordExpirationNotificationChannels != nil {
            map["PasswordExpirationNotificationChannels"] = self.passwordExpirationNotificationChannels!
        }
        if self.passwordExpirationNotificationDuration != nil {
            map["PasswordExpirationNotificationDuration"] = self.passwordExpirationNotificationDuration!
        }
        if self.passwordExpirationNotificationStatus != nil {
            map["PasswordExpirationNotificationStatus"] = self.passwordExpirationNotificationStatus!
        }
        if self.passwordExpirationStatus != nil {
            map["PasswordExpirationStatus"] = self.passwordExpirationStatus!
        }
        if self.passwordForcedUpdateDuration != nil {
            map["PasswordForcedUpdateDuration"] = self.passwordForcedUpdateDuration!
        }
        if self.passwordValidMaxDay != nil {
            map["PasswordValidMaxDay"] = self.passwordValidMaxDay!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["EffectiveAuthenticationSourceIds"] as? [String] {
            self.effectiveAuthenticationSourceIds = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["PasswordExpirationAction"] as? String {
            self.passwordExpirationAction = value
        }
        if let value = dict["PasswordExpirationNotificationChannels"] as? [String] {
            self.passwordExpirationNotificationChannels = value
        }
        if let value = dict["PasswordExpirationNotificationDuration"] as? Int32 {
            self.passwordExpirationNotificationDuration = value
        }
        if let value = dict["PasswordExpirationNotificationStatus"] as? String {
            self.passwordExpirationNotificationStatus = value
        }
        if let value = dict["PasswordExpirationStatus"] as? String {
            self.passwordExpirationStatus = value
        }
        if let value = dict["PasswordForcedUpdateDuration"] as? Int32 {
            self.passwordForcedUpdateDuration = value
        }
        if let value = dict["PasswordValidMaxDay"] as? Int32 {
            self.passwordValidMaxDay = value
        }
    }
}

public class SetPasswordExpirationConfigurationResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class SetPasswordExpirationConfigurationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SetPasswordExpirationConfigurationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = SetPasswordExpirationConfigurationResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class SetPasswordHistoryConfigurationRequest : Tea.TeaModel {
    public var instanceId: String?

    public var passwordHistoryMaxRetention: Int32?

    public var passwordHistoryStatus: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.passwordHistoryMaxRetention != nil {
            map["PasswordHistoryMaxRetention"] = self.passwordHistoryMaxRetention!
        }
        if self.passwordHistoryStatus != nil {
            map["PasswordHistoryStatus"] = self.passwordHistoryStatus!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["PasswordHistoryMaxRetention"] as? Int32 {
            self.passwordHistoryMaxRetention = value
        }
        if let value = dict["PasswordHistoryStatus"] as? String {
            self.passwordHistoryStatus = value
        }
    }
}

public class SetPasswordHistoryConfigurationResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class SetPasswordHistoryConfigurationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SetPasswordHistoryConfigurationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = SetPasswordHistoryConfigurationResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class SetPasswordInitializationConfigurationRequest : Tea.TeaModel {
    public var instanceId: String?

    public var passwordForcedUpdateStatus: String?

    public var passwordInitializationNotificationChannels: [String]?

    public var passwordInitializationStatus: String?

    public var passwordInitializationType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.passwordForcedUpdateStatus != nil {
            map["PasswordForcedUpdateStatus"] = self.passwordForcedUpdateStatus!
        }
        if self.passwordInitializationNotificationChannels != nil {
            map["PasswordInitializationNotificationChannels"] = self.passwordInitializationNotificationChannels!
        }
        if self.passwordInitializationStatus != nil {
            map["PasswordInitializationStatus"] = self.passwordInitializationStatus!
        }
        if self.passwordInitializationType != nil {
            map["PasswordInitializationType"] = self.passwordInitializationType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["PasswordForcedUpdateStatus"] as? String {
            self.passwordForcedUpdateStatus = value
        }
        if let value = dict["PasswordInitializationNotificationChannels"] as? [String] {
            self.passwordInitializationNotificationChannels = value
        }
        if let value = dict["PasswordInitializationStatus"] as? String {
            self.passwordInitializationStatus = value
        }
        if let value = dict["PasswordInitializationType"] as? String {
            self.passwordInitializationType = value
        }
    }
}

public class SetPasswordInitializationConfigurationResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class SetPasswordInitializationConfigurationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SetPasswordInitializationConfigurationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = SetPasswordInitializationConfigurationResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class SetUserPrimaryOrganizationalUnitRequest : Tea.TeaModel {
    public var instanceId: String?

    public var organizationalUnitId: String?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.organizationalUnitId != nil {
            map["OrganizationalUnitId"] = self.organizationalUnitId!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["OrganizationalUnitId"] as? String {
            self.organizationalUnitId = value
        }
        if let value = dict["UserId"] as? String {
            self.userId = value
        }
    }
}

public class SetUserPrimaryOrganizationalUnitResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class SetUserPrimaryOrganizationalUnitResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SetUserPrimaryOrganizationalUnitResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = SetUserPrimaryOrganizationalUnitResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UnlockUserRequest : Tea.TeaModel {
    public var instanceId: String?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["UserId"] as? String {
            self.userId = value
        }
    }
}

public class UnlockUserResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class UnlockUserResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UnlockUserResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UnlockUserResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateApplicationAuthorizationTypeRequest : Tea.TeaModel {
    public var applicationId: String?

    public var authorizationType: String?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.applicationId != nil {
            map["ApplicationId"] = self.applicationId!
        }
        if self.authorizationType != nil {
            map["AuthorizationType"] = self.authorizationType!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ApplicationId"] as? String {
            self.applicationId = value
        }
        if let value = dict["AuthorizationType"] as? String {
            self.authorizationType = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
    }
}

public class UpdateApplicationAuthorizationTypeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class UpdateApplicationAuthorizationTypeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateApplicationAuthorizationTypeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateApplicationAuthorizationTypeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateApplicationDescriptionRequest : Tea.TeaModel {
    public var applicationId: String?

    public var description_: String?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.applicationId != nil {
            map["ApplicationId"] = self.applicationId!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ApplicationId"] as? String {
            self.applicationId = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
    }
}

public class UpdateApplicationDescriptionResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class UpdateApplicationDescriptionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateApplicationDescriptionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateApplicationDescriptionResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateConditionalAccessPolicyRequest : Tea.TeaModel {
    public class ConditionsConfig : Tea.TeaModel {
        public class Applications : Tea.TeaModel {
            public var excludeApplications: [String]?

            public var includeApplications: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.excludeApplications != nil {
                    map["ExcludeApplications"] = self.excludeApplications!
                }
                if self.includeApplications != nil {
                    map["IncludeApplications"] = self.includeApplications!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ExcludeApplications"] as? [String] {
                    self.excludeApplications = value
                }
                if let value = dict["IncludeApplications"] as? [String] {
                    self.includeApplications = value
                }
            }
        }
        public class NetworkZones : Tea.TeaModel {
            public var excludeNetworkZones: [String]?

            public var includeNetworkZones: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.excludeNetworkZones != nil {
                    map["ExcludeNetworkZones"] = self.excludeNetworkZones!
                }
                if self.includeNetworkZones != nil {
                    map["IncludeNetworkZones"] = self.includeNetworkZones!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ExcludeNetworkZones"] as? [String] {
                    self.excludeNetworkZones = value
                }
                if let value = dict["IncludeNetworkZones"] as? [String] {
                    self.includeNetworkZones = value
                }
            }
        }
        public class Users : Tea.TeaModel {
            public var excludeGroups: [String]?

            public var excludeOrganizationalUnits: [String]?

            public var excludeUsers: [String]?

            public var includeGroups: [String]?

            public var includeOrganizationalUnits: [String]?

            public var includeUsers: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.excludeGroups != nil {
                    map["ExcludeGroups"] = self.excludeGroups!
                }
                if self.excludeOrganizationalUnits != nil {
                    map["ExcludeOrganizationalUnits"] = self.excludeOrganizationalUnits!
                }
                if self.excludeUsers != nil {
                    map["ExcludeUsers"] = self.excludeUsers!
                }
                if self.includeGroups != nil {
                    map["IncludeGroups"] = self.includeGroups!
                }
                if self.includeOrganizationalUnits != nil {
                    map["IncludeOrganizationalUnits"] = self.includeOrganizationalUnits!
                }
                if self.includeUsers != nil {
                    map["IncludeUsers"] = self.includeUsers!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ExcludeGroups"] as? [String] {
                    self.excludeGroups = value
                }
                if let value = dict["ExcludeOrganizationalUnits"] as? [String] {
                    self.excludeOrganizationalUnits = value
                }
                if let value = dict["ExcludeUsers"] as? [String] {
                    self.excludeUsers = value
                }
                if let value = dict["IncludeGroups"] as? [String] {
                    self.includeGroups = value
                }
                if let value = dict["IncludeOrganizationalUnits"] as? [String] {
                    self.includeOrganizationalUnits = value
                }
                if let value = dict["IncludeUsers"] as? [String] {
                    self.includeUsers = value
                }
            }
        }
        public var applications: UpdateConditionalAccessPolicyRequest.ConditionsConfig.Applications?

        public var networkZones: UpdateConditionalAccessPolicyRequest.ConditionsConfig.NetworkZones?

        public var users: UpdateConditionalAccessPolicyRequest.ConditionsConfig.Users?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.applications?.validate()
            try self.networkZones?.validate()
            try self.users?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.applications != nil {
                map["Applications"] = self.applications?.toMap()
            }
            if self.networkZones != nil {
                map["NetworkZones"] = self.networkZones?.toMap()
            }
            if self.users != nil {
                map["Users"] = self.users?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Applications"] as? [String: Any?] {
                var model = UpdateConditionalAccessPolicyRequest.ConditionsConfig.Applications()
                model.fromMap(value)
                self.applications = model
            }
            if let value = dict["NetworkZones"] as? [String: Any?] {
                var model = UpdateConditionalAccessPolicyRequest.ConditionsConfig.NetworkZones()
                model.fromMap(value)
                self.networkZones = model
            }
            if let value = dict["Users"] as? [String: Any?] {
                var model = UpdateConditionalAccessPolicyRequest.ConditionsConfig.Users()
                model.fromMap(value)
                self.users = model
            }
        }
    }
    public class DecisionConfig : Tea.TeaModel {
        public var activeSessionReuseStatus: String?

        public var effect: String?

        public var mfaAuthenticationIntervalSeconds: Int64?

        public var mfaAuthenticationMethods: [String]?

        public var mfaType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.activeSessionReuseStatus != nil {
                map["ActiveSessionReuseStatus"] = self.activeSessionReuseStatus!
            }
            if self.effect != nil {
                map["Effect"] = self.effect!
            }
            if self.mfaAuthenticationIntervalSeconds != nil {
                map["MfaAuthenticationIntervalSeconds"] = self.mfaAuthenticationIntervalSeconds!
            }
            if self.mfaAuthenticationMethods != nil {
                map["MfaAuthenticationMethods"] = self.mfaAuthenticationMethods!
            }
            if self.mfaType != nil {
                map["MfaType"] = self.mfaType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ActiveSessionReuseStatus"] as? String {
                self.activeSessionReuseStatus = value
            }
            if let value = dict["Effect"] as? String {
                self.effect = value
            }
            if let value = dict["MfaAuthenticationIntervalSeconds"] as? Int64 {
                self.mfaAuthenticationIntervalSeconds = value
            }
            if let value = dict["MfaAuthenticationMethods"] as? [String] {
                self.mfaAuthenticationMethods = value
            }
            if let value = dict["MfaType"] as? String {
                self.mfaType = value
            }
        }
    }
    public var clientToken: String?

    public var conditionalAccessPolicyId: String?

    public var conditionalAccessPolicyName: String?

    public var conditionsConfig: UpdateConditionalAccessPolicyRequest.ConditionsConfig?

    public var decisionConfig: UpdateConditionalAccessPolicyRequest.DecisionConfig?

    public var decisionType: String?

    public var instanceId: String?

    public var priority: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.conditionsConfig?.validate()
        try self.decisionConfig?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.conditionalAccessPolicyId != nil {
            map["ConditionalAccessPolicyId"] = self.conditionalAccessPolicyId!
        }
        if self.conditionalAccessPolicyName != nil {
            map["ConditionalAccessPolicyName"] = self.conditionalAccessPolicyName!
        }
        if self.conditionsConfig != nil {
            map["ConditionsConfig"] = self.conditionsConfig?.toMap()
        }
        if self.decisionConfig != nil {
            map["DecisionConfig"] = self.decisionConfig?.toMap()
        }
        if self.decisionType != nil {
            map["DecisionType"] = self.decisionType!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.priority != nil {
            map["Priority"] = self.priority!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["ConditionalAccessPolicyId"] as? String {
            self.conditionalAccessPolicyId = value
        }
        if let value = dict["ConditionalAccessPolicyName"] as? String {
            self.conditionalAccessPolicyName = value
        }
        if let value = dict["ConditionsConfig"] as? [String: Any?] {
            var model = UpdateConditionalAccessPolicyRequest.ConditionsConfig()
            model.fromMap(value)
            self.conditionsConfig = model
        }
        if let value = dict["DecisionConfig"] as? [String: Any?] {
            var model = UpdateConditionalAccessPolicyRequest.DecisionConfig()
            model.fromMap(value)
            self.decisionConfig = model
        }
        if let value = dict["DecisionType"] as? String {
            self.decisionType = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["Priority"] as? Int32 {
            self.priority = value
        }
    }
}

public class UpdateConditionalAccessPolicyResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class UpdateConditionalAccessPolicyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateConditionalAccessPolicyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateConditionalAccessPolicyResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateConditionalAccessPolicyDescriptionRequest : Tea.TeaModel {
    public var clientToken: String?

    public var conditionalAccessPolicyId: String?

    public var description_: String?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.conditionalAccessPolicyId != nil {
            map["ConditionalAccessPolicyId"] = self.conditionalAccessPolicyId!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["ConditionalAccessPolicyId"] as? String {
            self.conditionalAccessPolicyId = value
        }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
    }
}

public class UpdateConditionalAccessPolicyDescriptionResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class UpdateConditionalAccessPolicyDescriptionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateConditionalAccessPolicyDescriptionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateConditionalAccessPolicyDescriptionResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateGroupRequest : Tea.TeaModel {
    public var groupExternalId: String?

    public var groupId: String?

    public var groupName: String?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.groupExternalId != nil {
            map["GroupExternalId"] = self.groupExternalId!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.groupName != nil {
            map["GroupName"] = self.groupName!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["GroupExternalId"] as? String {
            self.groupExternalId = value
        }
        if let value = dict["GroupId"] as? String {
            self.groupId = value
        }
        if let value = dict["GroupName"] as? String {
            self.groupName = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
    }
}

public class UpdateGroupResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class UpdateGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateGroupResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateGroupDescriptionRequest : Tea.TeaModel {
    public var description_: String?

    public var groupId: String?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["GroupId"] as? String {
            self.groupId = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
    }
}

public class UpdateGroupDescriptionResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class UpdateGroupDescriptionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateGroupDescriptionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateGroupDescriptionResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateIdentityProviderRequest : Tea.TeaModel {
    public class DingtalkAppConfig : Tea.TeaModel {
        public var appKey: String?

        public var appSecret: String?

        public var encryptKey: String?

        public var verificationToken: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appKey != nil {
                map["AppKey"] = self.appKey!
            }
            if self.appSecret != nil {
                map["AppSecret"] = self.appSecret!
            }
            if self.encryptKey != nil {
                map["EncryptKey"] = self.encryptKey!
            }
            if self.verificationToken != nil {
                map["VerificationToken"] = self.verificationToken!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AppKey"] as? String {
                self.appKey = value
            }
            if let value = dict["AppSecret"] as? String {
                self.appSecret = value
            }
            if let value = dict["EncryptKey"] as? String {
                self.encryptKey = value
            }
            if let value = dict["VerificationToken"] as? String {
                self.verificationToken = value
            }
        }
    }
    public class LarkConfig : Tea.TeaModel {
        public var appId: String?

        public var appSecret: String?

        public var encryptKey: String?

        public var verificationToken: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.appId != nil {
                map["AppId"] = self.appId!
            }
            if self.appSecret != nil {
                map["AppSecret"] = self.appSecret!
            }
            if self.encryptKey != nil {
                map["EncryptKey"] = self.encryptKey!
            }
            if self.verificationToken != nil {
                map["VerificationToken"] = self.verificationToken!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AppId"] as? String {
                self.appId = value
            }
            if let value = dict["AppSecret"] as? String {
                self.appSecret = value
            }
            if let value = dict["EncryptKey"] as? String {
                self.encryptKey = value
            }
            if let value = dict["VerificationToken"] as? String {
                self.verificationToken = value
            }
        }
    }
    public class LdapConfig : Tea.TeaModel {
        public var administratorPassword: String?

        public var administratorUsername: String?

        public var certificateFingerprintStatus: String?

        public var certificateFingerprints: [String]?

        public var ldapProtocol: String?

        public var ldapServerHost: String?

        public var ldapServerPort: Int32?

        public var startTlsStatus: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.administratorPassword != nil {
                map["AdministratorPassword"] = self.administratorPassword!
            }
            if self.administratorUsername != nil {
                map["AdministratorUsername"] = self.administratorUsername!
            }
            if self.certificateFingerprintStatus != nil {
                map["CertificateFingerprintStatus"] = self.certificateFingerprintStatus!
            }
            if self.certificateFingerprints != nil {
                map["CertificateFingerprints"] = self.certificateFingerprints!
            }
            if self.ldapProtocol != nil {
                map["LdapProtocol"] = self.ldapProtocol!
            }
            if self.ldapServerHost != nil {
                map["LdapServerHost"] = self.ldapServerHost!
            }
            if self.ldapServerPort != nil {
                map["LdapServerPort"] = self.ldapServerPort!
            }
            if self.startTlsStatus != nil {
                map["StartTlsStatus"] = self.startTlsStatus!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AdministratorPassword"] as? String {
                self.administratorPassword = value
            }
            if let value = dict["AdministratorUsername"] as? String {
                self.administratorUsername = value
            }
            if let value = dict["CertificateFingerprintStatus"] as? String {
                self.certificateFingerprintStatus = value
            }
            if let value = dict["CertificateFingerprints"] as? [String] {
                self.certificateFingerprints = value
            }
            if let value = dict["LdapProtocol"] as? String {
                self.ldapProtocol = value
            }
            if let value = dict["LdapServerHost"] as? String {
                self.ldapServerHost = value
            }
            if let value = dict["LdapServerPort"] as? Int32 {
                self.ldapServerPort = value
            }
            if let value = dict["StartTlsStatus"] as? String {
                self.startTlsStatus = value
            }
        }
    }
    public class OidcConfig : Tea.TeaModel {
        public class AuthnParam : Tea.TeaModel {
            public var authnMethod: String?

            public var clientSecret: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.authnMethod != nil {
                    map["AuthnMethod"] = self.authnMethod!
                }
                if self.clientSecret != nil {
                    map["ClientSecret"] = self.clientSecret!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AuthnMethod"] as? String {
                    self.authnMethod = value
                }
                if let value = dict["ClientSecret"] as? String {
                    self.clientSecret = value
                }
            }
        }
        public class EndpointConfig : Tea.TeaModel {
            public var authorizationEndpoint: String?

            public var issuer: String?

            public var jwksUri: String?

            public var tokenEndpoint: String?

            public var userinfoEndpoint: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.authorizationEndpoint != nil {
                    map["AuthorizationEndpoint"] = self.authorizationEndpoint!
                }
                if self.issuer != nil {
                    map["Issuer"] = self.issuer!
                }
                if self.jwksUri != nil {
                    map["JwksUri"] = self.jwksUri!
                }
                if self.tokenEndpoint != nil {
                    map["TokenEndpoint"] = self.tokenEndpoint!
                }
                if self.userinfoEndpoint != nil {
                    map["UserinfoEndpoint"] = self.userinfoEndpoint!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["AuthorizationEndpoint"] as? String {
                    self.authorizationEndpoint = value
                }
                if let value = dict["Issuer"] as? String {
                    self.issuer = value
                }
                if let value = dict["JwksUri"] as? String {
                    self.jwksUri = value
                }
                if let value = dict["TokenEndpoint"] as? String {
                    self.tokenEndpoint = value
                }
                if let value = dict["UserinfoEndpoint"] as? String {
                    self.userinfoEndpoint = value
                }
            }
        }
        public var authnParam: UpdateIdentityProviderRequest.OidcConfig.AuthnParam?

        public var endpointConfig: UpdateIdentityProviderRequest.OidcConfig.EndpointConfig?

        public var grantScopes: [String]?

        public var grantType: String?

        public var pkceChallengeMethod: String?

        public var pkceRequired: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.authnParam?.validate()
            try self.endpointConfig?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.authnParam != nil {
                map["AuthnParam"] = self.authnParam?.toMap()
            }
            if self.endpointConfig != nil {
                map["EndpointConfig"] = self.endpointConfig?.toMap()
            }
            if self.grantScopes != nil {
                map["GrantScopes"] = self.grantScopes!
            }
            if self.grantType != nil {
                map["GrantType"] = self.grantType!
            }
            if self.pkceChallengeMethod != nil {
                map["PkceChallengeMethod"] = self.pkceChallengeMethod!
            }
            if self.pkceRequired != nil {
                map["PkceRequired"] = self.pkceRequired!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AuthnParam"] as? [String: Any?] {
                var model = UpdateIdentityProviderRequest.OidcConfig.AuthnParam()
                model.fromMap(value)
                self.authnParam = model
            }
            if let value = dict["EndpointConfig"] as? [String: Any?] {
                var model = UpdateIdentityProviderRequest.OidcConfig.EndpointConfig()
                model.fromMap(value)
                self.endpointConfig = model
            }
            if let value = dict["GrantScopes"] as? [String] {
                self.grantScopes = value
            }
            if let value = dict["GrantType"] as? String {
                self.grantType = value
            }
            if let value = dict["PkceChallengeMethod"] as? String {
                self.pkceChallengeMethod = value
            }
            if let value = dict["PkceRequired"] as? Bool {
                self.pkceRequired = value
            }
        }
    }
    public class WeComConfig : Tea.TeaModel {
        public var agentId: String?

        public var authorizeCallbackDomain: String?

        public var corpSecret: String?

        public var trustableDomain: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.agentId != nil {
                map["AgentId"] = self.agentId!
            }
            if self.authorizeCallbackDomain != nil {
                map["AuthorizeCallbackDomain"] = self.authorizeCallbackDomain!
            }
            if self.corpSecret != nil {
                map["CorpSecret"] = self.corpSecret!
            }
            if self.trustableDomain != nil {
                map["TrustableDomain"] = self.trustableDomain!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["AgentId"] as? String {
                self.agentId = value
            }
            if let value = dict["AuthorizeCallbackDomain"] as? String {
                self.authorizeCallbackDomain = value
            }
            if let value = dict["CorpSecret"] as? String {
                self.corpSecret = value
            }
            if let value = dict["TrustableDomain"] as? String {
                self.trustableDomain = value
            }
        }
    }
    public var clientToken: String?

    public var dingtalkAppConfig: UpdateIdentityProviderRequest.DingtalkAppConfig?

    public var identityProviderId: String?

    public var identityProviderName: String?

    public var instanceId: String?

    public var larkConfig: UpdateIdentityProviderRequest.LarkConfig?

    public var ldapConfig: UpdateIdentityProviderRequest.LdapConfig?

    public var logoUrl: String?

    public var networkAccessEndpointId: String?

    public var oidcConfig: UpdateIdentityProviderRequest.OidcConfig?

    public var weComConfig: UpdateIdentityProviderRequest.WeComConfig?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.dingtalkAppConfig?.validate()
        try self.larkConfig?.validate()
        try self.ldapConfig?.validate()
        try self.oidcConfig?.validate()
        try self.weComConfig?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dingtalkAppConfig != nil {
            map["DingtalkAppConfig"] = self.dingtalkAppConfig?.toMap()
        }
        if self.identityProviderId != nil {
            map["IdentityProviderId"] = self.identityProviderId!
        }
        if self.identityProviderName != nil {
            map["IdentityProviderName"] = self.identityProviderName!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.larkConfig != nil {
            map["LarkConfig"] = self.larkConfig?.toMap()
        }
        if self.ldapConfig != nil {
            map["LdapConfig"] = self.ldapConfig?.toMap()
        }
        if self.logoUrl != nil {
            map["LogoUrl"] = self.logoUrl!
        }
        if self.networkAccessEndpointId != nil {
            map["NetworkAccessEndpointId"] = self.networkAccessEndpointId!
        }
        if self.oidcConfig != nil {
            map["OidcConfig"] = self.oidcConfig?.toMap()
        }
        if self.weComConfig != nil {
            map["WeComConfig"] = self.weComConfig?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["DingtalkAppConfig"] as? [String: Any?] {
            var model = UpdateIdentityProviderRequest.DingtalkAppConfig()
            model.fromMap(value)
            self.dingtalkAppConfig = model
        }
        if let value = dict["IdentityProviderId"] as? String {
            self.identityProviderId = value
        }
        if let value = dict["IdentityProviderName"] as? String {
            self.identityProviderName = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["LarkConfig"] as? [String: Any?] {
            var model = UpdateIdentityProviderRequest.LarkConfig()
            model.fromMap(value)
            self.larkConfig = model
        }
        if let value = dict["LdapConfig"] as? [String: Any?] {
            var model = UpdateIdentityProviderRequest.LdapConfig()
            model.fromMap(value)
            self.ldapConfig = model
        }
        if let value = dict["LogoUrl"] as? String {
            self.logoUrl = value
        }
        if let value = dict["NetworkAccessEndpointId"] as? String {
            self.networkAccessEndpointId = value
        }
        if let value = dict["OidcConfig"] as? [String: Any?] {
            var model = UpdateIdentityProviderRequest.OidcConfig()
            model.fromMap(value)
            self.oidcConfig = model
        }
        if let value = dict["WeComConfig"] as? [String: Any?] {
            var model = UpdateIdentityProviderRequest.WeComConfig()
            model.fromMap(value)
            self.weComConfig = model
        }
    }
}

public class UpdateIdentityProviderResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class UpdateIdentityProviderResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateIdentityProviderResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateIdentityProviderResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateInstanceDescriptionRequest : Tea.TeaModel {
    public var description_: String?

    public var instanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
    }
}

public class UpdateInstanceDescriptionResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class UpdateInstanceDescriptionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateInstanceDescriptionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateInstanceDescriptionResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateNetworkAccessEndpointNameRequest : Tea.TeaModel {
    public var instanceId: String?

    public var networkAccessEndpointId: String?

    public var networkAccessEndpointName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.networkAccessEndpointId != nil {
            map["NetworkAccessEndpointId"] = self.networkAccessEndpointId!
        }
        if self.networkAccessEndpointName != nil {
            map["NetworkAccessEndpointName"] = self.networkAccessEndpointName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["NetworkAccessEndpointId"] as? String {
            self.networkAccessEndpointId = value
        }
        if let value = dict["NetworkAccessEndpointName"] as? String {
            self.networkAccessEndpointName = value
        }
    }
}

public class UpdateNetworkAccessEndpointNameResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class UpdateNetworkAccessEndpointNameResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateNetworkAccessEndpointNameResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateNetworkAccessEndpointNameResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateOrganizationalUnitRequest : Tea.TeaModel {
    public var instanceId: String?

    public var organizationalUnitId: String?

    public var organizationalUnitName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.organizationalUnitId != nil {
            map["OrganizationalUnitId"] = self.organizationalUnitId!
        }
        if self.organizationalUnitName != nil {
            map["OrganizationalUnitName"] = self.organizationalUnitName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["OrganizationalUnitId"] as? String {
            self.organizationalUnitId = value
        }
        if let value = dict["OrganizationalUnitName"] as? String {
            self.organizationalUnitName = value
        }
    }
}

public class UpdateOrganizationalUnitResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class UpdateOrganizationalUnitResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateOrganizationalUnitResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateOrganizationalUnitResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateOrganizationalUnitDescriptionRequest : Tea.TeaModel {
    public var description_: String?

    public var instanceId: String?

    public var organizationalUnitId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.organizationalUnitId != nil {
            map["OrganizationalUnitId"] = self.organizationalUnitId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["OrganizationalUnitId"] as? String {
            self.organizationalUnitId = value
        }
    }
}

public class UpdateOrganizationalUnitDescriptionResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class UpdateOrganizationalUnitDescriptionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateOrganizationalUnitDescriptionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateOrganizationalUnitDescriptionResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateOrganizationalUnitParentIdRequest : Tea.TeaModel {
    public var instanceId: String?

    public var organizationalUnitId: String?

    public var parentId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.organizationalUnitId != nil {
            map["OrganizationalUnitId"] = self.organizationalUnitId!
        }
        if self.parentId != nil {
            map["ParentId"] = self.parentId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["OrganizationalUnitId"] as? String {
            self.organizationalUnitId = value
        }
        if let value = dict["ParentId"] as? String {
            self.parentId = value
        }
    }
}

public class UpdateOrganizationalUnitParentIdResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class UpdateOrganizationalUnitParentIdResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateOrganizationalUnitParentIdResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateOrganizationalUnitParentIdResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateUserRequest : Tea.TeaModel {
    public class CustomFields : Tea.TeaModel {
        public var fieldName: String?

        public var fieldValue: String?

        public var operation: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.fieldName != nil {
                map["FieldName"] = self.fieldName!
            }
            if self.fieldValue != nil {
                map["FieldValue"] = self.fieldValue!
            }
            if self.operation != nil {
                map["Operation"] = self.operation!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["FieldName"] as? String {
                self.fieldName = value
            }
            if let value = dict["FieldValue"] as? String {
                self.fieldValue = value
            }
            if let value = dict["Operation"] as? String {
                self.operation = value
            }
        }
    }
    public var customFields: [UpdateUserRequest.CustomFields]?

    public var displayName: String?

    public var email: String?

    public var emailVerified: Bool?

    public var instanceId: String?

    public var phoneNumber: String?

    public var phoneNumberVerified: Bool?

    public var phoneRegion: String?

    public var userId: String?

    public var username: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.customFields != nil {
            var tmp : [Any] = []
            for k in self.customFields! {
                tmp.append(k.toMap())
            }
            map["CustomFields"] = tmp
        }
        if self.displayName != nil {
            map["DisplayName"] = self.displayName!
        }
        if self.email != nil {
            map["Email"] = self.email!
        }
        if self.emailVerified != nil {
            map["EmailVerified"] = self.emailVerified!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.phoneNumber != nil {
            map["PhoneNumber"] = self.phoneNumber!
        }
        if self.phoneNumberVerified != nil {
            map["PhoneNumberVerified"] = self.phoneNumberVerified!
        }
        if self.phoneRegion != nil {
            map["PhoneRegion"] = self.phoneRegion!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        if self.username != nil {
            map["Username"] = self.username!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["CustomFields"] as? [Any?] {
            var tmp : [UpdateUserRequest.CustomFields] = []
            for v in value {
                if v != nil {
                    var model = UpdateUserRequest.CustomFields()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.customFields = tmp
        }
        if let value = dict["DisplayName"] as? String {
            self.displayName = value
        }
        if let value = dict["Email"] as? String {
            self.email = value
        }
        if let value = dict["EmailVerified"] as? Bool {
            self.emailVerified = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["PhoneNumber"] as? String {
            self.phoneNumber = value
        }
        if let value = dict["PhoneNumberVerified"] as? Bool {
            self.phoneNumberVerified = value
        }
        if let value = dict["PhoneRegion"] as? String {
            self.phoneRegion = value
        }
        if let value = dict["UserId"] as? String {
            self.userId = value
        }
        if let value = dict["Username"] as? String {
            self.username = value
        }
    }
}

public class UpdateUserResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class UpdateUserResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateUserResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateUserResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateUserDescriptionRequest : Tea.TeaModel {
    public var description_: String?

    public var instanceId: String?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Description"] as? String {
            self.description_ = value
        }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["UserId"] as? String {
            self.userId = value
        }
    }
}

public class UpdateUserDescriptionResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class UpdateUserDescriptionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateUserDescriptionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateUserDescriptionResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateUserPasswordRequest : Tea.TeaModel {
    public var instanceId: String?

    public var password: String?

    public var passwordForcedUpdateStatus: String?

    public var userId: String?

    public var userNotificationChannels: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.password != nil {
            map["Password"] = self.password!
        }
        if self.passwordForcedUpdateStatus != nil {
            map["PasswordForcedUpdateStatus"] = self.passwordForcedUpdateStatus!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        if self.userNotificationChannels != nil {
            map["UserNotificationChannels"] = self.userNotificationChannels!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["InstanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["Password"] as? String {
            self.password = value
        }
        if let value = dict["PasswordForcedUpdateStatus"] as? String {
            self.passwordForcedUpdateStatus = value
        }
        if let value = dict["UserId"] as? String {
            self.userId = value
        }
        if let value = dict["UserNotificationChannels"] as? [String] {
            self.userNotificationChannels = value
        }
    }
}

public class UpdateUserPasswordResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class UpdateUserPasswordResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateUserPasswordResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateUserPasswordResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}
