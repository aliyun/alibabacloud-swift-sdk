import Foundation
import Tea
import TeaUtils
import AlibabacloudOpenApi
import AlibabaCloudOpenApiUtil
import AlibabacloudEndpointUtil

public class AddClusterServiceRequest : Tea.TeaModel {
    public class Service : Tea.TeaModel {
        public var serviceName: String?

        public var serviceVersion: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.serviceName != nil {
                map["ServiceName"] = self.serviceName!
            }
            if self.serviceVersion != nil {
                map["ServiceVersion"] = self.serviceVersion!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ServiceName") && dict["ServiceName"] != nil {
                self.serviceName = dict["ServiceName"] as! String
            }
            if dict.keys.contains("ServiceVersion") && dict["ServiceVersion"] != nil {
                self.serviceVersion = dict["ServiceVersion"] as! String
            }
        }
    }
    public var clusterId: String?

    public var comment: String?

    public var regionId: String?

    public var resourceOwnerId: Int64?

    public var service: [AddClusterServiceRequest.Service]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.comment != nil {
            map["Comment"] = self.comment!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.service != nil {
            var tmp : [Any] = []
            for k in self.service! {
                tmp.append(k.toMap())
            }
            map["Service"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("Comment") && dict["Comment"] != nil {
            self.comment = dict["Comment"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") && dict["ResourceOwnerId"] != nil {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("Service") && dict["Service"] != nil {
            var tmp : [AddClusterServiceRequest.Service] = []
            for v in dict["Service"] as! [Any] {
                var model = AddClusterServiceRequest.Service()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.service = tmp
        }
    }
}

public class AddClusterServiceResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AddClusterServiceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddClusterServiceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = AddClusterServiceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddScalingConfigItemV2Request : Tea.TeaModel {
    public var configItemInformation: String?

    public var configItemType: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerId: Int64?

    public var scalingGroupBizId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.configItemInformation != nil {
            map["ConfigItemInformation"] = self.configItemInformation!
        }
        if self.configItemType != nil {
            map["ConfigItemType"] = self.configItemType!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.scalingGroupBizId != nil {
            map["ScalingGroupBizId"] = self.scalingGroupBizId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ConfigItemInformation") && dict["ConfigItemInformation"] != nil {
            self.configItemInformation = dict["ConfigItemInformation"] as! String
        }
        if dict.keys.contains("ConfigItemType") && dict["ConfigItemType"] != nil {
            self.configItemType = dict["ConfigItemType"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") && dict["ResourceGroupId"] != nil {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") && dict["ResourceOwnerId"] != nil {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("ScalingGroupBizId") && dict["ScalingGroupBizId"] != nil {
            self.scalingGroupBizId = dict["ScalingGroupBizId"] as! String
        }
    }
}

public class AddScalingConfigItemV2ResponseBody : Tea.TeaModel {
    public var data: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AddScalingConfigItemV2Response : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddScalingConfigItemV2ResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = AddScalingConfigItemV2ResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CloneFlowRequest : Tea.TeaModel {
    public var id: String?

    public var projectId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! String
        }
        if dict.keys.contains("ProjectId") && dict["ProjectId"] != nil {
            self.projectId = dict["ProjectId"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class CloneFlowResponseBody : Tea.TeaModel {
    public var id: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CloneFlowResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CloneFlowResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CloneFlowResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CloneFlowJobRequest : Tea.TeaModel {
    public var id: String?

    public var name: String?

    public var projectId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! String
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("ProjectId") && dict["ProjectId"] != nil {
            self.projectId = dict["ProjectId"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class CloneFlowJobResponseBody : Tea.TeaModel {
    public var id: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CloneFlowJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CloneFlowJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CloneFlowJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateClusterHostGroupRequest : Tea.TeaModel {
    public var clusterId: String?

    public var comment: String?

    public var hostGroupName: String?

    public var hostGroupParams: String?

    public var hostGroupType: String?

    public var payType: String?

    public var regionId: String?

    public var resourceOwnerId: Int64?

    public var securityGroupId: String?

    public var vswitchId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.comment != nil {
            map["Comment"] = self.comment!
        }
        if self.hostGroupName != nil {
            map["HostGroupName"] = self.hostGroupName!
        }
        if self.hostGroupParams != nil {
            map["HostGroupParams"] = self.hostGroupParams!
        }
        if self.hostGroupType != nil {
            map["HostGroupType"] = self.hostGroupType!
        }
        if self.payType != nil {
            map["PayType"] = self.payType!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.securityGroupId != nil {
            map["SecurityGroupId"] = self.securityGroupId!
        }
        if self.vswitchId != nil {
            map["VswitchId"] = self.vswitchId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("Comment") && dict["Comment"] != nil {
            self.comment = dict["Comment"] as! String
        }
        if dict.keys.contains("HostGroupName") && dict["HostGroupName"] != nil {
            self.hostGroupName = dict["HostGroupName"] as! String
        }
        if dict.keys.contains("HostGroupParams") && dict["HostGroupParams"] != nil {
            self.hostGroupParams = dict["HostGroupParams"] as! String
        }
        if dict.keys.contains("HostGroupType") && dict["HostGroupType"] != nil {
            self.hostGroupType = dict["HostGroupType"] as! String
        }
        if dict.keys.contains("PayType") && dict["PayType"] != nil {
            self.payType = dict["PayType"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") && dict["ResourceOwnerId"] != nil {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("SecurityGroupId") && dict["SecurityGroupId"] != nil {
            self.securityGroupId = dict["SecurityGroupId"] as! String
        }
        if dict.keys.contains("VswitchId") && dict["VswitchId"] != nil {
            self.vswitchId = dict["VswitchId"] as! String
        }
    }
}

public class CreateClusterHostGroupResponseBody : Tea.TeaModel {
    public var clusterId: String?

    public var hostGroupId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.hostGroupId != nil {
            map["HostGroupId"] = self.hostGroupId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("HostGroupId") && dict["HostGroupId"] != nil {
            self.hostGroupId = dict["HostGroupId"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateClusterHostGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateClusterHostGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateClusterHostGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateClusterTemplateRequest : Tea.TeaModel {
    public class BootstrapAction : Tea.TeaModel {
        public var arg: String?

        public var executionFailStrategy: String?

        public var executionMoment: String?

        public var executionTarget: String?

        public var name: String?

        public var path: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.arg != nil {
                map["Arg"] = self.arg!
            }
            if self.executionFailStrategy != nil {
                map["ExecutionFailStrategy"] = self.executionFailStrategy!
            }
            if self.executionMoment != nil {
                map["ExecutionMoment"] = self.executionMoment!
            }
            if self.executionTarget != nil {
                map["ExecutionTarget"] = self.executionTarget!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.path != nil {
                map["Path"] = self.path!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Arg") && dict["Arg"] != nil {
                self.arg = dict["Arg"] as! String
            }
            if dict.keys.contains("ExecutionFailStrategy") && dict["ExecutionFailStrategy"] != nil {
                self.executionFailStrategy = dict["ExecutionFailStrategy"] as! String
            }
            if dict.keys.contains("ExecutionMoment") && dict["ExecutionMoment"] != nil {
                self.executionMoment = dict["ExecutionMoment"] as! String
            }
            if dict.keys.contains("ExecutionTarget") && dict["ExecutionTarget"] != nil {
                self.executionTarget = dict["ExecutionTarget"] as! String
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Path") && dict["Path"] != nil {
                self.path = dict["Path"] as! String
            }
        }
    }
    public class Config : Tea.TeaModel {
        public var configKey: String?

        public var configValue: String?

        public var encrypt: String?

        public var fileName: String?

        public var replace: String?

        public var serviceName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.configKey != nil {
                map["ConfigKey"] = self.configKey!
            }
            if self.configValue != nil {
                map["ConfigValue"] = self.configValue!
            }
            if self.encrypt != nil {
                map["Encrypt"] = self.encrypt!
            }
            if self.fileName != nil {
                map["FileName"] = self.fileName!
            }
            if self.replace != nil {
                map["Replace"] = self.replace!
            }
            if self.serviceName != nil {
                map["ServiceName"] = self.serviceName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ConfigKey") && dict["ConfigKey"] != nil {
                self.configKey = dict["ConfigKey"] as! String
            }
            if dict.keys.contains("ConfigValue") && dict["ConfigValue"] != nil {
                self.configValue = dict["ConfigValue"] as! String
            }
            if dict.keys.contains("Encrypt") && dict["Encrypt"] != nil {
                self.encrypt = dict["Encrypt"] as! String
            }
            if dict.keys.contains("FileName") && dict["FileName"] != nil {
                self.fileName = dict["FileName"] as! String
            }
            if dict.keys.contains("Replace") && dict["Replace"] != nil {
                self.replace = dict["Replace"] as! String
            }
            if dict.keys.contains("ServiceName") && dict["ServiceName"] != nil {
                self.serviceName = dict["ServiceName"] as! String
            }
        }
    }
    public class HostGroup : Tea.TeaModel {
        public var autoRenew: Bool?

        public var chargeType: String?

        public var clusterId: String?

        public var comment: String?

        public var createType: String?

        public var diskCapacity: Int32?

        public var diskCount: Int32?

        public var diskType: String?

        public var hostGroupId: String?

        public var hostGroupName: String?

        public var hostGroupType: String?

        public var instanceType: String?

        public var multiInstanceTypes: String?

        public var nodeCount: Int32?

        public var period: Int32?

        public var privatePoolOptionsId: String?

        public var privatePoolOptionsMatchCriteria: String?

        public var sysDiskCapacity: Int32?

        public var sysDiskType: String?

        public var vSwitchId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.autoRenew != nil {
                map["AutoRenew"] = self.autoRenew!
            }
            if self.chargeType != nil {
                map["ChargeType"] = self.chargeType!
            }
            if self.clusterId != nil {
                map["ClusterId"] = self.clusterId!
            }
            if self.comment != nil {
                map["Comment"] = self.comment!
            }
            if self.createType != nil {
                map["CreateType"] = self.createType!
            }
            if self.diskCapacity != nil {
                map["DiskCapacity"] = self.diskCapacity!
            }
            if self.diskCount != nil {
                map["DiskCount"] = self.diskCount!
            }
            if self.diskType != nil {
                map["DiskType"] = self.diskType!
            }
            if self.hostGroupId != nil {
                map["HostGroupId"] = self.hostGroupId!
            }
            if self.hostGroupName != nil {
                map["HostGroupName"] = self.hostGroupName!
            }
            if self.hostGroupType != nil {
                map["HostGroupType"] = self.hostGroupType!
            }
            if self.instanceType != nil {
                map["InstanceType"] = self.instanceType!
            }
            if self.multiInstanceTypes != nil {
                map["MultiInstanceTypes"] = self.multiInstanceTypes!
            }
            if self.nodeCount != nil {
                map["NodeCount"] = self.nodeCount!
            }
            if self.period != nil {
                map["Period"] = self.period!
            }
            if self.privatePoolOptionsId != nil {
                map["PrivatePoolOptionsId"] = self.privatePoolOptionsId!
            }
            if self.privatePoolOptionsMatchCriteria != nil {
                map["PrivatePoolOptionsMatchCriteria"] = self.privatePoolOptionsMatchCriteria!
            }
            if self.sysDiskCapacity != nil {
                map["SysDiskCapacity"] = self.sysDiskCapacity!
            }
            if self.sysDiskType != nil {
                map["SysDiskType"] = self.sysDiskType!
            }
            if self.vSwitchId != nil {
                map["VSwitchId"] = self.vSwitchId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AutoRenew") && dict["AutoRenew"] != nil {
                self.autoRenew = dict["AutoRenew"] as! Bool
            }
            if dict.keys.contains("ChargeType") && dict["ChargeType"] != nil {
                self.chargeType = dict["ChargeType"] as! String
            }
            if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
                self.clusterId = dict["ClusterId"] as! String
            }
            if dict.keys.contains("Comment") && dict["Comment"] != nil {
                self.comment = dict["Comment"] as! String
            }
            if dict.keys.contains("CreateType") && dict["CreateType"] != nil {
                self.createType = dict["CreateType"] as! String
            }
            if dict.keys.contains("DiskCapacity") && dict["DiskCapacity"] != nil {
                self.diskCapacity = dict["DiskCapacity"] as! Int32
            }
            if dict.keys.contains("DiskCount") && dict["DiskCount"] != nil {
                self.diskCount = dict["DiskCount"] as! Int32
            }
            if dict.keys.contains("DiskType") && dict["DiskType"] != nil {
                self.diskType = dict["DiskType"] as! String
            }
            if dict.keys.contains("HostGroupId") && dict["HostGroupId"] != nil {
                self.hostGroupId = dict["HostGroupId"] as! String
            }
            if dict.keys.contains("HostGroupName") && dict["HostGroupName"] != nil {
                self.hostGroupName = dict["HostGroupName"] as! String
            }
            if dict.keys.contains("HostGroupType") && dict["HostGroupType"] != nil {
                self.hostGroupType = dict["HostGroupType"] as! String
            }
            if dict.keys.contains("InstanceType") && dict["InstanceType"] != nil {
                self.instanceType = dict["InstanceType"] as! String
            }
            if dict.keys.contains("MultiInstanceTypes") && dict["MultiInstanceTypes"] != nil {
                self.multiInstanceTypes = dict["MultiInstanceTypes"] as! String
            }
            if dict.keys.contains("NodeCount") && dict["NodeCount"] != nil {
                self.nodeCount = dict["NodeCount"] as! Int32
            }
            if dict.keys.contains("Period") && dict["Period"] != nil {
                self.period = dict["Period"] as! Int32
            }
            if dict.keys.contains("PrivatePoolOptionsId") && dict["PrivatePoolOptionsId"] != nil {
                self.privatePoolOptionsId = dict["PrivatePoolOptionsId"] as! String
            }
            if dict.keys.contains("PrivatePoolOptionsMatchCriteria") && dict["PrivatePoolOptionsMatchCriteria"] != nil {
                self.privatePoolOptionsMatchCriteria = dict["PrivatePoolOptionsMatchCriteria"] as! String
            }
            if dict.keys.contains("SysDiskCapacity") && dict["SysDiskCapacity"] != nil {
                self.sysDiskCapacity = dict["SysDiskCapacity"] as! Int32
            }
            if dict.keys.contains("SysDiskType") && dict["SysDiskType"] != nil {
                self.sysDiskType = dict["SysDiskType"] as! String
            }
            if dict.keys.contains("VSwitchId") && dict["VSwitchId"] != nil {
                self.vSwitchId = dict["VSwitchId"] as! String
            }
        }
    }
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") && dict["Key"] != nil {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") && dict["Value"] != nil {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var autoRenew: Bool?

    public var bootstrapAction: [CreateClusterTemplateRequest.BootstrapAction]?

    public var clientToken: String?

    public var clusterType: String?

    public var config: [CreateClusterTemplateRequest.Config]?

    public var configurations: String?

    public var dataDiskEncrypted: Bool?

    public var dataDiskKMSKeyId: String?

    public var depositType: String?

    public var easEnable: Bool?

    public var emrVer: String?

    public var highAvailabilityEnable: Bool?

    public var hostGroup: [CreateClusterTemplateRequest.HostGroup]?

    public var initCustomHiveMetaDb: Bool?

    public var instanceGeneration: String?

    public var ioOptimized: Bool?

    public var isOpenPublicIp: Bool?

    public var keyPairName: String?

    public var logPath: String?

    public var machineType: String?

    public var masterPwd: String?

    public var metaStoreConf: String?

    public var metaStoreType: String?

    public var netType: String?

    public var optionSoftWareList: [String]?

    public var period: Int32?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerId: Int64?

    public var securityGroupId: String?

    public var securityGroupName: String?

    public var sshEnable: Bool?

    public var tag: [CreateClusterTemplateRequest.Tag]?

    public var templateName: String?

    public var useCustomHiveMetaDb: Bool?

    public var useLocalMetaDb: Bool?

    public var userDefinedEmrEcsRole: String?

    public var vSwitchId: String?

    public var vpcId: String?

    public var zoneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.autoRenew != nil {
            map["AutoRenew"] = self.autoRenew!
        }
        if self.bootstrapAction != nil {
            var tmp : [Any] = []
            for k in self.bootstrapAction! {
                tmp.append(k.toMap())
            }
            map["BootstrapAction"] = tmp
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.clusterType != nil {
            map["ClusterType"] = self.clusterType!
        }
        if self.config != nil {
            var tmp : [Any] = []
            for k in self.config! {
                tmp.append(k.toMap())
            }
            map["Config"] = tmp
        }
        if self.configurations != nil {
            map["Configurations"] = self.configurations!
        }
        if self.dataDiskEncrypted != nil {
            map["DataDiskEncrypted"] = self.dataDiskEncrypted!
        }
        if self.dataDiskKMSKeyId != nil {
            map["DataDiskKMSKeyId"] = self.dataDiskKMSKeyId!
        }
        if self.depositType != nil {
            map["DepositType"] = self.depositType!
        }
        if self.easEnable != nil {
            map["EasEnable"] = self.easEnable!
        }
        if self.emrVer != nil {
            map["EmrVer"] = self.emrVer!
        }
        if self.highAvailabilityEnable != nil {
            map["HighAvailabilityEnable"] = self.highAvailabilityEnable!
        }
        if self.hostGroup != nil {
            var tmp : [Any] = []
            for k in self.hostGroup! {
                tmp.append(k.toMap())
            }
            map["HostGroup"] = tmp
        }
        if self.initCustomHiveMetaDb != nil {
            map["InitCustomHiveMetaDb"] = self.initCustomHiveMetaDb!
        }
        if self.instanceGeneration != nil {
            map["InstanceGeneration"] = self.instanceGeneration!
        }
        if self.ioOptimized != nil {
            map["IoOptimized"] = self.ioOptimized!
        }
        if self.isOpenPublicIp != nil {
            map["IsOpenPublicIp"] = self.isOpenPublicIp!
        }
        if self.keyPairName != nil {
            map["KeyPairName"] = self.keyPairName!
        }
        if self.logPath != nil {
            map["LogPath"] = self.logPath!
        }
        if self.machineType != nil {
            map["MachineType"] = self.machineType!
        }
        if self.masterPwd != nil {
            map["MasterPwd"] = self.masterPwd!
        }
        if self.metaStoreConf != nil {
            map["MetaStoreConf"] = self.metaStoreConf!
        }
        if self.metaStoreType != nil {
            map["MetaStoreType"] = self.metaStoreType!
        }
        if self.netType != nil {
            map["NetType"] = self.netType!
        }
        if self.optionSoftWareList != nil {
            map["OptionSoftWareList"] = self.optionSoftWareList!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.securityGroupId != nil {
            map["SecurityGroupId"] = self.securityGroupId!
        }
        if self.securityGroupName != nil {
            map["SecurityGroupName"] = self.securityGroupName!
        }
        if self.sshEnable != nil {
            map["SshEnable"] = self.sshEnable!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.templateName != nil {
            map["TemplateName"] = self.templateName!
        }
        if self.useCustomHiveMetaDb != nil {
            map["UseCustomHiveMetaDb"] = self.useCustomHiveMetaDb!
        }
        if self.useLocalMetaDb != nil {
            map["UseLocalMetaDb"] = self.useLocalMetaDb!
        }
        if self.userDefinedEmrEcsRole != nil {
            map["UserDefinedEmrEcsRole"] = self.userDefinedEmrEcsRole!
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AutoRenew") && dict["AutoRenew"] != nil {
            self.autoRenew = dict["AutoRenew"] as! Bool
        }
        if dict.keys.contains("BootstrapAction") && dict["BootstrapAction"] != nil {
            var tmp : [CreateClusterTemplateRequest.BootstrapAction] = []
            for v in dict["BootstrapAction"] as! [Any] {
                var model = CreateClusterTemplateRequest.BootstrapAction()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.bootstrapAction = tmp
        }
        if dict.keys.contains("ClientToken") && dict["ClientToken"] != nil {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("ClusterType") && dict["ClusterType"] != nil {
            self.clusterType = dict["ClusterType"] as! String
        }
        if dict.keys.contains("Config") && dict["Config"] != nil {
            var tmp : [CreateClusterTemplateRequest.Config] = []
            for v in dict["Config"] as! [Any] {
                var model = CreateClusterTemplateRequest.Config()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.config = tmp
        }
        if dict.keys.contains("Configurations") && dict["Configurations"] != nil {
            self.configurations = dict["Configurations"] as! String
        }
        if dict.keys.contains("DataDiskEncrypted") && dict["DataDiskEncrypted"] != nil {
            self.dataDiskEncrypted = dict["DataDiskEncrypted"] as! Bool
        }
        if dict.keys.contains("DataDiskKMSKeyId") && dict["DataDiskKMSKeyId"] != nil {
            self.dataDiskKMSKeyId = dict["DataDiskKMSKeyId"] as! String
        }
        if dict.keys.contains("DepositType") && dict["DepositType"] != nil {
            self.depositType = dict["DepositType"] as! String
        }
        if dict.keys.contains("EasEnable") && dict["EasEnable"] != nil {
            self.easEnable = dict["EasEnable"] as! Bool
        }
        if dict.keys.contains("EmrVer") && dict["EmrVer"] != nil {
            self.emrVer = dict["EmrVer"] as! String
        }
        if dict.keys.contains("HighAvailabilityEnable") && dict["HighAvailabilityEnable"] != nil {
            self.highAvailabilityEnable = dict["HighAvailabilityEnable"] as! Bool
        }
        if dict.keys.contains("HostGroup") && dict["HostGroup"] != nil {
            var tmp : [CreateClusterTemplateRequest.HostGroup] = []
            for v in dict["HostGroup"] as! [Any] {
                var model = CreateClusterTemplateRequest.HostGroup()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.hostGroup = tmp
        }
        if dict.keys.contains("InitCustomHiveMetaDb") && dict["InitCustomHiveMetaDb"] != nil {
            self.initCustomHiveMetaDb = dict["InitCustomHiveMetaDb"] as! Bool
        }
        if dict.keys.contains("InstanceGeneration") && dict["InstanceGeneration"] != nil {
            self.instanceGeneration = dict["InstanceGeneration"] as! String
        }
        if dict.keys.contains("IoOptimized") && dict["IoOptimized"] != nil {
            self.ioOptimized = dict["IoOptimized"] as! Bool
        }
        if dict.keys.contains("IsOpenPublicIp") && dict["IsOpenPublicIp"] != nil {
            self.isOpenPublicIp = dict["IsOpenPublicIp"] as! Bool
        }
        if dict.keys.contains("KeyPairName") && dict["KeyPairName"] != nil {
            self.keyPairName = dict["KeyPairName"] as! String
        }
        if dict.keys.contains("LogPath") && dict["LogPath"] != nil {
            self.logPath = dict["LogPath"] as! String
        }
        if dict.keys.contains("MachineType") && dict["MachineType"] != nil {
            self.machineType = dict["MachineType"] as! String
        }
        if dict.keys.contains("MasterPwd") && dict["MasterPwd"] != nil {
            self.masterPwd = dict["MasterPwd"] as! String
        }
        if dict.keys.contains("MetaStoreConf") && dict["MetaStoreConf"] != nil {
            self.metaStoreConf = dict["MetaStoreConf"] as! String
        }
        if dict.keys.contains("MetaStoreType") && dict["MetaStoreType"] != nil {
            self.metaStoreType = dict["MetaStoreType"] as! String
        }
        if dict.keys.contains("NetType") && dict["NetType"] != nil {
            self.netType = dict["NetType"] as! String
        }
        if dict.keys.contains("OptionSoftWareList") && dict["OptionSoftWareList"] != nil {
            self.optionSoftWareList = dict["OptionSoftWareList"] as! [String]
        }
        if dict.keys.contains("Period") && dict["Period"] != nil {
            self.period = dict["Period"] as! Int32
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") && dict["ResourceGroupId"] != nil {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") && dict["ResourceOwnerId"] != nil {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("SecurityGroupId") && dict["SecurityGroupId"] != nil {
            self.securityGroupId = dict["SecurityGroupId"] as! String
        }
        if dict.keys.contains("SecurityGroupName") && dict["SecurityGroupName"] != nil {
            self.securityGroupName = dict["SecurityGroupName"] as! String
        }
        if dict.keys.contains("SshEnable") && dict["SshEnable"] != nil {
            self.sshEnable = dict["SshEnable"] as! Bool
        }
        if dict.keys.contains("Tag") && dict["Tag"] != nil {
            var tmp : [CreateClusterTemplateRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = CreateClusterTemplateRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
        if dict.keys.contains("TemplateName") && dict["TemplateName"] != nil {
            self.templateName = dict["TemplateName"] as! String
        }
        if dict.keys.contains("UseCustomHiveMetaDb") && dict["UseCustomHiveMetaDb"] != nil {
            self.useCustomHiveMetaDb = dict["UseCustomHiveMetaDb"] as! Bool
        }
        if dict.keys.contains("UseLocalMetaDb") && dict["UseLocalMetaDb"] != nil {
            self.useLocalMetaDb = dict["UseLocalMetaDb"] as! Bool
        }
        if dict.keys.contains("UserDefinedEmrEcsRole") && dict["UserDefinedEmrEcsRole"] != nil {
            self.userDefinedEmrEcsRole = dict["UserDefinedEmrEcsRole"] as! String
        }
        if dict.keys.contains("VSwitchId") && dict["VSwitchId"] != nil {
            self.vSwitchId = dict["VSwitchId"] as! String
        }
        if dict.keys.contains("VpcId") && dict["VpcId"] != nil {
            self.vpcId = dict["VpcId"] as! String
        }
        if dict.keys.contains("ZoneId") && dict["ZoneId"] != nil {
            self.zoneId = dict["ZoneId"] as! String
        }
    }
}

public class CreateClusterTemplateResponseBody : Tea.TeaModel {
    public var clusterTemplateId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterTemplateId != nil {
            map["ClusterTemplateId"] = self.clusterTemplateId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterTemplateId") && dict["ClusterTemplateId"] != nil {
            self.clusterTemplateId = dict["ClusterTemplateId"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateClusterTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateClusterTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateClusterTemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateClusterV2Request : Tea.TeaModel {
    public class BootstrapAction : Tea.TeaModel {
        public var arg: String?

        public var executionFailStrategy: String?

        public var executionMoment: String?

        public var executionTarget: String?

        public var name: String?

        public var path: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.arg != nil {
                map["Arg"] = self.arg!
            }
            if self.executionFailStrategy != nil {
                map["ExecutionFailStrategy"] = self.executionFailStrategy!
            }
            if self.executionMoment != nil {
                map["ExecutionMoment"] = self.executionMoment!
            }
            if self.executionTarget != nil {
                map["ExecutionTarget"] = self.executionTarget!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.path != nil {
                map["Path"] = self.path!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Arg") && dict["Arg"] != nil {
                self.arg = dict["Arg"] as! String
            }
            if dict.keys.contains("ExecutionFailStrategy") && dict["ExecutionFailStrategy"] != nil {
                self.executionFailStrategy = dict["ExecutionFailStrategy"] as! String
            }
            if dict.keys.contains("ExecutionMoment") && dict["ExecutionMoment"] != nil {
                self.executionMoment = dict["ExecutionMoment"] as! String
            }
            if dict.keys.contains("ExecutionTarget") && dict["ExecutionTarget"] != nil {
                self.executionTarget = dict["ExecutionTarget"] as! String
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Path") && dict["Path"] != nil {
                self.path = dict["Path"] as! String
            }
        }
    }
    public class Config : Tea.TeaModel {
        public var configKey: String?

        public var configValue: String?

        public var encrypt: String?

        public var fileName: String?

        public var replace: String?

        public var serviceName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.configKey != nil {
                map["ConfigKey"] = self.configKey!
            }
            if self.configValue != nil {
                map["ConfigValue"] = self.configValue!
            }
            if self.encrypt != nil {
                map["Encrypt"] = self.encrypt!
            }
            if self.fileName != nil {
                map["FileName"] = self.fileName!
            }
            if self.replace != nil {
                map["Replace"] = self.replace!
            }
            if self.serviceName != nil {
                map["ServiceName"] = self.serviceName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ConfigKey") && dict["ConfigKey"] != nil {
                self.configKey = dict["ConfigKey"] as! String
            }
            if dict.keys.contains("ConfigValue") && dict["ConfigValue"] != nil {
                self.configValue = dict["ConfigValue"] as! String
            }
            if dict.keys.contains("Encrypt") && dict["Encrypt"] != nil {
                self.encrypt = dict["Encrypt"] as! String
            }
            if dict.keys.contains("FileName") && dict["FileName"] != nil {
                self.fileName = dict["FileName"] as! String
            }
            if dict.keys.contains("Replace") && dict["Replace"] != nil {
                self.replace = dict["Replace"] as! String
            }
            if dict.keys.contains("ServiceName") && dict["ServiceName"] != nil {
                self.serviceName = dict["ServiceName"] as! String
            }
        }
    }
    public class HostComponentInfo : Tea.TeaModel {
        public var componentNameList: [String]?

        public var hostName: String?

        public var serviceName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.componentNameList != nil {
                map["ComponentNameList"] = self.componentNameList!
            }
            if self.hostName != nil {
                map["HostName"] = self.hostName!
            }
            if self.serviceName != nil {
                map["ServiceName"] = self.serviceName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ComponentNameList") && dict["ComponentNameList"] != nil {
                self.componentNameList = dict["ComponentNameList"] as! [String]
            }
            if dict.keys.contains("HostName") && dict["HostName"] != nil {
                self.hostName = dict["HostName"] as! String
            }
            if dict.keys.contains("ServiceName") && dict["ServiceName"] != nil {
                self.serviceName = dict["ServiceName"] as! String
            }
        }
    }
    public class HostGroup : Tea.TeaModel {
        public var autoRenew: Bool?

        public var chargeType: String?

        public var clusterId: String?

        public var comment: String?

        public var createType: String?

        public var diskCapacity: Int32?

        public var diskCount: Int32?

        public var diskType: String?

        public var gpuDriver: String?

        public var hostGroupId: String?

        public var hostGroupName: String?

        public var hostGroupType: String?

        public var instanceType: String?

        public var nodeCount: Int32?

        public var period: Int32?

        public var privatePoolOptionsId: String?

        public var privatePoolOptionsMatchCriteria: String?

        public var sysDiskCapacity: Int32?

        public var sysDiskType: String?

        public var vSwitchId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.autoRenew != nil {
                map["AutoRenew"] = self.autoRenew!
            }
            if self.chargeType != nil {
                map["ChargeType"] = self.chargeType!
            }
            if self.clusterId != nil {
                map["ClusterId"] = self.clusterId!
            }
            if self.comment != nil {
                map["Comment"] = self.comment!
            }
            if self.createType != nil {
                map["CreateType"] = self.createType!
            }
            if self.diskCapacity != nil {
                map["DiskCapacity"] = self.diskCapacity!
            }
            if self.diskCount != nil {
                map["DiskCount"] = self.diskCount!
            }
            if self.diskType != nil {
                map["DiskType"] = self.diskType!
            }
            if self.gpuDriver != nil {
                map["GpuDriver"] = self.gpuDriver!
            }
            if self.hostGroupId != nil {
                map["HostGroupId"] = self.hostGroupId!
            }
            if self.hostGroupName != nil {
                map["HostGroupName"] = self.hostGroupName!
            }
            if self.hostGroupType != nil {
                map["HostGroupType"] = self.hostGroupType!
            }
            if self.instanceType != nil {
                map["InstanceType"] = self.instanceType!
            }
            if self.nodeCount != nil {
                map["NodeCount"] = self.nodeCount!
            }
            if self.period != nil {
                map["Period"] = self.period!
            }
            if self.privatePoolOptionsId != nil {
                map["PrivatePoolOptionsId"] = self.privatePoolOptionsId!
            }
            if self.privatePoolOptionsMatchCriteria != nil {
                map["PrivatePoolOptionsMatchCriteria"] = self.privatePoolOptionsMatchCriteria!
            }
            if self.sysDiskCapacity != nil {
                map["SysDiskCapacity"] = self.sysDiskCapacity!
            }
            if self.sysDiskType != nil {
                map["SysDiskType"] = self.sysDiskType!
            }
            if self.vSwitchId != nil {
                map["VSwitchId"] = self.vSwitchId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AutoRenew") && dict["AutoRenew"] != nil {
                self.autoRenew = dict["AutoRenew"] as! Bool
            }
            if dict.keys.contains("ChargeType") && dict["ChargeType"] != nil {
                self.chargeType = dict["ChargeType"] as! String
            }
            if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
                self.clusterId = dict["ClusterId"] as! String
            }
            if dict.keys.contains("Comment") && dict["Comment"] != nil {
                self.comment = dict["Comment"] as! String
            }
            if dict.keys.contains("CreateType") && dict["CreateType"] != nil {
                self.createType = dict["CreateType"] as! String
            }
            if dict.keys.contains("DiskCapacity") && dict["DiskCapacity"] != nil {
                self.diskCapacity = dict["DiskCapacity"] as! Int32
            }
            if dict.keys.contains("DiskCount") && dict["DiskCount"] != nil {
                self.diskCount = dict["DiskCount"] as! Int32
            }
            if dict.keys.contains("DiskType") && dict["DiskType"] != nil {
                self.diskType = dict["DiskType"] as! String
            }
            if dict.keys.contains("GpuDriver") && dict["GpuDriver"] != nil {
                self.gpuDriver = dict["GpuDriver"] as! String
            }
            if dict.keys.contains("HostGroupId") && dict["HostGroupId"] != nil {
                self.hostGroupId = dict["HostGroupId"] as! String
            }
            if dict.keys.contains("HostGroupName") && dict["HostGroupName"] != nil {
                self.hostGroupName = dict["HostGroupName"] as! String
            }
            if dict.keys.contains("HostGroupType") && dict["HostGroupType"] != nil {
                self.hostGroupType = dict["HostGroupType"] as! String
            }
            if dict.keys.contains("InstanceType") && dict["InstanceType"] != nil {
                self.instanceType = dict["InstanceType"] as! String
            }
            if dict.keys.contains("NodeCount") && dict["NodeCount"] != nil {
                self.nodeCount = dict["NodeCount"] as! Int32
            }
            if dict.keys.contains("Period") && dict["Period"] != nil {
                self.period = dict["Period"] as! Int32
            }
            if dict.keys.contains("PrivatePoolOptionsId") && dict["PrivatePoolOptionsId"] != nil {
                self.privatePoolOptionsId = dict["PrivatePoolOptionsId"] as! String
            }
            if dict.keys.contains("PrivatePoolOptionsMatchCriteria") && dict["PrivatePoolOptionsMatchCriteria"] != nil {
                self.privatePoolOptionsMatchCriteria = dict["PrivatePoolOptionsMatchCriteria"] as! String
            }
            if dict.keys.contains("SysDiskCapacity") && dict["SysDiskCapacity"] != nil {
                self.sysDiskCapacity = dict["SysDiskCapacity"] as! Int32
            }
            if dict.keys.contains("SysDiskType") && dict["SysDiskType"] != nil {
                self.sysDiskType = dict["SysDiskType"] as! String
            }
            if dict.keys.contains("VSwitchId") && dict["VSwitchId"] != nil {
                self.vSwitchId = dict["VSwitchId"] as! String
            }
        }
    }
    public class PromotionInfo : Tea.TeaModel {
        public var productCode: String?

        public var promotionOptionCode: String?

        public var promotionOptionNo: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.productCode != nil {
                map["ProductCode"] = self.productCode!
            }
            if self.promotionOptionCode != nil {
                map["PromotionOptionCode"] = self.promotionOptionCode!
            }
            if self.promotionOptionNo != nil {
                map["PromotionOptionNo"] = self.promotionOptionNo!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ProductCode") && dict["ProductCode"] != nil {
                self.productCode = dict["ProductCode"] as! String
            }
            if dict.keys.contains("PromotionOptionCode") && dict["PromotionOptionCode"] != nil {
                self.promotionOptionCode = dict["PromotionOptionCode"] as! String
            }
            if dict.keys.contains("PromotionOptionNo") && dict["PromotionOptionNo"] != nil {
                self.promotionOptionNo = dict["PromotionOptionNo"] as! String
            }
        }
    }
    public class ServiceInfo : Tea.TeaModel {
        public var serviceName: String?

        public var serviceVersion: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.serviceName != nil {
                map["ServiceName"] = self.serviceName!
            }
            if self.serviceVersion != nil {
                map["ServiceVersion"] = self.serviceVersion!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ServiceName") && dict["ServiceName"] != nil {
                self.serviceName = dict["ServiceName"] as! String
            }
            if dict.keys.contains("ServiceVersion") && dict["ServiceVersion"] != nil {
                self.serviceVersion = dict["ServiceVersion"] as! String
            }
        }
    }
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") && dict["Key"] != nil {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") && dict["Value"] != nil {
                self.value = dict["Value"] as! String
            }
        }
    }
    public class UserInfo : Tea.TeaModel {
        public var password: String?

        public var userId: String?

        public var userName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.password != nil {
                map["Password"] = self.password!
            }
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            if self.userName != nil {
                map["UserName"] = self.userName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Password") && dict["Password"] != nil {
                self.password = dict["Password"] as! String
            }
            if dict.keys.contains("UserId") && dict["UserId"] != nil {
                self.userId = dict["UserId"] as! String
            }
            if dict.keys.contains("UserName") && dict["UserName"] != nil {
                self.userName = dict["UserName"] as! String
            }
        }
    }
    public var authorizeContent: String?

    public var autoPayOrder: Bool?

    public var autoRenew: Bool?

    public var bootstrapAction: [CreateClusterV2Request.BootstrapAction]?

    public var chargeType: String?

    public var clickHouseConf: String?

    public var clientToken: String?

    public var clusterType: String?

    public var config: [CreateClusterV2Request.Config]?

    public var configurations: String?

    public var dataDiskEncrypted: Bool?

    public var dataDiskKMSKeyId: String?

    public var depositType: String?

    public var easEnable: Bool?

    public var emrVer: String?

    public var extraAttributes: String?

    public var highAvailabilityEnable: Bool?

    public var hostComponentInfo: [CreateClusterV2Request.HostComponentInfo]?

    public var hostGroup: [CreateClusterV2Request.HostGroup]?

    public var initCustomHiveMetaDB: Bool?

    public var instanceGeneration: String?

    public var ioOptimized: Bool?

    public var isOpenPublicIp: Bool?

    public var keyPairName: String?

    public var logPath: String?

    public var machineType: String?

    public var masterPwd: String?

    public var metaStoreConf: String?

    public var metaStoreType: String?

    public var name: String?

    public var netType: String?

    public var optionSoftWareList: [String]?

    public var period: Int32?

    public var promotionInfo: [CreateClusterV2Request.PromotionInfo]?

    public var regionId: String?

    public var relatedClusterId: String?

    public var resourceGroupId: String?

    public var resourceOwnerId: Int64?

    public var securityGroupId: String?

    public var securityGroupName: String?

    public var serviceInfo: [CreateClusterV2Request.ServiceInfo]?

    public var sshEnable: Bool?

    public var tag: [CreateClusterV2Request.Tag]?

    public var useCustomHiveMetaDB: Bool?

    public var useLocalMetaDb: Bool?

    public var userDefinedEmrEcsRole: String?

    public var userInfo: [CreateClusterV2Request.UserInfo]?

    public var vSwitchId: String?

    public var vpcId: String?

    public var whiteListType: String?

    public var zoneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.authorizeContent != nil {
            map["AuthorizeContent"] = self.authorizeContent!
        }
        if self.autoPayOrder != nil {
            map["AutoPayOrder"] = self.autoPayOrder!
        }
        if self.autoRenew != nil {
            map["AutoRenew"] = self.autoRenew!
        }
        if self.bootstrapAction != nil {
            var tmp : [Any] = []
            for k in self.bootstrapAction! {
                tmp.append(k.toMap())
            }
            map["BootstrapAction"] = tmp
        }
        if self.chargeType != nil {
            map["ChargeType"] = self.chargeType!
        }
        if self.clickHouseConf != nil {
            map["ClickHouseConf"] = self.clickHouseConf!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.clusterType != nil {
            map["ClusterType"] = self.clusterType!
        }
        if self.config != nil {
            var tmp : [Any] = []
            for k in self.config! {
                tmp.append(k.toMap())
            }
            map["Config"] = tmp
        }
        if self.configurations != nil {
            map["Configurations"] = self.configurations!
        }
        if self.dataDiskEncrypted != nil {
            map["DataDiskEncrypted"] = self.dataDiskEncrypted!
        }
        if self.dataDiskKMSKeyId != nil {
            map["DataDiskKMSKeyId"] = self.dataDiskKMSKeyId!
        }
        if self.depositType != nil {
            map["DepositType"] = self.depositType!
        }
        if self.easEnable != nil {
            map["EasEnable"] = self.easEnable!
        }
        if self.emrVer != nil {
            map["EmrVer"] = self.emrVer!
        }
        if self.extraAttributes != nil {
            map["ExtraAttributes"] = self.extraAttributes!
        }
        if self.highAvailabilityEnable != nil {
            map["HighAvailabilityEnable"] = self.highAvailabilityEnable!
        }
        if self.hostComponentInfo != nil {
            var tmp : [Any] = []
            for k in self.hostComponentInfo! {
                tmp.append(k.toMap())
            }
            map["HostComponentInfo"] = tmp
        }
        if self.hostGroup != nil {
            var tmp : [Any] = []
            for k in self.hostGroup! {
                tmp.append(k.toMap())
            }
            map["HostGroup"] = tmp
        }
        if self.initCustomHiveMetaDB != nil {
            map["InitCustomHiveMetaDB"] = self.initCustomHiveMetaDB!
        }
        if self.instanceGeneration != nil {
            map["InstanceGeneration"] = self.instanceGeneration!
        }
        if self.ioOptimized != nil {
            map["IoOptimized"] = self.ioOptimized!
        }
        if self.isOpenPublicIp != nil {
            map["IsOpenPublicIp"] = self.isOpenPublicIp!
        }
        if self.keyPairName != nil {
            map["KeyPairName"] = self.keyPairName!
        }
        if self.logPath != nil {
            map["LogPath"] = self.logPath!
        }
        if self.machineType != nil {
            map["MachineType"] = self.machineType!
        }
        if self.masterPwd != nil {
            map["MasterPwd"] = self.masterPwd!
        }
        if self.metaStoreConf != nil {
            map["MetaStoreConf"] = self.metaStoreConf!
        }
        if self.metaStoreType != nil {
            map["MetaStoreType"] = self.metaStoreType!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.netType != nil {
            map["NetType"] = self.netType!
        }
        if self.optionSoftWareList != nil {
            map["OptionSoftWareList"] = self.optionSoftWareList!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.promotionInfo != nil {
            var tmp : [Any] = []
            for k in self.promotionInfo! {
                tmp.append(k.toMap())
            }
            map["PromotionInfo"] = tmp
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.relatedClusterId != nil {
            map["RelatedClusterId"] = self.relatedClusterId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.securityGroupId != nil {
            map["SecurityGroupId"] = self.securityGroupId!
        }
        if self.securityGroupName != nil {
            map["SecurityGroupName"] = self.securityGroupName!
        }
        if self.serviceInfo != nil {
            var tmp : [Any] = []
            for k in self.serviceInfo! {
                tmp.append(k.toMap())
            }
            map["ServiceInfo"] = tmp
        }
        if self.sshEnable != nil {
            map["SshEnable"] = self.sshEnable!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.useCustomHiveMetaDB != nil {
            map["UseCustomHiveMetaDB"] = self.useCustomHiveMetaDB!
        }
        if self.useLocalMetaDb != nil {
            map["UseLocalMetaDb"] = self.useLocalMetaDb!
        }
        if self.userDefinedEmrEcsRole != nil {
            map["UserDefinedEmrEcsRole"] = self.userDefinedEmrEcsRole!
        }
        if self.userInfo != nil {
            var tmp : [Any] = []
            for k in self.userInfo! {
                tmp.append(k.toMap())
            }
            map["UserInfo"] = tmp
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        if self.whiteListType != nil {
            map["WhiteListType"] = self.whiteListType!
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AuthorizeContent") && dict["AuthorizeContent"] != nil {
            self.authorizeContent = dict["AuthorizeContent"] as! String
        }
        if dict.keys.contains("AutoPayOrder") && dict["AutoPayOrder"] != nil {
            self.autoPayOrder = dict["AutoPayOrder"] as! Bool
        }
        if dict.keys.contains("AutoRenew") && dict["AutoRenew"] != nil {
            self.autoRenew = dict["AutoRenew"] as! Bool
        }
        if dict.keys.contains("BootstrapAction") && dict["BootstrapAction"] != nil {
            var tmp : [CreateClusterV2Request.BootstrapAction] = []
            for v in dict["BootstrapAction"] as! [Any] {
                var model = CreateClusterV2Request.BootstrapAction()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.bootstrapAction = tmp
        }
        if dict.keys.contains("ChargeType") && dict["ChargeType"] != nil {
            self.chargeType = dict["ChargeType"] as! String
        }
        if dict.keys.contains("ClickHouseConf") && dict["ClickHouseConf"] != nil {
            self.clickHouseConf = dict["ClickHouseConf"] as! String
        }
        if dict.keys.contains("ClientToken") && dict["ClientToken"] != nil {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("ClusterType") && dict["ClusterType"] != nil {
            self.clusterType = dict["ClusterType"] as! String
        }
        if dict.keys.contains("Config") && dict["Config"] != nil {
            var tmp : [CreateClusterV2Request.Config] = []
            for v in dict["Config"] as! [Any] {
                var model = CreateClusterV2Request.Config()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.config = tmp
        }
        if dict.keys.contains("Configurations") && dict["Configurations"] != nil {
            self.configurations = dict["Configurations"] as! String
        }
        if dict.keys.contains("DataDiskEncrypted") && dict["DataDiskEncrypted"] != nil {
            self.dataDiskEncrypted = dict["DataDiskEncrypted"] as! Bool
        }
        if dict.keys.contains("DataDiskKMSKeyId") && dict["DataDiskKMSKeyId"] != nil {
            self.dataDiskKMSKeyId = dict["DataDiskKMSKeyId"] as! String
        }
        if dict.keys.contains("DepositType") && dict["DepositType"] != nil {
            self.depositType = dict["DepositType"] as! String
        }
        if dict.keys.contains("EasEnable") && dict["EasEnable"] != nil {
            self.easEnable = dict["EasEnable"] as! Bool
        }
        if dict.keys.contains("EmrVer") && dict["EmrVer"] != nil {
            self.emrVer = dict["EmrVer"] as! String
        }
        if dict.keys.contains("ExtraAttributes") && dict["ExtraAttributes"] != nil {
            self.extraAttributes = dict["ExtraAttributes"] as! String
        }
        if dict.keys.contains("HighAvailabilityEnable") && dict["HighAvailabilityEnable"] != nil {
            self.highAvailabilityEnable = dict["HighAvailabilityEnable"] as! Bool
        }
        if dict.keys.contains("HostComponentInfo") && dict["HostComponentInfo"] != nil {
            var tmp : [CreateClusterV2Request.HostComponentInfo] = []
            for v in dict["HostComponentInfo"] as! [Any] {
                var model = CreateClusterV2Request.HostComponentInfo()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.hostComponentInfo = tmp
        }
        if dict.keys.contains("HostGroup") && dict["HostGroup"] != nil {
            var tmp : [CreateClusterV2Request.HostGroup] = []
            for v in dict["HostGroup"] as! [Any] {
                var model = CreateClusterV2Request.HostGroup()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.hostGroup = tmp
        }
        if dict.keys.contains("InitCustomHiveMetaDB") && dict["InitCustomHiveMetaDB"] != nil {
            self.initCustomHiveMetaDB = dict["InitCustomHiveMetaDB"] as! Bool
        }
        if dict.keys.contains("InstanceGeneration") && dict["InstanceGeneration"] != nil {
            self.instanceGeneration = dict["InstanceGeneration"] as! String
        }
        if dict.keys.contains("IoOptimized") && dict["IoOptimized"] != nil {
            self.ioOptimized = dict["IoOptimized"] as! Bool
        }
        if dict.keys.contains("IsOpenPublicIp") && dict["IsOpenPublicIp"] != nil {
            self.isOpenPublicIp = dict["IsOpenPublicIp"] as! Bool
        }
        if dict.keys.contains("KeyPairName") && dict["KeyPairName"] != nil {
            self.keyPairName = dict["KeyPairName"] as! String
        }
        if dict.keys.contains("LogPath") && dict["LogPath"] != nil {
            self.logPath = dict["LogPath"] as! String
        }
        if dict.keys.contains("MachineType") && dict["MachineType"] != nil {
            self.machineType = dict["MachineType"] as! String
        }
        if dict.keys.contains("MasterPwd") && dict["MasterPwd"] != nil {
            self.masterPwd = dict["MasterPwd"] as! String
        }
        if dict.keys.contains("MetaStoreConf") && dict["MetaStoreConf"] != nil {
            self.metaStoreConf = dict["MetaStoreConf"] as! String
        }
        if dict.keys.contains("MetaStoreType") && dict["MetaStoreType"] != nil {
            self.metaStoreType = dict["MetaStoreType"] as! String
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("NetType") && dict["NetType"] != nil {
            self.netType = dict["NetType"] as! String
        }
        if dict.keys.contains("OptionSoftWareList") && dict["OptionSoftWareList"] != nil {
            self.optionSoftWareList = dict["OptionSoftWareList"] as! [String]
        }
        if dict.keys.contains("Period") && dict["Period"] != nil {
            self.period = dict["Period"] as! Int32
        }
        if dict.keys.contains("PromotionInfo") && dict["PromotionInfo"] != nil {
            var tmp : [CreateClusterV2Request.PromotionInfo] = []
            for v in dict["PromotionInfo"] as! [Any] {
                var model = CreateClusterV2Request.PromotionInfo()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.promotionInfo = tmp
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("RelatedClusterId") && dict["RelatedClusterId"] != nil {
            self.relatedClusterId = dict["RelatedClusterId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") && dict["ResourceGroupId"] != nil {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") && dict["ResourceOwnerId"] != nil {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("SecurityGroupId") && dict["SecurityGroupId"] != nil {
            self.securityGroupId = dict["SecurityGroupId"] as! String
        }
        if dict.keys.contains("SecurityGroupName") && dict["SecurityGroupName"] != nil {
            self.securityGroupName = dict["SecurityGroupName"] as! String
        }
        if dict.keys.contains("ServiceInfo") && dict["ServiceInfo"] != nil {
            var tmp : [CreateClusterV2Request.ServiceInfo] = []
            for v in dict["ServiceInfo"] as! [Any] {
                var model = CreateClusterV2Request.ServiceInfo()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.serviceInfo = tmp
        }
        if dict.keys.contains("SshEnable") && dict["SshEnable"] != nil {
            self.sshEnable = dict["SshEnable"] as! Bool
        }
        if dict.keys.contains("Tag") && dict["Tag"] != nil {
            var tmp : [CreateClusterV2Request.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = CreateClusterV2Request.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
        if dict.keys.contains("UseCustomHiveMetaDB") && dict["UseCustomHiveMetaDB"] != nil {
            self.useCustomHiveMetaDB = dict["UseCustomHiveMetaDB"] as! Bool
        }
        if dict.keys.contains("UseLocalMetaDb") && dict["UseLocalMetaDb"] != nil {
            self.useLocalMetaDb = dict["UseLocalMetaDb"] as! Bool
        }
        if dict.keys.contains("UserDefinedEmrEcsRole") && dict["UserDefinedEmrEcsRole"] != nil {
            self.userDefinedEmrEcsRole = dict["UserDefinedEmrEcsRole"] as! String
        }
        if dict.keys.contains("UserInfo") && dict["UserInfo"] != nil {
            var tmp : [CreateClusterV2Request.UserInfo] = []
            for v in dict["UserInfo"] as! [Any] {
                var model = CreateClusterV2Request.UserInfo()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.userInfo = tmp
        }
        if dict.keys.contains("VSwitchId") && dict["VSwitchId"] != nil {
            self.vSwitchId = dict["VSwitchId"] as! String
        }
        if dict.keys.contains("VpcId") && dict["VpcId"] != nil {
            self.vpcId = dict["VpcId"] as! String
        }
        if dict.keys.contains("WhiteListType") && dict["WhiteListType"] != nil {
            self.whiteListType = dict["WhiteListType"] as! String
        }
        if dict.keys.contains("ZoneId") && dict["ZoneId"] != nil {
            self.zoneId = dict["ZoneId"] as! String
        }
    }
}

public class CreateClusterV2ResponseBody : Tea.TeaModel {
    public var clusterId: String?

    public var coreOrderId: String?

    public var emrOrderId: String?

    public var masterOrderId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.coreOrderId != nil {
            map["CoreOrderId"] = self.coreOrderId!
        }
        if self.emrOrderId != nil {
            map["EmrOrderId"] = self.emrOrderId!
        }
        if self.masterOrderId != nil {
            map["MasterOrderId"] = self.masterOrderId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("CoreOrderId") && dict["CoreOrderId"] != nil {
            self.coreOrderId = dict["CoreOrderId"] as! String
        }
        if dict.keys.contains("EmrOrderId") && dict["EmrOrderId"] != nil {
            self.emrOrderId = dict["EmrOrderId"] as! String
        }
        if dict.keys.contains("MasterOrderId") && dict["MasterOrderId"] != nil {
            self.masterOrderId = dict["MasterOrderId"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateClusterV2Response : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateClusterV2ResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateClusterV2ResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateClusterWithTemplateRequest : Tea.TeaModel {
    public var clientToken: String?

    public var clusterName: String?

    public var resourceGroupId: String?

    public var resourceOwnerId: Int64?

    public var templateBizId: String?

    public var uniqueTag: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.clusterName != nil {
            map["ClusterName"] = self.clusterName!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.templateBizId != nil {
            map["TemplateBizId"] = self.templateBizId!
        }
        if self.uniqueTag != nil {
            map["UniqueTag"] = self.uniqueTag!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") && dict["ClientToken"] != nil {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("ClusterName") && dict["ClusterName"] != nil {
            self.clusterName = dict["ClusterName"] as! String
        }
        if dict.keys.contains("ResourceGroupId") && dict["ResourceGroupId"] != nil {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") && dict["ResourceOwnerId"] != nil {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("TemplateBizId") && dict["TemplateBizId"] != nil {
            self.templateBizId = dict["TemplateBizId"] as! String
        }
        if dict.keys.contains("UniqueTag") && dict["UniqueTag"] != nil {
            self.uniqueTag = dict["UniqueTag"] as! String
        }
    }
}

public class CreateClusterWithTemplateResponseBody : Tea.TeaModel {
    public var clusterId: String?

    public var coreOrderId: String?

    public var emrOrderId: String?

    public var masterOrderId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.coreOrderId != nil {
            map["CoreOrderId"] = self.coreOrderId!
        }
        if self.emrOrderId != nil {
            map["EmrOrderId"] = self.emrOrderId!
        }
        if self.masterOrderId != nil {
            map["MasterOrderId"] = self.masterOrderId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("CoreOrderId") && dict["CoreOrderId"] != nil {
            self.coreOrderId = dict["CoreOrderId"] as! String
        }
        if dict.keys.contains("EmrOrderId") && dict["EmrOrderId"] != nil {
            self.emrOrderId = dict["EmrOrderId"] as! String
        }
        if dict.keys.contains("MasterOrderId") && dict["MasterOrderId"] != nil {
            self.masterOrderId = dict["MasterOrderId"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateClusterWithTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateClusterWithTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateClusterWithTemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateFlowRequest : Tea.TeaModel {
    public var alertConf: String?

    public var alertDingDingGroupBizId: String?

    public var alertUserGroupBizId: String?

    public var application: String?

    public var clusterId: String?

    public var createCluster: Bool?

    public var cronExpr: String?

    public var description_: String?

    public var endSchedule: Int64?

    public var hostName: String?

    public var lifecycle: String?

    public var logArchiveLocation: String?

    public var name: String?

    public var namespace: String?

    public var parentCategory: String?

    public var parentFlowList: String?

    public var projectId: String?

    public var regionId: String?

    public var startSchedule: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.alertConf != nil {
            map["AlertConf"] = self.alertConf!
        }
        if self.alertDingDingGroupBizId != nil {
            map["AlertDingDingGroupBizId"] = self.alertDingDingGroupBizId!
        }
        if self.alertUserGroupBizId != nil {
            map["AlertUserGroupBizId"] = self.alertUserGroupBizId!
        }
        if self.application != nil {
            map["Application"] = self.application!
        }
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.createCluster != nil {
            map["CreateCluster"] = self.createCluster!
        }
        if self.cronExpr != nil {
            map["CronExpr"] = self.cronExpr!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.endSchedule != nil {
            map["EndSchedule"] = self.endSchedule!
        }
        if self.hostName != nil {
            map["HostName"] = self.hostName!
        }
        if self.lifecycle != nil {
            map["Lifecycle"] = self.lifecycle!
        }
        if self.logArchiveLocation != nil {
            map["LogArchiveLocation"] = self.logArchiveLocation!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        if self.parentCategory != nil {
            map["ParentCategory"] = self.parentCategory!
        }
        if self.parentFlowList != nil {
            map["ParentFlowList"] = self.parentFlowList!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.startSchedule != nil {
            map["StartSchedule"] = self.startSchedule!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AlertConf") && dict["AlertConf"] != nil {
            self.alertConf = dict["AlertConf"] as! String
        }
        if dict.keys.contains("AlertDingDingGroupBizId") && dict["AlertDingDingGroupBizId"] != nil {
            self.alertDingDingGroupBizId = dict["AlertDingDingGroupBizId"] as! String
        }
        if dict.keys.contains("AlertUserGroupBizId") && dict["AlertUserGroupBizId"] != nil {
            self.alertUserGroupBizId = dict["AlertUserGroupBizId"] as! String
        }
        if dict.keys.contains("Application") && dict["Application"] != nil {
            self.application = dict["Application"] as! String
        }
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("CreateCluster") && dict["CreateCluster"] != nil {
            self.createCluster = dict["CreateCluster"] as! Bool
        }
        if dict.keys.contains("CronExpr") && dict["CronExpr"] != nil {
            self.cronExpr = dict["CronExpr"] as! String
        }
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("EndSchedule") && dict["EndSchedule"] != nil {
            self.endSchedule = dict["EndSchedule"] as! Int64
        }
        if dict.keys.contains("HostName") && dict["HostName"] != nil {
            self.hostName = dict["HostName"] as! String
        }
        if dict.keys.contains("Lifecycle") && dict["Lifecycle"] != nil {
            self.lifecycle = dict["Lifecycle"] as! String
        }
        if dict.keys.contains("LogArchiveLocation") && dict["LogArchiveLocation"] != nil {
            self.logArchiveLocation = dict["LogArchiveLocation"] as! String
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
            self.namespace = dict["Namespace"] as! String
        }
        if dict.keys.contains("ParentCategory") && dict["ParentCategory"] != nil {
            self.parentCategory = dict["ParentCategory"] as! String
        }
        if dict.keys.contains("ParentFlowList") && dict["ParentFlowList"] != nil {
            self.parentFlowList = dict["ParentFlowList"] as! String
        }
        if dict.keys.contains("ProjectId") && dict["ProjectId"] != nil {
            self.projectId = dict["ProjectId"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("StartSchedule") && dict["StartSchedule"] != nil {
            self.startSchedule = dict["StartSchedule"] as! Int64
        }
    }
}

public class CreateFlowResponseBody : Tea.TeaModel {
    public var id: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateFlowResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateFlowResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateFlowResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateFlowCategoryRequest : Tea.TeaModel {
    public var name: String?

    public var parentId: String?

    public var projectId: String?

    public var regionId: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.parentId != nil {
            map["ParentId"] = self.parentId!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("ParentId") && dict["ParentId"] != nil {
            self.parentId = dict["ParentId"] as! String
        }
        if dict.keys.contains("ProjectId") && dict["ProjectId"] != nil {
            self.projectId = dict["ProjectId"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! String
        }
    }
}

public class CreateFlowCategoryResponseBody : Tea.TeaModel {
    public var id: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateFlowCategoryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateFlowCategoryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateFlowCategoryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateFlowForWebRequest : Tea.TeaModel {
    public var alertConf: String?

    public var alertDingDingGroupBizId: String?

    public var alertUserGroupBizId: String?

    public var clusterId: String?

    public var createCluster: Bool?

    public var cronExpr: String?

    public var description_: String?

    public var endSchedule: Int64?

    public var graph: String?

    public var hostName: String?

    public var lifecycle: String?

    public var logArchiveLocation: String?

    public var name: String?

    public var namespace: String?

    public var parentCategory: String?

    public var parentFlowList: String?

    public var projectId: String?

    public var regionId: String?

    public var startSchedule: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.alertConf != nil {
            map["AlertConf"] = self.alertConf!
        }
        if self.alertDingDingGroupBizId != nil {
            map["AlertDingDingGroupBizId"] = self.alertDingDingGroupBizId!
        }
        if self.alertUserGroupBizId != nil {
            map["AlertUserGroupBizId"] = self.alertUserGroupBizId!
        }
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.createCluster != nil {
            map["CreateCluster"] = self.createCluster!
        }
        if self.cronExpr != nil {
            map["CronExpr"] = self.cronExpr!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.endSchedule != nil {
            map["EndSchedule"] = self.endSchedule!
        }
        if self.graph != nil {
            map["Graph"] = self.graph!
        }
        if self.hostName != nil {
            map["HostName"] = self.hostName!
        }
        if self.lifecycle != nil {
            map["Lifecycle"] = self.lifecycle!
        }
        if self.logArchiveLocation != nil {
            map["LogArchiveLocation"] = self.logArchiveLocation!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        if self.parentCategory != nil {
            map["ParentCategory"] = self.parentCategory!
        }
        if self.parentFlowList != nil {
            map["ParentFlowList"] = self.parentFlowList!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.startSchedule != nil {
            map["StartSchedule"] = self.startSchedule!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AlertConf") && dict["AlertConf"] != nil {
            self.alertConf = dict["AlertConf"] as! String
        }
        if dict.keys.contains("AlertDingDingGroupBizId") && dict["AlertDingDingGroupBizId"] != nil {
            self.alertDingDingGroupBizId = dict["AlertDingDingGroupBizId"] as! String
        }
        if dict.keys.contains("AlertUserGroupBizId") && dict["AlertUserGroupBizId"] != nil {
            self.alertUserGroupBizId = dict["AlertUserGroupBizId"] as! String
        }
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("CreateCluster") && dict["CreateCluster"] != nil {
            self.createCluster = dict["CreateCluster"] as! Bool
        }
        if dict.keys.contains("CronExpr") && dict["CronExpr"] != nil {
            self.cronExpr = dict["CronExpr"] as! String
        }
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("EndSchedule") && dict["EndSchedule"] != nil {
            self.endSchedule = dict["EndSchedule"] as! Int64
        }
        if dict.keys.contains("Graph") && dict["Graph"] != nil {
            self.graph = dict["Graph"] as! String
        }
        if dict.keys.contains("HostName") && dict["HostName"] != nil {
            self.hostName = dict["HostName"] as! String
        }
        if dict.keys.contains("Lifecycle") && dict["Lifecycle"] != nil {
            self.lifecycle = dict["Lifecycle"] as! String
        }
        if dict.keys.contains("LogArchiveLocation") && dict["LogArchiveLocation"] != nil {
            self.logArchiveLocation = dict["LogArchiveLocation"] as! String
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
            self.namespace = dict["Namespace"] as! String
        }
        if dict.keys.contains("ParentCategory") && dict["ParentCategory"] != nil {
            self.parentCategory = dict["ParentCategory"] as! String
        }
        if dict.keys.contains("ParentFlowList") && dict["ParentFlowList"] != nil {
            self.parentFlowList = dict["ParentFlowList"] as! String
        }
        if dict.keys.contains("ProjectId") && dict["ProjectId"] != nil {
            self.projectId = dict["ProjectId"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("StartSchedule") && dict["StartSchedule"] != nil {
            self.startSchedule = dict["StartSchedule"] as! Int64
        }
    }
}

public class CreateFlowForWebResponseBody : Tea.TeaModel {
    public var id: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateFlowForWebResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateFlowForWebResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateFlowForWebResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateFlowJobRequest : Tea.TeaModel {
    public class ResourceList : Tea.TeaModel {
        public var alias: String?

        public var path: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.alias != nil {
                map["Alias"] = self.alias!
            }
            if self.path != nil {
                map["Path"] = self.path!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Alias") && dict["Alias"] != nil {
                self.alias = dict["Alias"] as! String
            }
            if dict.keys.contains("Path") && dict["Path"] != nil {
                self.path = dict["Path"] as! String
            }
        }
    }
    public var adhoc: Bool?

    public var alertConf: String?

    public var clusterId: String?

    public var customVariables: String?

    public var description_: String?

    public var envConf: String?

    public var failAct: String?

    public var maxRetry: Int32?

    public var maxRunningTimeSec: Int64?

    public var mode: String?

    public var monitorConf: String?

    public var name: String?

    public var paramConf: String?

    public var params: String?

    public var parentCategory: String?

    public var projectId: String?

    public var regionId: String?

    public var resourceList: [CreateFlowJobRequest.ResourceList]?

    public var retryInterval: Int64?

    public var retryPolicy: String?

    public var runConf: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.adhoc != nil {
            map["Adhoc"] = self.adhoc!
        }
        if self.alertConf != nil {
            map["AlertConf"] = self.alertConf!
        }
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.customVariables != nil {
            map["CustomVariables"] = self.customVariables!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.envConf != nil {
            map["EnvConf"] = self.envConf!
        }
        if self.failAct != nil {
            map["FailAct"] = self.failAct!
        }
        if self.maxRetry != nil {
            map["MaxRetry"] = self.maxRetry!
        }
        if self.maxRunningTimeSec != nil {
            map["MaxRunningTimeSec"] = self.maxRunningTimeSec!
        }
        if self.mode != nil {
            map["Mode"] = self.mode!
        }
        if self.monitorConf != nil {
            map["MonitorConf"] = self.monitorConf!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.paramConf != nil {
            map["ParamConf"] = self.paramConf!
        }
        if self.params != nil {
            map["Params"] = self.params!
        }
        if self.parentCategory != nil {
            map["ParentCategory"] = self.parentCategory!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceList != nil {
            var tmp : [Any] = []
            for k in self.resourceList! {
                tmp.append(k.toMap())
            }
            map["ResourceList"] = tmp
        }
        if self.retryInterval != nil {
            map["RetryInterval"] = self.retryInterval!
        }
        if self.retryPolicy != nil {
            map["RetryPolicy"] = self.retryPolicy!
        }
        if self.runConf != nil {
            map["RunConf"] = self.runConf!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Adhoc") && dict["Adhoc"] != nil {
            self.adhoc = dict["Adhoc"] as! Bool
        }
        if dict.keys.contains("AlertConf") && dict["AlertConf"] != nil {
            self.alertConf = dict["AlertConf"] as! String
        }
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("CustomVariables") && dict["CustomVariables"] != nil {
            self.customVariables = dict["CustomVariables"] as! String
        }
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("EnvConf") && dict["EnvConf"] != nil {
            self.envConf = dict["EnvConf"] as! String
        }
        if dict.keys.contains("FailAct") && dict["FailAct"] != nil {
            self.failAct = dict["FailAct"] as! String
        }
        if dict.keys.contains("MaxRetry") && dict["MaxRetry"] != nil {
            self.maxRetry = dict["MaxRetry"] as! Int32
        }
        if dict.keys.contains("MaxRunningTimeSec") && dict["MaxRunningTimeSec"] != nil {
            self.maxRunningTimeSec = dict["MaxRunningTimeSec"] as! Int64
        }
        if dict.keys.contains("Mode") && dict["Mode"] != nil {
            self.mode = dict["Mode"] as! String
        }
        if dict.keys.contains("MonitorConf") && dict["MonitorConf"] != nil {
            self.monitorConf = dict["MonitorConf"] as! String
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("ParamConf") && dict["ParamConf"] != nil {
            self.paramConf = dict["ParamConf"] as! String
        }
        if dict.keys.contains("Params") && dict["Params"] != nil {
            self.params = dict["Params"] as! String
        }
        if dict.keys.contains("ParentCategory") && dict["ParentCategory"] != nil {
            self.parentCategory = dict["ParentCategory"] as! String
        }
        if dict.keys.contains("ProjectId") && dict["ProjectId"] != nil {
            self.projectId = dict["ProjectId"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceList") && dict["ResourceList"] != nil {
            var tmp : [CreateFlowJobRequest.ResourceList] = []
            for v in dict["ResourceList"] as! [Any] {
                var model = CreateFlowJobRequest.ResourceList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.resourceList = tmp
        }
        if dict.keys.contains("RetryInterval") && dict["RetryInterval"] != nil {
            self.retryInterval = dict["RetryInterval"] as! Int64
        }
        if dict.keys.contains("RetryPolicy") && dict["RetryPolicy"] != nil {
            self.retryPolicy = dict["RetryPolicy"] as! String
        }
        if dict.keys.contains("RunConf") && dict["RunConf"] != nil {
            self.runConf = dict["RunConf"] as! String
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! String
        }
    }
}

public class CreateFlowJobResponseBody : Tea.TeaModel {
    public var id: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateFlowJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateFlowJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateFlowJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateFlowProjectRequest : Tea.TeaModel {
    public var description_: String?

    public var name: String?

    public var productType: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.productType != nil {
            map["ProductType"] = self.productType!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("ProductType") && dict["ProductType"] != nil {
            self.productType = dict["ProductType"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") && dict["ResourceGroupId"] != nil {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
    }
}

public class CreateFlowProjectResponseBody : Tea.TeaModel {
    public var id: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateFlowProjectResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateFlowProjectResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateFlowProjectResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateFlowProjectClusterSettingRequest : Tea.TeaModel {
    public var clusterId: String?

    public var defaultQueue: String?

    public var defaultUser: String?

    public var hostList: [String]?

    public var projectId: String?

    public var queueList: [String]?

    public var regionId: String?

    public var userList: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.defaultQueue != nil {
            map["DefaultQueue"] = self.defaultQueue!
        }
        if self.defaultUser != nil {
            map["DefaultUser"] = self.defaultUser!
        }
        if self.hostList != nil {
            map["HostList"] = self.hostList!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.queueList != nil {
            map["QueueList"] = self.queueList!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.userList != nil {
            map["UserList"] = self.userList!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("DefaultQueue") && dict["DefaultQueue"] != nil {
            self.defaultQueue = dict["DefaultQueue"] as! String
        }
        if dict.keys.contains("DefaultUser") && dict["DefaultUser"] != nil {
            self.defaultUser = dict["DefaultUser"] as! String
        }
        if dict.keys.contains("HostList") && dict["HostList"] != nil {
            self.hostList = dict["HostList"] as! [String]
        }
        if dict.keys.contains("ProjectId") && dict["ProjectId"] != nil {
            self.projectId = dict["ProjectId"] as! String
        }
        if dict.keys.contains("QueueList") && dict["QueueList"] != nil {
            self.queueList = dict["QueueList"] as! [String]
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("UserList") && dict["UserList"] != nil {
            self.userList = dict["UserList"] as! [String]
        }
    }
}

public class CreateFlowProjectClusterSettingResponseBody : Tea.TeaModel {
    public var data: Bool?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! Bool
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateFlowProjectClusterSettingResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateFlowProjectClusterSettingResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateFlowProjectClusterSettingResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateFlowProjectUserRequest : Tea.TeaModel {
    public class User : Tea.TeaModel {
        public var userId: String?

        public var userName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            if self.userName != nil {
                map["UserName"] = self.userName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("UserId") && dict["UserId"] != nil {
                self.userId = dict["UserId"] as! String
            }
            if dict.keys.contains("UserName") && dict["UserName"] != nil {
                self.userName = dict["UserName"] as! String
            }
        }
    }
    public var projectId: String?

    public var regionId: String?

    public var user: [CreateFlowProjectUserRequest.User]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.user != nil {
            var tmp : [Any] = []
            for k in self.user! {
                tmp.append(k.toMap())
            }
            map["User"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ProjectId") && dict["ProjectId"] != nil {
            self.projectId = dict["ProjectId"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("User") && dict["User"] != nil {
            var tmp : [CreateFlowProjectUserRequest.User] = []
            for v in dict["User"] as! [Any] {
                var model = CreateFlowProjectUserRequest.User()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.user = tmp
        }
    }
}

public class CreateFlowProjectUserResponseBody : Tea.TeaModel {
    public var data: Bool?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! Bool
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateFlowProjectUserResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateFlowProjectUserResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateFlowProjectUserResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateResourcePoolRequest : Tea.TeaModel {
    public class Config : Tea.TeaModel {
        public var category: String?

        public var configKey: String?

        public var configValue: String?

        public var note: String?

        public var targetId: String?

        public var configType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.category != nil {
                map["Category"] = self.category!
            }
            if self.configKey != nil {
                map["ConfigKey"] = self.configKey!
            }
            if self.configValue != nil {
                map["ConfigValue"] = self.configValue!
            }
            if self.note != nil {
                map["Note"] = self.note!
            }
            if self.targetId != nil {
                map["TargetId"] = self.targetId!
            }
            if self.configType != nil {
                map["configType"] = self.configType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Category") && dict["Category"] != nil {
                self.category = dict["Category"] as! String
            }
            if dict.keys.contains("ConfigKey") && dict["ConfigKey"] != nil {
                self.configKey = dict["ConfigKey"] as! String
            }
            if dict.keys.contains("ConfigValue") && dict["ConfigValue"] != nil {
                self.configValue = dict["ConfigValue"] as! String
            }
            if dict.keys.contains("Note") && dict["Note"] != nil {
                self.note = dict["Note"] as! String
            }
            if dict.keys.contains("TargetId") && dict["TargetId"] != nil {
                self.targetId = dict["TargetId"] as! String
            }
            if dict.keys.contains("configType") && dict["configType"] != nil {
                self.configType = dict["configType"] as! String
            }
        }
    }
    public var active: Bool?

    public var clusterId: String?

    public var config: [CreateResourcePoolRequest.Config]?

    public var name: String?

    public var note: String?

    public var poolType: String?

    public var regionId: String?

    public var resourceOwnerId: Int64?

    public var yarnSiteConfig: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.active != nil {
            map["Active"] = self.active!
        }
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.config != nil {
            var tmp : [Any] = []
            for k in self.config! {
                tmp.append(k.toMap())
            }
            map["Config"] = tmp
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.note != nil {
            map["Note"] = self.note!
        }
        if self.poolType != nil {
            map["PoolType"] = self.poolType!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.yarnSiteConfig != nil {
            map["YarnSiteConfig"] = self.yarnSiteConfig!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Active") && dict["Active"] != nil {
            self.active = dict["Active"] as! Bool
        }
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("Config") && dict["Config"] != nil {
            var tmp : [CreateResourcePoolRequest.Config] = []
            for v in dict["Config"] as! [Any] {
                var model = CreateResourcePoolRequest.Config()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.config = tmp
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Note") && dict["Note"] != nil {
            self.note = dict["Note"] as! String
        }
        if dict.keys.contains("PoolType") && dict["PoolType"] != nil {
            self.poolType = dict["PoolType"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") && dict["ResourceOwnerId"] != nil {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("YarnSiteConfig") && dict["YarnSiteConfig"] != nil {
            self.yarnSiteConfig = dict["YarnSiteConfig"] as! String
        }
    }
}

public class CreateResourcePoolResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateResourcePoolResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateResourcePoolResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateResourcePoolResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateResourceQueueRequest : Tea.TeaModel {
    public class Config : Tea.TeaModel {
        public var category: String?

        public var configKey: String?

        public var configValue: String?

        public var note: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.category != nil {
                map["Category"] = self.category!
            }
            if self.configKey != nil {
                map["ConfigKey"] = self.configKey!
            }
            if self.configValue != nil {
                map["ConfigValue"] = self.configValue!
            }
            if self.note != nil {
                map["Note"] = self.note!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Category") && dict["Category"] != nil {
                self.category = dict["Category"] as! String
            }
            if dict.keys.contains("ConfigKey") && dict["ConfigKey"] != nil {
                self.configKey = dict["ConfigKey"] as! String
            }
            if dict.keys.contains("ConfigValue") && dict["ConfigValue"] != nil {
                self.configValue = dict["ConfigValue"] as! String
            }
            if dict.keys.contains("Note") && dict["Note"] != nil {
                self.note = dict["Note"] as! String
            }
        }
    }
    public var clusterId: String?

    public var config: [CreateResourceQueueRequest.Config]?

    public var leaf: Bool?

    public var name: String?

    public var parentQueueId: Int64?

    public var qualifiedName: String?

    public var regionId: String?

    public var resourceOwnerId: Int64?

    public var resourcePoolId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.config != nil {
            var tmp : [Any] = []
            for k in self.config! {
                tmp.append(k.toMap())
            }
            map["Config"] = tmp
        }
        if self.leaf != nil {
            map["Leaf"] = self.leaf!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.parentQueueId != nil {
            map["ParentQueueId"] = self.parentQueueId!
        }
        if self.qualifiedName != nil {
            map["QualifiedName"] = self.qualifiedName!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.resourcePoolId != nil {
            map["ResourcePoolId"] = self.resourcePoolId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("Config") && dict["Config"] != nil {
            var tmp : [CreateResourceQueueRequest.Config] = []
            for v in dict["Config"] as! [Any] {
                var model = CreateResourceQueueRequest.Config()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.config = tmp
        }
        if dict.keys.contains("Leaf") && dict["Leaf"] != nil {
            self.leaf = dict["Leaf"] as! Bool
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("ParentQueueId") && dict["ParentQueueId"] != nil {
            self.parentQueueId = dict["ParentQueueId"] as! Int64
        }
        if dict.keys.contains("QualifiedName") && dict["QualifiedName"] != nil {
            self.qualifiedName = dict["QualifiedName"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") && dict["ResourceOwnerId"] != nil {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("ResourcePoolId") && dict["ResourcePoolId"] != nil {
            self.resourcePoolId = dict["ResourcePoolId"] as! Int64
        }
    }
}

public class CreateResourceQueueResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateResourceQueueResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateResourceQueueResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateResourceQueueResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateScalingGroupV2Request : Tea.TeaModel {
    public var description_: String?

    public var hostGroupId: String?

    public var name: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.hostGroupId != nil {
            map["HostGroupId"] = self.hostGroupId!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("HostGroupId") && dict["HostGroupId"] != nil {
            self.hostGroupId = dict["HostGroupId"] as! String
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") && dict["ResourceGroupId"] != nil {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") && dict["ResourceOwnerId"] != nil {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class CreateScalingGroupV2ResponseBody : Tea.TeaModel {
    public var data: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateScalingGroupV2Response : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateScalingGroupV2ResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = CreateScalingGroupV2ResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteClusterTemplateRequest : Tea.TeaModel {
    public var bizId: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") && dict["ResourceGroupId"] != nil {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") && dict["ResourceOwnerId"] != nil {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class DeleteClusterTemplateResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteClusterTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteClusterTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteClusterTemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteFlowRequest : Tea.TeaModel {
    public var id: String?

    public var projectId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! String
        }
        if dict.keys.contains("ProjectId") && dict["ProjectId"] != nil {
            self.projectId = dict["ProjectId"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DeleteFlowResponseBody : Tea.TeaModel {
    public var data: Bool?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! Bool
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteFlowResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteFlowResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteFlowResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteFlowCategoryRequest : Tea.TeaModel {
    public var id: String?

    public var projectId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! String
        }
        if dict.keys.contains("ProjectId") && dict["ProjectId"] != nil {
            self.projectId = dict["ProjectId"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DeleteFlowCategoryResponseBody : Tea.TeaModel {
    public var data: Bool?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! Bool
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteFlowCategoryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteFlowCategoryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteFlowCategoryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteFlowJobRequest : Tea.TeaModel {
    public var id: String?

    public var projectId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! String
        }
        if dict.keys.contains("ProjectId") && dict["ProjectId"] != nil {
            self.projectId = dict["ProjectId"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DeleteFlowJobResponseBody : Tea.TeaModel {
    public var data: Bool?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! Bool
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteFlowJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteFlowJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteFlowJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteFlowProjectRequest : Tea.TeaModel {
    public var projectId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ProjectId") && dict["ProjectId"] != nil {
            self.projectId = dict["ProjectId"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DeleteFlowProjectResponseBody : Tea.TeaModel {
    public var data: Bool?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! Bool
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteFlowProjectResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteFlowProjectResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteFlowProjectResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteFlowProjectClusterSettingRequest : Tea.TeaModel {
    public var clusterId: String?

    public var projectId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("ProjectId") && dict["ProjectId"] != nil {
            self.projectId = dict["ProjectId"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DeleteFlowProjectClusterSettingResponseBody : Tea.TeaModel {
    public var data: Bool?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! Bool
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteFlowProjectClusterSettingResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteFlowProjectClusterSettingResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteFlowProjectClusterSettingResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteFlowProjectUserRequest : Tea.TeaModel {
    public var projectId: String?

    public var regionId: String?

    public var userName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.userName != nil {
            map["UserName"] = self.userName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ProjectId") && dict["ProjectId"] != nil {
            self.projectId = dict["ProjectId"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("UserName") && dict["UserName"] != nil {
            self.userName = dict["UserName"] as! String
        }
    }
}

public class DeleteFlowProjectUserResponseBody : Tea.TeaModel {
    public var data: Bool?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! Bool
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteFlowProjectUserResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteFlowProjectUserResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteFlowProjectUserResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteResourcePoolRequest : Tea.TeaModel {
    public var clusterId: String?

    public var regionId: String?

    public var resourceOwnerId: Int64?

    public var resourcePoolId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.resourcePoolId != nil {
            map["ResourcePoolId"] = self.resourcePoolId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") && dict["ResourceOwnerId"] != nil {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("ResourcePoolId") && dict["ResourcePoolId"] != nil {
            self.resourcePoolId = dict["ResourcePoolId"] as! String
        }
    }
}

public class DeleteResourcePoolResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteResourcePoolResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteResourcePoolResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteResourcePoolResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteResourceQueueRequest : Tea.TeaModel {
    public var clusterId: String?

    public var regionId: String?

    public var resourceOwnerId: Int64?

    public var resourceQueueId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.resourceQueueId != nil {
            map["ResourceQueueId"] = self.resourceQueueId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") && dict["ResourceOwnerId"] != nil {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceQueueId") && dict["ResourceQueueId"] != nil {
            self.resourceQueueId = dict["ResourceQueueId"] as! String
        }
    }
}

public class DeleteResourceQueueResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteResourceQueueResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteResourceQueueResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DeleteResourceQueueResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeClusterBasicInfoRequest : Tea.TeaModel {
    public var clusterId: String?

    public var regionId: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") && dict["ResourceOwnerId"] != nil {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class DescribeClusterBasicInfoResponseBody : Tea.TeaModel {
    public class ClusterInfo : Tea.TeaModel {
        public class AccessInfo : Tea.TeaModel {
            public class ZKLinks : Tea.TeaModel {
                public class ZKLink : Tea.TeaModel {
                    public var link: String?

                    public var port: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.link != nil {
                            map["Link"] = self.link!
                        }
                        if self.port != nil {
                            map["Port"] = self.port!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Link") && dict["Link"] != nil {
                            self.link = dict["Link"] as! String
                        }
                        if dict.keys.contains("Port") && dict["Port"] != nil {
                            self.port = dict["Port"] as! String
                        }
                    }
                }
                public var ZKLink: [DescribeClusterBasicInfoResponseBody.ClusterInfo.AccessInfo.ZKLinks.ZKLink]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.ZKLink != nil {
                        var tmp : [Any] = []
                        for k in self.ZKLink! {
                            tmp.append(k.toMap())
                        }
                        map["ZKLink"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ZKLink") && dict["ZKLink"] != nil {
                        var tmp : [DescribeClusterBasicInfoResponseBody.ClusterInfo.AccessInfo.ZKLinks.ZKLink] = []
                        for v in dict["ZKLink"] as! [Any] {
                            var model = DescribeClusterBasicInfoResponseBody.ClusterInfo.AccessInfo.ZKLinks.ZKLink()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.ZKLink = tmp
                    }
                }
            }
            public var ZKLinks: DescribeClusterBasicInfoResponseBody.ClusterInfo.AccessInfo.ZKLinks?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.ZKLinks?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.ZKLinks != nil {
                    map["ZKLinks"] = self.ZKLinks?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ZKLinks") && dict["ZKLinks"] != nil {
                    var model = DescribeClusterBasicInfoResponseBody.ClusterInfo.AccessInfo.ZKLinks()
                    model.fromMap(dict["ZKLinks"] as! [String: Any])
                    self.ZKLinks = model
                }
            }
        }
        public class BootstrapActionList : Tea.TeaModel {
            public class BootstrapAction : Tea.TeaModel {
                public var arg: String?

                public var name: String?

                public var path: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.arg != nil {
                        map["Arg"] = self.arg!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.path != nil {
                        map["Path"] = self.path!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Arg") && dict["Arg"] != nil {
                        self.arg = dict["Arg"] as! String
                    }
                    if dict.keys.contains("Name") && dict["Name"] != nil {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Path") && dict["Path"] != nil {
                        self.path = dict["Path"] as! String
                    }
                }
            }
            public var bootstrapAction: [DescribeClusterBasicInfoResponseBody.ClusterInfo.BootstrapActionList.BootstrapAction]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bootstrapAction != nil {
                    var tmp : [Any] = []
                    for k in self.bootstrapAction! {
                        tmp.append(k.toMap())
                    }
                    map["BootstrapAction"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BootstrapAction") && dict["BootstrapAction"] != nil {
                    var tmp : [DescribeClusterBasicInfoResponseBody.ClusterInfo.BootstrapActionList.BootstrapAction] = []
                    for v in dict["BootstrapAction"] as! [Any] {
                        var model = DescribeClusterBasicInfoResponseBody.ClusterInfo.BootstrapActionList.BootstrapAction()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.bootstrapAction = tmp
                }
            }
        }
        public class FailReason : Tea.TeaModel {
            public var errorCode: String?

            public var errorMsg: String?

            public var requestId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.errorCode != nil {
                    map["ErrorCode"] = self.errorCode!
                }
                if self.errorMsg != nil {
                    map["ErrorMsg"] = self.errorMsg!
                }
                if self.requestId != nil {
                    map["RequestId"] = self.requestId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
                    self.errorCode = dict["ErrorCode"] as! String
                }
                if dict.keys.contains("ErrorMsg") && dict["ErrorMsg"] != nil {
                    self.errorMsg = dict["ErrorMsg"] as! String
                }
                if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
                    self.requestId = dict["RequestId"] as! String
                }
            }
        }
        public class GatewayClusterInfoList : Tea.TeaModel {
            public class GatewayClusterInfo : Tea.TeaModel {
                public var clusterId: String?

                public var clusterName: String?

                public var status: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.clusterId != nil {
                        map["ClusterId"] = self.clusterId!
                    }
                    if self.clusterName != nil {
                        map["ClusterName"] = self.clusterName!
                    }
                    if self.status != nil {
                        map["Status"] = self.status!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
                        self.clusterId = dict["ClusterId"] as! String
                    }
                    if dict.keys.contains("ClusterName") && dict["ClusterName"] != nil {
                        self.clusterName = dict["ClusterName"] as! String
                    }
                    if dict.keys.contains("Status") && dict["Status"] != nil {
                        self.status = dict["Status"] as! String
                    }
                }
            }
            public var gatewayClusterInfo: [DescribeClusterBasicInfoResponseBody.ClusterInfo.GatewayClusterInfoList.GatewayClusterInfo]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.gatewayClusterInfo != nil {
                    var tmp : [Any] = []
                    for k in self.gatewayClusterInfo! {
                        tmp.append(k.toMap())
                    }
                    map["GatewayClusterInfo"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("GatewayClusterInfo") && dict["GatewayClusterInfo"] != nil {
                    var tmp : [DescribeClusterBasicInfoResponseBody.ClusterInfo.GatewayClusterInfoList.GatewayClusterInfo] = []
                    for v in dict["GatewayClusterInfo"] as! [Any] {
                        var model = DescribeClusterBasicInfoResponseBody.ClusterInfo.GatewayClusterInfoList.GatewayClusterInfo()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.gatewayClusterInfo = tmp
                }
            }
        }
        public class HostPoolInfo : Tea.TeaModel {
            public var hpBizId: String?

            public var hpName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.hpBizId != nil {
                    map["HpBizId"] = self.hpBizId!
                }
                if self.hpName != nil {
                    map["HpName"] = self.hpName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("HpBizId") && dict["HpBizId"] != nil {
                    self.hpBizId = dict["HpBizId"] as! String
                }
                if dict.keys.contains("HpName") && dict["HpName"] != nil {
                    self.hpName = dict["HpName"] as! String
                }
            }
        }
        public class RelateClusterInfo : Tea.TeaModel {
            public var clusterId: String?

            public var clusterName: String?

            public var clusterType: String?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.clusterId != nil {
                    map["ClusterId"] = self.clusterId!
                }
                if self.clusterName != nil {
                    map["ClusterName"] = self.clusterName!
                }
                if self.clusterType != nil {
                    map["ClusterType"] = self.clusterType!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
                    self.clusterId = dict["ClusterId"] as! String
                }
                if dict.keys.contains("ClusterName") && dict["ClusterName"] != nil {
                    self.clusterName = dict["ClusterName"] as! String
                }
                if dict.keys.contains("ClusterType") && dict["ClusterType"] != nil {
                    self.clusterType = dict["ClusterType"] as! String
                }
                if dict.keys.contains("Status") && dict["Status"] != nil {
                    self.status = dict["Status"] as! String
                }
            }
        }
        public class SoftwareInfo : Tea.TeaModel {
            public class Softwares : Tea.TeaModel {
                public class Software : Tea.TeaModel {
                    public var displayName: String?

                    public var name: String?

                    public var onlyDisplay: Bool?

                    public var startTpe: Int32?

                    public var version: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.displayName != nil {
                            map["DisplayName"] = self.displayName!
                        }
                        if self.name != nil {
                            map["Name"] = self.name!
                        }
                        if self.onlyDisplay != nil {
                            map["OnlyDisplay"] = self.onlyDisplay!
                        }
                        if self.startTpe != nil {
                            map["StartTpe"] = self.startTpe!
                        }
                        if self.version != nil {
                            map["Version"] = self.version!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("DisplayName") && dict["DisplayName"] != nil {
                            self.displayName = dict["DisplayName"] as! String
                        }
                        if dict.keys.contains("Name") && dict["Name"] != nil {
                            self.name = dict["Name"] as! String
                        }
                        if dict.keys.contains("OnlyDisplay") && dict["OnlyDisplay"] != nil {
                            self.onlyDisplay = dict["OnlyDisplay"] as! Bool
                        }
                        if dict.keys.contains("StartTpe") && dict["StartTpe"] != nil {
                            self.startTpe = dict["StartTpe"] as! Int32
                        }
                        if dict.keys.contains("Version") && dict["Version"] != nil {
                            self.version = dict["Version"] as! String
                        }
                    }
                }
                public var software: [DescribeClusterBasicInfoResponseBody.ClusterInfo.SoftwareInfo.Softwares.Software]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.software != nil {
                        var tmp : [Any] = []
                        for k in self.software! {
                            tmp.append(k.toMap())
                        }
                        map["Software"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Software") && dict["Software"] != nil {
                        var tmp : [DescribeClusterBasicInfoResponseBody.ClusterInfo.SoftwareInfo.Softwares.Software] = []
                        for v in dict["Software"] as! [Any] {
                            var model = DescribeClusterBasicInfoResponseBody.ClusterInfo.SoftwareInfo.Softwares.Software()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.software = tmp
                    }
                }
            }
            public var clusterType: String?

            public var emrVer: String?

            public var softwares: DescribeClusterBasicInfoResponseBody.ClusterInfo.SoftwareInfo.Softwares?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.softwares?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.clusterType != nil {
                    map["ClusterType"] = self.clusterType!
                }
                if self.emrVer != nil {
                    map["EmrVer"] = self.emrVer!
                }
                if self.softwares != nil {
                    map["Softwares"] = self.softwares?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ClusterType") && dict["ClusterType"] != nil {
                    self.clusterType = dict["ClusterType"] as! String
                }
                if dict.keys.contains("EmrVer") && dict["EmrVer"] != nil {
                    self.emrVer = dict["EmrVer"] as! String
                }
                if dict.keys.contains("Softwares") && dict["Softwares"] != nil {
                    var model = DescribeClusterBasicInfoResponseBody.ClusterInfo.SoftwareInfo.Softwares()
                    model.fromMap(dict["Softwares"] as! [String: Any])
                    self.softwares = model
                }
            }
        }
        public var accessInfo: DescribeClusterBasicInfoResponseBody.ClusterInfo.AccessInfo?

        public var autoScalingAllowed: Bool?

        public var autoScalingByLoadAllowed: Bool?

        public var autoScalingEnable: Bool?

        public var autoScalingSpotWithLimitAllowed: Bool?

        public var autoScalingVersion: String?

        public var autoScalingWithGraceAllowed: Bool?

        public var bootstrapActionList: DescribeClusterBasicInfoResponseBody.ClusterInfo.BootstrapActionList?

        public var bootstrapFailed: Bool?

        public var chargeType: String?

        public var clickhouseConf: String?

        public var clusterId: String?

        public var configurations: String?

        public var coreNodeInService: Int32?

        public var coreNodeTotal: Int32?

        public var createResource: String?

        public var createType: String?

        public var dataDiskEncrypted: Bool?

        public var dataDiskKMSKeyId: String?

        public var depositType: String?

        public var easEnable: Bool?

        public var expiredTime: Int64?

        public var extraInfo: String?

        public var failReason: DescribeClusterBasicInfoResponseBody.ClusterInfo.FailReason?

        public var gatewayClusterIds: String?

        public var gatewayClusterInfoList: DescribeClusterBasicInfoResponseBody.ClusterInfo.GatewayClusterInfoList?

        public var highAvailabilityEnable: Bool?

        public var hostPoolInfo: DescribeClusterBasicInfoResponseBody.ClusterInfo.HostPoolInfo?

        public var imageId: String?

        public var instanceGeneration: String?

        public var ioOptimized: Bool?

        public var k8sClusterId: String?

        public var localMetaDb: Bool?

        public var logEnable: Bool?

        public var logPath: String?

        public var machineType: String?

        public var masterNodeInService: Int32?

        public var masterNodeTotal: Int32?

        public var metaStoreType: String?

        public var name: String?

        public var netType: String?

        public var operationId: String?

        public var period: Int32?

        public var regionId: String?

        public var relateClusterId: String?

        public var relateClusterInfo: DescribeClusterBasicInfoResponseBody.ClusterInfo.RelateClusterInfo?

        public var resizeClusterEnable: Bool?

        public var resizeDiskEnable: Bool?

        public var runningTime: Int32?

        public var securityGroupId: String?

        public var securityGroupName: String?

        public var showSoftwareInterface: Bool?

        public var softwareInfo: DescribeClusterBasicInfoResponseBody.ClusterInfo.SoftwareInfo?

        public var startTime: Int64?

        public var status: String?

        public var stopTime: Int64?

        public var taskNodeInService: Int32?

        public var taskNodeTotal: Int32?

        public var userDefinedEmrEcsRole: String?

        public var userId: String?

        public var vSwitchId: String?

        public var vpcId: String?

        public var zoneId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.accessInfo?.validate()
            try self.bootstrapActionList?.validate()
            try self.failReason?.validate()
            try self.gatewayClusterInfoList?.validate()
            try self.hostPoolInfo?.validate()
            try self.relateClusterInfo?.validate()
            try self.softwareInfo?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accessInfo != nil {
                map["AccessInfo"] = self.accessInfo?.toMap()
            }
            if self.autoScalingAllowed != nil {
                map["AutoScalingAllowed"] = self.autoScalingAllowed!
            }
            if self.autoScalingByLoadAllowed != nil {
                map["AutoScalingByLoadAllowed"] = self.autoScalingByLoadAllowed!
            }
            if self.autoScalingEnable != nil {
                map["AutoScalingEnable"] = self.autoScalingEnable!
            }
            if self.autoScalingSpotWithLimitAllowed != nil {
                map["AutoScalingSpotWithLimitAllowed"] = self.autoScalingSpotWithLimitAllowed!
            }
            if self.autoScalingVersion != nil {
                map["AutoScalingVersion"] = self.autoScalingVersion!
            }
            if self.autoScalingWithGraceAllowed != nil {
                map["AutoScalingWithGraceAllowed"] = self.autoScalingWithGraceAllowed!
            }
            if self.bootstrapActionList != nil {
                map["BootstrapActionList"] = self.bootstrapActionList?.toMap()
            }
            if self.bootstrapFailed != nil {
                map["BootstrapFailed"] = self.bootstrapFailed!
            }
            if self.chargeType != nil {
                map["ChargeType"] = self.chargeType!
            }
            if self.clickhouseConf != nil {
                map["ClickhouseConf"] = self.clickhouseConf!
            }
            if self.clusterId != nil {
                map["ClusterId"] = self.clusterId!
            }
            if self.configurations != nil {
                map["Configurations"] = self.configurations!
            }
            if self.coreNodeInService != nil {
                map["CoreNodeInService"] = self.coreNodeInService!
            }
            if self.coreNodeTotal != nil {
                map["CoreNodeTotal"] = self.coreNodeTotal!
            }
            if self.createResource != nil {
                map["CreateResource"] = self.createResource!
            }
            if self.createType != nil {
                map["CreateType"] = self.createType!
            }
            if self.dataDiskEncrypted != nil {
                map["DataDiskEncrypted"] = self.dataDiskEncrypted!
            }
            if self.dataDiskKMSKeyId != nil {
                map["DataDiskKMSKeyId"] = self.dataDiskKMSKeyId!
            }
            if self.depositType != nil {
                map["DepositType"] = self.depositType!
            }
            if self.easEnable != nil {
                map["EasEnable"] = self.easEnable!
            }
            if self.expiredTime != nil {
                map["ExpiredTime"] = self.expiredTime!
            }
            if self.extraInfo != nil {
                map["ExtraInfo"] = self.extraInfo!
            }
            if self.failReason != nil {
                map["FailReason"] = self.failReason?.toMap()
            }
            if self.gatewayClusterIds != nil {
                map["GatewayClusterIds"] = self.gatewayClusterIds!
            }
            if self.gatewayClusterInfoList != nil {
                map["GatewayClusterInfoList"] = self.gatewayClusterInfoList?.toMap()
            }
            if self.highAvailabilityEnable != nil {
                map["HighAvailabilityEnable"] = self.highAvailabilityEnable!
            }
            if self.hostPoolInfo != nil {
                map["HostPoolInfo"] = self.hostPoolInfo?.toMap()
            }
            if self.imageId != nil {
                map["ImageId"] = self.imageId!
            }
            if self.instanceGeneration != nil {
                map["InstanceGeneration"] = self.instanceGeneration!
            }
            if self.ioOptimized != nil {
                map["IoOptimized"] = self.ioOptimized!
            }
            if self.k8sClusterId != nil {
                map["K8sClusterId"] = self.k8sClusterId!
            }
            if self.localMetaDb != nil {
                map["LocalMetaDb"] = self.localMetaDb!
            }
            if self.logEnable != nil {
                map["LogEnable"] = self.logEnable!
            }
            if self.logPath != nil {
                map["LogPath"] = self.logPath!
            }
            if self.machineType != nil {
                map["MachineType"] = self.machineType!
            }
            if self.masterNodeInService != nil {
                map["MasterNodeInService"] = self.masterNodeInService!
            }
            if self.masterNodeTotal != nil {
                map["MasterNodeTotal"] = self.masterNodeTotal!
            }
            if self.metaStoreType != nil {
                map["MetaStoreType"] = self.metaStoreType!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.netType != nil {
                map["NetType"] = self.netType!
            }
            if self.operationId != nil {
                map["OperationId"] = self.operationId!
            }
            if self.period != nil {
                map["Period"] = self.period!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.relateClusterId != nil {
                map["RelateClusterId"] = self.relateClusterId!
            }
            if self.relateClusterInfo != nil {
                map["RelateClusterInfo"] = self.relateClusterInfo?.toMap()
            }
            if self.resizeClusterEnable != nil {
                map["ResizeClusterEnable"] = self.resizeClusterEnable!
            }
            if self.resizeDiskEnable != nil {
                map["ResizeDiskEnable"] = self.resizeDiskEnable!
            }
            if self.runningTime != nil {
                map["RunningTime"] = self.runningTime!
            }
            if self.securityGroupId != nil {
                map["SecurityGroupId"] = self.securityGroupId!
            }
            if self.securityGroupName != nil {
                map["SecurityGroupName"] = self.securityGroupName!
            }
            if self.showSoftwareInterface != nil {
                map["ShowSoftwareInterface"] = self.showSoftwareInterface!
            }
            if self.softwareInfo != nil {
                map["SoftwareInfo"] = self.softwareInfo?.toMap()
            }
            if self.startTime != nil {
                map["StartTime"] = self.startTime!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.stopTime != nil {
                map["StopTime"] = self.stopTime!
            }
            if self.taskNodeInService != nil {
                map["TaskNodeInService"] = self.taskNodeInService!
            }
            if self.taskNodeTotal != nil {
                map["TaskNodeTotal"] = self.taskNodeTotal!
            }
            if self.userDefinedEmrEcsRole != nil {
                map["UserDefinedEmrEcsRole"] = self.userDefinedEmrEcsRole!
            }
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            if self.vSwitchId != nil {
                map["VSwitchId"] = self.vSwitchId!
            }
            if self.vpcId != nil {
                map["VpcId"] = self.vpcId!
            }
            if self.zoneId != nil {
                map["ZoneId"] = self.zoneId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AccessInfo") && dict["AccessInfo"] != nil {
                var model = DescribeClusterBasicInfoResponseBody.ClusterInfo.AccessInfo()
                model.fromMap(dict["AccessInfo"] as! [String: Any])
                self.accessInfo = model
            }
            if dict.keys.contains("AutoScalingAllowed") && dict["AutoScalingAllowed"] != nil {
                self.autoScalingAllowed = dict["AutoScalingAllowed"] as! Bool
            }
            if dict.keys.contains("AutoScalingByLoadAllowed") && dict["AutoScalingByLoadAllowed"] != nil {
                self.autoScalingByLoadAllowed = dict["AutoScalingByLoadAllowed"] as! Bool
            }
            if dict.keys.contains("AutoScalingEnable") && dict["AutoScalingEnable"] != nil {
                self.autoScalingEnable = dict["AutoScalingEnable"] as! Bool
            }
            if dict.keys.contains("AutoScalingSpotWithLimitAllowed") && dict["AutoScalingSpotWithLimitAllowed"] != nil {
                self.autoScalingSpotWithLimitAllowed = dict["AutoScalingSpotWithLimitAllowed"] as! Bool
            }
            if dict.keys.contains("AutoScalingVersion") && dict["AutoScalingVersion"] != nil {
                self.autoScalingVersion = dict["AutoScalingVersion"] as! String
            }
            if dict.keys.contains("AutoScalingWithGraceAllowed") && dict["AutoScalingWithGraceAllowed"] != nil {
                self.autoScalingWithGraceAllowed = dict["AutoScalingWithGraceAllowed"] as! Bool
            }
            if dict.keys.contains("BootstrapActionList") && dict["BootstrapActionList"] != nil {
                var model = DescribeClusterBasicInfoResponseBody.ClusterInfo.BootstrapActionList()
                model.fromMap(dict["BootstrapActionList"] as! [String: Any])
                self.bootstrapActionList = model
            }
            if dict.keys.contains("BootstrapFailed") && dict["BootstrapFailed"] != nil {
                self.bootstrapFailed = dict["BootstrapFailed"] as! Bool
            }
            if dict.keys.contains("ChargeType") && dict["ChargeType"] != nil {
                self.chargeType = dict["ChargeType"] as! String
            }
            if dict.keys.contains("ClickhouseConf") && dict["ClickhouseConf"] != nil {
                self.clickhouseConf = dict["ClickhouseConf"] as! String
            }
            if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
                self.clusterId = dict["ClusterId"] as! String
            }
            if dict.keys.contains("Configurations") && dict["Configurations"] != nil {
                self.configurations = dict["Configurations"] as! String
            }
            if dict.keys.contains("CoreNodeInService") && dict["CoreNodeInService"] != nil {
                self.coreNodeInService = dict["CoreNodeInService"] as! Int32
            }
            if dict.keys.contains("CoreNodeTotal") && dict["CoreNodeTotal"] != nil {
                self.coreNodeTotal = dict["CoreNodeTotal"] as! Int32
            }
            if dict.keys.contains("CreateResource") && dict["CreateResource"] != nil {
                self.createResource = dict["CreateResource"] as! String
            }
            if dict.keys.contains("CreateType") && dict["CreateType"] != nil {
                self.createType = dict["CreateType"] as! String
            }
            if dict.keys.contains("DataDiskEncrypted") && dict["DataDiskEncrypted"] != nil {
                self.dataDiskEncrypted = dict["DataDiskEncrypted"] as! Bool
            }
            if dict.keys.contains("DataDiskKMSKeyId") && dict["DataDiskKMSKeyId"] != nil {
                self.dataDiskKMSKeyId = dict["DataDiskKMSKeyId"] as! String
            }
            if dict.keys.contains("DepositType") && dict["DepositType"] != nil {
                self.depositType = dict["DepositType"] as! String
            }
            if dict.keys.contains("EasEnable") && dict["EasEnable"] != nil {
                self.easEnable = dict["EasEnable"] as! Bool
            }
            if dict.keys.contains("ExpiredTime") && dict["ExpiredTime"] != nil {
                self.expiredTime = dict["ExpiredTime"] as! Int64
            }
            if dict.keys.contains("ExtraInfo") && dict["ExtraInfo"] != nil {
                self.extraInfo = dict["ExtraInfo"] as! String
            }
            if dict.keys.contains("FailReason") && dict["FailReason"] != nil {
                var model = DescribeClusterBasicInfoResponseBody.ClusterInfo.FailReason()
                model.fromMap(dict["FailReason"] as! [String: Any])
                self.failReason = model
            }
            if dict.keys.contains("GatewayClusterIds") && dict["GatewayClusterIds"] != nil {
                self.gatewayClusterIds = dict["GatewayClusterIds"] as! String
            }
            if dict.keys.contains("GatewayClusterInfoList") && dict["GatewayClusterInfoList"] != nil {
                var model = DescribeClusterBasicInfoResponseBody.ClusterInfo.GatewayClusterInfoList()
                model.fromMap(dict["GatewayClusterInfoList"] as! [String: Any])
                self.gatewayClusterInfoList = model
            }
            if dict.keys.contains("HighAvailabilityEnable") && dict["HighAvailabilityEnable"] != nil {
                self.highAvailabilityEnable = dict["HighAvailabilityEnable"] as! Bool
            }
            if dict.keys.contains("HostPoolInfo") && dict["HostPoolInfo"] != nil {
                var model = DescribeClusterBasicInfoResponseBody.ClusterInfo.HostPoolInfo()
                model.fromMap(dict["HostPoolInfo"] as! [String: Any])
                self.hostPoolInfo = model
            }
            if dict.keys.contains("ImageId") && dict["ImageId"] != nil {
                self.imageId = dict["ImageId"] as! String
            }
            if dict.keys.contains("InstanceGeneration") && dict["InstanceGeneration"] != nil {
                self.instanceGeneration = dict["InstanceGeneration"] as! String
            }
            if dict.keys.contains("IoOptimized") && dict["IoOptimized"] != nil {
                self.ioOptimized = dict["IoOptimized"] as! Bool
            }
            if dict.keys.contains("K8sClusterId") && dict["K8sClusterId"] != nil {
                self.k8sClusterId = dict["K8sClusterId"] as! String
            }
            if dict.keys.contains("LocalMetaDb") && dict["LocalMetaDb"] != nil {
                self.localMetaDb = dict["LocalMetaDb"] as! Bool
            }
            if dict.keys.contains("LogEnable") && dict["LogEnable"] != nil {
                self.logEnable = dict["LogEnable"] as! Bool
            }
            if dict.keys.contains("LogPath") && dict["LogPath"] != nil {
                self.logPath = dict["LogPath"] as! String
            }
            if dict.keys.contains("MachineType") && dict["MachineType"] != nil {
                self.machineType = dict["MachineType"] as! String
            }
            if dict.keys.contains("MasterNodeInService") && dict["MasterNodeInService"] != nil {
                self.masterNodeInService = dict["MasterNodeInService"] as! Int32
            }
            if dict.keys.contains("MasterNodeTotal") && dict["MasterNodeTotal"] != nil {
                self.masterNodeTotal = dict["MasterNodeTotal"] as! Int32
            }
            if dict.keys.contains("MetaStoreType") && dict["MetaStoreType"] != nil {
                self.metaStoreType = dict["MetaStoreType"] as! String
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("NetType") && dict["NetType"] != nil {
                self.netType = dict["NetType"] as! String
            }
            if dict.keys.contains("OperationId") && dict["OperationId"] != nil {
                self.operationId = dict["OperationId"] as! String
            }
            if dict.keys.contains("Period") && dict["Period"] != nil {
                self.period = dict["Period"] as! Int32
            }
            if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("RelateClusterId") && dict["RelateClusterId"] != nil {
                self.relateClusterId = dict["RelateClusterId"] as! String
            }
            if dict.keys.contains("RelateClusterInfo") && dict["RelateClusterInfo"] != nil {
                var model = DescribeClusterBasicInfoResponseBody.ClusterInfo.RelateClusterInfo()
                model.fromMap(dict["RelateClusterInfo"] as! [String: Any])
                self.relateClusterInfo = model
            }
            if dict.keys.contains("ResizeClusterEnable") && dict["ResizeClusterEnable"] != nil {
                self.resizeClusterEnable = dict["ResizeClusterEnable"] as! Bool
            }
            if dict.keys.contains("ResizeDiskEnable") && dict["ResizeDiskEnable"] != nil {
                self.resizeDiskEnable = dict["ResizeDiskEnable"] as! Bool
            }
            if dict.keys.contains("RunningTime") && dict["RunningTime"] != nil {
                self.runningTime = dict["RunningTime"] as! Int32
            }
            if dict.keys.contains("SecurityGroupId") && dict["SecurityGroupId"] != nil {
                self.securityGroupId = dict["SecurityGroupId"] as! String
            }
            if dict.keys.contains("SecurityGroupName") && dict["SecurityGroupName"] != nil {
                self.securityGroupName = dict["SecurityGroupName"] as! String
            }
            if dict.keys.contains("ShowSoftwareInterface") && dict["ShowSoftwareInterface"] != nil {
                self.showSoftwareInterface = dict["ShowSoftwareInterface"] as! Bool
            }
            if dict.keys.contains("SoftwareInfo") && dict["SoftwareInfo"] != nil {
                var model = DescribeClusterBasicInfoResponseBody.ClusterInfo.SoftwareInfo()
                model.fromMap(dict["SoftwareInfo"] as! [String: Any])
                self.softwareInfo = model
            }
            if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
                self.startTime = dict["StartTime"] as! Int64
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("StopTime") && dict["StopTime"] != nil {
                self.stopTime = dict["StopTime"] as! Int64
            }
            if dict.keys.contains("TaskNodeInService") && dict["TaskNodeInService"] != nil {
                self.taskNodeInService = dict["TaskNodeInService"] as! Int32
            }
            if dict.keys.contains("TaskNodeTotal") && dict["TaskNodeTotal"] != nil {
                self.taskNodeTotal = dict["TaskNodeTotal"] as! Int32
            }
            if dict.keys.contains("UserDefinedEmrEcsRole") && dict["UserDefinedEmrEcsRole"] != nil {
                self.userDefinedEmrEcsRole = dict["UserDefinedEmrEcsRole"] as! String
            }
            if dict.keys.contains("UserId") && dict["UserId"] != nil {
                self.userId = dict["UserId"] as! String
            }
            if dict.keys.contains("VSwitchId") && dict["VSwitchId"] != nil {
                self.vSwitchId = dict["VSwitchId"] as! String
            }
            if dict.keys.contains("VpcId") && dict["VpcId"] != nil {
                self.vpcId = dict["VpcId"] as! String
            }
            if dict.keys.contains("ZoneId") && dict["ZoneId"] != nil {
                self.zoneId = dict["ZoneId"] as! String
            }
        }
    }
    public var clusterInfo: DescribeClusterBasicInfoResponseBody.ClusterInfo?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.clusterInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterInfo != nil {
            map["ClusterInfo"] = self.clusterInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterInfo") && dict["ClusterInfo"] != nil {
            var model = DescribeClusterBasicInfoResponseBody.ClusterInfo()
            model.fromMap(dict["ClusterInfo"] as! [String: Any])
            self.clusterInfo = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeClusterBasicInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeClusterBasicInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeClusterBasicInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeClusterOperationHostTaskLogRequest : Tea.TeaModel {
    public var clusterId: String?

    public var hostId: String?

    public var operationId: String?

    public var regionId: String?

    public var resourceOwnerId: Int64?

    public var status: String?

    public var taskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.hostId != nil {
            map["HostId"] = self.hostId!
        }
        if self.operationId != nil {
            map["OperationId"] = self.operationId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("HostId") && dict["HostId"] != nil {
            self.hostId = dict["HostId"] as! String
        }
        if dict.keys.contains("OperationId") && dict["OperationId"] != nil {
            self.operationId = dict["OperationId"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") && dict["ResourceOwnerId"] != nil {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("Status") && dict["Status"] != nil {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("TaskId") && dict["TaskId"] != nil {
            self.taskId = dict["TaskId"] as! String
        }
    }
}

public class DescribeClusterOperationHostTaskLogResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var stderr: String?

    public var stdout: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.stderr != nil {
            map["Stderr"] = self.stderr!
        }
        if self.stdout != nil {
            map["Stdout"] = self.stdout!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Stderr") && dict["Stderr"] != nil {
            self.stderr = dict["Stderr"] as! String
        }
        if dict.keys.contains("Stdout") && dict["Stdout"] != nil {
            self.stdout = dict["Stdout"] as! String
        }
    }
}

public class DescribeClusterOperationHostTaskLogResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeClusterOperationHostTaskLogResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeClusterOperationHostTaskLogResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeClusterResourcePoolSchedulerTypeRequest : Tea.TeaModel {
    public var clusterId: String?

    public var regionId: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") && dict["ResourceOwnerId"] != nil {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class DescribeClusterResourcePoolSchedulerTypeResponseBody : Tea.TeaModel {
    public var currentSchedulerType: String?

    public var defaultSchedulerType: String?

    public var requestId: String?

    public var supportSchedulerType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.currentSchedulerType != nil {
            map["CurrentSchedulerType"] = self.currentSchedulerType!
        }
        if self.defaultSchedulerType != nil {
            map["DefaultSchedulerType"] = self.defaultSchedulerType!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.supportSchedulerType != nil {
            map["SupportSchedulerType"] = self.supportSchedulerType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CurrentSchedulerType") && dict["CurrentSchedulerType"] != nil {
            self.currentSchedulerType = dict["CurrentSchedulerType"] as! String
        }
        if dict.keys.contains("DefaultSchedulerType") && dict["DefaultSchedulerType"] != nil {
            self.defaultSchedulerType = dict["DefaultSchedulerType"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SupportSchedulerType") && dict["SupportSchedulerType"] != nil {
            self.supportSchedulerType = dict["SupportSchedulerType"] as! String
        }
    }
}

public class DescribeClusterResourcePoolSchedulerTypeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeClusterResourcePoolSchedulerTypeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeClusterResourcePoolSchedulerTypeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeClusterServiceRequest : Tea.TeaModel {
    public var clusterId: String?

    public var regionId: String?

    public var resourceOwnerId: Int64?

    public var serviceName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.serviceName != nil {
            map["ServiceName"] = self.serviceName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") && dict["ResourceOwnerId"] != nil {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("ServiceName") && dict["ServiceName"] != nil {
            self.serviceName = dict["ServiceName"] as! String
        }
    }
}

public class DescribeClusterServiceResponseBody : Tea.TeaModel {
    public class ServiceInfo : Tea.TeaModel {
        public class ClusterServiceSummaryList : Tea.TeaModel {
            public class ClusterServiceSummary : Tea.TeaModel {
                public var alertInfo: String?

                public var category: String?

                public var desiredStoppedValue: Int32?

                public var displayName: String?

                public var key: String?

                public var status: String?

                public var type: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.alertInfo != nil {
                        map["AlertInfo"] = self.alertInfo!
                    }
                    if self.category != nil {
                        map["Category"] = self.category!
                    }
                    if self.desiredStoppedValue != nil {
                        map["DesiredStoppedValue"] = self.desiredStoppedValue!
                    }
                    if self.displayName != nil {
                        map["DisplayName"] = self.displayName!
                    }
                    if self.key != nil {
                        map["Key"] = self.key!
                    }
                    if self.status != nil {
                        map["Status"] = self.status!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AlertInfo") && dict["AlertInfo"] != nil {
                        self.alertInfo = dict["AlertInfo"] as! String
                    }
                    if dict.keys.contains("Category") && dict["Category"] != nil {
                        self.category = dict["Category"] as! String
                    }
                    if dict.keys.contains("DesiredStoppedValue") && dict["DesiredStoppedValue"] != nil {
                        self.desiredStoppedValue = dict["DesiredStoppedValue"] as! Int32
                    }
                    if dict.keys.contains("DisplayName") && dict["DisplayName"] != nil {
                        self.displayName = dict["DisplayName"] as! String
                    }
                    if dict.keys.contains("Key") && dict["Key"] != nil {
                        self.key = dict["Key"] as! String
                    }
                    if dict.keys.contains("Status") && dict["Status"] != nil {
                        self.status = dict["Status"] as! String
                    }
                    if dict.keys.contains("Type") && dict["Type"] != nil {
                        self.type = dict["Type"] as! String
                    }
                    if dict.keys.contains("Value") && dict["Value"] != nil {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public var clusterServiceSummary: [DescribeClusterServiceResponseBody.ServiceInfo.ClusterServiceSummaryList.ClusterServiceSummary]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.clusterServiceSummary != nil {
                    var tmp : [Any] = []
                    for k in self.clusterServiceSummary! {
                        tmp.append(k.toMap())
                    }
                    map["ClusterServiceSummary"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ClusterServiceSummary") && dict["ClusterServiceSummary"] != nil {
                    var tmp : [DescribeClusterServiceResponseBody.ServiceInfo.ClusterServiceSummaryList.ClusterServiceSummary] = []
                    for v in dict["ClusterServiceSummary"] as! [Any] {
                        var model = DescribeClusterServiceResponseBody.ServiceInfo.ClusterServiceSummaryList.ClusterServiceSummary()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.clusterServiceSummary = tmp
                }
            }
        }
        public class NeedRestartComponentNameList : Tea.TeaModel {
            public var service: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.service != nil {
                    map["Service"] = self.service!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Service") && dict["Service"] != nil {
                    self.service = dict["Service"] as! [String]
                }
            }
        }
        public class NeedRestartHostIdList : Tea.TeaModel {
            public var service: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.service != nil {
                    map["Service"] = self.service!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Service") && dict["Service"] != nil {
                    self.service = dict["Service"] as! [String]
                }
            }
        }
        public class ServiceActionList : Tea.TeaModel {
            public class ServiceAction : Tea.TeaModel {
                public var actionName: String?

                public var command: String?

                public var componentName: String?

                public var displayName: String?

                public var serviceName: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.actionName != nil {
                        map["ActionName"] = self.actionName!
                    }
                    if self.command != nil {
                        map["Command"] = self.command!
                    }
                    if self.componentName != nil {
                        map["ComponentName"] = self.componentName!
                    }
                    if self.displayName != nil {
                        map["DisplayName"] = self.displayName!
                    }
                    if self.serviceName != nil {
                        map["ServiceName"] = self.serviceName!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ActionName") && dict["ActionName"] != nil {
                        self.actionName = dict["ActionName"] as! String
                    }
                    if dict.keys.contains("Command") && dict["Command"] != nil {
                        self.command = dict["Command"] as! String
                    }
                    if dict.keys.contains("ComponentName") && dict["ComponentName"] != nil {
                        self.componentName = dict["ComponentName"] as! String
                    }
                    if dict.keys.contains("DisplayName") && dict["DisplayName"] != nil {
                        self.displayName = dict["DisplayName"] as! String
                    }
                    if dict.keys.contains("ServiceName") && dict["ServiceName"] != nil {
                        self.serviceName = dict["ServiceName"] as! String
                    }
                }
            }
            public var serviceAction: [DescribeClusterServiceResponseBody.ServiceInfo.ServiceActionList.ServiceAction]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.serviceAction != nil {
                    var tmp : [Any] = []
                    for k in self.serviceAction! {
                        tmp.append(k.toMap())
                    }
                    map["ServiceAction"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ServiceAction") && dict["ServiceAction"] != nil {
                    var tmp : [DescribeClusterServiceResponseBody.ServiceInfo.ServiceActionList.ServiceAction] = []
                    for v in dict["ServiceAction"] as! [Any] {
                        var model = DescribeClusterServiceResponseBody.ServiceInfo.ServiceActionList.ServiceAction()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.serviceAction = tmp
                }
            }
        }
        public var clusterServiceSummaryList: DescribeClusterServiceResponseBody.ServiceInfo.ClusterServiceSummaryList?

        public var needRestartComponentNameList: DescribeClusterServiceResponseBody.ServiceInfo.NeedRestartComponentNameList?

        public var needRestartHostIdList: DescribeClusterServiceResponseBody.ServiceInfo.NeedRestartHostIdList?

        public var needRestartInfo: String?

        public var needRestartNum: Int32?

        public var serviceActionList: DescribeClusterServiceResponseBody.ServiceInfo.ServiceActionList?

        public var serviceName: String?

        public var serviceStatus: String?

        public var serviceVersion: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.clusterServiceSummaryList?.validate()
            try self.needRestartComponentNameList?.validate()
            try self.needRestartHostIdList?.validate()
            try self.serviceActionList?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.clusterServiceSummaryList != nil {
                map["ClusterServiceSummaryList"] = self.clusterServiceSummaryList?.toMap()
            }
            if self.needRestartComponentNameList != nil {
                map["NeedRestartComponentNameList"] = self.needRestartComponentNameList?.toMap()
            }
            if self.needRestartHostIdList != nil {
                map["NeedRestartHostIdList"] = self.needRestartHostIdList?.toMap()
            }
            if self.needRestartInfo != nil {
                map["NeedRestartInfo"] = self.needRestartInfo!
            }
            if self.needRestartNum != nil {
                map["NeedRestartNum"] = self.needRestartNum!
            }
            if self.serviceActionList != nil {
                map["ServiceActionList"] = self.serviceActionList?.toMap()
            }
            if self.serviceName != nil {
                map["ServiceName"] = self.serviceName!
            }
            if self.serviceStatus != nil {
                map["ServiceStatus"] = self.serviceStatus!
            }
            if self.serviceVersion != nil {
                map["ServiceVersion"] = self.serviceVersion!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ClusterServiceSummaryList") && dict["ClusterServiceSummaryList"] != nil {
                var model = DescribeClusterServiceResponseBody.ServiceInfo.ClusterServiceSummaryList()
                model.fromMap(dict["ClusterServiceSummaryList"] as! [String: Any])
                self.clusterServiceSummaryList = model
            }
            if dict.keys.contains("NeedRestartComponentNameList") && dict["NeedRestartComponentNameList"] != nil {
                var model = DescribeClusterServiceResponseBody.ServiceInfo.NeedRestartComponentNameList()
                model.fromMap(dict["NeedRestartComponentNameList"] as! [String: Any])
                self.needRestartComponentNameList = model
            }
            if dict.keys.contains("NeedRestartHostIdList") && dict["NeedRestartHostIdList"] != nil {
                var model = DescribeClusterServiceResponseBody.ServiceInfo.NeedRestartHostIdList()
                model.fromMap(dict["NeedRestartHostIdList"] as! [String: Any])
                self.needRestartHostIdList = model
            }
            if dict.keys.contains("NeedRestartInfo") && dict["NeedRestartInfo"] != nil {
                self.needRestartInfo = dict["NeedRestartInfo"] as! String
            }
            if dict.keys.contains("NeedRestartNum") && dict["NeedRestartNum"] != nil {
                self.needRestartNum = dict["NeedRestartNum"] as! Int32
            }
            if dict.keys.contains("ServiceActionList") && dict["ServiceActionList"] != nil {
                var model = DescribeClusterServiceResponseBody.ServiceInfo.ServiceActionList()
                model.fromMap(dict["ServiceActionList"] as! [String: Any])
                self.serviceActionList = model
            }
            if dict.keys.contains("ServiceName") && dict["ServiceName"] != nil {
                self.serviceName = dict["ServiceName"] as! String
            }
            if dict.keys.contains("ServiceStatus") && dict["ServiceStatus"] != nil {
                self.serviceStatus = dict["ServiceStatus"] as! String
            }
            if dict.keys.contains("ServiceVersion") && dict["ServiceVersion"] != nil {
                self.serviceVersion = dict["ServiceVersion"] as! String
            }
        }
    }
    public var requestId: String?

    public var serviceInfo: DescribeClusterServiceResponseBody.ServiceInfo?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.serviceInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.serviceInfo != nil {
            map["ServiceInfo"] = self.serviceInfo?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ServiceInfo") && dict["ServiceInfo"] != nil {
            var model = DescribeClusterServiceResponseBody.ServiceInfo()
            model.fromMap(dict["ServiceInfo"] as! [String: Any])
            self.serviceInfo = model
        }
    }
}

public class DescribeClusterServiceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeClusterServiceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeClusterServiceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeClusterServiceConfigRequest : Tea.TeaModel {
    public var clusterId: String?

    public var configVersion: String?

    public var groupId: String?

    public var hostInstanceId: String?

    public var regionId: String?

    public var resourceOwnerId: Int64?

    public var serviceName: String?

    public var tagValue: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.configVersion != nil {
            map["ConfigVersion"] = self.configVersion!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.hostInstanceId != nil {
            map["HostInstanceId"] = self.hostInstanceId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.serviceName != nil {
            map["ServiceName"] = self.serviceName!
        }
        if self.tagValue != nil {
            map["TagValue"] = self.tagValue!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("ConfigVersion") && dict["ConfigVersion"] != nil {
            self.configVersion = dict["ConfigVersion"] as! String
        }
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("HostInstanceId") && dict["HostInstanceId"] != nil {
            self.hostInstanceId = dict["HostInstanceId"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") && dict["ResourceOwnerId"] != nil {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("ServiceName") && dict["ServiceName"] != nil {
            self.serviceName = dict["ServiceName"] as! String
        }
        if dict.keys.contains("TagValue") && dict["TagValue"] != nil {
            self.tagValue = dict["TagValue"] as! String
        }
    }
}

public class DescribeClusterServiceConfigResponseBody : Tea.TeaModel {
    public class Config : Tea.TeaModel {
        public class ConfigValueList : Tea.TeaModel {
            public class ConfigValue : Tea.TeaModel {
                public class ConfigItemValueList : Tea.TeaModel {
                    public class ConfigItemValue : Tea.TeaModel {
                        public var description_: String?

                        public var isCustom: Bool?

                        public var itemName: String?

                        public var value: String?

                        public var valueScope: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.description_ != nil {
                                map["Description"] = self.description_!
                            }
                            if self.isCustom != nil {
                                map["IsCustom"] = self.isCustom!
                            }
                            if self.itemName != nil {
                                map["ItemName"] = self.itemName!
                            }
                            if self.value != nil {
                                map["Value"] = self.value!
                            }
                            if self.valueScope != nil {
                                map["ValueScope"] = self.valueScope!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Description") && dict["Description"] != nil {
                                self.description_ = dict["Description"] as! String
                            }
                            if dict.keys.contains("IsCustom") && dict["IsCustom"] != nil {
                                self.isCustom = dict["IsCustom"] as! Bool
                            }
                            if dict.keys.contains("ItemName") && dict["ItemName"] != nil {
                                self.itemName = dict["ItemName"] as! String
                            }
                            if dict.keys.contains("Value") && dict["Value"] != nil {
                                self.value = dict["Value"] as! String
                            }
                            if dict.keys.contains("ValueScope") && dict["ValueScope"] != nil {
                                self.valueScope = dict["ValueScope"] as! String
                            }
                        }
                    }
                    public var configItemValue: [DescribeClusterServiceConfigResponseBody.Config.ConfigValueList.ConfigValue.ConfigItemValueList.ConfigItemValue]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.configItemValue != nil {
                            var tmp : [Any] = []
                            for k in self.configItemValue! {
                                tmp.append(k.toMap())
                            }
                            map["ConfigItemValue"] = tmp
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("ConfigItemValue") && dict["ConfigItemValue"] != nil {
                            var tmp : [DescribeClusterServiceConfigResponseBody.Config.ConfigValueList.ConfigValue.ConfigItemValueList.ConfigItemValue] = []
                            for v in dict["ConfigItemValue"] as! [Any] {
                                var model = DescribeClusterServiceConfigResponseBody.Config.ConfigValueList.ConfigValue.ConfigItemValueList.ConfigItemValue()
                                if v != nil {
                                    model.fromMap(v as! [String: Any])
                                }
                                tmp.append(model)
                            }
                            self.configItemValue = tmp
                        }
                    }
                }
                public var allowCustom: Bool?

                public var configItemValueList: DescribeClusterServiceConfigResponseBody.Config.ConfigValueList.ConfigValue.ConfigItemValueList?

                public var configName: String?

                public var scope: String?

                public var scopeId: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.configItemValueList?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.allowCustom != nil {
                        map["AllowCustom"] = self.allowCustom!
                    }
                    if self.configItemValueList != nil {
                        map["ConfigItemValueList"] = self.configItemValueList?.toMap()
                    }
                    if self.configName != nil {
                        map["ConfigName"] = self.configName!
                    }
                    if self.scope != nil {
                        map["Scope"] = self.scope!
                    }
                    if self.scopeId != nil {
                        map["ScopeId"] = self.scopeId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AllowCustom") && dict["AllowCustom"] != nil {
                        self.allowCustom = dict["AllowCustom"] as! Bool
                    }
                    if dict.keys.contains("ConfigItemValueList") && dict["ConfigItemValueList"] != nil {
                        var model = DescribeClusterServiceConfigResponseBody.Config.ConfigValueList.ConfigValue.ConfigItemValueList()
                        model.fromMap(dict["ConfigItemValueList"] as! [String: Any])
                        self.configItemValueList = model
                    }
                    if dict.keys.contains("ConfigName") && dict["ConfigName"] != nil {
                        self.configName = dict["ConfigName"] as! String
                    }
                    if dict.keys.contains("Scope") && dict["Scope"] != nil {
                        self.scope = dict["Scope"] as! String
                    }
                    if dict.keys.contains("ScopeId") && dict["ScopeId"] != nil {
                        self.scopeId = dict["ScopeId"] as! Int64
                    }
                }
            }
            public var configValue: [DescribeClusterServiceConfigResponseBody.Config.ConfigValueList.ConfigValue]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.configValue != nil {
                    var tmp : [Any] = []
                    for k in self.configValue! {
                        tmp.append(k.toMap())
                    }
                    map["ConfigValue"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ConfigValue") && dict["ConfigValue"] != nil {
                    var tmp : [DescribeClusterServiceConfigResponseBody.Config.ConfigValueList.ConfigValue] = []
                    for v in dict["ConfigValue"] as! [Any] {
                        var model = DescribeClusterServiceConfigResponseBody.Config.ConfigValueList.ConfigValue()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.configValue = tmp
                }
            }
        }
        public class PropertyInfoList : Tea.TeaModel {
            public class PropertyInfo : Tea.TeaModel {
                public class EffectWay : Tea.TeaModel {
                    public var effectType: String?

                    public var invokeServiceName: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.effectType != nil {
                            map["EffectType"] = self.effectType!
                        }
                        if self.invokeServiceName != nil {
                            map["InvokeServiceName"] = self.invokeServiceName!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("EffectType") && dict["EffectType"] != nil {
                            self.effectType = dict["EffectType"] as! String
                        }
                        if dict.keys.contains("InvokeServiceName") && dict["InvokeServiceName"] != nil {
                            self.invokeServiceName = dict["InvokeServiceName"] as! String
                        }
                    }
                }
                public class PropertyTypes : Tea.TeaModel {
                    public var propertyType: [String]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.propertyType != nil {
                            map["propertyType"] = self.propertyType!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("propertyType") && dict["propertyType"] != nil {
                            self.propertyType = dict["propertyType"] as! [String]
                        }
                    }
                }
                public class PropertyValueAttributes : Tea.TeaModel {
                    public class Entries : Tea.TeaModel {
                        public class ValueEntryInfo : Tea.TeaModel {
                            public var description_: String?

                            public var label: String?

                            public var value: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.description_ != nil {
                                    map["Description"] = self.description_!
                                }
                                if self.label != nil {
                                    map["Label"] = self.label!
                                }
                                if self.value != nil {
                                    map["Value"] = self.value!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Description") && dict["Description"] != nil {
                                    self.description_ = dict["Description"] as! String
                                }
                                if dict.keys.contains("Label") && dict["Label"] != nil {
                                    self.label = dict["Label"] as! String
                                }
                                if dict.keys.contains("Value") && dict["Value"] != nil {
                                    self.value = dict["Value"] as! String
                                }
                            }
                        }
                        public var valueEntryInfo: [DescribeClusterServiceConfigResponseBody.Config.PropertyInfoList.PropertyInfo.PropertyValueAttributes.Entries.ValueEntryInfo]?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.valueEntryInfo != nil {
                                var tmp : [Any] = []
                                for k in self.valueEntryInfo! {
                                    tmp.append(k.toMap())
                                }
                                map["ValueEntryInfo"] = tmp
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("ValueEntryInfo") && dict["ValueEntryInfo"] != nil {
                                var tmp : [DescribeClusterServiceConfigResponseBody.Config.PropertyInfoList.PropertyInfo.PropertyValueAttributes.Entries.ValueEntryInfo] = []
                                for v in dict["ValueEntryInfo"] as! [Any] {
                                    var model = DescribeClusterServiceConfigResponseBody.Config.PropertyInfoList.PropertyInfo.PropertyValueAttributes.Entries.ValueEntryInfo()
                                    if v != nil {
                                        model.fromMap(v as! [String: Any])
                                    }
                                    tmp.append(model)
                                }
                                self.valueEntryInfo = tmp
                            }
                        }
                    }
                    public var entries: DescribeClusterServiceConfigResponseBody.Config.PropertyInfoList.PropertyInfo.PropertyValueAttributes.Entries?

                    public var hidden: Bool?

                    public var incrememtStep: String?

                    public var maximum: String?

                    public var mimimum: String?

                    public var readOnly: Bool?

                    public var type: String?

                    public var unit: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.entries?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.entries != nil {
                            map["Entries"] = self.entries?.toMap()
                        }
                        if self.hidden != nil {
                            map["Hidden"] = self.hidden!
                        }
                        if self.incrememtStep != nil {
                            map["IncrememtStep"] = self.incrememtStep!
                        }
                        if self.maximum != nil {
                            map["Maximum"] = self.maximum!
                        }
                        if self.mimimum != nil {
                            map["Mimimum"] = self.mimimum!
                        }
                        if self.readOnly != nil {
                            map["ReadOnly"] = self.readOnly!
                        }
                        if self.type != nil {
                            map["Type"] = self.type!
                        }
                        if self.unit != nil {
                            map["Unit"] = self.unit!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Entries") && dict["Entries"] != nil {
                            var model = DescribeClusterServiceConfigResponseBody.Config.PropertyInfoList.PropertyInfo.PropertyValueAttributes.Entries()
                            model.fromMap(dict["Entries"] as! [String: Any])
                            self.entries = model
                        }
                        if dict.keys.contains("Hidden") && dict["Hidden"] != nil {
                            self.hidden = dict["Hidden"] as! Bool
                        }
                        if dict.keys.contains("IncrememtStep") && dict["IncrememtStep"] != nil {
                            self.incrememtStep = dict["IncrememtStep"] as! String
                        }
                        if dict.keys.contains("Maximum") && dict["Maximum"] != nil {
                            self.maximum = dict["Maximum"] as! String
                        }
                        if dict.keys.contains("Mimimum") && dict["Mimimum"] != nil {
                            self.mimimum = dict["Mimimum"] as! String
                        }
                        if dict.keys.contains("ReadOnly") && dict["ReadOnly"] != nil {
                            self.readOnly = dict["ReadOnly"] as! Bool
                        }
                        if dict.keys.contains("Type") && dict["Type"] != nil {
                            self.type = dict["Type"] as! String
                        }
                        if dict.keys.contains("Unit") && dict["Unit"] != nil {
                            self.unit = dict["Unit"] as! String
                        }
                    }
                }
                public var component: String?

                public var description_: String?

                public var displayName: String?

                public var effectWay: DescribeClusterServiceConfigResponseBody.Config.PropertyInfoList.PropertyInfo.EffectWay?

                public var fileName: String?

                public var name: String?

                public var propertyTypes: DescribeClusterServiceConfigResponseBody.Config.PropertyInfoList.PropertyInfo.PropertyTypes?

                public var propertyValueAttributes: DescribeClusterServiceConfigResponseBody.Config.PropertyInfoList.PropertyInfo.PropertyValueAttributes?

                public var serviceName: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.effectWay?.validate()
                    try self.propertyTypes?.validate()
                    try self.propertyValueAttributes?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.component != nil {
                        map["Component"] = self.component!
                    }
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.displayName != nil {
                        map["DisplayName"] = self.displayName!
                    }
                    if self.effectWay != nil {
                        map["EffectWay"] = self.effectWay?.toMap()
                    }
                    if self.fileName != nil {
                        map["FileName"] = self.fileName!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.propertyTypes != nil {
                        map["PropertyTypes"] = self.propertyTypes?.toMap()
                    }
                    if self.propertyValueAttributes != nil {
                        map["PropertyValueAttributes"] = self.propertyValueAttributes?.toMap()
                    }
                    if self.serviceName != nil {
                        map["ServiceName"] = self.serviceName!
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Component") && dict["Component"] != nil {
                        self.component = dict["Component"] as! String
                    }
                    if dict.keys.contains("Description") && dict["Description"] != nil {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("DisplayName") && dict["DisplayName"] != nil {
                        self.displayName = dict["DisplayName"] as! String
                    }
                    if dict.keys.contains("EffectWay") && dict["EffectWay"] != nil {
                        var model = DescribeClusterServiceConfigResponseBody.Config.PropertyInfoList.PropertyInfo.EffectWay()
                        model.fromMap(dict["EffectWay"] as! [String: Any])
                        self.effectWay = model
                    }
                    if dict.keys.contains("FileName") && dict["FileName"] != nil {
                        self.fileName = dict["FileName"] as! String
                    }
                    if dict.keys.contains("Name") && dict["Name"] != nil {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("PropertyTypes") && dict["PropertyTypes"] != nil {
                        var model = DescribeClusterServiceConfigResponseBody.Config.PropertyInfoList.PropertyInfo.PropertyTypes()
                        model.fromMap(dict["PropertyTypes"] as! [String: Any])
                        self.propertyTypes = model
                    }
                    if dict.keys.contains("PropertyValueAttributes") && dict["PropertyValueAttributes"] != nil {
                        var model = DescribeClusterServiceConfigResponseBody.Config.PropertyInfoList.PropertyInfo.PropertyValueAttributes()
                        model.fromMap(dict["PropertyValueAttributes"] as! [String: Any])
                        self.propertyValueAttributes = model
                    }
                    if dict.keys.contains("ServiceName") && dict["ServiceName"] != nil {
                        self.serviceName = dict["ServiceName"] as! String
                    }
                    if dict.keys.contains("Value") && dict["Value"] != nil {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public var propertyInfo: [DescribeClusterServiceConfigResponseBody.Config.PropertyInfoList.PropertyInfo]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.propertyInfo != nil {
                    var tmp : [Any] = []
                    for k in self.propertyInfo! {
                        tmp.append(k.toMap())
                    }
                    map["PropertyInfo"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("PropertyInfo") && dict["PropertyInfo"] != nil {
                    var tmp : [DescribeClusterServiceConfigResponseBody.Config.PropertyInfoList.PropertyInfo] = []
                    for v in dict["PropertyInfo"] as! [Any] {
                        var model = DescribeClusterServiceConfigResponseBody.Config.PropertyInfoList.PropertyInfo()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.propertyInfo = tmp
                }
            }
        }
        public var applied: String?

        public var author: String?

        public var comment: String?

        public var configValueList: DescribeClusterServiceConfigResponseBody.Config.ConfigValueList?

        public var configVersion: String?

        public var createTime: String?

        public var propertyInfoList: DescribeClusterServiceConfigResponseBody.Config.PropertyInfoList?

        public var serviceName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.configValueList?.validate()
            try self.propertyInfoList?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.applied != nil {
                map["Applied"] = self.applied!
            }
            if self.author != nil {
                map["Author"] = self.author!
            }
            if self.comment != nil {
                map["Comment"] = self.comment!
            }
            if self.configValueList != nil {
                map["ConfigValueList"] = self.configValueList?.toMap()
            }
            if self.configVersion != nil {
                map["ConfigVersion"] = self.configVersion!
            }
            if self.createTime != nil {
                map["CreateTime"] = self.createTime!
            }
            if self.propertyInfoList != nil {
                map["PropertyInfoList"] = self.propertyInfoList?.toMap()
            }
            if self.serviceName != nil {
                map["ServiceName"] = self.serviceName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Applied") && dict["Applied"] != nil {
                self.applied = dict["Applied"] as! String
            }
            if dict.keys.contains("Author") && dict["Author"] != nil {
                self.author = dict["Author"] as! String
            }
            if dict.keys.contains("Comment") && dict["Comment"] != nil {
                self.comment = dict["Comment"] as! String
            }
            if dict.keys.contains("ConfigValueList") && dict["ConfigValueList"] != nil {
                var model = DescribeClusterServiceConfigResponseBody.Config.ConfigValueList()
                model.fromMap(dict["ConfigValueList"] as! [String: Any])
                self.configValueList = model
            }
            if dict.keys.contains("ConfigVersion") && dict["ConfigVersion"] != nil {
                self.configVersion = dict["ConfigVersion"] as! String
            }
            if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                self.createTime = dict["CreateTime"] as! String
            }
            if dict.keys.contains("PropertyInfoList") && dict["PropertyInfoList"] != nil {
                var model = DescribeClusterServiceConfigResponseBody.Config.PropertyInfoList()
                model.fromMap(dict["PropertyInfoList"] as! [String: Any])
                self.propertyInfoList = model
            }
            if dict.keys.contains("ServiceName") && dict["ServiceName"] != nil {
                self.serviceName = dict["ServiceName"] as! String
            }
        }
    }
    public var config: DescribeClusterServiceConfigResponseBody.Config?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.config?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.config != nil {
            map["Config"] = self.config?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Config") && dict["Config"] != nil {
            var model = DescribeClusterServiceConfigResponseBody.Config()
            model.fromMap(dict["Config"] as! [String: Any])
            self.config = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeClusterServiceConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeClusterServiceConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeClusterServiceConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeClusterServiceConfigTagRequest : Tea.TeaModel {
    public var clusterId: String?

    public var configTag: String?

    public var regionId: String?

    public var resourceOwnerId: Int64?

    public var serviceName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.configTag != nil {
            map["ConfigTag"] = self.configTag!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.serviceName != nil {
            map["ServiceName"] = self.serviceName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("ConfigTag") && dict["ConfigTag"] != nil {
            self.configTag = dict["ConfigTag"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") && dict["ResourceOwnerId"] != nil {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("ServiceName") && dict["ServiceName"] != nil {
            self.serviceName = dict["ServiceName"] as! String
        }
    }
}

public class DescribeClusterServiceConfigTagResponseBody : Tea.TeaModel {
    public class ConfigTagList : Tea.TeaModel {
        public class ConfigTag : Tea.TeaModel {
            public class ValueList : Tea.TeaModel {
                public class Value : Tea.TeaModel {
                    public var value: String?

                    public var valueDesc: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        if self.valueDesc != nil {
                            map["ValueDesc"] = self.valueDesc!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Value") && dict["Value"] != nil {
                            self.value = dict["Value"] as! String
                        }
                        if dict.keys.contains("ValueDesc") && dict["ValueDesc"] != nil {
                            self.valueDesc = dict["ValueDesc"] as! String
                        }
                    }
                }
                public var value: [DescribeClusterServiceConfigTagResponseBody.ConfigTagList.ConfigTag.ValueList.Value]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.value != nil {
                        var tmp : [Any] = []
                        for k in self.value! {
                            tmp.append(k.toMap())
                        }
                        map["Value"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Value") && dict["Value"] != nil {
                        var tmp : [DescribeClusterServiceConfigTagResponseBody.ConfigTagList.ConfigTag.ValueList.Value] = []
                        for v in dict["Value"] as! [Any] {
                            var model = DescribeClusterServiceConfigTagResponseBody.ConfigTagList.ConfigTag.ValueList.Value()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.value = tmp
                    }
                }
            }
            public var tag: String?

            public var tagDesc: String?

            public var valueList: DescribeClusterServiceConfigTagResponseBody.ConfigTagList.ConfigTag.ValueList?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.valueList?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.tag != nil {
                    map["Tag"] = self.tag!
                }
                if self.tagDesc != nil {
                    map["TagDesc"] = self.tagDesc!
                }
                if self.valueList != nil {
                    map["ValueList"] = self.valueList?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Tag") && dict["Tag"] != nil {
                    self.tag = dict["Tag"] as! String
                }
                if dict.keys.contains("TagDesc") && dict["TagDesc"] != nil {
                    self.tagDesc = dict["TagDesc"] as! String
                }
                if dict.keys.contains("ValueList") && dict["ValueList"] != nil {
                    var model = DescribeClusterServiceConfigTagResponseBody.ConfigTagList.ConfigTag.ValueList()
                    model.fromMap(dict["ValueList"] as! [String: Any])
                    self.valueList = model
                }
            }
        }
        public var configTag: [DescribeClusterServiceConfigTagResponseBody.ConfigTagList.ConfigTag]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.configTag != nil {
                var tmp : [Any] = []
                for k in self.configTag! {
                    tmp.append(k.toMap())
                }
                map["ConfigTag"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ConfigTag") && dict["ConfigTag"] != nil {
                var tmp : [DescribeClusterServiceConfigTagResponseBody.ConfigTagList.ConfigTag] = []
                for v in dict["ConfigTag"] as! [Any] {
                    var model = DescribeClusterServiceConfigTagResponseBody.ConfigTagList.ConfigTag()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.configTag = tmp
            }
        }
    }
    public var configTagList: DescribeClusterServiceConfigTagResponseBody.ConfigTagList?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.configTagList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.configTagList != nil {
            map["ConfigTagList"] = self.configTagList?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ConfigTagList") && dict["ConfigTagList"] != nil {
            var model = DescribeClusterServiceConfigTagResponseBody.ConfigTagList()
            model.fromMap(dict["ConfigTagList"] as! [String: Any])
            self.configTagList = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeClusterServiceConfigTagResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeClusterServiceConfigTagResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeClusterServiceConfigTagResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeClusterTemplateRequest : Tea.TeaModel {
    public var bizId: String?

    public var resourceGroupId: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") && dict["ResourceGroupId"] != nil {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") && dict["ResourceOwnerId"] != nil {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class DescribeClusterTemplateResponseBody : Tea.TeaModel {
    public class TemplateInfo : Tea.TeaModel {
        public class BootstrapActionList : Tea.TeaModel {
            public class BootstrapAction : Tea.TeaModel {
                public var arg: String?

                public var name: String?

                public var path: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.arg != nil {
                        map["Arg"] = self.arg!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.path != nil {
                        map["Path"] = self.path!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Arg") && dict["Arg"] != nil {
                        self.arg = dict["Arg"] as! String
                    }
                    if dict.keys.contains("Name") && dict["Name"] != nil {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Path") && dict["Path"] != nil {
                        self.path = dict["Path"] as! String
                    }
                }
            }
            public var bootstrapAction: [DescribeClusterTemplateResponseBody.TemplateInfo.BootstrapActionList.BootstrapAction]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bootstrapAction != nil {
                    var tmp : [Any] = []
                    for k in self.bootstrapAction! {
                        tmp.append(k.toMap())
                    }
                    map["BootstrapAction"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BootstrapAction") && dict["BootstrapAction"] != nil {
                    var tmp : [DescribeClusterTemplateResponseBody.TemplateInfo.BootstrapActionList.BootstrapAction] = []
                    for v in dict["BootstrapAction"] as! [Any] {
                        var model = DescribeClusterTemplateResponseBody.TemplateInfo.BootstrapActionList.BootstrapAction()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.bootstrapAction = tmp
                }
            }
        }
        public class ConfigList : Tea.TeaModel {
            public class Config : Tea.TeaModel {
                public var configKey: String?

                public var configValue: String?

                public var encrypt: String?

                public var fileName: String?

                public var replace: String?

                public var serviceName: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.configKey != nil {
                        map["ConfigKey"] = self.configKey!
                    }
                    if self.configValue != nil {
                        map["ConfigValue"] = self.configValue!
                    }
                    if self.encrypt != nil {
                        map["Encrypt"] = self.encrypt!
                    }
                    if self.fileName != nil {
                        map["FileName"] = self.fileName!
                    }
                    if self.replace != nil {
                        map["Replace"] = self.replace!
                    }
                    if self.serviceName != nil {
                        map["ServiceName"] = self.serviceName!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ConfigKey") && dict["ConfigKey"] != nil {
                        self.configKey = dict["ConfigKey"] as! String
                    }
                    if dict.keys.contains("ConfigValue") && dict["ConfigValue"] != nil {
                        self.configValue = dict["ConfigValue"] as! String
                    }
                    if dict.keys.contains("Encrypt") && dict["Encrypt"] != nil {
                        self.encrypt = dict["Encrypt"] as! String
                    }
                    if dict.keys.contains("FileName") && dict["FileName"] != nil {
                        self.fileName = dict["FileName"] as! String
                    }
                    if dict.keys.contains("Replace") && dict["Replace"] != nil {
                        self.replace = dict["Replace"] as! String
                    }
                    if dict.keys.contains("ServiceName") && dict["ServiceName"] != nil {
                        self.serviceName = dict["ServiceName"] as! String
                    }
                }
            }
            public var config: [DescribeClusterTemplateResponseBody.TemplateInfo.ConfigList.Config]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.config != nil {
                    var tmp : [Any] = []
                    for k in self.config! {
                        tmp.append(k.toMap())
                    }
                    map["Config"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Config") && dict["Config"] != nil {
                    var tmp : [DescribeClusterTemplateResponseBody.TemplateInfo.ConfigList.Config] = []
                    for v in dict["Config"] as! [Any] {
                        var model = DescribeClusterTemplateResponseBody.TemplateInfo.ConfigList.Config()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.config = tmp
                }
            }
        }
        public class HostGroupList : Tea.TeaModel {
            public class HostGroup : Tea.TeaModel {
                public var chargeType: String?

                public var diskCapacity: Int32?

                public var diskCount: Int32?

                public var diskType: String?

                public var hostGroupId: String?

                public var hostGroupName: String?

                public var hostGroupType: String?

                public var instanceType: String?

                public var multiInstanceTypes: String?

                public var nodeCount: Int32?

                public var period: String?

                public var sysDiskCapacity: Int32?

                public var sysDiskType: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.chargeType != nil {
                        map["ChargeType"] = self.chargeType!
                    }
                    if self.diskCapacity != nil {
                        map["DiskCapacity"] = self.diskCapacity!
                    }
                    if self.diskCount != nil {
                        map["DiskCount"] = self.diskCount!
                    }
                    if self.diskType != nil {
                        map["DiskType"] = self.diskType!
                    }
                    if self.hostGroupId != nil {
                        map["HostGroupId"] = self.hostGroupId!
                    }
                    if self.hostGroupName != nil {
                        map["HostGroupName"] = self.hostGroupName!
                    }
                    if self.hostGroupType != nil {
                        map["HostGroupType"] = self.hostGroupType!
                    }
                    if self.instanceType != nil {
                        map["InstanceType"] = self.instanceType!
                    }
                    if self.multiInstanceTypes != nil {
                        map["MultiInstanceTypes"] = self.multiInstanceTypes!
                    }
                    if self.nodeCount != nil {
                        map["NodeCount"] = self.nodeCount!
                    }
                    if self.period != nil {
                        map["Period"] = self.period!
                    }
                    if self.sysDiskCapacity != nil {
                        map["SysDiskCapacity"] = self.sysDiskCapacity!
                    }
                    if self.sysDiskType != nil {
                        map["SysDiskType"] = self.sysDiskType!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ChargeType") && dict["ChargeType"] != nil {
                        self.chargeType = dict["ChargeType"] as! String
                    }
                    if dict.keys.contains("DiskCapacity") && dict["DiskCapacity"] != nil {
                        self.diskCapacity = dict["DiskCapacity"] as! Int32
                    }
                    if dict.keys.contains("DiskCount") && dict["DiskCount"] != nil {
                        self.diskCount = dict["DiskCount"] as! Int32
                    }
                    if dict.keys.contains("DiskType") && dict["DiskType"] != nil {
                        self.diskType = dict["DiskType"] as! String
                    }
                    if dict.keys.contains("HostGroupId") && dict["HostGroupId"] != nil {
                        self.hostGroupId = dict["HostGroupId"] as! String
                    }
                    if dict.keys.contains("HostGroupName") && dict["HostGroupName"] != nil {
                        self.hostGroupName = dict["HostGroupName"] as! String
                    }
                    if dict.keys.contains("HostGroupType") && dict["HostGroupType"] != nil {
                        self.hostGroupType = dict["HostGroupType"] as! String
                    }
                    if dict.keys.contains("InstanceType") && dict["InstanceType"] != nil {
                        self.instanceType = dict["InstanceType"] as! String
                    }
                    if dict.keys.contains("MultiInstanceTypes") && dict["MultiInstanceTypes"] != nil {
                        self.multiInstanceTypes = dict["MultiInstanceTypes"] as! String
                    }
                    if dict.keys.contains("NodeCount") && dict["NodeCount"] != nil {
                        self.nodeCount = dict["NodeCount"] as! Int32
                    }
                    if dict.keys.contains("Period") && dict["Period"] != nil {
                        self.period = dict["Period"] as! String
                    }
                    if dict.keys.contains("SysDiskCapacity") && dict["SysDiskCapacity"] != nil {
                        self.sysDiskCapacity = dict["SysDiskCapacity"] as! Int32
                    }
                    if dict.keys.contains("SysDiskType") && dict["SysDiskType"] != nil {
                        self.sysDiskType = dict["SysDiskType"] as! String
                    }
                }
            }
            public var hostGroup: [DescribeClusterTemplateResponseBody.TemplateInfo.HostGroupList.HostGroup]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.hostGroup != nil {
                    var tmp : [Any] = []
                    for k in self.hostGroup! {
                        tmp.append(k.toMap())
                    }
                    map["HostGroup"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("HostGroup") && dict["HostGroup"] != nil {
                    var tmp : [DescribeClusterTemplateResponseBody.TemplateInfo.HostGroupList.HostGroup] = []
                    for v in dict["HostGroup"] as! [Any] {
                        var model = DescribeClusterTemplateResponseBody.TemplateInfo.HostGroupList.HostGroup()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.hostGroup = tmp
                }
            }
        }
        public class SoftwareInfoList : Tea.TeaModel {
            public var softwareInfo: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.softwareInfo != nil {
                    map["SoftwareInfo"] = self.softwareInfo!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("SoftwareInfo") && dict["SoftwareInfo"] != nil {
                    self.softwareInfo = dict["SoftwareInfo"] as! [String]
                }
            }
        }
        public class Tags : Tea.TeaModel {
            public class Tag : Tea.TeaModel {
                public var tagKey: String?

                public var tagValue: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.tagKey != nil {
                        map["TagKey"] = self.tagKey!
                    }
                    if self.tagValue != nil {
                        map["TagValue"] = self.tagValue!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("TagKey") && dict["TagKey"] != nil {
                        self.tagKey = dict["TagKey"] as! String
                    }
                    if dict.keys.contains("TagValue") && dict["TagValue"] != nil {
                        self.tagValue = dict["TagValue"] as! String
                    }
                }
            }
            public var tag: [DescribeClusterTemplateResponseBody.TemplateInfo.Tags.Tag]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.tag != nil {
                    var tmp : [Any] = []
                    for k in self.tag! {
                        tmp.append(k.toMap())
                    }
                    map["Tag"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Tag") && dict["Tag"] != nil {
                    var tmp : [DescribeClusterTemplateResponseBody.TemplateInfo.Tags.Tag] = []
                    for v in dict["Tag"] as! [Any] {
                        var model = DescribeClusterTemplateResponseBody.TemplateInfo.Tags.Tag()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.tag = tmp
                }
            }
        }
        public var allowNotebook: Bool?

        public var bootstrapActionList: DescribeClusterTemplateResponseBody.TemplateInfo.BootstrapActionList?

        public var clusterType: String?

        public var configList: DescribeClusterTemplateResponseBody.TemplateInfo.ConfigList?

        public var configurations: String?

        public var createSource: String?

        public var dataDiskEncrypted: Bool?

        public var dataDiskKMSKeyId: String?

        public var depositType: String?

        public var easEnable: Bool?

        public var emrVer: String?

        public var gmtCreate: Int64?

        public var gmtModified: Int64?

        public var highAvailabilityEnable: Bool?

        public var hostGroupList: DescribeClusterTemplateResponseBody.TemplateInfo.HostGroupList?

        public var id: String?

        public var initCustomHiveMetaDb: Bool?

        public var instanceGeneration: String?

        public var ioOptimized: Bool?

        public var isOpenPublicIp: Bool?

        public var keyPairName: String?

        public var logEnable: Bool?

        public var logPath: String?

        public var machineType: String?

        public var masterNodeTotal: Int32?

        public var masterPwd: String?

        public var metaStoreConf: String?

        public var metaStoreType: String?

        public var netType: String?

        public var securityGroupId: String?

        public var securityGroupName: String?

        public var softwareInfoList: DescribeClusterTemplateResponseBody.TemplateInfo.SoftwareInfoList?

        public var sshEnable: Bool?

        public var tags: DescribeClusterTemplateResponseBody.TemplateInfo.Tags?

        public var templateName: String?

        public var useCustomHiveMetaDb: Bool?

        public var useLocalMetaDb: Bool?

        public var userDefinedEmrEcsRole: String?

        public var userId: String?

        public var vSwitchId: String?

        public var vpcId: String?

        public var zoneId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.bootstrapActionList?.validate()
            try self.configList?.validate()
            try self.hostGroupList?.validate()
            try self.softwareInfoList?.validate()
            try self.tags?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.allowNotebook != nil {
                map["AllowNotebook"] = self.allowNotebook!
            }
            if self.bootstrapActionList != nil {
                map["BootstrapActionList"] = self.bootstrapActionList?.toMap()
            }
            if self.clusterType != nil {
                map["ClusterType"] = self.clusterType!
            }
            if self.configList != nil {
                map["ConfigList"] = self.configList?.toMap()
            }
            if self.configurations != nil {
                map["Configurations"] = self.configurations!
            }
            if self.createSource != nil {
                map["CreateSource"] = self.createSource!
            }
            if self.dataDiskEncrypted != nil {
                map["DataDiskEncrypted"] = self.dataDiskEncrypted!
            }
            if self.dataDiskKMSKeyId != nil {
                map["DataDiskKMSKeyId"] = self.dataDiskKMSKeyId!
            }
            if self.depositType != nil {
                map["DepositType"] = self.depositType!
            }
            if self.easEnable != nil {
                map["EasEnable"] = self.easEnable!
            }
            if self.emrVer != nil {
                map["EmrVer"] = self.emrVer!
            }
            if self.gmtCreate != nil {
                map["GmtCreate"] = self.gmtCreate!
            }
            if self.gmtModified != nil {
                map["GmtModified"] = self.gmtModified!
            }
            if self.highAvailabilityEnable != nil {
                map["HighAvailabilityEnable"] = self.highAvailabilityEnable!
            }
            if self.hostGroupList != nil {
                map["HostGroupList"] = self.hostGroupList?.toMap()
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.initCustomHiveMetaDb != nil {
                map["InitCustomHiveMetaDb"] = self.initCustomHiveMetaDb!
            }
            if self.instanceGeneration != nil {
                map["InstanceGeneration"] = self.instanceGeneration!
            }
            if self.ioOptimized != nil {
                map["IoOptimized"] = self.ioOptimized!
            }
            if self.isOpenPublicIp != nil {
                map["IsOpenPublicIp"] = self.isOpenPublicIp!
            }
            if self.keyPairName != nil {
                map["KeyPairName"] = self.keyPairName!
            }
            if self.logEnable != nil {
                map["LogEnable"] = self.logEnable!
            }
            if self.logPath != nil {
                map["LogPath"] = self.logPath!
            }
            if self.machineType != nil {
                map["MachineType"] = self.machineType!
            }
            if self.masterNodeTotal != nil {
                map["MasterNodeTotal"] = self.masterNodeTotal!
            }
            if self.masterPwd != nil {
                map["MasterPwd"] = self.masterPwd!
            }
            if self.metaStoreConf != nil {
                map["MetaStoreConf"] = self.metaStoreConf!
            }
            if self.metaStoreType != nil {
                map["MetaStoreType"] = self.metaStoreType!
            }
            if self.netType != nil {
                map["NetType"] = self.netType!
            }
            if self.securityGroupId != nil {
                map["SecurityGroupId"] = self.securityGroupId!
            }
            if self.securityGroupName != nil {
                map["SecurityGroupName"] = self.securityGroupName!
            }
            if self.softwareInfoList != nil {
                map["SoftwareInfoList"] = self.softwareInfoList?.toMap()
            }
            if self.sshEnable != nil {
                map["SshEnable"] = self.sshEnable!
            }
            if self.tags != nil {
                map["Tags"] = self.tags?.toMap()
            }
            if self.templateName != nil {
                map["TemplateName"] = self.templateName!
            }
            if self.useCustomHiveMetaDb != nil {
                map["UseCustomHiveMetaDb"] = self.useCustomHiveMetaDb!
            }
            if self.useLocalMetaDb != nil {
                map["UseLocalMetaDb"] = self.useLocalMetaDb!
            }
            if self.userDefinedEmrEcsRole != nil {
                map["UserDefinedEmrEcsRole"] = self.userDefinedEmrEcsRole!
            }
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            if self.vSwitchId != nil {
                map["VSwitchId"] = self.vSwitchId!
            }
            if self.vpcId != nil {
                map["VpcId"] = self.vpcId!
            }
            if self.zoneId != nil {
                map["ZoneId"] = self.zoneId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AllowNotebook") && dict["AllowNotebook"] != nil {
                self.allowNotebook = dict["AllowNotebook"] as! Bool
            }
            if dict.keys.contains("BootstrapActionList") && dict["BootstrapActionList"] != nil {
                var model = DescribeClusterTemplateResponseBody.TemplateInfo.BootstrapActionList()
                model.fromMap(dict["BootstrapActionList"] as! [String: Any])
                self.bootstrapActionList = model
            }
            if dict.keys.contains("ClusterType") && dict["ClusterType"] != nil {
                self.clusterType = dict["ClusterType"] as! String
            }
            if dict.keys.contains("ConfigList") && dict["ConfigList"] != nil {
                var model = DescribeClusterTemplateResponseBody.TemplateInfo.ConfigList()
                model.fromMap(dict["ConfigList"] as! [String: Any])
                self.configList = model
            }
            if dict.keys.contains("Configurations") && dict["Configurations"] != nil {
                self.configurations = dict["Configurations"] as! String
            }
            if dict.keys.contains("CreateSource") && dict["CreateSource"] != nil {
                self.createSource = dict["CreateSource"] as! String
            }
            if dict.keys.contains("DataDiskEncrypted") && dict["DataDiskEncrypted"] != nil {
                self.dataDiskEncrypted = dict["DataDiskEncrypted"] as! Bool
            }
            if dict.keys.contains("DataDiskKMSKeyId") && dict["DataDiskKMSKeyId"] != nil {
                self.dataDiskKMSKeyId = dict["DataDiskKMSKeyId"] as! String
            }
            if dict.keys.contains("DepositType") && dict["DepositType"] != nil {
                self.depositType = dict["DepositType"] as! String
            }
            if dict.keys.contains("EasEnable") && dict["EasEnable"] != nil {
                self.easEnable = dict["EasEnable"] as! Bool
            }
            if dict.keys.contains("EmrVer") && dict["EmrVer"] != nil {
                self.emrVer = dict["EmrVer"] as! String
            }
            if dict.keys.contains("GmtCreate") && dict["GmtCreate"] != nil {
                self.gmtCreate = dict["GmtCreate"] as! Int64
            }
            if dict.keys.contains("GmtModified") && dict["GmtModified"] != nil {
                self.gmtModified = dict["GmtModified"] as! Int64
            }
            if dict.keys.contains("HighAvailabilityEnable") && dict["HighAvailabilityEnable"] != nil {
                self.highAvailabilityEnable = dict["HighAvailabilityEnable"] as! Bool
            }
            if dict.keys.contains("HostGroupList") && dict["HostGroupList"] != nil {
                var model = DescribeClusterTemplateResponseBody.TemplateInfo.HostGroupList()
                model.fromMap(dict["HostGroupList"] as! [String: Any])
                self.hostGroupList = model
            }
            if dict.keys.contains("Id") && dict["Id"] != nil {
                self.id = dict["Id"] as! String
            }
            if dict.keys.contains("InitCustomHiveMetaDb") && dict["InitCustomHiveMetaDb"] != nil {
                self.initCustomHiveMetaDb = dict["InitCustomHiveMetaDb"] as! Bool
            }
            if dict.keys.contains("InstanceGeneration") && dict["InstanceGeneration"] != nil {
                self.instanceGeneration = dict["InstanceGeneration"] as! String
            }
            if dict.keys.contains("IoOptimized") && dict["IoOptimized"] != nil {
                self.ioOptimized = dict["IoOptimized"] as! Bool
            }
            if dict.keys.contains("IsOpenPublicIp") && dict["IsOpenPublicIp"] != nil {
                self.isOpenPublicIp = dict["IsOpenPublicIp"] as! Bool
            }
            if dict.keys.contains("KeyPairName") && dict["KeyPairName"] != nil {
                self.keyPairName = dict["KeyPairName"] as! String
            }
            if dict.keys.contains("LogEnable") && dict["LogEnable"] != nil {
                self.logEnable = dict["LogEnable"] as! Bool
            }
            if dict.keys.contains("LogPath") && dict["LogPath"] != nil {
                self.logPath = dict["LogPath"] as! String
            }
            if dict.keys.contains("MachineType") && dict["MachineType"] != nil {
                self.machineType = dict["MachineType"] as! String
            }
            if dict.keys.contains("MasterNodeTotal") && dict["MasterNodeTotal"] != nil {
                self.masterNodeTotal = dict["MasterNodeTotal"] as! Int32
            }
            if dict.keys.contains("MasterPwd") && dict["MasterPwd"] != nil {
                self.masterPwd = dict["MasterPwd"] as! String
            }
            if dict.keys.contains("MetaStoreConf") && dict["MetaStoreConf"] != nil {
                self.metaStoreConf = dict["MetaStoreConf"] as! String
            }
            if dict.keys.contains("MetaStoreType") && dict["MetaStoreType"] != nil {
                self.metaStoreType = dict["MetaStoreType"] as! String
            }
            if dict.keys.contains("NetType") && dict["NetType"] != nil {
                self.netType = dict["NetType"] as! String
            }
            if dict.keys.contains("SecurityGroupId") && dict["SecurityGroupId"] != nil {
                self.securityGroupId = dict["SecurityGroupId"] as! String
            }
            if dict.keys.contains("SecurityGroupName") && dict["SecurityGroupName"] != nil {
                self.securityGroupName = dict["SecurityGroupName"] as! String
            }
            if dict.keys.contains("SoftwareInfoList") && dict["SoftwareInfoList"] != nil {
                var model = DescribeClusterTemplateResponseBody.TemplateInfo.SoftwareInfoList()
                model.fromMap(dict["SoftwareInfoList"] as! [String: Any])
                self.softwareInfoList = model
            }
            if dict.keys.contains("SshEnable") && dict["SshEnable"] != nil {
                self.sshEnable = dict["SshEnable"] as! Bool
            }
            if dict.keys.contains("Tags") && dict["Tags"] != nil {
                var model = DescribeClusterTemplateResponseBody.TemplateInfo.Tags()
                model.fromMap(dict["Tags"] as! [String: Any])
                self.tags = model
            }
            if dict.keys.contains("TemplateName") && dict["TemplateName"] != nil {
                self.templateName = dict["TemplateName"] as! String
            }
            if dict.keys.contains("UseCustomHiveMetaDb") && dict["UseCustomHiveMetaDb"] != nil {
                self.useCustomHiveMetaDb = dict["UseCustomHiveMetaDb"] as! Bool
            }
            if dict.keys.contains("UseLocalMetaDb") && dict["UseLocalMetaDb"] != nil {
                self.useLocalMetaDb = dict["UseLocalMetaDb"] as! Bool
            }
            if dict.keys.contains("UserDefinedEmrEcsRole") && dict["UserDefinedEmrEcsRole"] != nil {
                self.userDefinedEmrEcsRole = dict["UserDefinedEmrEcsRole"] as! String
            }
            if dict.keys.contains("UserId") && dict["UserId"] != nil {
                self.userId = dict["UserId"] as! String
            }
            if dict.keys.contains("VSwitchId") && dict["VSwitchId"] != nil {
                self.vSwitchId = dict["VSwitchId"] as! String
            }
            if dict.keys.contains("VpcId") && dict["VpcId"] != nil {
                self.vpcId = dict["VpcId"] as! String
            }
            if dict.keys.contains("ZoneId") && dict["ZoneId"] != nil {
                self.zoneId = dict["ZoneId"] as! String
            }
        }
    }
    public var requestId: String?

    public var templateInfo: DescribeClusterTemplateResponseBody.TemplateInfo?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.templateInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.templateInfo != nil {
            map["TemplateInfo"] = self.templateInfo?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TemplateInfo") && dict["TemplateInfo"] != nil {
            var model = DescribeClusterTemplateResponseBody.TemplateInfo()
            model.fromMap(dict["TemplateInfo"] as! [String: Any])
            self.templateInfo = model
        }
    }
}

public class DescribeClusterTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeClusterTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeClusterTemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeClusterV2Request : Tea.TeaModel {
    public var id: String?

    public var regionId: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") && dict["ResourceOwnerId"] != nil {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class DescribeClusterV2ResponseBody : Tea.TeaModel {
    public class ClusterInfo : Tea.TeaModel {
        public class AccessInfo : Tea.TeaModel {
            public class ZKLinks : Tea.TeaModel {
                public class ZKLink : Tea.TeaModel {
                    public var link: String?

                    public var port: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.link != nil {
                            map["Link"] = self.link!
                        }
                        if self.port != nil {
                            map["Port"] = self.port!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Link") && dict["Link"] != nil {
                            self.link = dict["Link"] as! String
                        }
                        if dict.keys.contains("Port") && dict["Port"] != nil {
                            self.port = dict["Port"] as! String
                        }
                    }
                }
                public var ZKLink: [DescribeClusterV2ResponseBody.ClusterInfo.AccessInfo.ZKLinks.ZKLink]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.ZKLink != nil {
                        var tmp : [Any] = []
                        for k in self.ZKLink! {
                            tmp.append(k.toMap())
                        }
                        map["ZKLink"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ZKLink") && dict["ZKLink"] != nil {
                        var tmp : [DescribeClusterV2ResponseBody.ClusterInfo.AccessInfo.ZKLinks.ZKLink] = []
                        for v in dict["ZKLink"] as! [Any] {
                            var model = DescribeClusterV2ResponseBody.ClusterInfo.AccessInfo.ZKLinks.ZKLink()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.ZKLink = tmp
                    }
                }
            }
            public var ZKLinks: DescribeClusterV2ResponseBody.ClusterInfo.AccessInfo.ZKLinks?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.ZKLinks?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.ZKLinks != nil {
                    map["ZKLinks"] = self.ZKLinks?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ZKLinks") && dict["ZKLinks"] != nil {
                    var model = DescribeClusterV2ResponseBody.ClusterInfo.AccessInfo.ZKLinks()
                    model.fromMap(dict["ZKLinks"] as! [String: Any])
                    self.ZKLinks = model
                }
            }
        }
        public class BootstrapActionList : Tea.TeaModel {
            public class BootstrapAction : Tea.TeaModel {
                public var arg: String?

                public var name: String?

                public var path: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.arg != nil {
                        map["Arg"] = self.arg!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.path != nil {
                        map["Path"] = self.path!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Arg") && dict["Arg"] != nil {
                        self.arg = dict["Arg"] as! String
                    }
                    if dict.keys.contains("Name") && dict["Name"] != nil {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Path") && dict["Path"] != nil {
                        self.path = dict["Path"] as! String
                    }
                }
            }
            public var bootstrapAction: [DescribeClusterV2ResponseBody.ClusterInfo.BootstrapActionList.BootstrapAction]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bootstrapAction != nil {
                    var tmp : [Any] = []
                    for k in self.bootstrapAction! {
                        tmp.append(k.toMap())
                    }
                    map["BootstrapAction"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BootstrapAction") && dict["BootstrapAction"] != nil {
                    var tmp : [DescribeClusterV2ResponseBody.ClusterInfo.BootstrapActionList.BootstrapAction] = []
                    for v in dict["BootstrapAction"] as! [Any] {
                        var model = DescribeClusterV2ResponseBody.ClusterInfo.BootstrapActionList.BootstrapAction()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.bootstrapAction = tmp
                }
            }
        }
        public class FailReason : Tea.TeaModel {
            public var errorCode: String?

            public var errorMsg: String?

            public var requestId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.errorCode != nil {
                    map["ErrorCode"] = self.errorCode!
                }
                if self.errorMsg != nil {
                    map["ErrorMsg"] = self.errorMsg!
                }
                if self.requestId != nil {
                    map["RequestId"] = self.requestId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
                    self.errorCode = dict["ErrorCode"] as! String
                }
                if dict.keys.contains("ErrorMsg") && dict["ErrorMsg"] != nil {
                    self.errorMsg = dict["ErrorMsg"] as! String
                }
                if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
                    self.requestId = dict["RequestId"] as! String
                }
            }
        }
        public class GatewayClusterInfoList : Tea.TeaModel {
            public class GatewayClusterInfo : Tea.TeaModel {
                public var clusterId: String?

                public var clusterName: String?

                public var status: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.clusterId != nil {
                        map["ClusterId"] = self.clusterId!
                    }
                    if self.clusterName != nil {
                        map["ClusterName"] = self.clusterName!
                    }
                    if self.status != nil {
                        map["Status"] = self.status!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
                        self.clusterId = dict["ClusterId"] as! String
                    }
                    if dict.keys.contains("ClusterName") && dict["ClusterName"] != nil {
                        self.clusterName = dict["ClusterName"] as! String
                    }
                    if dict.keys.contains("Status") && dict["Status"] != nil {
                        self.status = dict["Status"] as! String
                    }
                }
            }
            public var gatewayClusterInfo: [DescribeClusterV2ResponseBody.ClusterInfo.GatewayClusterInfoList.GatewayClusterInfo]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.gatewayClusterInfo != nil {
                    var tmp : [Any] = []
                    for k in self.gatewayClusterInfo! {
                        tmp.append(k.toMap())
                    }
                    map["GatewayClusterInfo"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("GatewayClusterInfo") && dict["GatewayClusterInfo"] != nil {
                    var tmp : [DescribeClusterV2ResponseBody.ClusterInfo.GatewayClusterInfoList.GatewayClusterInfo] = []
                    for v in dict["GatewayClusterInfo"] as! [Any] {
                        var model = DescribeClusterV2ResponseBody.ClusterInfo.GatewayClusterInfoList.GatewayClusterInfo()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.gatewayClusterInfo = tmp
                }
            }
        }
        public class HostGroupList : Tea.TeaModel {
            public class HostGroup : Tea.TeaModel {
                public class Nodes : Tea.TeaModel {
                    public class Node : Tea.TeaModel {
                        public class DaemonInfos : Tea.TeaModel {
                            public class DaemonInfo : Tea.TeaModel {
                                public var name: String?

                                public override init() {
                                    super.init()
                                }

                                public init(_ dict: [String: Any]) {
                                    super.init()
                                    self.fromMap(dict)
                                }

                                public override func validate() throws -> Void {
                                }

                                public override func toMap() -> [String : Any] {
                                    var map = super.toMap()
                                    if self.name != nil {
                                        map["Name"] = self.name!
                                    }
                                    return map
                                }

                                public override func fromMap(_ dict: [String: Any]) -> Void {
                                    if dict.keys.contains("Name") && dict["Name"] != nil {
                                        self.name = dict["Name"] as! String
                                    }
                                }
                            }
                            public var daemonInfo: [DescribeClusterV2ResponseBody.ClusterInfo.HostGroupList.HostGroup.Nodes.Node.DaemonInfos.DaemonInfo]?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.daemonInfo != nil {
                                    var tmp : [Any] = []
                                    for k in self.daemonInfo! {
                                        tmp.append(k.toMap())
                                    }
                                    map["DaemonInfo"] = tmp
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("DaemonInfo") && dict["DaemonInfo"] != nil {
                                    var tmp : [DescribeClusterV2ResponseBody.ClusterInfo.HostGroupList.HostGroup.Nodes.Node.DaemonInfos.DaemonInfo] = []
                                    for v in dict["DaemonInfo"] as! [Any] {
                                        var model = DescribeClusterV2ResponseBody.ClusterInfo.HostGroupList.HostGroup.Nodes.Node.DaemonInfos.DaemonInfo()
                                        if v != nil {
                                            model.fromMap(v as! [String: Any])
                                        }
                                        tmp.append(model)
                                    }
                                    self.daemonInfo = tmp
                                }
                            }
                        }
                        public class DiskInfos : Tea.TeaModel {
                            public class DiskInfo : Tea.TeaModel {
                                public var device: String?

                                public var diskId: String?

                                public var diskName: String?

                                public var size: Int32?

                                public var type: String?

                                public override init() {
                                    super.init()
                                }

                                public init(_ dict: [String: Any]) {
                                    super.init()
                                    self.fromMap(dict)
                                }

                                public override func validate() throws -> Void {
                                }

                                public override func toMap() -> [String : Any] {
                                    var map = super.toMap()
                                    if self.device != nil {
                                        map["Device"] = self.device!
                                    }
                                    if self.diskId != nil {
                                        map["DiskId"] = self.diskId!
                                    }
                                    if self.diskName != nil {
                                        map["DiskName"] = self.diskName!
                                    }
                                    if self.size != nil {
                                        map["Size"] = self.size!
                                    }
                                    if self.type != nil {
                                        map["Type"] = self.type!
                                    }
                                    return map
                                }

                                public override func fromMap(_ dict: [String: Any]) -> Void {
                                    if dict.keys.contains("Device") && dict["Device"] != nil {
                                        self.device = dict["Device"] as! String
                                    }
                                    if dict.keys.contains("DiskId") && dict["DiskId"] != nil {
                                        self.diskId = dict["DiskId"] as! String
                                    }
                                    if dict.keys.contains("DiskName") && dict["DiskName"] != nil {
                                        self.diskName = dict["DiskName"] as! String
                                    }
                                    if dict.keys.contains("Size") && dict["Size"] != nil {
                                        self.size = dict["Size"] as! Int32
                                    }
                                    if dict.keys.contains("Type") && dict["Type"] != nil {
                                        self.type = dict["Type"] as! String
                                    }
                                }
                            }
                            public var diskInfo: [DescribeClusterV2ResponseBody.ClusterInfo.HostGroupList.HostGroup.Nodes.Node.DiskInfos.DiskInfo]?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.diskInfo != nil {
                                    var tmp : [Any] = []
                                    for k in self.diskInfo! {
                                        tmp.append(k.toMap())
                                    }
                                    map["DiskInfo"] = tmp
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("DiskInfo") && dict["DiskInfo"] != nil {
                                    var tmp : [DescribeClusterV2ResponseBody.ClusterInfo.HostGroupList.HostGroup.Nodes.Node.DiskInfos.DiskInfo] = []
                                    for v in dict["DiskInfo"] as! [Any] {
                                        var model = DescribeClusterV2ResponseBody.ClusterInfo.HostGroupList.HostGroup.Nodes.Node.DiskInfos.DiskInfo()
                                        if v != nil {
                                            model.fromMap(v as! [String: Any])
                                        }
                                        tmp.append(model)
                                    }
                                    self.diskInfo = tmp
                                }
                            }
                        }
                        public var createTime: String?

                        public var daemonInfos: DescribeClusterV2ResponseBody.ClusterInfo.HostGroupList.HostGroup.Nodes.Node.DaemonInfos?

                        public var diskInfos: DescribeClusterV2ResponseBody.ClusterInfo.HostGroupList.HostGroup.Nodes.Node.DiskInfos?

                        public var emrExpiredTime: String?

                        public var expiredTime: String?

                        public var innerIp: String?

                        public var instanceId: String?

                        public var pubIp: String?

                        public var status: String?

                        public var supportIpV6: Bool?

                        public var zoneId: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                            try self.daemonInfos?.validate()
                            try self.diskInfos?.validate()
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.createTime != nil {
                                map["CreateTime"] = self.createTime!
                            }
                            if self.daemonInfos != nil {
                                map["DaemonInfos"] = self.daemonInfos?.toMap()
                            }
                            if self.diskInfos != nil {
                                map["DiskInfos"] = self.diskInfos?.toMap()
                            }
                            if self.emrExpiredTime != nil {
                                map["EmrExpiredTime"] = self.emrExpiredTime!
                            }
                            if self.expiredTime != nil {
                                map["ExpiredTime"] = self.expiredTime!
                            }
                            if self.innerIp != nil {
                                map["InnerIp"] = self.innerIp!
                            }
                            if self.instanceId != nil {
                                map["InstanceId"] = self.instanceId!
                            }
                            if self.pubIp != nil {
                                map["PubIp"] = self.pubIp!
                            }
                            if self.status != nil {
                                map["Status"] = self.status!
                            }
                            if self.supportIpV6 != nil {
                                map["SupportIpV6"] = self.supportIpV6!
                            }
                            if self.zoneId != nil {
                                map["ZoneId"] = self.zoneId!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                                self.createTime = dict["CreateTime"] as! String
                            }
                            if dict.keys.contains("DaemonInfos") && dict["DaemonInfos"] != nil {
                                var model = DescribeClusterV2ResponseBody.ClusterInfo.HostGroupList.HostGroup.Nodes.Node.DaemonInfos()
                                model.fromMap(dict["DaemonInfos"] as! [String: Any])
                                self.daemonInfos = model
                            }
                            if dict.keys.contains("DiskInfos") && dict["DiskInfos"] != nil {
                                var model = DescribeClusterV2ResponseBody.ClusterInfo.HostGroupList.HostGroup.Nodes.Node.DiskInfos()
                                model.fromMap(dict["DiskInfos"] as! [String: Any])
                                self.diskInfos = model
                            }
                            if dict.keys.contains("EmrExpiredTime") && dict["EmrExpiredTime"] != nil {
                                self.emrExpiredTime = dict["EmrExpiredTime"] as! String
                            }
                            if dict.keys.contains("ExpiredTime") && dict["ExpiredTime"] != nil {
                                self.expiredTime = dict["ExpiredTime"] as! String
                            }
                            if dict.keys.contains("InnerIp") && dict["InnerIp"] != nil {
                                self.innerIp = dict["InnerIp"] as! String
                            }
                            if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
                                self.instanceId = dict["InstanceId"] as! String
                            }
                            if dict.keys.contains("PubIp") && dict["PubIp"] != nil {
                                self.pubIp = dict["PubIp"] as! String
                            }
                            if dict.keys.contains("Status") && dict["Status"] != nil {
                                self.status = dict["Status"] as! String
                            }
                            if dict.keys.contains("SupportIpV6") && dict["SupportIpV6"] != nil {
                                self.supportIpV6 = dict["SupportIpV6"] as! Bool
                            }
                            if dict.keys.contains("ZoneId") && dict["ZoneId"] != nil {
                                self.zoneId = dict["ZoneId"] as! String
                            }
                        }
                    }
                    public var node: [DescribeClusterV2ResponseBody.ClusterInfo.HostGroupList.HostGroup.Nodes.Node]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.node != nil {
                            var tmp : [Any] = []
                            for k in self.node! {
                                tmp.append(k.toMap())
                            }
                            map["Node"] = tmp
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Node") && dict["Node"] != nil {
                            var tmp : [DescribeClusterV2ResponseBody.ClusterInfo.HostGroupList.HostGroup.Nodes.Node] = []
                            for v in dict["Node"] as! [Any] {
                                var model = DescribeClusterV2ResponseBody.ClusterInfo.HostGroupList.HostGroup.Nodes.Node()
                                if v != nil {
                                    model.fromMap(v as! [String: Any])
                                }
                                tmp.append(model)
                            }
                            self.node = tmp
                        }
                    }
                }
                public var bandWidth: String?

                public var chargeType: String?

                public var cpuCore: Int32?

                public var diskCapacity: Int32?

                public var diskCount: Int32?

                public var diskType: String?

                public var hostGroupChangeStatus: String?

                public var hostGroupChangeType: String?

                public var hostGroupId: String?

                public var hostGroupName: String?

                public var hostGroupSubType: String?

                public var hostGroupType: String?

                public var instanceType: String?

                public var lockReason: String?

                public var lockType: String?

                public var memoryCapacity: Int32?

                public var nodeCount: Int32?

                public var nodes: DescribeClusterV2ResponseBody.ClusterInfo.HostGroupList.HostGroup.Nodes?

                public var period: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.nodes?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bandWidth != nil {
                        map["BandWidth"] = self.bandWidth!
                    }
                    if self.chargeType != nil {
                        map["ChargeType"] = self.chargeType!
                    }
                    if self.cpuCore != nil {
                        map["CpuCore"] = self.cpuCore!
                    }
                    if self.diskCapacity != nil {
                        map["DiskCapacity"] = self.diskCapacity!
                    }
                    if self.diskCount != nil {
                        map["DiskCount"] = self.diskCount!
                    }
                    if self.diskType != nil {
                        map["DiskType"] = self.diskType!
                    }
                    if self.hostGroupChangeStatus != nil {
                        map["HostGroupChangeStatus"] = self.hostGroupChangeStatus!
                    }
                    if self.hostGroupChangeType != nil {
                        map["HostGroupChangeType"] = self.hostGroupChangeType!
                    }
                    if self.hostGroupId != nil {
                        map["HostGroupId"] = self.hostGroupId!
                    }
                    if self.hostGroupName != nil {
                        map["HostGroupName"] = self.hostGroupName!
                    }
                    if self.hostGroupSubType != nil {
                        map["HostGroupSubType"] = self.hostGroupSubType!
                    }
                    if self.hostGroupType != nil {
                        map["HostGroupType"] = self.hostGroupType!
                    }
                    if self.instanceType != nil {
                        map["InstanceType"] = self.instanceType!
                    }
                    if self.lockReason != nil {
                        map["LockReason"] = self.lockReason!
                    }
                    if self.lockType != nil {
                        map["LockType"] = self.lockType!
                    }
                    if self.memoryCapacity != nil {
                        map["MemoryCapacity"] = self.memoryCapacity!
                    }
                    if self.nodeCount != nil {
                        map["NodeCount"] = self.nodeCount!
                    }
                    if self.nodes != nil {
                        map["Nodes"] = self.nodes?.toMap()
                    }
                    if self.period != nil {
                        map["Period"] = self.period!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("BandWidth") && dict["BandWidth"] != nil {
                        self.bandWidth = dict["BandWidth"] as! String
                    }
                    if dict.keys.contains("ChargeType") && dict["ChargeType"] != nil {
                        self.chargeType = dict["ChargeType"] as! String
                    }
                    if dict.keys.contains("CpuCore") && dict["CpuCore"] != nil {
                        self.cpuCore = dict["CpuCore"] as! Int32
                    }
                    if dict.keys.contains("DiskCapacity") && dict["DiskCapacity"] != nil {
                        self.diskCapacity = dict["DiskCapacity"] as! Int32
                    }
                    if dict.keys.contains("DiskCount") && dict["DiskCount"] != nil {
                        self.diskCount = dict["DiskCount"] as! Int32
                    }
                    if dict.keys.contains("DiskType") && dict["DiskType"] != nil {
                        self.diskType = dict["DiskType"] as! String
                    }
                    if dict.keys.contains("HostGroupChangeStatus") && dict["HostGroupChangeStatus"] != nil {
                        self.hostGroupChangeStatus = dict["HostGroupChangeStatus"] as! String
                    }
                    if dict.keys.contains("HostGroupChangeType") && dict["HostGroupChangeType"] != nil {
                        self.hostGroupChangeType = dict["HostGroupChangeType"] as! String
                    }
                    if dict.keys.contains("HostGroupId") && dict["HostGroupId"] != nil {
                        self.hostGroupId = dict["HostGroupId"] as! String
                    }
                    if dict.keys.contains("HostGroupName") && dict["HostGroupName"] != nil {
                        self.hostGroupName = dict["HostGroupName"] as! String
                    }
                    if dict.keys.contains("HostGroupSubType") && dict["HostGroupSubType"] != nil {
                        self.hostGroupSubType = dict["HostGroupSubType"] as! String
                    }
                    if dict.keys.contains("HostGroupType") && dict["HostGroupType"] != nil {
                        self.hostGroupType = dict["HostGroupType"] as! String
                    }
                    if dict.keys.contains("InstanceType") && dict["InstanceType"] != nil {
                        self.instanceType = dict["InstanceType"] as! String
                    }
                    if dict.keys.contains("LockReason") && dict["LockReason"] != nil {
                        self.lockReason = dict["LockReason"] as! String
                    }
                    if dict.keys.contains("LockType") && dict["LockType"] != nil {
                        self.lockType = dict["LockType"] as! String
                    }
                    if dict.keys.contains("MemoryCapacity") && dict["MemoryCapacity"] != nil {
                        self.memoryCapacity = dict["MemoryCapacity"] as! Int32
                    }
                    if dict.keys.contains("NodeCount") && dict["NodeCount"] != nil {
                        self.nodeCount = dict["NodeCount"] as! Int32
                    }
                    if dict.keys.contains("Nodes") && dict["Nodes"] != nil {
                        var model = DescribeClusterV2ResponseBody.ClusterInfo.HostGroupList.HostGroup.Nodes()
                        model.fromMap(dict["Nodes"] as! [String: Any])
                        self.nodes = model
                    }
                    if dict.keys.contains("Period") && dict["Period"] != nil {
                        self.period = dict["Period"] as! String
                    }
                }
            }
            public var hostGroup: [DescribeClusterV2ResponseBody.ClusterInfo.HostGroupList.HostGroup]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.hostGroup != nil {
                    var tmp : [Any] = []
                    for k in self.hostGroup! {
                        tmp.append(k.toMap())
                    }
                    map["HostGroup"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("HostGroup") && dict["HostGroup"] != nil {
                    var tmp : [DescribeClusterV2ResponseBody.ClusterInfo.HostGroupList.HostGroup] = []
                    for v in dict["HostGroup"] as! [Any] {
                        var model = DescribeClusterV2ResponseBody.ClusterInfo.HostGroupList.HostGroup()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.hostGroup = tmp
                }
            }
        }
        public class HostPoolInfo : Tea.TeaModel {
            public var hpBizId: String?

            public var hpName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.hpBizId != nil {
                    map["HpBizId"] = self.hpBizId!
                }
                if self.hpName != nil {
                    map["HpName"] = self.hpName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("HpBizId") && dict["HpBizId"] != nil {
                    self.hpBizId = dict["HpBizId"] as! String
                }
                if dict.keys.contains("HpName") && dict["HpName"] != nil {
                    self.hpName = dict["HpName"] as! String
                }
            }
        }
        public class RelateClusterInfo : Tea.TeaModel {
            public var clusterId: String?

            public var clusterName: String?

            public var clusterType: String?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.clusterId != nil {
                    map["ClusterId"] = self.clusterId!
                }
                if self.clusterName != nil {
                    map["ClusterName"] = self.clusterName!
                }
                if self.clusterType != nil {
                    map["ClusterType"] = self.clusterType!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
                    self.clusterId = dict["ClusterId"] as! String
                }
                if dict.keys.contains("ClusterName") && dict["ClusterName"] != nil {
                    self.clusterName = dict["ClusterName"] as! String
                }
                if dict.keys.contains("ClusterType") && dict["ClusterType"] != nil {
                    self.clusterType = dict["ClusterType"] as! String
                }
                if dict.keys.contains("Status") && dict["Status"] != nil {
                    self.status = dict["Status"] as! String
                }
            }
        }
        public class SoftwareInfo : Tea.TeaModel {
            public class Softwares : Tea.TeaModel {
                public class Software : Tea.TeaModel {
                    public var displayName: String?

                    public var name: String?

                    public var onlyDisplay: Bool?

                    public var startTpe: Int32?

                    public var version: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.displayName != nil {
                            map["DisplayName"] = self.displayName!
                        }
                        if self.name != nil {
                            map["Name"] = self.name!
                        }
                        if self.onlyDisplay != nil {
                            map["OnlyDisplay"] = self.onlyDisplay!
                        }
                        if self.startTpe != nil {
                            map["StartTpe"] = self.startTpe!
                        }
                        if self.version != nil {
                            map["Version"] = self.version!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("DisplayName") && dict["DisplayName"] != nil {
                            self.displayName = dict["DisplayName"] as! String
                        }
                        if dict.keys.contains("Name") && dict["Name"] != nil {
                            self.name = dict["Name"] as! String
                        }
                        if dict.keys.contains("OnlyDisplay") && dict["OnlyDisplay"] != nil {
                            self.onlyDisplay = dict["OnlyDisplay"] as! Bool
                        }
                        if dict.keys.contains("StartTpe") && dict["StartTpe"] != nil {
                            self.startTpe = dict["StartTpe"] as! Int32
                        }
                        if dict.keys.contains("Version") && dict["Version"] != nil {
                            self.version = dict["Version"] as! String
                        }
                    }
                }
                public var software: [DescribeClusterV2ResponseBody.ClusterInfo.SoftwareInfo.Softwares.Software]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.software != nil {
                        var tmp : [Any] = []
                        for k in self.software! {
                            tmp.append(k.toMap())
                        }
                        map["Software"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Software") && dict["Software"] != nil {
                        var tmp : [DescribeClusterV2ResponseBody.ClusterInfo.SoftwareInfo.Softwares.Software] = []
                        for v in dict["Software"] as! [Any] {
                            var model = DescribeClusterV2ResponseBody.ClusterInfo.SoftwareInfo.Softwares.Software()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.software = tmp
                    }
                }
            }
            public var clusterType: String?

            public var emrVer: String?

            public var softwares: DescribeClusterV2ResponseBody.ClusterInfo.SoftwareInfo.Softwares?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.softwares?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.clusterType != nil {
                    map["ClusterType"] = self.clusterType!
                }
                if self.emrVer != nil {
                    map["EmrVer"] = self.emrVer!
                }
                if self.softwares != nil {
                    map["Softwares"] = self.softwares?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ClusterType") && dict["ClusterType"] != nil {
                    self.clusterType = dict["ClusterType"] as! String
                }
                if dict.keys.contains("EmrVer") && dict["EmrVer"] != nil {
                    self.emrVer = dict["EmrVer"] as! String
                }
                if dict.keys.contains("Softwares") && dict["Softwares"] != nil {
                    var model = DescribeClusterV2ResponseBody.ClusterInfo.SoftwareInfo.Softwares()
                    model.fromMap(dict["Softwares"] as! [String: Any])
                    self.softwares = model
                }
            }
        }
        public var accessInfo: DescribeClusterV2ResponseBody.ClusterInfo.AccessInfo?

        public var autoScalingAllowed: Bool?

        public var autoScalingByLoadAllowed: Bool?

        public var autoScalingEnable: Bool?

        public var autoScalingSpotWithLimitAllowed: Bool?

        public var autoScalingVersion: String?

        public var autoScalingWithGraceAllowed: Bool?

        public var bootstrapActionList: DescribeClusterV2ResponseBody.ClusterInfo.BootstrapActionList?

        public var bootstrapFailed: Bool?

        public var chargeType: String?

        public var configurations: String?

        public var coreNodeInService: Int32?

        public var coreNodeTotal: Int32?

        public var createResource: String?

        public var createType: String?

        public var dataDiskEncrypted: Bool?

        public var dataDiskKMSKeyId: String?

        public var depositType: String?

        public var easEnable: Bool?

        public var expiredTime: Int64?

        public var extraInfo: String?

        public var failReason: DescribeClusterV2ResponseBody.ClusterInfo.FailReason?

        public var gatewayClusterIds: String?

        public var gatewayClusterInfoList: DescribeClusterV2ResponseBody.ClusterInfo.GatewayClusterInfoList?

        public var highAvailabilityEnable: Bool?

        public var hostGroupList: DescribeClusterV2ResponseBody.ClusterInfo.HostGroupList?

        public var hostPoolInfo: DescribeClusterV2ResponseBody.ClusterInfo.HostPoolInfo?

        public var id: String?

        public var imageId: String?

        public var instanceGeneration: String?

        public var ioOptimized: Bool?

        public var k8sClusterId: String?

        public var localMetaDb: Bool?

        public var logEnable: Bool?

        public var logPath: String?

        public var machineType: String?

        public var masterNodeInService: Int32?

        public var masterNodeTotal: Int32?

        public var metaStoreType: String?

        public var name: String?

        public var netType: String?

        public var period: Int32?

        public var regionId: String?

        public var relateClusterId: String?

        public var relateClusterInfo: DescribeClusterV2ResponseBody.ClusterInfo.RelateClusterInfo?

        public var resizeDiskEnable: Bool?

        public var runningTime: Int32?

        public var securityGroupId: String?

        public var securityGroupName: String?

        public var showSoftwareInterface: Bool?

        public var softwareInfo: DescribeClusterV2ResponseBody.ClusterInfo.SoftwareInfo?

        public var startTime: Int64?

        public var status: String?

        public var stopTime: Int64?

        public var taskNodeInService: Int32?

        public var taskNodeTotal: Int32?

        public var userDefinedEmrEcsRole: String?

        public var userId: String?

        public var vSwitchId: String?

        public var vpcId: String?

        public var zoneId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.accessInfo?.validate()
            try self.bootstrapActionList?.validate()
            try self.failReason?.validate()
            try self.gatewayClusterInfoList?.validate()
            try self.hostGroupList?.validate()
            try self.hostPoolInfo?.validate()
            try self.relateClusterInfo?.validate()
            try self.softwareInfo?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accessInfo != nil {
                map["AccessInfo"] = self.accessInfo?.toMap()
            }
            if self.autoScalingAllowed != nil {
                map["AutoScalingAllowed"] = self.autoScalingAllowed!
            }
            if self.autoScalingByLoadAllowed != nil {
                map["AutoScalingByLoadAllowed"] = self.autoScalingByLoadAllowed!
            }
            if self.autoScalingEnable != nil {
                map["AutoScalingEnable"] = self.autoScalingEnable!
            }
            if self.autoScalingSpotWithLimitAllowed != nil {
                map["AutoScalingSpotWithLimitAllowed"] = self.autoScalingSpotWithLimitAllowed!
            }
            if self.autoScalingVersion != nil {
                map["AutoScalingVersion"] = self.autoScalingVersion!
            }
            if self.autoScalingWithGraceAllowed != nil {
                map["AutoScalingWithGraceAllowed"] = self.autoScalingWithGraceAllowed!
            }
            if self.bootstrapActionList != nil {
                map["BootstrapActionList"] = self.bootstrapActionList?.toMap()
            }
            if self.bootstrapFailed != nil {
                map["BootstrapFailed"] = self.bootstrapFailed!
            }
            if self.chargeType != nil {
                map["ChargeType"] = self.chargeType!
            }
            if self.configurations != nil {
                map["Configurations"] = self.configurations!
            }
            if self.coreNodeInService != nil {
                map["CoreNodeInService"] = self.coreNodeInService!
            }
            if self.coreNodeTotal != nil {
                map["CoreNodeTotal"] = self.coreNodeTotal!
            }
            if self.createResource != nil {
                map["CreateResource"] = self.createResource!
            }
            if self.createType != nil {
                map["CreateType"] = self.createType!
            }
            if self.dataDiskEncrypted != nil {
                map["DataDiskEncrypted"] = self.dataDiskEncrypted!
            }
            if self.dataDiskKMSKeyId != nil {
                map["DataDiskKMSKeyId"] = self.dataDiskKMSKeyId!
            }
            if self.depositType != nil {
                map["DepositType"] = self.depositType!
            }
            if self.easEnable != nil {
                map["EasEnable"] = self.easEnable!
            }
            if self.expiredTime != nil {
                map["ExpiredTime"] = self.expiredTime!
            }
            if self.extraInfo != nil {
                map["ExtraInfo"] = self.extraInfo!
            }
            if self.failReason != nil {
                map["FailReason"] = self.failReason?.toMap()
            }
            if self.gatewayClusterIds != nil {
                map["GatewayClusterIds"] = self.gatewayClusterIds!
            }
            if self.gatewayClusterInfoList != nil {
                map["GatewayClusterInfoList"] = self.gatewayClusterInfoList?.toMap()
            }
            if self.highAvailabilityEnable != nil {
                map["HighAvailabilityEnable"] = self.highAvailabilityEnable!
            }
            if self.hostGroupList != nil {
                map["HostGroupList"] = self.hostGroupList?.toMap()
            }
            if self.hostPoolInfo != nil {
                map["HostPoolInfo"] = self.hostPoolInfo?.toMap()
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.imageId != nil {
                map["ImageId"] = self.imageId!
            }
            if self.instanceGeneration != nil {
                map["InstanceGeneration"] = self.instanceGeneration!
            }
            if self.ioOptimized != nil {
                map["IoOptimized"] = self.ioOptimized!
            }
            if self.k8sClusterId != nil {
                map["K8sClusterId"] = self.k8sClusterId!
            }
            if self.localMetaDb != nil {
                map["LocalMetaDb"] = self.localMetaDb!
            }
            if self.logEnable != nil {
                map["LogEnable"] = self.logEnable!
            }
            if self.logPath != nil {
                map["LogPath"] = self.logPath!
            }
            if self.machineType != nil {
                map["MachineType"] = self.machineType!
            }
            if self.masterNodeInService != nil {
                map["MasterNodeInService"] = self.masterNodeInService!
            }
            if self.masterNodeTotal != nil {
                map["MasterNodeTotal"] = self.masterNodeTotal!
            }
            if self.metaStoreType != nil {
                map["MetaStoreType"] = self.metaStoreType!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.netType != nil {
                map["NetType"] = self.netType!
            }
            if self.period != nil {
                map["Period"] = self.period!
            }
            if self.regionId != nil {
                map["RegionId"] = self.regionId!
            }
            if self.relateClusterId != nil {
                map["RelateClusterId"] = self.relateClusterId!
            }
            if self.relateClusterInfo != nil {
                map["RelateClusterInfo"] = self.relateClusterInfo?.toMap()
            }
            if self.resizeDiskEnable != nil {
                map["ResizeDiskEnable"] = self.resizeDiskEnable!
            }
            if self.runningTime != nil {
                map["RunningTime"] = self.runningTime!
            }
            if self.securityGroupId != nil {
                map["SecurityGroupId"] = self.securityGroupId!
            }
            if self.securityGroupName != nil {
                map["SecurityGroupName"] = self.securityGroupName!
            }
            if self.showSoftwareInterface != nil {
                map["ShowSoftwareInterface"] = self.showSoftwareInterface!
            }
            if self.softwareInfo != nil {
                map["SoftwareInfo"] = self.softwareInfo?.toMap()
            }
            if self.startTime != nil {
                map["StartTime"] = self.startTime!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.stopTime != nil {
                map["StopTime"] = self.stopTime!
            }
            if self.taskNodeInService != nil {
                map["TaskNodeInService"] = self.taskNodeInService!
            }
            if self.taskNodeTotal != nil {
                map["TaskNodeTotal"] = self.taskNodeTotal!
            }
            if self.userDefinedEmrEcsRole != nil {
                map["UserDefinedEmrEcsRole"] = self.userDefinedEmrEcsRole!
            }
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            if self.vSwitchId != nil {
                map["VSwitchId"] = self.vSwitchId!
            }
            if self.vpcId != nil {
                map["VpcId"] = self.vpcId!
            }
            if self.zoneId != nil {
                map["ZoneId"] = self.zoneId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AccessInfo") && dict["AccessInfo"] != nil {
                var model = DescribeClusterV2ResponseBody.ClusterInfo.AccessInfo()
                model.fromMap(dict["AccessInfo"] as! [String: Any])
                self.accessInfo = model
            }
            if dict.keys.contains("AutoScalingAllowed") && dict["AutoScalingAllowed"] != nil {
                self.autoScalingAllowed = dict["AutoScalingAllowed"] as! Bool
            }
            if dict.keys.contains("AutoScalingByLoadAllowed") && dict["AutoScalingByLoadAllowed"] != nil {
                self.autoScalingByLoadAllowed = dict["AutoScalingByLoadAllowed"] as! Bool
            }
            if dict.keys.contains("AutoScalingEnable") && dict["AutoScalingEnable"] != nil {
                self.autoScalingEnable = dict["AutoScalingEnable"] as! Bool
            }
            if dict.keys.contains("AutoScalingSpotWithLimitAllowed") && dict["AutoScalingSpotWithLimitAllowed"] != nil {
                self.autoScalingSpotWithLimitAllowed = dict["AutoScalingSpotWithLimitAllowed"] as! Bool
            }
            if dict.keys.contains("AutoScalingVersion") && dict["AutoScalingVersion"] != nil {
                self.autoScalingVersion = dict["AutoScalingVersion"] as! String
            }
            if dict.keys.contains("AutoScalingWithGraceAllowed") && dict["AutoScalingWithGraceAllowed"] != nil {
                self.autoScalingWithGraceAllowed = dict["AutoScalingWithGraceAllowed"] as! Bool
            }
            if dict.keys.contains("BootstrapActionList") && dict["BootstrapActionList"] != nil {
                var model = DescribeClusterV2ResponseBody.ClusterInfo.BootstrapActionList()
                model.fromMap(dict["BootstrapActionList"] as! [String: Any])
                self.bootstrapActionList = model
            }
            if dict.keys.contains("BootstrapFailed") && dict["BootstrapFailed"] != nil {
                self.bootstrapFailed = dict["BootstrapFailed"] as! Bool
            }
            if dict.keys.contains("ChargeType") && dict["ChargeType"] != nil {
                self.chargeType = dict["ChargeType"] as! String
            }
            if dict.keys.contains("Configurations") && dict["Configurations"] != nil {
                self.configurations = dict["Configurations"] as! String
            }
            if dict.keys.contains("CoreNodeInService") && dict["CoreNodeInService"] != nil {
                self.coreNodeInService = dict["CoreNodeInService"] as! Int32
            }
            if dict.keys.contains("CoreNodeTotal") && dict["CoreNodeTotal"] != nil {
                self.coreNodeTotal = dict["CoreNodeTotal"] as! Int32
            }
            if dict.keys.contains("CreateResource") && dict["CreateResource"] != nil {
                self.createResource = dict["CreateResource"] as! String
            }
            if dict.keys.contains("CreateType") && dict["CreateType"] != nil {
                self.createType = dict["CreateType"] as! String
            }
            if dict.keys.contains("DataDiskEncrypted") && dict["DataDiskEncrypted"] != nil {
                self.dataDiskEncrypted = dict["DataDiskEncrypted"] as! Bool
            }
            if dict.keys.contains("DataDiskKMSKeyId") && dict["DataDiskKMSKeyId"] != nil {
                self.dataDiskKMSKeyId = dict["DataDiskKMSKeyId"] as! String
            }
            if dict.keys.contains("DepositType") && dict["DepositType"] != nil {
                self.depositType = dict["DepositType"] as! String
            }
            if dict.keys.contains("EasEnable") && dict["EasEnable"] != nil {
                self.easEnable = dict["EasEnable"] as! Bool
            }
            if dict.keys.contains("ExpiredTime") && dict["ExpiredTime"] != nil {
                self.expiredTime = dict["ExpiredTime"] as! Int64
            }
            if dict.keys.contains("ExtraInfo") && dict["ExtraInfo"] != nil {
                self.extraInfo = dict["ExtraInfo"] as! String
            }
            if dict.keys.contains("FailReason") && dict["FailReason"] != nil {
                var model = DescribeClusterV2ResponseBody.ClusterInfo.FailReason()
                model.fromMap(dict["FailReason"] as! [String: Any])
                self.failReason = model
            }
            if dict.keys.contains("GatewayClusterIds") && dict["GatewayClusterIds"] != nil {
                self.gatewayClusterIds = dict["GatewayClusterIds"] as! String
            }
            if dict.keys.contains("GatewayClusterInfoList") && dict["GatewayClusterInfoList"] != nil {
                var model = DescribeClusterV2ResponseBody.ClusterInfo.GatewayClusterInfoList()
                model.fromMap(dict["GatewayClusterInfoList"] as! [String: Any])
                self.gatewayClusterInfoList = model
            }
            if dict.keys.contains("HighAvailabilityEnable") && dict["HighAvailabilityEnable"] != nil {
                self.highAvailabilityEnable = dict["HighAvailabilityEnable"] as! Bool
            }
            if dict.keys.contains("HostGroupList") && dict["HostGroupList"] != nil {
                var model = DescribeClusterV2ResponseBody.ClusterInfo.HostGroupList()
                model.fromMap(dict["HostGroupList"] as! [String: Any])
                self.hostGroupList = model
            }
            if dict.keys.contains("HostPoolInfo") && dict["HostPoolInfo"] != nil {
                var model = DescribeClusterV2ResponseBody.ClusterInfo.HostPoolInfo()
                model.fromMap(dict["HostPoolInfo"] as! [String: Any])
                self.hostPoolInfo = model
            }
            if dict.keys.contains("Id") && dict["Id"] != nil {
                self.id = dict["Id"] as! String
            }
            if dict.keys.contains("ImageId") && dict["ImageId"] != nil {
                self.imageId = dict["ImageId"] as! String
            }
            if dict.keys.contains("InstanceGeneration") && dict["InstanceGeneration"] != nil {
                self.instanceGeneration = dict["InstanceGeneration"] as! String
            }
            if dict.keys.contains("IoOptimized") && dict["IoOptimized"] != nil {
                self.ioOptimized = dict["IoOptimized"] as! Bool
            }
            if dict.keys.contains("K8sClusterId") && dict["K8sClusterId"] != nil {
                self.k8sClusterId = dict["K8sClusterId"] as! String
            }
            if dict.keys.contains("LocalMetaDb") && dict["LocalMetaDb"] != nil {
                self.localMetaDb = dict["LocalMetaDb"] as! Bool
            }
            if dict.keys.contains("LogEnable") && dict["LogEnable"] != nil {
                self.logEnable = dict["LogEnable"] as! Bool
            }
            if dict.keys.contains("LogPath") && dict["LogPath"] != nil {
                self.logPath = dict["LogPath"] as! String
            }
            if dict.keys.contains("MachineType") && dict["MachineType"] != nil {
                self.machineType = dict["MachineType"] as! String
            }
            if dict.keys.contains("MasterNodeInService") && dict["MasterNodeInService"] != nil {
                self.masterNodeInService = dict["MasterNodeInService"] as! Int32
            }
            if dict.keys.contains("MasterNodeTotal") && dict["MasterNodeTotal"] != nil {
                self.masterNodeTotal = dict["MasterNodeTotal"] as! Int32
            }
            if dict.keys.contains("MetaStoreType") && dict["MetaStoreType"] != nil {
                self.metaStoreType = dict["MetaStoreType"] as! String
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("NetType") && dict["NetType"] != nil {
                self.netType = dict["NetType"] as! String
            }
            if dict.keys.contains("Period") && dict["Period"] != nil {
                self.period = dict["Period"] as! Int32
            }
            if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
                self.regionId = dict["RegionId"] as! String
            }
            if dict.keys.contains("RelateClusterId") && dict["RelateClusterId"] != nil {
                self.relateClusterId = dict["RelateClusterId"] as! String
            }
            if dict.keys.contains("RelateClusterInfo") && dict["RelateClusterInfo"] != nil {
                var model = DescribeClusterV2ResponseBody.ClusterInfo.RelateClusterInfo()
                model.fromMap(dict["RelateClusterInfo"] as! [String: Any])
                self.relateClusterInfo = model
            }
            if dict.keys.contains("ResizeDiskEnable") && dict["ResizeDiskEnable"] != nil {
                self.resizeDiskEnable = dict["ResizeDiskEnable"] as! Bool
            }
            if dict.keys.contains("RunningTime") && dict["RunningTime"] != nil {
                self.runningTime = dict["RunningTime"] as! Int32
            }
            if dict.keys.contains("SecurityGroupId") && dict["SecurityGroupId"] != nil {
                self.securityGroupId = dict["SecurityGroupId"] as! String
            }
            if dict.keys.contains("SecurityGroupName") && dict["SecurityGroupName"] != nil {
                self.securityGroupName = dict["SecurityGroupName"] as! String
            }
            if dict.keys.contains("ShowSoftwareInterface") && dict["ShowSoftwareInterface"] != nil {
                self.showSoftwareInterface = dict["ShowSoftwareInterface"] as! Bool
            }
            if dict.keys.contains("SoftwareInfo") && dict["SoftwareInfo"] != nil {
                var model = DescribeClusterV2ResponseBody.ClusterInfo.SoftwareInfo()
                model.fromMap(dict["SoftwareInfo"] as! [String: Any])
                self.softwareInfo = model
            }
            if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
                self.startTime = dict["StartTime"] as! Int64
            }
            if dict.keys.contains("Status") && dict["Status"] != nil {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("StopTime") && dict["StopTime"] != nil {
                self.stopTime = dict["StopTime"] as! Int64
            }
            if dict.keys.contains("TaskNodeInService") && dict["TaskNodeInService"] != nil {
                self.taskNodeInService = dict["TaskNodeInService"] as! Int32
            }
            if dict.keys.contains("TaskNodeTotal") && dict["TaskNodeTotal"] != nil {
                self.taskNodeTotal = dict["TaskNodeTotal"] as! Int32
            }
            if dict.keys.contains("UserDefinedEmrEcsRole") && dict["UserDefinedEmrEcsRole"] != nil {
                self.userDefinedEmrEcsRole = dict["UserDefinedEmrEcsRole"] as! String
            }
            if dict.keys.contains("UserId") && dict["UserId"] != nil {
                self.userId = dict["UserId"] as! String
            }
            if dict.keys.contains("VSwitchId") && dict["VSwitchId"] != nil {
                self.vSwitchId = dict["VSwitchId"] as! String
            }
            if dict.keys.contains("VpcId") && dict["VpcId"] != nil {
                self.vpcId = dict["VpcId"] as! String
            }
            if dict.keys.contains("ZoneId") && dict["ZoneId"] != nil {
                self.zoneId = dict["ZoneId"] as! String
            }
        }
    }
    public var clusterInfo: DescribeClusterV2ResponseBody.ClusterInfo?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.clusterInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterInfo != nil {
            map["ClusterInfo"] = self.clusterInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterInfo") && dict["ClusterInfo"] != nil {
            var model = DescribeClusterV2ResponseBody.ClusterInfo()
            model.fromMap(dict["ClusterInfo"] as! [String: Any])
            self.clusterInfo = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeClusterV2Response : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeClusterV2ResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeClusterV2ResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeFlowRequest : Tea.TeaModel {
    public var id: String?

    public var projectId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! String
        }
        if dict.keys.contains("ProjectId") && dict["ProjectId"] != nil {
            self.projectId = dict["ProjectId"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DescribeFlowResponseBody : Tea.TeaModel {
    public class ParentFlowList : Tea.TeaModel {
        public class ParentFlow : Tea.TeaModel {
            public var parentFlowId: String?

            public var parentFlowName: String?

            public var projectId: String?

            public var projectName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.parentFlowId != nil {
                    map["ParentFlowId"] = self.parentFlowId!
                }
                if self.parentFlowName != nil {
                    map["ParentFlowName"] = self.parentFlowName!
                }
                if self.projectId != nil {
                    map["ProjectId"] = self.projectId!
                }
                if self.projectName != nil {
                    map["ProjectName"] = self.projectName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ParentFlowId") && dict["ParentFlowId"] != nil {
                    self.parentFlowId = dict["ParentFlowId"] as! String
                }
                if dict.keys.contains("ParentFlowName") && dict["ParentFlowName"] != nil {
                    self.parentFlowName = dict["ParentFlowName"] as! String
                }
                if dict.keys.contains("ProjectId") && dict["ProjectId"] != nil {
                    self.projectId = dict["ProjectId"] as! String
                }
                if dict.keys.contains("ProjectName") && dict["ProjectName"] != nil {
                    self.projectName = dict["ProjectName"] as! String
                }
            }
        }
        public var parentFlow: [DescribeFlowResponseBody.ParentFlowList.ParentFlow]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.parentFlow != nil {
                var tmp : [Any] = []
                for k in self.parentFlow! {
                    tmp.append(k.toMap())
                }
                map["ParentFlow"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ParentFlow") && dict["ParentFlow"] != nil {
                var tmp : [DescribeFlowResponseBody.ParentFlowList.ParentFlow] = []
                for v in dict["ParentFlow"] as! [Any] {
                    var model = DescribeFlowResponseBody.ParentFlowList.ParentFlow()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.parentFlow = tmp
            }
        }
    }
    public var alertConf: String?

    public var alertDingDingGroupBizId: String?

    public var alertUserGroupBizId: String?

    public var application: String?

    public var categoryId: String?

    public var clusterId: String?

    public var createCluster: Bool?

    public var cronExpr: String?

    public var description_: String?

    public var editLockDetail: String?

    public var endSchedule: Int64?

    public var gmtCreate: Int64?

    public var gmtModified: Int64?

    public var graph: String?

    public var hostName: String?

    public var id: String?

    public var lifecycle: String?

    public var logArchiveLocation: String?

    public var name: String?

    public var namespace: String?

    public var parentFlowList: DescribeFlowResponseBody.ParentFlowList?

    public var periodic: Bool?

    public var requestId: String?

    public var startSchedule: Int64?

    public var status: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.parentFlowList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.alertConf != nil {
            map["AlertConf"] = self.alertConf!
        }
        if self.alertDingDingGroupBizId != nil {
            map["AlertDingDingGroupBizId"] = self.alertDingDingGroupBizId!
        }
        if self.alertUserGroupBizId != nil {
            map["AlertUserGroupBizId"] = self.alertUserGroupBizId!
        }
        if self.application != nil {
            map["Application"] = self.application!
        }
        if self.categoryId != nil {
            map["CategoryId"] = self.categoryId!
        }
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.createCluster != nil {
            map["CreateCluster"] = self.createCluster!
        }
        if self.cronExpr != nil {
            map["CronExpr"] = self.cronExpr!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.editLockDetail != nil {
            map["EditLockDetail"] = self.editLockDetail!
        }
        if self.endSchedule != nil {
            map["EndSchedule"] = self.endSchedule!
        }
        if self.gmtCreate != nil {
            map["GmtCreate"] = self.gmtCreate!
        }
        if self.gmtModified != nil {
            map["GmtModified"] = self.gmtModified!
        }
        if self.graph != nil {
            map["Graph"] = self.graph!
        }
        if self.hostName != nil {
            map["HostName"] = self.hostName!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.lifecycle != nil {
            map["Lifecycle"] = self.lifecycle!
        }
        if self.logArchiveLocation != nil {
            map["LogArchiveLocation"] = self.logArchiveLocation!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        if self.parentFlowList != nil {
            map["ParentFlowList"] = self.parentFlowList?.toMap()
        }
        if self.periodic != nil {
            map["Periodic"] = self.periodic!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.startSchedule != nil {
            map["StartSchedule"] = self.startSchedule!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AlertConf") && dict["AlertConf"] != nil {
            self.alertConf = dict["AlertConf"] as! String
        }
        if dict.keys.contains("AlertDingDingGroupBizId") && dict["AlertDingDingGroupBizId"] != nil {
            self.alertDingDingGroupBizId = dict["AlertDingDingGroupBizId"] as! String
        }
        if dict.keys.contains("AlertUserGroupBizId") && dict["AlertUserGroupBizId"] != nil {
            self.alertUserGroupBizId = dict["AlertUserGroupBizId"] as! String
        }
        if dict.keys.contains("Application") && dict["Application"] != nil {
            self.application = dict["Application"] as! String
        }
        if dict.keys.contains("CategoryId") && dict["CategoryId"] != nil {
            self.categoryId = dict["CategoryId"] as! String
        }
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("CreateCluster") && dict["CreateCluster"] != nil {
            self.createCluster = dict["CreateCluster"] as! Bool
        }
        if dict.keys.contains("CronExpr") && dict["CronExpr"] != nil {
            self.cronExpr = dict["CronExpr"] as! String
        }
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("EditLockDetail") && dict["EditLockDetail"] != nil {
            self.editLockDetail = dict["EditLockDetail"] as! String
        }
        if dict.keys.contains("EndSchedule") && dict["EndSchedule"] != nil {
            self.endSchedule = dict["EndSchedule"] as! Int64
        }
        if dict.keys.contains("GmtCreate") && dict["GmtCreate"] != nil {
            self.gmtCreate = dict["GmtCreate"] as! Int64
        }
        if dict.keys.contains("GmtModified") && dict["GmtModified"] != nil {
            self.gmtModified = dict["GmtModified"] as! Int64
        }
        if dict.keys.contains("Graph") && dict["Graph"] != nil {
            self.graph = dict["Graph"] as! String
        }
        if dict.keys.contains("HostName") && dict["HostName"] != nil {
            self.hostName = dict["HostName"] as! String
        }
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! String
        }
        if dict.keys.contains("Lifecycle") && dict["Lifecycle"] != nil {
            self.lifecycle = dict["Lifecycle"] as! String
        }
        if dict.keys.contains("LogArchiveLocation") && dict["LogArchiveLocation"] != nil {
            self.logArchiveLocation = dict["LogArchiveLocation"] as! String
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
            self.namespace = dict["Namespace"] as! String
        }
        if dict.keys.contains("ParentFlowList") && dict["ParentFlowList"] != nil {
            var model = DescribeFlowResponseBody.ParentFlowList()
            model.fromMap(dict["ParentFlowList"] as! [String: Any])
            self.parentFlowList = model
        }
        if dict.keys.contains("Periodic") && dict["Periodic"] != nil {
            self.periodic = dict["Periodic"] as! Bool
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("StartSchedule") && dict["StartSchedule"] != nil {
            self.startSchedule = dict["StartSchedule"] as! Int64
        }
        if dict.keys.contains("Status") && dict["Status"] != nil {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! String
        }
    }
}

public class DescribeFlowResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeFlowResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeFlowResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeFlowCategoryRequest : Tea.TeaModel {
    public var id: String?

    public var projectId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! String
        }
        if dict.keys.contains("ProjectId") && dict["ProjectId"] != nil {
            self.projectId = dict["ProjectId"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DescribeFlowCategoryResponseBody : Tea.TeaModel {
    public var categoryType: String?

    public var gmtCreate: Int64?

    public var gmtModified: Int64?

    public var id: String?

    public var name: String?

    public var objectId: String?

    public var objectType: String?

    public var parentId: String?

    public var projectId: String?

    public var requestId: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.categoryType != nil {
            map["CategoryType"] = self.categoryType!
        }
        if self.gmtCreate != nil {
            map["GmtCreate"] = self.gmtCreate!
        }
        if self.gmtModified != nil {
            map["GmtModified"] = self.gmtModified!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.objectId != nil {
            map["ObjectId"] = self.objectId!
        }
        if self.objectType != nil {
            map["ObjectType"] = self.objectType!
        }
        if self.parentId != nil {
            map["ParentId"] = self.parentId!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CategoryType") && dict["CategoryType"] != nil {
            self.categoryType = dict["CategoryType"] as! String
        }
        if dict.keys.contains("GmtCreate") && dict["GmtCreate"] != nil {
            self.gmtCreate = dict["GmtCreate"] as! Int64
        }
        if dict.keys.contains("GmtModified") && dict["GmtModified"] != nil {
            self.gmtModified = dict["GmtModified"] as! Int64
        }
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! String
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("ObjectId") && dict["ObjectId"] != nil {
            self.objectId = dict["ObjectId"] as! String
        }
        if dict.keys.contains("ObjectType") && dict["ObjectType"] != nil {
            self.objectType = dict["ObjectType"] as! String
        }
        if dict.keys.contains("ParentId") && dict["ParentId"] != nil {
            self.parentId = dict["ParentId"] as! String
        }
        if dict.keys.contains("ProjectId") && dict["ProjectId"] != nil {
            self.projectId = dict["ProjectId"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! String
        }
    }
}

public class DescribeFlowCategoryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeFlowCategoryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeFlowCategoryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeFlowCategoryTreeRequest : Tea.TeaModel {
    public var categoryId: String?

    public var keyword: String?

    public var mode: String?

    public var projectId: String?

    public var regionId: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.categoryId != nil {
            map["CategoryId"] = self.categoryId!
        }
        if self.keyword != nil {
            map["Keyword"] = self.keyword!
        }
        if self.mode != nil {
            map["Mode"] = self.mode!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CategoryId") && dict["CategoryId"] != nil {
            self.categoryId = dict["CategoryId"] as! String
        }
        if dict.keys.contains("Keyword") && dict["Keyword"] != nil {
            self.keyword = dict["Keyword"] as! String
        }
        if dict.keys.contains("Mode") && dict["Mode"] != nil {
            self.mode = dict["Mode"] as! String
        }
        if dict.keys.contains("ProjectId") && dict["ProjectId"] != nil {
            self.projectId = dict["ProjectId"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! String
        }
    }
}

public class DescribeFlowCategoryTreeResponseBody : Tea.TeaModel {
    public var data: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeFlowCategoryTreeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeFlowCategoryTreeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeFlowCategoryTreeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeFlowInstanceRequest : Tea.TeaModel {
    public var id: String?

    public var projectId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! String
        }
        if dict.keys.contains("ProjectId") && dict["ProjectId"] != nil {
            self.projectId = dict["ProjectId"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DescribeFlowInstanceResponseBody : Tea.TeaModel {
    public class DependencyFlowList : Tea.TeaModel {
        public class ParentFlow : Tea.TeaModel {
            public var bizDate: Int64?

            public var dependencyFlowId: String?

            public var dependencyInstanceId: String?

            public var flowId: String?

            public var flowInstanceId: String?

            public var meet: Bool?

            public var projectId: String?

            public var scheduleKey: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bizDate != nil {
                    map["BizDate"] = self.bizDate!
                }
                if self.dependencyFlowId != nil {
                    map["DependencyFlowId"] = self.dependencyFlowId!
                }
                if self.dependencyInstanceId != nil {
                    map["DependencyInstanceId"] = self.dependencyInstanceId!
                }
                if self.flowId != nil {
                    map["FlowId"] = self.flowId!
                }
                if self.flowInstanceId != nil {
                    map["FlowInstanceId"] = self.flowInstanceId!
                }
                if self.meet != nil {
                    map["Meet"] = self.meet!
                }
                if self.projectId != nil {
                    map["ProjectId"] = self.projectId!
                }
                if self.scheduleKey != nil {
                    map["ScheduleKey"] = self.scheduleKey!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BizDate") && dict["BizDate"] != nil {
                    self.bizDate = dict["BizDate"] as! Int64
                }
                if dict.keys.contains("DependencyFlowId") && dict["DependencyFlowId"] != nil {
                    self.dependencyFlowId = dict["DependencyFlowId"] as! String
                }
                if dict.keys.contains("DependencyInstanceId") && dict["DependencyInstanceId"] != nil {
                    self.dependencyInstanceId = dict["DependencyInstanceId"] as! String
                }
                if dict.keys.contains("FlowId") && dict["FlowId"] != nil {
                    self.flowId = dict["FlowId"] as! String
                }
                if dict.keys.contains("FlowInstanceId") && dict["FlowInstanceId"] != nil {
                    self.flowInstanceId = dict["FlowInstanceId"] as! String
                }
                if dict.keys.contains("Meet") && dict["Meet"] != nil {
                    self.meet = dict["Meet"] as! Bool
                }
                if dict.keys.contains("ProjectId") && dict["ProjectId"] != nil {
                    self.projectId = dict["ProjectId"] as! String
                }
                if dict.keys.contains("ScheduleKey") && dict["ScheduleKey"] != nil {
                    self.scheduleKey = dict["ScheduleKey"] as! String
                }
            }
        }
        public var parentFlow: [DescribeFlowInstanceResponseBody.DependencyFlowList.ParentFlow]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.parentFlow != nil {
                var tmp : [Any] = []
                for k in self.parentFlow! {
                    tmp.append(k.toMap())
                }
                map["ParentFlow"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ParentFlow") && dict["ParentFlow"] != nil {
                var tmp : [DescribeFlowInstanceResponseBody.DependencyFlowList.ParentFlow] = []
                for v in dict["ParentFlow"] as! [Any] {
                    var model = DescribeFlowInstanceResponseBody.DependencyFlowList.ParentFlow()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.parentFlow = tmp
            }
        }
    }
    public class NodeInstance : Tea.TeaModel {
        public class NodeInstance : Tea.TeaModel {
            public var clusterId: String?

            public var duration: Int64?

            public var endTime: Int64?

            public var externalId: String?

            public var externalInfo: String?

            public var externalStatus: String?

            public var failAct: String?

            public var gmtCreate: Int64?

            public var gmtModified: Int64?

            public var hostName: String?

            public var id: String?

            public var jobId: String?

            public var jobName: String?

            public var jobType: String?

            public var maxRetry: String?

            public var nodeName: String?

            public var pending: Bool?

            public var projectId: String?

            public var retries: Int32?

            public var retryInterval: String?

            public var startTime: Int64?

            public var status: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.clusterId != nil {
                    map["ClusterId"] = self.clusterId!
                }
                if self.duration != nil {
                    map["Duration"] = self.duration!
                }
                if self.endTime != nil {
                    map["EndTime"] = self.endTime!
                }
                if self.externalId != nil {
                    map["ExternalId"] = self.externalId!
                }
                if self.externalInfo != nil {
                    map["ExternalInfo"] = self.externalInfo!
                }
                if self.externalStatus != nil {
                    map["ExternalStatus"] = self.externalStatus!
                }
                if self.failAct != nil {
                    map["FailAct"] = self.failAct!
                }
                if self.gmtCreate != nil {
                    map["GmtCreate"] = self.gmtCreate!
                }
                if self.gmtModified != nil {
                    map["GmtModified"] = self.gmtModified!
                }
                if self.hostName != nil {
                    map["HostName"] = self.hostName!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.jobId != nil {
                    map["JobId"] = self.jobId!
                }
                if self.jobName != nil {
                    map["JobName"] = self.jobName!
                }
                if self.jobType != nil {
                    map["JobType"] = self.jobType!
                }
                if self.maxRetry != nil {
                    map["MaxRetry"] = self.maxRetry!
                }
                if self.nodeName != nil {
                    map["NodeName"] = self.nodeName!
                }
                if self.pending != nil {
                    map["Pending"] = self.pending!
                }
                if self.projectId != nil {
                    map["ProjectId"] = self.projectId!
                }
                if self.retries != nil {
                    map["Retries"] = self.retries!
                }
                if self.retryInterval != nil {
                    map["RetryInterval"] = self.retryInterval!
                }
                if self.startTime != nil {
                    map["StartTime"] = self.startTime!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
                    self.clusterId = dict["ClusterId"] as! String
                }
                if dict.keys.contains("Duration") && dict["Duration"] != nil {
                    self.duration = dict["Duration"] as! Int64
                }
                if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
                    self.endTime = dict["EndTime"] as! Int64
                }
                if dict.keys.contains("ExternalId") && dict["ExternalId"] != nil {
                    self.externalId = dict["ExternalId"] as! String
                }
                if dict.keys.contains("ExternalInfo") && dict["ExternalInfo"] != nil {
                    self.externalInfo = dict["ExternalInfo"] as! String
                }
                if dict.keys.contains("ExternalStatus") && dict["ExternalStatus"] != nil {
                    self.externalStatus = dict["ExternalStatus"] as! String
                }
                if dict.keys.contains("FailAct") && dict["FailAct"] != nil {
                    self.failAct = dict["FailAct"] as! String
                }
                if dict.keys.contains("GmtCreate") && dict["GmtCreate"] != nil {
                    self.gmtCreate = dict["GmtCreate"] as! Int64
                }
                if dict.keys.contains("GmtModified") && dict["GmtModified"] != nil {
                    self.gmtModified = dict["GmtModified"] as! Int64
                }
                if dict.keys.contains("HostName") && dict["HostName"] != nil {
                    self.hostName = dict["HostName"] as! String
                }
                if dict.keys.contains("Id") && dict["Id"] != nil {
                    self.id = dict["Id"] as! String
                }
                if dict.keys.contains("JobId") && dict["JobId"] != nil {
                    self.jobId = dict["JobId"] as! String
                }
                if dict.keys.contains("JobName") && dict["JobName"] != nil {
                    self.jobName = dict["JobName"] as! String
                }
                if dict.keys.contains("JobType") && dict["JobType"] != nil {
                    self.jobType = dict["JobType"] as! String
                }
                if dict.keys.contains("MaxRetry") && dict["MaxRetry"] != nil {
                    self.maxRetry = dict["MaxRetry"] as! String
                }
                if dict.keys.contains("NodeName") && dict["NodeName"] != nil {
                    self.nodeName = dict["NodeName"] as! String
                }
                if dict.keys.contains("Pending") && dict["Pending"] != nil {
                    self.pending = dict["Pending"] as! Bool
                }
                if dict.keys.contains("ProjectId") && dict["ProjectId"] != nil {
                    self.projectId = dict["ProjectId"] as! String
                }
                if dict.keys.contains("Retries") && dict["Retries"] != nil {
                    self.retries = dict["Retries"] as! Int32
                }
                if dict.keys.contains("RetryInterval") && dict["RetryInterval"] != nil {
                    self.retryInterval = dict["RetryInterval"] as! String
                }
                if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
                    self.startTime = dict["StartTime"] as! Int64
                }
                if dict.keys.contains("Status") && dict["Status"] != nil {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var nodeInstance: [DescribeFlowInstanceResponseBody.NodeInstance.NodeInstance]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.nodeInstance != nil {
                var tmp : [Any] = []
                for k in self.nodeInstance! {
                    tmp.append(k.toMap())
                }
                map["NodeInstance"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("NodeInstance") && dict["NodeInstance"] != nil {
                var tmp : [DescribeFlowInstanceResponseBody.NodeInstance.NodeInstance] = []
                for v in dict["NodeInstance"] as! [Any] {
                    var model = DescribeFlowInstanceResponseBody.NodeInstance.NodeInstance()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.nodeInstance = tmp
            }
        }
    }
    public var clusterId: String?

    public var cronExpression: String?

    public var dependencyFlowList: DescribeFlowInstanceResponseBody.DependencyFlowList?

    public var duration: Int64?

    public var endTime: Int64?

    public var flowId: String?

    public var flowName: String?

    public var gmtCreate: Int64?

    public var gmtModified: Int64?

    public var graph: String?

    public var hasNodeFailed: Bool?

    public var id: String?

    public var lifecycle: String?

    public var logArchiveLocation: String?

    public var namespace: String?

    public var nodeInstance: DescribeFlowInstanceResponseBody.NodeInstance?

    public var projectId: String?

    public var requestId: String?

    public var scheduleTime: Int64?

    public var startTime: Int64?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.dependencyFlowList?.validate()
        try self.nodeInstance?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.cronExpression != nil {
            map["CronExpression"] = self.cronExpression!
        }
        if self.dependencyFlowList != nil {
            map["DependencyFlowList"] = self.dependencyFlowList?.toMap()
        }
        if self.duration != nil {
            map["Duration"] = self.duration!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.flowId != nil {
            map["FlowId"] = self.flowId!
        }
        if self.flowName != nil {
            map["FlowName"] = self.flowName!
        }
        if self.gmtCreate != nil {
            map["GmtCreate"] = self.gmtCreate!
        }
        if self.gmtModified != nil {
            map["GmtModified"] = self.gmtModified!
        }
        if self.graph != nil {
            map["Graph"] = self.graph!
        }
        if self.hasNodeFailed != nil {
            map["HasNodeFailed"] = self.hasNodeFailed!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.lifecycle != nil {
            map["Lifecycle"] = self.lifecycle!
        }
        if self.logArchiveLocation != nil {
            map["LogArchiveLocation"] = self.logArchiveLocation!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        if self.nodeInstance != nil {
            map["NodeInstance"] = self.nodeInstance?.toMap()
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.scheduleTime != nil {
            map["ScheduleTime"] = self.scheduleTime!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("CronExpression") && dict["CronExpression"] != nil {
            self.cronExpression = dict["CronExpression"] as! String
        }
        if dict.keys.contains("DependencyFlowList") && dict["DependencyFlowList"] != nil {
            var model = DescribeFlowInstanceResponseBody.DependencyFlowList()
            model.fromMap(dict["DependencyFlowList"] as! [String: Any])
            self.dependencyFlowList = model
        }
        if dict.keys.contains("Duration") && dict["Duration"] != nil {
            self.duration = dict["Duration"] as! Int64
        }
        if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("FlowId") && dict["FlowId"] != nil {
            self.flowId = dict["FlowId"] as! String
        }
        if dict.keys.contains("FlowName") && dict["FlowName"] != nil {
            self.flowName = dict["FlowName"] as! String
        }
        if dict.keys.contains("GmtCreate") && dict["GmtCreate"] != nil {
            self.gmtCreate = dict["GmtCreate"] as! Int64
        }
        if dict.keys.contains("GmtModified") && dict["GmtModified"] != nil {
            self.gmtModified = dict["GmtModified"] as! Int64
        }
        if dict.keys.contains("Graph") && dict["Graph"] != nil {
            self.graph = dict["Graph"] as! String
        }
        if dict.keys.contains("HasNodeFailed") && dict["HasNodeFailed"] != nil {
            self.hasNodeFailed = dict["HasNodeFailed"] as! Bool
        }
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! String
        }
        if dict.keys.contains("Lifecycle") && dict["Lifecycle"] != nil {
            self.lifecycle = dict["Lifecycle"] as! String
        }
        if dict.keys.contains("LogArchiveLocation") && dict["LogArchiveLocation"] != nil {
            self.logArchiveLocation = dict["LogArchiveLocation"] as! String
        }
        if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
            self.namespace = dict["Namespace"] as! String
        }
        if dict.keys.contains("NodeInstance") && dict["NodeInstance"] != nil {
            var model = DescribeFlowInstanceResponseBody.NodeInstance()
            model.fromMap(dict["NodeInstance"] as! [String: Any])
            self.nodeInstance = model
        }
        if dict.keys.contains("ProjectId") && dict["ProjectId"] != nil {
            self.projectId = dict["ProjectId"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ScheduleTime") && dict["ScheduleTime"] != nil {
            self.scheduleTime = dict["ScheduleTime"] as! Int64
        }
        if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
            self.startTime = dict["StartTime"] as! Int64
        }
        if dict.keys.contains("Status") && dict["Status"] != nil {
            self.status = dict["Status"] as! String
        }
    }
}

public class DescribeFlowInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeFlowInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeFlowInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeFlowJobRequest : Tea.TeaModel {
    public var id: String?

    public var projectId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! String
        }
        if dict.keys.contains("ProjectId") && dict["ProjectId"] != nil {
            self.projectId = dict["ProjectId"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DescribeFlowJobResponseBody : Tea.TeaModel {
    public class ResourceList : Tea.TeaModel {
        public class Resource : Tea.TeaModel {
            public var alias: String?

            public var path: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.alias != nil {
                    map["Alias"] = self.alias!
                }
                if self.path != nil {
                    map["Path"] = self.path!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Alias") && dict["Alias"] != nil {
                    self.alias = dict["Alias"] as! String
                }
                if dict.keys.contains("Path") && dict["Path"] != nil {
                    self.path = dict["Path"] as! String
                }
            }
        }
        public var resource: [DescribeFlowJobResponseBody.ResourceList.Resource]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.resource != nil {
                var tmp : [Any] = []
                for k in self.resource! {
                    tmp.append(k.toMap())
                }
                map["Resource"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Resource") && dict["Resource"] != nil {
                var tmp : [DescribeFlowJobResponseBody.ResourceList.Resource] = []
                for v in dict["Resource"] as! [Any] {
                    var model = DescribeFlowJobResponseBody.ResourceList.Resource()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.resource = tmp
            }
        }
    }
    public var adhoc: String?

    public var alertConf: String?

    public var categoryId: String?

    public var customVariables: String?

    public var description_: String?

    public var editLockDetail: String?

    public var envConf: String?

    public var failAct: String?

    public var gmtCreate: Int64?

    public var gmtModified: Int64?

    public var id: String?

    public var lastInstanceId: String?

    public var maxRetry: Int32?

    public var maxRunningTimeSec: Int64?

    public var monitorConf: String?

    public var name: String?

    public var paramConf: String?

    public var params: String?

    public var requestId: String?

    public var resourceList: DescribeFlowJobResponseBody.ResourceList?

    public var retryInterval: Int64?

    public var retryPolicy: String?

    public var runConf: String?

    public var type: String?

    public var mode: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.resourceList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.adhoc != nil {
            map["Adhoc"] = self.adhoc!
        }
        if self.alertConf != nil {
            map["AlertConf"] = self.alertConf!
        }
        if self.categoryId != nil {
            map["CategoryId"] = self.categoryId!
        }
        if self.customVariables != nil {
            map["CustomVariables"] = self.customVariables!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.editLockDetail != nil {
            map["EditLockDetail"] = self.editLockDetail!
        }
        if self.envConf != nil {
            map["EnvConf"] = self.envConf!
        }
        if self.failAct != nil {
            map["FailAct"] = self.failAct!
        }
        if self.gmtCreate != nil {
            map["GmtCreate"] = self.gmtCreate!
        }
        if self.gmtModified != nil {
            map["GmtModified"] = self.gmtModified!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.lastInstanceId != nil {
            map["LastInstanceId"] = self.lastInstanceId!
        }
        if self.maxRetry != nil {
            map["MaxRetry"] = self.maxRetry!
        }
        if self.maxRunningTimeSec != nil {
            map["MaxRunningTimeSec"] = self.maxRunningTimeSec!
        }
        if self.monitorConf != nil {
            map["MonitorConf"] = self.monitorConf!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.paramConf != nil {
            map["ParamConf"] = self.paramConf!
        }
        if self.params != nil {
            map["Params"] = self.params!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resourceList != nil {
            map["ResourceList"] = self.resourceList?.toMap()
        }
        if self.retryInterval != nil {
            map["RetryInterval"] = self.retryInterval!
        }
        if self.retryPolicy != nil {
            map["RetryPolicy"] = self.retryPolicy!
        }
        if self.runConf != nil {
            map["RunConf"] = self.runConf!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        if self.mode != nil {
            map["mode"] = self.mode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Adhoc") && dict["Adhoc"] != nil {
            self.adhoc = dict["Adhoc"] as! String
        }
        if dict.keys.contains("AlertConf") && dict["AlertConf"] != nil {
            self.alertConf = dict["AlertConf"] as! String
        }
        if dict.keys.contains("CategoryId") && dict["CategoryId"] != nil {
            self.categoryId = dict["CategoryId"] as! String
        }
        if dict.keys.contains("CustomVariables") && dict["CustomVariables"] != nil {
            self.customVariables = dict["CustomVariables"] as! String
        }
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("EditLockDetail") && dict["EditLockDetail"] != nil {
            self.editLockDetail = dict["EditLockDetail"] as! String
        }
        if dict.keys.contains("EnvConf") && dict["EnvConf"] != nil {
            self.envConf = dict["EnvConf"] as! String
        }
        if dict.keys.contains("FailAct") && dict["FailAct"] != nil {
            self.failAct = dict["FailAct"] as! String
        }
        if dict.keys.contains("GmtCreate") && dict["GmtCreate"] != nil {
            self.gmtCreate = dict["GmtCreate"] as! Int64
        }
        if dict.keys.contains("GmtModified") && dict["GmtModified"] != nil {
            self.gmtModified = dict["GmtModified"] as! Int64
        }
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! String
        }
        if dict.keys.contains("LastInstanceId") && dict["LastInstanceId"] != nil {
            self.lastInstanceId = dict["LastInstanceId"] as! String
        }
        if dict.keys.contains("MaxRetry") && dict["MaxRetry"] != nil {
            self.maxRetry = dict["MaxRetry"] as! Int32
        }
        if dict.keys.contains("MaxRunningTimeSec") && dict["MaxRunningTimeSec"] != nil {
            self.maxRunningTimeSec = dict["MaxRunningTimeSec"] as! Int64
        }
        if dict.keys.contains("MonitorConf") && dict["MonitorConf"] != nil {
            self.monitorConf = dict["MonitorConf"] as! String
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("ParamConf") && dict["ParamConf"] != nil {
            self.paramConf = dict["ParamConf"] as! String
        }
        if dict.keys.contains("Params") && dict["Params"] != nil {
            self.params = dict["Params"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResourceList") && dict["ResourceList"] != nil {
            var model = DescribeFlowJobResponseBody.ResourceList()
            model.fromMap(dict["ResourceList"] as! [String: Any])
            self.resourceList = model
        }
        if dict.keys.contains("RetryInterval") && dict["RetryInterval"] != nil {
            self.retryInterval = dict["RetryInterval"] as! Int64
        }
        if dict.keys.contains("RetryPolicy") && dict["RetryPolicy"] != nil {
            self.retryPolicy = dict["RetryPolicy"] as! String
        }
        if dict.keys.contains("RunConf") && dict["RunConf"] != nil {
            self.runConf = dict["RunConf"] as! String
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! String
        }
        if dict.keys.contains("mode") && dict["mode"] != nil {
            self.mode = dict["mode"] as! String
        }
    }
}

public class DescribeFlowJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeFlowJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeFlowJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeFlowNodeInstanceRequest : Tea.TeaModel {
    public var id: String?

    public var projectId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! String
        }
        if dict.keys.contains("ProjectId") && dict["ProjectId"] != nil {
            self.projectId = dict["ProjectId"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DescribeFlowNodeInstanceResponseBody : Tea.TeaModel {
    public var adhoc: Bool?

    public var clusterId: String?

    public var clusterName: String?

    public var duration: Int64?

    public var endTime: Int64?

    public var envConf: String?

    public var externalChildIds: String?

    public var externalId: String?

    public var externalInfo: String?

    public var externalStatus: String?

    public var externalSubId: String?

    public var failAct: String?

    public var flowId: String?

    public var flowInstanceId: String?

    public var gmtCreate: Int64?

    public var gmtModified: Int64?

    public var hostName: String?

    public var id: String?

    public var jobId: String?

    public var jobName: String?

    public var jobParams: String?

    public var jobType: String?

    public var maxRetry: String?

    public var mode: String?

    public var monitorConf: String?

    public var nodeName: String?

    public var paramConf: String?

    public var pending: Bool?

    public var projectId: String?

    public var requestId: String?

    public var retries: Int32?

    public var retryInterval: String?

    public var retryPolicy: String?

    public var runConf: String?

    public var startTime: Int64?

    public var status: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.adhoc != nil {
            map["Adhoc"] = self.adhoc!
        }
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.clusterName != nil {
            map["ClusterName"] = self.clusterName!
        }
        if self.duration != nil {
            map["Duration"] = self.duration!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.envConf != nil {
            map["EnvConf"] = self.envConf!
        }
        if self.externalChildIds != nil {
            map["ExternalChildIds"] = self.externalChildIds!
        }
        if self.externalId != nil {
            map["ExternalId"] = self.externalId!
        }
        if self.externalInfo != nil {
            map["ExternalInfo"] = self.externalInfo!
        }
        if self.externalStatus != nil {
            map["ExternalStatus"] = self.externalStatus!
        }
        if self.externalSubId != nil {
            map["ExternalSubId"] = self.externalSubId!
        }
        if self.failAct != nil {
            map["FailAct"] = self.failAct!
        }
        if self.flowId != nil {
            map["FlowId"] = self.flowId!
        }
        if self.flowInstanceId != nil {
            map["FlowInstanceId"] = self.flowInstanceId!
        }
        if self.gmtCreate != nil {
            map["GmtCreate"] = self.gmtCreate!
        }
        if self.gmtModified != nil {
            map["GmtModified"] = self.gmtModified!
        }
        if self.hostName != nil {
            map["HostName"] = self.hostName!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.jobName != nil {
            map["JobName"] = self.jobName!
        }
        if self.jobParams != nil {
            map["JobParams"] = self.jobParams!
        }
        if self.jobType != nil {
            map["JobType"] = self.jobType!
        }
        if self.maxRetry != nil {
            map["MaxRetry"] = self.maxRetry!
        }
        if self.mode != nil {
            map["Mode"] = self.mode!
        }
        if self.monitorConf != nil {
            map["MonitorConf"] = self.monitorConf!
        }
        if self.nodeName != nil {
            map["NodeName"] = self.nodeName!
        }
        if self.paramConf != nil {
            map["ParamConf"] = self.paramConf!
        }
        if self.pending != nil {
            map["Pending"] = self.pending!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.retries != nil {
            map["Retries"] = self.retries!
        }
        if self.retryInterval != nil {
            map["RetryInterval"] = self.retryInterval!
        }
        if self.retryPolicy != nil {
            map["RetryPolicy"] = self.retryPolicy!
        }
        if self.runConf != nil {
            map["RunConf"] = self.runConf!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Adhoc") && dict["Adhoc"] != nil {
            self.adhoc = dict["Adhoc"] as! Bool
        }
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("ClusterName") && dict["ClusterName"] != nil {
            self.clusterName = dict["ClusterName"] as! String
        }
        if dict.keys.contains("Duration") && dict["Duration"] != nil {
            self.duration = dict["Duration"] as! Int64
        }
        if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("EnvConf") && dict["EnvConf"] != nil {
            self.envConf = dict["EnvConf"] as! String
        }
        if dict.keys.contains("ExternalChildIds") && dict["ExternalChildIds"] != nil {
            self.externalChildIds = dict["ExternalChildIds"] as! String
        }
        if dict.keys.contains("ExternalId") && dict["ExternalId"] != nil {
            self.externalId = dict["ExternalId"] as! String
        }
        if dict.keys.contains("ExternalInfo") && dict["ExternalInfo"] != nil {
            self.externalInfo = dict["ExternalInfo"] as! String
        }
        if dict.keys.contains("ExternalStatus") && dict["ExternalStatus"] != nil {
            self.externalStatus = dict["ExternalStatus"] as! String
        }
        if dict.keys.contains("ExternalSubId") && dict["ExternalSubId"] != nil {
            self.externalSubId = dict["ExternalSubId"] as! String
        }
        if dict.keys.contains("FailAct") && dict["FailAct"] != nil {
            self.failAct = dict["FailAct"] as! String
        }
        if dict.keys.contains("FlowId") && dict["FlowId"] != nil {
            self.flowId = dict["FlowId"] as! String
        }
        if dict.keys.contains("FlowInstanceId") && dict["FlowInstanceId"] != nil {
            self.flowInstanceId = dict["FlowInstanceId"] as! String
        }
        if dict.keys.contains("GmtCreate") && dict["GmtCreate"] != nil {
            self.gmtCreate = dict["GmtCreate"] as! Int64
        }
        if dict.keys.contains("GmtModified") && dict["GmtModified"] != nil {
            self.gmtModified = dict["GmtModified"] as! Int64
        }
        if dict.keys.contains("HostName") && dict["HostName"] != nil {
            self.hostName = dict["HostName"] as! String
        }
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! String
        }
        if dict.keys.contains("JobId") && dict["JobId"] != nil {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("JobName") && dict["JobName"] != nil {
            self.jobName = dict["JobName"] as! String
        }
        if dict.keys.contains("JobParams") && dict["JobParams"] != nil {
            self.jobParams = dict["JobParams"] as! String
        }
        if dict.keys.contains("JobType") && dict["JobType"] != nil {
            self.jobType = dict["JobType"] as! String
        }
        if dict.keys.contains("MaxRetry") && dict["MaxRetry"] != nil {
            self.maxRetry = dict["MaxRetry"] as! String
        }
        if dict.keys.contains("Mode") && dict["Mode"] != nil {
            self.mode = dict["Mode"] as! String
        }
        if dict.keys.contains("MonitorConf") && dict["MonitorConf"] != nil {
            self.monitorConf = dict["MonitorConf"] as! String
        }
        if dict.keys.contains("NodeName") && dict["NodeName"] != nil {
            self.nodeName = dict["NodeName"] as! String
        }
        if dict.keys.contains("ParamConf") && dict["ParamConf"] != nil {
            self.paramConf = dict["ParamConf"] as! String
        }
        if dict.keys.contains("Pending") && dict["Pending"] != nil {
            self.pending = dict["Pending"] as! Bool
        }
        if dict.keys.contains("ProjectId") && dict["ProjectId"] != nil {
            self.projectId = dict["ProjectId"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Retries") && dict["Retries"] != nil {
            self.retries = dict["Retries"] as! Int32
        }
        if dict.keys.contains("RetryInterval") && dict["RetryInterval"] != nil {
            self.retryInterval = dict["RetryInterval"] as! String
        }
        if dict.keys.contains("RetryPolicy") && dict["RetryPolicy"] != nil {
            self.retryPolicy = dict["RetryPolicy"] as! String
        }
        if dict.keys.contains("RunConf") && dict["RunConf"] != nil {
            self.runConf = dict["RunConf"] as! String
        }
        if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
            self.startTime = dict["StartTime"] as! Int64
        }
        if dict.keys.contains("Status") && dict["Status"] != nil {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! String
        }
    }
}

public class DescribeFlowNodeInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeFlowNodeInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeFlowNodeInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeFlowNodeInstanceContainerLogRequest : Tea.TeaModel {
    public var appId: String?

    public var containerId: String?

    public var length: Int32?

    public var logName: String?

    public var nodeInstanceId: String?

    public var offset: Int32?

    public var projectId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.appId != nil {
            map["AppId"] = self.appId!
        }
        if self.containerId != nil {
            map["ContainerId"] = self.containerId!
        }
        if self.length != nil {
            map["Length"] = self.length!
        }
        if self.logName != nil {
            map["LogName"] = self.logName!
        }
        if self.nodeInstanceId != nil {
            map["NodeInstanceId"] = self.nodeInstanceId!
        }
        if self.offset != nil {
            map["Offset"] = self.offset!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AppId") && dict["AppId"] != nil {
            self.appId = dict["AppId"] as! String
        }
        if dict.keys.contains("ContainerId") && dict["ContainerId"] != nil {
            self.containerId = dict["ContainerId"] as! String
        }
        if dict.keys.contains("Length") && dict["Length"] != nil {
            self.length = dict["Length"] as! Int32
        }
        if dict.keys.contains("LogName") && dict["LogName"] != nil {
            self.logName = dict["LogName"] as! String
        }
        if dict.keys.contains("NodeInstanceId") && dict["NodeInstanceId"] != nil {
            self.nodeInstanceId = dict["NodeInstanceId"] as! String
        }
        if dict.keys.contains("Offset") && dict["Offset"] != nil {
            self.offset = dict["Offset"] as! Int32
        }
        if dict.keys.contains("ProjectId") && dict["ProjectId"] != nil {
            self.projectId = dict["ProjectId"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DescribeFlowNodeInstanceContainerLogResponseBody : Tea.TeaModel {
    public class LogEntrys : Tea.TeaModel {
        public class LogEntry : Tea.TeaModel {
            public var content: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.content != nil {
                    map["Content"] = self.content!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Content") && dict["Content"] != nil {
                    self.content = dict["Content"] as! String
                }
            }
        }
        public var logEntry: [DescribeFlowNodeInstanceContainerLogResponseBody.LogEntrys.LogEntry]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.logEntry != nil {
                var tmp : [Any] = []
                for k in self.logEntry! {
                    tmp.append(k.toMap())
                }
                map["LogEntry"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("LogEntry") && dict["LogEntry"] != nil {
                var tmp : [DescribeFlowNodeInstanceContainerLogResponseBody.LogEntrys.LogEntry] = []
                for v in dict["LogEntry"] as! [Any] {
                    var model = DescribeFlowNodeInstanceContainerLogResponseBody.LogEntrys.LogEntry()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.logEntry = tmp
            }
        }
    }
    public var logEnd: Bool?

    public var logEntrys: DescribeFlowNodeInstanceContainerLogResponseBody.LogEntrys?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.logEntrys?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.logEnd != nil {
            map["LogEnd"] = self.logEnd!
        }
        if self.logEntrys != nil {
            map["LogEntrys"] = self.logEntrys?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("LogEnd") && dict["LogEnd"] != nil {
            self.logEnd = dict["LogEnd"] as! Bool
        }
        if dict.keys.contains("LogEntrys") && dict["LogEntrys"] != nil {
            var model = DescribeFlowNodeInstanceContainerLogResponseBody.LogEntrys()
            model.fromMap(dict["LogEntrys"] as! [String: Any])
            self.logEntrys = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeFlowNodeInstanceContainerLogResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeFlowNodeInstanceContainerLogResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeFlowNodeInstanceContainerLogResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeFlowNodeInstanceLauncherLogRequest : Tea.TeaModel {
    public var endTime: Int64?

    public var length: Int32?

    public var lines: Int32?

    public var nodeInstanceId: String?

    public var offset: Int32?

    public var projectId: String?

    public var regionId: String?

    public var reverse: Bool?

    public var start: Int32?

    public var startTime: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.length != nil {
            map["Length"] = self.length!
        }
        if self.lines != nil {
            map["Lines"] = self.lines!
        }
        if self.nodeInstanceId != nil {
            map["NodeInstanceId"] = self.nodeInstanceId!
        }
        if self.offset != nil {
            map["Offset"] = self.offset!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.reverse != nil {
            map["Reverse"] = self.reverse!
        }
        if self.start != nil {
            map["Start"] = self.start!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
            self.endTime = dict["EndTime"] as! Int64
        }
        if dict.keys.contains("Length") && dict["Length"] != nil {
            self.length = dict["Length"] as! Int32
        }
        if dict.keys.contains("Lines") && dict["Lines"] != nil {
            self.lines = dict["Lines"] as! Int32
        }
        if dict.keys.contains("NodeInstanceId") && dict["NodeInstanceId"] != nil {
            self.nodeInstanceId = dict["NodeInstanceId"] as! String
        }
        if dict.keys.contains("Offset") && dict["Offset"] != nil {
            self.offset = dict["Offset"] as! Int32
        }
        if dict.keys.contains("ProjectId") && dict["ProjectId"] != nil {
            self.projectId = dict["ProjectId"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("Reverse") && dict["Reverse"] != nil {
            self.reverse = dict["Reverse"] as! Bool
        }
        if dict.keys.contains("Start") && dict["Start"] != nil {
            self.start = dict["Start"] as! Int32
        }
        if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
            self.startTime = dict["StartTime"] as! Int64
        }
    }
}

public class DescribeFlowNodeInstanceLauncherLogResponseBody : Tea.TeaModel {
    public class LogEntrys : Tea.TeaModel {
        public class LogEntry : Tea.TeaModel {
            public var content: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.content != nil {
                    map["Content"] = self.content!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Content") && dict["Content"] != nil {
                    self.content = dict["Content"] as! String
                }
            }
        }
        public var logEntry: [DescribeFlowNodeInstanceLauncherLogResponseBody.LogEntrys.LogEntry]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.logEntry != nil {
                var tmp : [Any] = []
                for k in self.logEntry! {
                    tmp.append(k.toMap())
                }
                map["LogEntry"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("LogEntry") && dict["LogEntry"] != nil {
                var tmp : [DescribeFlowNodeInstanceLauncherLogResponseBody.LogEntrys.LogEntry] = []
                for v in dict["LogEntry"] as! [Any] {
                    var model = DescribeFlowNodeInstanceLauncherLogResponseBody.LogEntrys.LogEntry()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.logEntry = tmp
            }
        }
    }
    public var logEnd: Bool?

    public var logEntrys: DescribeFlowNodeInstanceLauncherLogResponseBody.LogEntrys?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.logEntrys?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.logEnd != nil {
            map["LogEnd"] = self.logEnd!
        }
        if self.logEntrys != nil {
            map["LogEntrys"] = self.logEntrys?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("LogEnd") && dict["LogEnd"] != nil {
            self.logEnd = dict["LogEnd"] as! Bool
        }
        if dict.keys.contains("LogEntrys") && dict["LogEntrys"] != nil {
            var model = DescribeFlowNodeInstanceLauncherLogResponseBody.LogEntrys()
            model.fromMap(dict["LogEntrys"] as! [String: Any])
            self.logEntrys = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeFlowNodeInstanceLauncherLogResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeFlowNodeInstanceLauncherLogResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeFlowNodeInstanceLauncherLogResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeFlowProjectRequest : Tea.TeaModel {
    public var projectId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ProjectId") && dict["ProjectId"] != nil {
            self.projectId = dict["ProjectId"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DescribeFlowProjectResponseBody : Tea.TeaModel {
    public var description_: String?

    public var gmtCreate: Int64?

    public var gmtModified: Int64?

    public var id: String?

    public var name: String?

    public var requestId: String?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.gmtCreate != nil {
            map["GmtCreate"] = self.gmtCreate!
        }
        if self.gmtModified != nil {
            map["GmtModified"] = self.gmtModified!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.userId != nil {
            map["UserId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("GmtCreate") && dict["GmtCreate"] != nil {
            self.gmtCreate = dict["GmtCreate"] as! Int64
        }
        if dict.keys.contains("GmtModified") && dict["GmtModified"] != nil {
            self.gmtModified = dict["GmtModified"] as! Int64
        }
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! String
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("UserId") && dict["UserId"] != nil {
            self.userId = dict["UserId"] as! String
        }
    }
}

public class DescribeFlowProjectResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeFlowProjectResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeFlowProjectResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeFlowProjectClusterSettingRequest : Tea.TeaModel {
    public var clusterId: String?

    public var projectId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("ProjectId") && dict["ProjectId"] != nil {
            self.projectId = dict["ProjectId"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DescribeFlowProjectClusterSettingResponseBody : Tea.TeaModel {
    public class HostList : Tea.TeaModel {
        public var host: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.host != nil {
                map["Host"] = self.host!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Host") && dict["Host"] != nil {
                self.host = dict["Host"] as! [String]
            }
        }
    }
    public class QueueList : Tea.TeaModel {
        public var queue: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.queue != nil {
                map["Queue"] = self.queue!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Queue") && dict["Queue"] != nil {
                self.queue = dict["Queue"] as! [String]
            }
        }
    }
    public class UserList : Tea.TeaModel {
        public var user: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.user != nil {
                map["User"] = self.user!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("User") && dict["User"] != nil {
                self.user = dict["User"] as! [String]
            }
        }
    }
    public var clusterId: String?

    public var defaultQueue: String?

    public var defaultUser: String?

    public var gmtCreate: Int64?

    public var gmtModified: Int64?

    public var hostList: DescribeFlowProjectClusterSettingResponseBody.HostList?

    public var k8sClusterId: String?

    public var projectId: String?

    public var queueList: DescribeFlowProjectClusterSettingResponseBody.QueueList?

    public var requestId: String?

    public var userList: DescribeFlowProjectClusterSettingResponseBody.UserList?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.hostList?.validate()
        try self.queueList?.validate()
        try self.userList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.defaultQueue != nil {
            map["DefaultQueue"] = self.defaultQueue!
        }
        if self.defaultUser != nil {
            map["DefaultUser"] = self.defaultUser!
        }
        if self.gmtCreate != nil {
            map["GmtCreate"] = self.gmtCreate!
        }
        if self.gmtModified != nil {
            map["GmtModified"] = self.gmtModified!
        }
        if self.hostList != nil {
            map["HostList"] = self.hostList?.toMap()
        }
        if self.k8sClusterId != nil {
            map["K8sClusterId"] = self.k8sClusterId!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.queueList != nil {
            map["QueueList"] = self.queueList?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.userList != nil {
            map["UserList"] = self.userList?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("DefaultQueue") && dict["DefaultQueue"] != nil {
            self.defaultQueue = dict["DefaultQueue"] as! String
        }
        if dict.keys.contains("DefaultUser") && dict["DefaultUser"] != nil {
            self.defaultUser = dict["DefaultUser"] as! String
        }
        if dict.keys.contains("GmtCreate") && dict["GmtCreate"] != nil {
            self.gmtCreate = dict["GmtCreate"] as! Int64
        }
        if dict.keys.contains("GmtModified") && dict["GmtModified"] != nil {
            self.gmtModified = dict["GmtModified"] as! Int64
        }
        if dict.keys.contains("HostList") && dict["HostList"] != nil {
            var model = DescribeFlowProjectClusterSettingResponseBody.HostList()
            model.fromMap(dict["HostList"] as! [String: Any])
            self.hostList = model
        }
        if dict.keys.contains("K8sClusterId") && dict["K8sClusterId"] != nil {
            self.k8sClusterId = dict["K8sClusterId"] as! String
        }
        if dict.keys.contains("ProjectId") && dict["ProjectId"] != nil {
            self.projectId = dict["ProjectId"] as! String
        }
        if dict.keys.contains("QueueList") && dict["QueueList"] != nil {
            var model = DescribeFlowProjectClusterSettingResponseBody.QueueList()
            model.fromMap(dict["QueueList"] as! [String: Any])
            self.queueList = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("UserList") && dict["UserList"] != nil {
            var model = DescribeFlowProjectClusterSettingResponseBody.UserList()
            model.fromMap(dict["UserList"] as! [String: Any])
            self.userList = model
        }
    }
}

public class DescribeFlowProjectClusterSettingResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeFlowProjectClusterSettingResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeFlowProjectClusterSettingResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeScalingConfigItemV2Request : Tea.TeaModel {
    public var configItemType: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerId: Int64?

    public var scalingConfigItemId: String?

    public var scalingGroupBizId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.configItemType != nil {
            map["ConfigItemType"] = self.configItemType!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.scalingConfigItemId != nil {
            map["ScalingConfigItemId"] = self.scalingConfigItemId!
        }
        if self.scalingGroupBizId != nil {
            map["ScalingGroupBizId"] = self.scalingGroupBizId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ConfigItemType") && dict["ConfigItemType"] != nil {
            self.configItemType = dict["ConfigItemType"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") && dict["ResourceGroupId"] != nil {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") && dict["ResourceOwnerId"] != nil {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("ScalingConfigItemId") && dict["ScalingConfigItemId"] != nil {
            self.scalingConfigItemId = dict["ScalingConfigItemId"] as! String
        }
        if dict.keys.contains("ScalingGroupBizId") && dict["ScalingGroupBizId"] != nil {
            self.scalingGroupBizId = dict["ScalingGroupBizId"] as! String
        }
    }
}

public class DescribeScalingConfigItemV2ResponseBody : Tea.TeaModel {
    public var configItemInformation: String?

    public var configItemType: String?

    public var requestId: String?

    public var scalingConfigItemBizId: String?

    public var scalingGroupBizId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.configItemInformation != nil {
            map["ConfigItemInformation"] = self.configItemInformation!
        }
        if self.configItemType != nil {
            map["ConfigItemType"] = self.configItemType!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.scalingConfigItemBizId != nil {
            map["ScalingConfigItemBizId"] = self.scalingConfigItemBizId!
        }
        if self.scalingGroupBizId != nil {
            map["ScalingGroupBizId"] = self.scalingGroupBizId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ConfigItemInformation") && dict["ConfigItemInformation"] != nil {
            self.configItemInformation = dict["ConfigItemInformation"] as! String
        }
        if dict.keys.contains("ConfigItemType") && dict["ConfigItemType"] != nil {
            self.configItemType = dict["ConfigItemType"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ScalingConfigItemBizId") && dict["ScalingConfigItemBizId"] != nil {
            self.scalingConfigItemBizId = dict["ScalingConfigItemBizId"] as! String
        }
        if dict.keys.contains("ScalingGroupBizId") && dict["ScalingGroupBizId"] != nil {
            self.scalingGroupBizId = dict["ScalingGroupBizId"] as! String
        }
    }
}

public class DescribeScalingConfigItemV2Response : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeScalingConfigItemV2ResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeScalingConfigItemV2ResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeScalingGroupInstanceV2Request : Tea.TeaModel {
    public var hostGroupBizId: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerId: Int64?

    public var scalingGroupBizId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.hostGroupBizId != nil {
            map["HostGroupBizId"] = self.hostGroupBizId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.scalingGroupBizId != nil {
            map["ScalingGroupBizId"] = self.scalingGroupBizId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("HostGroupBizId") && dict["HostGroupBizId"] != nil {
            self.hostGroupBizId = dict["HostGroupBizId"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") && dict["ResourceGroupId"] != nil {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") && dict["ResourceOwnerId"] != nil {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("ScalingGroupBizId") && dict["ScalingGroupBizId"] != nil {
            self.scalingGroupBizId = dict["ScalingGroupBizId"] as! String
        }
    }
}

public class DescribeScalingGroupInstanceV2ResponseBody : Tea.TeaModel {
    public class ScalingConfig : Tea.TeaModel {
        public class InstanceTypeList : Tea.TeaModel {
            public var instanceType: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.instanceType != nil {
                    map["InstanceType"] = self.instanceType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("InstanceType") && dict["InstanceType"] != nil {
                    self.instanceType = dict["InstanceType"] as! [String]
                }
            }
        }
        public class SpotPriceLimits : Tea.TeaModel {
            public class SpotPriceLimit : Tea.TeaModel {
                public var instanceType: String?

                public var priceLimit: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.instanceType != nil {
                        map["InstanceType"] = self.instanceType!
                    }
                    if self.priceLimit != nil {
                        map["PriceLimit"] = self.priceLimit!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("InstanceType") && dict["InstanceType"] != nil {
                        self.instanceType = dict["InstanceType"] as! String
                    }
                    if dict.keys.contains("PriceLimit") && dict["PriceLimit"] != nil {
                        self.priceLimit = dict["PriceLimit"] as! Double
                    }
                }
            }
            public var spotPriceLimit: [DescribeScalingGroupInstanceV2ResponseBody.ScalingConfig.SpotPriceLimits.SpotPriceLimit]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.spotPriceLimit != nil {
                    var tmp : [Any] = []
                    for k in self.spotPriceLimit! {
                        tmp.append(k.toMap())
                    }
                    map["SpotPriceLimit"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("SpotPriceLimit") && dict["SpotPriceLimit"] != nil {
                    var tmp : [DescribeScalingGroupInstanceV2ResponseBody.ScalingConfig.SpotPriceLimits.SpotPriceLimit] = []
                    for v in dict["SpotPriceLimit"] as! [Any] {
                        var model = DescribeScalingGroupInstanceV2ResponseBody.ScalingConfig.SpotPriceLimits.SpotPriceLimit()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.spotPriceLimit = tmp
                }
            }
        }
        public var dataDiskCategory: String?

        public var dataDiskCount: Int32?

        public var dataDiskSize: Int32?

        public var instanceTypeList: DescribeScalingGroupInstanceV2ResponseBody.ScalingConfig.InstanceTypeList?

        public var payType: String?

        public var spotPriceLimits: DescribeScalingGroupInstanceV2ResponseBody.ScalingConfig.SpotPriceLimits?

        public var spotStrategy: String?

        public var sysDiskCategory: String?

        public var sysDiskSize: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.instanceTypeList?.validate()
            try self.spotPriceLimits?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dataDiskCategory != nil {
                map["DataDiskCategory"] = self.dataDiskCategory!
            }
            if self.dataDiskCount != nil {
                map["DataDiskCount"] = self.dataDiskCount!
            }
            if self.dataDiskSize != nil {
                map["DataDiskSize"] = self.dataDiskSize!
            }
            if self.instanceTypeList != nil {
                map["InstanceTypeList"] = self.instanceTypeList?.toMap()
            }
            if self.payType != nil {
                map["PayType"] = self.payType!
            }
            if self.spotPriceLimits != nil {
                map["SpotPriceLimits"] = self.spotPriceLimits?.toMap()
            }
            if self.spotStrategy != nil {
                map["SpotStrategy"] = self.spotStrategy!
            }
            if self.sysDiskCategory != nil {
                map["SysDiskCategory"] = self.sysDiskCategory!
            }
            if self.sysDiskSize != nil {
                map["SysDiskSize"] = self.sysDiskSize!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DataDiskCategory") && dict["DataDiskCategory"] != nil {
                self.dataDiskCategory = dict["DataDiskCategory"] as! String
            }
            if dict.keys.contains("DataDiskCount") && dict["DataDiskCount"] != nil {
                self.dataDiskCount = dict["DataDiskCount"] as! Int32
            }
            if dict.keys.contains("DataDiskSize") && dict["DataDiskSize"] != nil {
                self.dataDiskSize = dict["DataDiskSize"] as! Int32
            }
            if dict.keys.contains("InstanceTypeList") && dict["InstanceTypeList"] != nil {
                var model = DescribeScalingGroupInstanceV2ResponseBody.ScalingConfig.InstanceTypeList()
                model.fromMap(dict["InstanceTypeList"] as! [String: Any])
                self.instanceTypeList = model
            }
            if dict.keys.contains("PayType") && dict["PayType"] != nil {
                self.payType = dict["PayType"] as! String
            }
            if dict.keys.contains("SpotPriceLimits") && dict["SpotPriceLimits"] != nil {
                var model = DescribeScalingGroupInstanceV2ResponseBody.ScalingConfig.SpotPriceLimits()
                model.fromMap(dict["SpotPriceLimits"] as! [String: Any])
                self.spotPriceLimits = model
            }
            if dict.keys.contains("SpotStrategy") && dict["SpotStrategy"] != nil {
                self.spotStrategy = dict["SpotStrategy"] as! String
            }
            if dict.keys.contains("SysDiskCategory") && dict["SysDiskCategory"] != nil {
                self.sysDiskCategory = dict["SysDiskCategory"] as! String
            }
            if dict.keys.contains("SysDiskSize") && dict["SysDiskSize"] != nil {
                self.sysDiskSize = dict["SysDiskSize"] as! Int32
            }
        }
    }
    public class ScalingRuleList : Tea.TeaModel {
        public class ScalingRule : Tea.TeaModel {
            public class CloudWatchTrigger : Tea.TeaModel {
                public var comparisonOperator: String?

                public var evaluationCount: String?

                public var metricDisplayName: String?

                public var metricName: String?

                public var period: Int32?

                public var statistics: String?

                public var threshold: String?

                public var unit: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.comparisonOperator != nil {
                        map["ComparisonOperator"] = self.comparisonOperator!
                    }
                    if self.evaluationCount != nil {
                        map["EvaluationCount"] = self.evaluationCount!
                    }
                    if self.metricDisplayName != nil {
                        map["MetricDisplayName"] = self.metricDisplayName!
                    }
                    if self.metricName != nil {
                        map["MetricName"] = self.metricName!
                    }
                    if self.period != nil {
                        map["Period"] = self.period!
                    }
                    if self.statistics != nil {
                        map["Statistics"] = self.statistics!
                    }
                    if self.threshold != nil {
                        map["Threshold"] = self.threshold!
                    }
                    if self.unit != nil {
                        map["Unit"] = self.unit!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ComparisonOperator") && dict["ComparisonOperator"] != nil {
                        self.comparisonOperator = dict["ComparisonOperator"] as! String
                    }
                    if dict.keys.contains("EvaluationCount") && dict["EvaluationCount"] != nil {
                        self.evaluationCount = dict["EvaluationCount"] as! String
                    }
                    if dict.keys.contains("MetricDisplayName") && dict["MetricDisplayName"] != nil {
                        self.metricDisplayName = dict["MetricDisplayName"] as! String
                    }
                    if dict.keys.contains("MetricName") && dict["MetricName"] != nil {
                        self.metricName = dict["MetricName"] as! String
                    }
                    if dict.keys.contains("Period") && dict["Period"] != nil {
                        self.period = dict["Period"] as! Int32
                    }
                    if dict.keys.contains("Statistics") && dict["Statistics"] != nil {
                        self.statistics = dict["Statistics"] as! String
                    }
                    if dict.keys.contains("Threshold") && dict["Threshold"] != nil {
                        self.threshold = dict["Threshold"] as! String
                    }
                    if dict.keys.contains("Unit") && dict["Unit"] != nil {
                        self.unit = dict["Unit"] as! String
                    }
                }
            }
            public class SchedulerTrigger : Tea.TeaModel {
                public var launchExpirationTime: Int32?

                public var launchTime: Int64?

                public var recurrenceEndTime: Int64?

                public var recurrenceType: String?

                public var recurrenceValue: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.launchExpirationTime != nil {
                        map["LaunchExpirationTime"] = self.launchExpirationTime!
                    }
                    if self.launchTime != nil {
                        map["LaunchTime"] = self.launchTime!
                    }
                    if self.recurrenceEndTime != nil {
                        map["RecurrenceEndTime"] = self.recurrenceEndTime!
                    }
                    if self.recurrenceType != nil {
                        map["RecurrenceType"] = self.recurrenceType!
                    }
                    if self.recurrenceValue != nil {
                        map["RecurrenceValue"] = self.recurrenceValue!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("LaunchExpirationTime") && dict["LaunchExpirationTime"] != nil {
                        self.launchExpirationTime = dict["LaunchExpirationTime"] as! Int32
                    }
                    if dict.keys.contains("LaunchTime") && dict["LaunchTime"] != nil {
                        self.launchTime = dict["LaunchTime"] as! Int64
                    }
                    if dict.keys.contains("RecurrenceEndTime") && dict["RecurrenceEndTime"] != nil {
                        self.recurrenceEndTime = dict["RecurrenceEndTime"] as! Int64
                    }
                    if dict.keys.contains("RecurrenceType") && dict["RecurrenceType"] != nil {
                        self.recurrenceType = dict["RecurrenceType"] as! String
                    }
                    if dict.keys.contains("RecurrenceValue") && dict["RecurrenceValue"] != nil {
                        self.recurrenceValue = dict["RecurrenceValue"] as! String
                    }
                }
            }
            public var adjustmentType: String?

            public var adjustmentValue: Int32?

            public var cloudWatchTrigger: DescribeScalingGroupInstanceV2ResponseBody.ScalingRuleList.ScalingRule.CloudWatchTrigger?

            public var cooldown: Int32?

            public var essScalingRuleId: String?

            public var launchExpirationTime: Int32?

            public var launchTime: String?

            public var recurrenceEndTime: String?

            public var recurrenceType: String?

            public var recurrenceValue: String?

            public var ruleCategory: String?

            public var ruleName: String?

            public var scalingGroupId: Int64?

            public var schedulerTrigger: DescribeScalingGroupInstanceV2ResponseBody.ScalingRuleList.ScalingRule.SchedulerTrigger?

            public var status: String?

            public var timeoutWithGrace: Int64?

            public var withGrace: Bool?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.cloudWatchTrigger?.validate()
                try self.schedulerTrigger?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.adjustmentType != nil {
                    map["AdjustmentType"] = self.adjustmentType!
                }
                if self.adjustmentValue != nil {
                    map["AdjustmentValue"] = self.adjustmentValue!
                }
                if self.cloudWatchTrigger != nil {
                    map["CloudWatchTrigger"] = self.cloudWatchTrigger?.toMap()
                }
                if self.cooldown != nil {
                    map["Cooldown"] = self.cooldown!
                }
                if self.essScalingRuleId != nil {
                    map["EssScalingRuleId"] = self.essScalingRuleId!
                }
                if self.launchExpirationTime != nil {
                    map["LaunchExpirationTime"] = self.launchExpirationTime!
                }
                if self.launchTime != nil {
                    map["LaunchTime"] = self.launchTime!
                }
                if self.recurrenceEndTime != nil {
                    map["RecurrenceEndTime"] = self.recurrenceEndTime!
                }
                if self.recurrenceType != nil {
                    map["RecurrenceType"] = self.recurrenceType!
                }
                if self.recurrenceValue != nil {
                    map["RecurrenceValue"] = self.recurrenceValue!
                }
                if self.ruleCategory != nil {
                    map["RuleCategory"] = self.ruleCategory!
                }
                if self.ruleName != nil {
                    map["RuleName"] = self.ruleName!
                }
                if self.scalingGroupId != nil {
                    map["ScalingGroupId"] = self.scalingGroupId!
                }
                if self.schedulerTrigger != nil {
                    map["SchedulerTrigger"] = self.schedulerTrigger?.toMap()
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.timeoutWithGrace != nil {
                    map["TimeoutWithGrace"] = self.timeoutWithGrace!
                }
                if self.withGrace != nil {
                    map["WithGrace"] = self.withGrace!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AdjustmentType") && dict["AdjustmentType"] != nil {
                    self.adjustmentType = dict["AdjustmentType"] as! String
                }
                if dict.keys.contains("AdjustmentValue") && dict["AdjustmentValue"] != nil {
                    self.adjustmentValue = dict["AdjustmentValue"] as! Int32
                }
                if dict.keys.contains("CloudWatchTrigger") && dict["CloudWatchTrigger"] != nil {
                    var model = DescribeScalingGroupInstanceV2ResponseBody.ScalingRuleList.ScalingRule.CloudWatchTrigger()
                    model.fromMap(dict["CloudWatchTrigger"] as! [String: Any])
                    self.cloudWatchTrigger = model
                }
                if dict.keys.contains("Cooldown") && dict["Cooldown"] != nil {
                    self.cooldown = dict["Cooldown"] as! Int32
                }
                if dict.keys.contains("EssScalingRuleId") && dict["EssScalingRuleId"] != nil {
                    self.essScalingRuleId = dict["EssScalingRuleId"] as! String
                }
                if dict.keys.contains("LaunchExpirationTime") && dict["LaunchExpirationTime"] != nil {
                    self.launchExpirationTime = dict["LaunchExpirationTime"] as! Int32
                }
                if dict.keys.contains("LaunchTime") && dict["LaunchTime"] != nil {
                    self.launchTime = dict["LaunchTime"] as! String
                }
                if dict.keys.contains("RecurrenceEndTime") && dict["RecurrenceEndTime"] != nil {
                    self.recurrenceEndTime = dict["RecurrenceEndTime"] as! String
                }
                if dict.keys.contains("RecurrenceType") && dict["RecurrenceType"] != nil {
                    self.recurrenceType = dict["RecurrenceType"] as! String
                }
                if dict.keys.contains("RecurrenceValue") && dict["RecurrenceValue"] != nil {
                    self.recurrenceValue = dict["RecurrenceValue"] as! String
                }
                if dict.keys.contains("RuleCategory") && dict["RuleCategory"] != nil {
                    self.ruleCategory = dict["RuleCategory"] as! String
                }
                if dict.keys.contains("RuleName") && dict["RuleName"] != nil {
                    self.ruleName = dict["RuleName"] as! String
                }
                if dict.keys.contains("ScalingGroupId") && dict["ScalingGroupId"] != nil {
                    self.scalingGroupId = dict["ScalingGroupId"] as! Int64
                }
                if dict.keys.contains("SchedulerTrigger") && dict["SchedulerTrigger"] != nil {
                    var model = DescribeScalingGroupInstanceV2ResponseBody.ScalingRuleList.ScalingRule.SchedulerTrigger()
                    model.fromMap(dict["SchedulerTrigger"] as! [String: Any])
                    self.schedulerTrigger = model
                }
                if dict.keys.contains("Status") && dict["Status"] != nil {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("TimeoutWithGrace") && dict["TimeoutWithGrace"] != nil {
                    self.timeoutWithGrace = dict["TimeoutWithGrace"] as! Int64
                }
                if dict.keys.contains("WithGrace") && dict["WithGrace"] != nil {
                    self.withGrace = dict["WithGrace"] as! Bool
                }
            }
        }
        public var scalingRule: [DescribeScalingGroupInstanceV2ResponseBody.ScalingRuleList.ScalingRule]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.scalingRule != nil {
                var tmp : [Any] = []
                for k in self.scalingRule! {
                    tmp.append(k.toMap())
                }
                map["ScalingRule"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ScalingRule") && dict["ScalingRule"] != nil {
                var tmp : [DescribeScalingGroupInstanceV2ResponseBody.ScalingRuleList.ScalingRule] = []
                for v in dict["ScalingRule"] as! [Any] {
                    var model = DescribeScalingGroupInstanceV2ResponseBody.ScalingRuleList.ScalingRule()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.scalingRule = tmp
            }
        }
    }
    public var activeRuleCategory: String?

    public var defaultCooldown: Int32?

    public var hostGroupId: String?

    public var maxSize: Int32?

    public var minSize: Int32?

    public var multiAvailablePolicy: String?

    public var multiAvailablePolicyParam: String?

    public var requestId: String?

    public var scalingConfig: DescribeScalingGroupInstanceV2ResponseBody.ScalingConfig?

    public var scalingGroupId: String?

    public var scalingRuleList: DescribeScalingGroupInstanceV2ResponseBody.ScalingRuleList?

    public var timeoutWithGrace: Int64?

    public var withGrace: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.scalingConfig?.validate()
        try self.scalingRuleList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.activeRuleCategory != nil {
            map["ActiveRuleCategory"] = self.activeRuleCategory!
        }
        if self.defaultCooldown != nil {
            map["DefaultCooldown"] = self.defaultCooldown!
        }
        if self.hostGroupId != nil {
            map["HostGroupId"] = self.hostGroupId!
        }
        if self.maxSize != nil {
            map["MaxSize"] = self.maxSize!
        }
        if self.minSize != nil {
            map["MinSize"] = self.minSize!
        }
        if self.multiAvailablePolicy != nil {
            map["MultiAvailablePolicy"] = self.multiAvailablePolicy!
        }
        if self.multiAvailablePolicyParam != nil {
            map["MultiAvailablePolicyParam"] = self.multiAvailablePolicyParam!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.scalingConfig != nil {
            map["ScalingConfig"] = self.scalingConfig?.toMap()
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        if self.scalingRuleList != nil {
            map["ScalingRuleList"] = self.scalingRuleList?.toMap()
        }
        if self.timeoutWithGrace != nil {
            map["TimeoutWithGrace"] = self.timeoutWithGrace!
        }
        if self.withGrace != nil {
            map["WithGrace"] = self.withGrace!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ActiveRuleCategory") && dict["ActiveRuleCategory"] != nil {
            self.activeRuleCategory = dict["ActiveRuleCategory"] as! String
        }
        if dict.keys.contains("DefaultCooldown") && dict["DefaultCooldown"] != nil {
            self.defaultCooldown = dict["DefaultCooldown"] as! Int32
        }
        if dict.keys.contains("HostGroupId") && dict["HostGroupId"] != nil {
            self.hostGroupId = dict["HostGroupId"] as! String
        }
        if dict.keys.contains("MaxSize") && dict["MaxSize"] != nil {
            self.maxSize = dict["MaxSize"] as! Int32
        }
        if dict.keys.contains("MinSize") && dict["MinSize"] != nil {
            self.minSize = dict["MinSize"] as! Int32
        }
        if dict.keys.contains("MultiAvailablePolicy") && dict["MultiAvailablePolicy"] != nil {
            self.multiAvailablePolicy = dict["MultiAvailablePolicy"] as! String
        }
        if dict.keys.contains("MultiAvailablePolicyParam") && dict["MultiAvailablePolicyParam"] != nil {
            self.multiAvailablePolicyParam = dict["MultiAvailablePolicyParam"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ScalingConfig") && dict["ScalingConfig"] != nil {
            var model = DescribeScalingGroupInstanceV2ResponseBody.ScalingConfig()
            model.fromMap(dict["ScalingConfig"] as! [String: Any])
            self.scalingConfig = model
        }
        if dict.keys.contains("ScalingGroupId") && dict["ScalingGroupId"] != nil {
            self.scalingGroupId = dict["ScalingGroupId"] as! String
        }
        if dict.keys.contains("ScalingRuleList") && dict["ScalingRuleList"] != nil {
            var model = DescribeScalingGroupInstanceV2ResponseBody.ScalingRuleList()
            model.fromMap(dict["ScalingRuleList"] as! [String: Any])
            self.scalingRuleList = model
        }
        if dict.keys.contains("TimeoutWithGrace") && dict["TimeoutWithGrace"] != nil {
            self.timeoutWithGrace = dict["TimeoutWithGrace"] as! Int64
        }
        if dict.keys.contains("WithGrace") && dict["WithGrace"] != nil {
            self.withGrace = dict["WithGrace"] as! Bool
        }
    }
}

public class DescribeScalingGroupInstanceV2Response : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeScalingGroupInstanceV2ResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeScalingGroupInstanceV2ResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeScalingGroupV2Request : Tea.TeaModel {
    public var hostGroupBizId: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerId: Int64?

    public var scalingGroupBizId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.hostGroupBizId != nil {
            map["HostGroupBizId"] = self.hostGroupBizId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.scalingGroupBizId != nil {
            map["ScalingGroupBizId"] = self.scalingGroupBizId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("HostGroupBizId") && dict["HostGroupBizId"] != nil {
            self.hostGroupBizId = dict["HostGroupBizId"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") && dict["ResourceGroupId"] != nil {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") && dict["ResourceOwnerId"] != nil {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("ScalingGroupBizId") && dict["ScalingGroupBizId"] != nil {
            self.scalingGroupBizId = dict["ScalingGroupBizId"] as! String
        }
    }
}

public class DescribeScalingGroupV2ResponseBody : Tea.TeaModel {
    public var activeStatus: String?

    public var configState: String?

    public var description_: String?

    public var hostGroupBizId: String?

    public var name: String?

    public var requestId: String?

    public var scalingGroupId: String?

    public var scalingInMode: String?

    public var scalingMaxSize: Int32?

    public var scalingMinSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.activeStatus != nil {
            map["ActiveStatus"] = self.activeStatus!
        }
        if self.configState != nil {
            map["ConfigState"] = self.configState!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.hostGroupBizId != nil {
            map["HostGroupBizId"] = self.hostGroupBizId!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.scalingGroupId != nil {
            map["ScalingGroupId"] = self.scalingGroupId!
        }
        if self.scalingInMode != nil {
            map["ScalingInMode"] = self.scalingInMode!
        }
        if self.scalingMaxSize != nil {
            map["ScalingMaxSize"] = self.scalingMaxSize!
        }
        if self.scalingMinSize != nil {
            map["ScalingMinSize"] = self.scalingMinSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ActiveStatus") && dict["ActiveStatus"] != nil {
            self.activeStatus = dict["ActiveStatus"] as! String
        }
        if dict.keys.contains("ConfigState") && dict["ConfigState"] != nil {
            self.configState = dict["ConfigState"] as! String
        }
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("HostGroupBizId") && dict["HostGroupBizId"] != nil {
            self.hostGroupBizId = dict["HostGroupBizId"] as! String
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ScalingGroupId") && dict["ScalingGroupId"] != nil {
            self.scalingGroupId = dict["ScalingGroupId"] as! String
        }
        if dict.keys.contains("ScalingInMode") && dict["ScalingInMode"] != nil {
            self.scalingInMode = dict["ScalingInMode"] as! String
        }
        if dict.keys.contains("ScalingMaxSize") && dict["ScalingMaxSize"] != nil {
            self.scalingMaxSize = dict["ScalingMaxSize"] as! Int32
        }
        if dict.keys.contains("ScalingMinSize") && dict["ScalingMinSize"] != nil {
            self.scalingMinSize = dict["ScalingMinSize"] as! Int32
        }
    }
}

public class DescribeScalingGroupV2Response : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeScalingGroupV2ResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = DescribeScalingGroupV2ResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class JoinResourceGroupRequest : Tea.TeaModel {
    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceId: String?

    public var resourceOwnerId: Int64?

    public var resourceType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") && dict["ResourceGroupId"] != nil {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceId") && dict["ResourceId"] != nil {
            self.resourceId = dict["ResourceId"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") && dict["ResourceOwnerId"] != nil {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceType") && dict["ResourceType"] != nil {
            self.resourceType = dict["ResourceType"] as! String
        }
    }
}

public class JoinResourceGroupResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class JoinResourceGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: JoinResourceGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = JoinResourceGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class KillFlowJobRequest : Tea.TeaModel {
    public var jobInstanceId: String?

    public var projectId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobInstanceId != nil {
            map["JobInstanceId"] = self.jobInstanceId!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobInstanceId") && dict["JobInstanceId"] != nil {
            self.jobInstanceId = dict["JobInstanceId"] as! String
        }
        if dict.keys.contains("ProjectId") && dict["ProjectId"] != nil {
            self.projectId = dict["ProjectId"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class KillFlowJobResponseBody : Tea.TeaModel {
    public var data: Bool?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! Bool
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class KillFlowJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: KillFlowJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = KillFlowJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListClusterHostRequest : Tea.TeaModel {
    public var clusterId: String?

    public var componentName: String?

    public var groupType: String?

    public var hostGroupId: String?

    public var hostInstanceId: String?

    public var hostName: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var privateIp: String?

    public var publicIp: String?

    public var regionId: String?

    public var resourceOwnerId: Int64?

    public var statusList: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.componentName != nil {
            map["ComponentName"] = self.componentName!
        }
        if self.groupType != nil {
            map["GroupType"] = self.groupType!
        }
        if self.hostGroupId != nil {
            map["HostGroupId"] = self.hostGroupId!
        }
        if self.hostInstanceId != nil {
            map["HostInstanceId"] = self.hostInstanceId!
        }
        if self.hostName != nil {
            map["HostName"] = self.hostName!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.privateIp != nil {
            map["PrivateIp"] = self.privateIp!
        }
        if self.publicIp != nil {
            map["PublicIp"] = self.publicIp!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.statusList != nil {
            map["StatusList"] = self.statusList!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("ComponentName") && dict["ComponentName"] != nil {
            self.componentName = dict["ComponentName"] as! String
        }
        if dict.keys.contains("GroupType") && dict["GroupType"] != nil {
            self.groupType = dict["GroupType"] as! String
        }
        if dict.keys.contains("HostGroupId") && dict["HostGroupId"] != nil {
            self.hostGroupId = dict["HostGroupId"] as! String
        }
        if dict.keys.contains("HostInstanceId") && dict["HostInstanceId"] != nil {
            self.hostInstanceId = dict["HostInstanceId"] as! String
        }
        if dict.keys.contains("HostName") && dict["HostName"] != nil {
            self.hostName = dict["HostName"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("PrivateIp") && dict["PrivateIp"] != nil {
            self.privateIp = dict["PrivateIp"] as! String
        }
        if dict.keys.contains("PublicIp") && dict["PublicIp"] != nil {
            self.publicIp = dict["PublicIp"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") && dict["ResourceOwnerId"] != nil {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("StatusList") && dict["StatusList"] != nil {
            self.statusList = dict["StatusList"] as! [String]
        }
    }
}

public class ListClusterHostResponseBody : Tea.TeaModel {
    public class HostList : Tea.TeaModel {
        public class Host : Tea.TeaModel {
            public class DiskList : Tea.TeaModel {
                public class Disk : Tea.TeaModel {
                    public var blockMountPoint: String?

                    public var device: String?

                    public var diskId: String?

                    public var diskMountPoint: String?

                    public var diskSize: Int32?

                    public var diskType: String?

                    public var event: String?

                    public var type: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.blockMountPoint != nil {
                            map["BlockMountPoint"] = self.blockMountPoint!
                        }
                        if self.device != nil {
                            map["Device"] = self.device!
                        }
                        if self.diskId != nil {
                            map["DiskId"] = self.diskId!
                        }
                        if self.diskMountPoint != nil {
                            map["DiskMountPoint"] = self.diskMountPoint!
                        }
                        if self.diskSize != nil {
                            map["DiskSize"] = self.diskSize!
                        }
                        if self.diskType != nil {
                            map["DiskType"] = self.diskType!
                        }
                        if self.event != nil {
                            map["Event"] = self.event!
                        }
                        if self.type != nil {
                            map["Type"] = self.type!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("BlockMountPoint") && dict["BlockMountPoint"] != nil {
                            self.blockMountPoint = dict["BlockMountPoint"] as! String
                        }
                        if dict.keys.contains("Device") && dict["Device"] != nil {
                            self.device = dict["Device"] as! String
                        }
                        if dict.keys.contains("DiskId") && dict["DiskId"] != nil {
                            self.diskId = dict["DiskId"] as! String
                        }
                        if dict.keys.contains("DiskMountPoint") && dict["DiskMountPoint"] != nil {
                            self.diskMountPoint = dict["DiskMountPoint"] as! String
                        }
                        if dict.keys.contains("DiskSize") && dict["DiskSize"] != nil {
                            self.diskSize = dict["DiskSize"] as! Int32
                        }
                        if dict.keys.contains("DiskType") && dict["DiskType"] != nil {
                            self.diskType = dict["DiskType"] as! String
                        }
                        if dict.keys.contains("Event") && dict["Event"] != nil {
                            self.event = dict["Event"] as! String
                        }
                        if dict.keys.contains("Type") && dict["Type"] != nil {
                            self.type = dict["Type"] as! String
                        }
                    }
                }
                public var disk: [ListClusterHostResponseBody.HostList.Host.DiskList.Disk]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.disk != nil {
                        var tmp : [Any] = []
                        for k in self.disk! {
                            tmp.append(k.toMap())
                        }
                        map["Disk"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Disk") && dict["Disk"] != nil {
                        var tmp : [ListClusterHostResponseBody.HostList.Host.DiskList.Disk] = []
                        for v in dict["Disk"] as! [Any] {
                            var model = ListClusterHostResponseBody.HostList.Host.DiskList.Disk()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.disk = tmp
                    }
                }
            }
            public var chargeType: String?

            public var cpu: Int32?

            public var createTime: String?

            public var diskList: ListClusterHostResponseBody.HostList.Host.DiskList?

            public var emrExpiredTime: String?

            public var expiredTime: Int64?

            public var hostGroupId: String?

            public var hostInstanceId: String?

            public var hostName: String?

            public var instanceStatus: String?

            public var instanceType: String?

            public var memory: Int32?

            public var privateIp: String?

            public var publicIp: String?

            public var role: String?

            public var serialNumber: String?

            public var status: String?

            public var supportIpV6: Bool?

            public var type: String?

            public var zoneId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.diskList?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.chargeType != nil {
                    map["ChargeType"] = self.chargeType!
                }
                if self.cpu != nil {
                    map["Cpu"] = self.cpu!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.diskList != nil {
                    map["DiskList"] = self.diskList?.toMap()
                }
                if self.emrExpiredTime != nil {
                    map["EmrExpiredTime"] = self.emrExpiredTime!
                }
                if self.expiredTime != nil {
                    map["ExpiredTime"] = self.expiredTime!
                }
                if self.hostGroupId != nil {
                    map["HostGroupId"] = self.hostGroupId!
                }
                if self.hostInstanceId != nil {
                    map["HostInstanceId"] = self.hostInstanceId!
                }
                if self.hostName != nil {
                    map["HostName"] = self.hostName!
                }
                if self.instanceStatus != nil {
                    map["InstanceStatus"] = self.instanceStatus!
                }
                if self.instanceType != nil {
                    map["InstanceType"] = self.instanceType!
                }
                if self.memory != nil {
                    map["Memory"] = self.memory!
                }
                if self.privateIp != nil {
                    map["PrivateIp"] = self.privateIp!
                }
                if self.publicIp != nil {
                    map["PublicIp"] = self.publicIp!
                }
                if self.role != nil {
                    map["Role"] = self.role!
                }
                if self.serialNumber != nil {
                    map["SerialNumber"] = self.serialNumber!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.supportIpV6 != nil {
                    map["SupportIpV6"] = self.supportIpV6!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.zoneId != nil {
                    map["ZoneId"] = self.zoneId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ChargeType") && dict["ChargeType"] != nil {
                    self.chargeType = dict["ChargeType"] as! String
                }
                if dict.keys.contains("Cpu") && dict["Cpu"] != nil {
                    self.cpu = dict["Cpu"] as! Int32
                }
                if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                    self.createTime = dict["CreateTime"] as! String
                }
                if dict.keys.contains("DiskList") && dict["DiskList"] != nil {
                    var model = ListClusterHostResponseBody.HostList.Host.DiskList()
                    model.fromMap(dict["DiskList"] as! [String: Any])
                    self.diskList = model
                }
                if dict.keys.contains("EmrExpiredTime") && dict["EmrExpiredTime"] != nil {
                    self.emrExpiredTime = dict["EmrExpiredTime"] as! String
                }
                if dict.keys.contains("ExpiredTime") && dict["ExpiredTime"] != nil {
                    self.expiredTime = dict["ExpiredTime"] as! Int64
                }
                if dict.keys.contains("HostGroupId") && dict["HostGroupId"] != nil {
                    self.hostGroupId = dict["HostGroupId"] as! String
                }
                if dict.keys.contains("HostInstanceId") && dict["HostInstanceId"] != nil {
                    self.hostInstanceId = dict["HostInstanceId"] as! String
                }
                if dict.keys.contains("HostName") && dict["HostName"] != nil {
                    self.hostName = dict["HostName"] as! String
                }
                if dict.keys.contains("InstanceStatus") && dict["InstanceStatus"] != nil {
                    self.instanceStatus = dict["InstanceStatus"] as! String
                }
                if dict.keys.contains("InstanceType") && dict["InstanceType"] != nil {
                    self.instanceType = dict["InstanceType"] as! String
                }
                if dict.keys.contains("Memory") && dict["Memory"] != nil {
                    self.memory = dict["Memory"] as! Int32
                }
                if dict.keys.contains("PrivateIp") && dict["PrivateIp"] != nil {
                    self.privateIp = dict["PrivateIp"] as! String
                }
                if dict.keys.contains("PublicIp") && dict["PublicIp"] != nil {
                    self.publicIp = dict["PublicIp"] as! String
                }
                if dict.keys.contains("Role") && dict["Role"] != nil {
                    self.role = dict["Role"] as! String
                }
                if dict.keys.contains("SerialNumber") && dict["SerialNumber"] != nil {
                    self.serialNumber = dict["SerialNumber"] as! String
                }
                if dict.keys.contains("Status") && dict["Status"] != nil {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("SupportIpV6") && dict["SupportIpV6"] != nil {
                    self.supportIpV6 = dict["SupportIpV6"] as! Bool
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("ZoneId") && dict["ZoneId"] != nil {
                    self.zoneId = dict["ZoneId"] as! String
                }
            }
        }
        public var host: [ListClusterHostResponseBody.HostList.Host]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.host != nil {
                var tmp : [Any] = []
                for k in self.host! {
                    tmp.append(k.toMap())
                }
                map["Host"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Host") && dict["Host"] != nil {
                var tmp : [ListClusterHostResponseBody.HostList.Host] = []
                for v in dict["Host"] as! [Any] {
                    var model = ListClusterHostResponseBody.HostList.Host()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.host = tmp
            }
        }
    }
    public var hostList: ListClusterHostResponseBody.HostList?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var total: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.hostList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.hostList != nil {
            map["HostList"] = self.hostList?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.total != nil {
            map["Total"] = self.total!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("HostList") && dict["HostList"] != nil {
            var model = ListClusterHostResponseBody.HostList()
            model.fromMap(dict["HostList"] as! [String: Any])
            self.hostList = model
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Total") && dict["Total"] != nil {
            self.total = dict["Total"] as! Int32
        }
    }
}

public class ListClusterHostResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListClusterHostResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListClusterHostResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListClusterHostComponentRequest : Tea.TeaModel {
    public var clusterId: String?

    public var componentName: String?

    public var componentStatus: String?

    public var hostInstanceId: String?

    public var hostName: String?

    public var hostRole: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceOwnerId: Int64?

    public var serviceName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.componentName != nil {
            map["ComponentName"] = self.componentName!
        }
        if self.componentStatus != nil {
            map["ComponentStatus"] = self.componentStatus!
        }
        if self.hostInstanceId != nil {
            map["HostInstanceId"] = self.hostInstanceId!
        }
        if self.hostName != nil {
            map["HostName"] = self.hostName!
        }
        if self.hostRole != nil {
            map["HostRole"] = self.hostRole!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.serviceName != nil {
            map["ServiceName"] = self.serviceName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("ComponentName") && dict["ComponentName"] != nil {
            self.componentName = dict["ComponentName"] as! String
        }
        if dict.keys.contains("ComponentStatus") && dict["ComponentStatus"] != nil {
            self.componentStatus = dict["ComponentStatus"] as! String
        }
        if dict.keys.contains("HostInstanceId") && dict["HostInstanceId"] != nil {
            self.hostInstanceId = dict["HostInstanceId"] as! String
        }
        if dict.keys.contains("HostName") && dict["HostName"] != nil {
            self.hostName = dict["HostName"] as! String
        }
        if dict.keys.contains("HostRole") && dict["HostRole"] != nil {
            self.hostRole = dict["HostRole"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") && dict["ResourceOwnerId"] != nil {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("ServiceName") && dict["ServiceName"] != nil {
            self.serviceName = dict["ServiceName"] as! String
        }
    }
}

public class ListClusterHostComponentResponseBody : Tea.TeaModel {
    public class ComponentList : Tea.TeaModel {
        public class Component : Tea.TeaModel {
            public var commissionStatus: String?

            public var componentDisplayName: String?

            public var componentName: String?

            public var cpu: Int32?

            public var healthReportTime: Int64?

            public var healthStatus: String?

            public var hostId: String?

            public var hostInstanceId: String?

            public var hostName: String?

            public var instanceType: String?

            public var memory: Int32?

            public var needRestart: Bool?

            public var privateIp: String?

            public var publicIp: String?

            public var role: String?

            public var serialNumber: String?

            public var serverStatus: String?

            public var serviceDisplayName: String?

            public var serviceName: String?

            public var state: String?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.commissionStatus != nil {
                    map["CommissionStatus"] = self.commissionStatus!
                }
                if self.componentDisplayName != nil {
                    map["ComponentDisplayName"] = self.componentDisplayName!
                }
                if self.componentName != nil {
                    map["ComponentName"] = self.componentName!
                }
                if self.cpu != nil {
                    map["Cpu"] = self.cpu!
                }
                if self.healthReportTime != nil {
                    map["HealthReportTime"] = self.healthReportTime!
                }
                if self.healthStatus != nil {
                    map["HealthStatus"] = self.healthStatus!
                }
                if self.hostId != nil {
                    map["HostId"] = self.hostId!
                }
                if self.hostInstanceId != nil {
                    map["HostInstanceId"] = self.hostInstanceId!
                }
                if self.hostName != nil {
                    map["HostName"] = self.hostName!
                }
                if self.instanceType != nil {
                    map["InstanceType"] = self.instanceType!
                }
                if self.memory != nil {
                    map["Memory"] = self.memory!
                }
                if self.needRestart != nil {
                    map["NeedRestart"] = self.needRestart!
                }
                if self.privateIp != nil {
                    map["PrivateIp"] = self.privateIp!
                }
                if self.publicIp != nil {
                    map["PublicIp"] = self.publicIp!
                }
                if self.role != nil {
                    map["Role"] = self.role!
                }
                if self.serialNumber != nil {
                    map["SerialNumber"] = self.serialNumber!
                }
                if self.serverStatus != nil {
                    map["ServerStatus"] = self.serverStatus!
                }
                if self.serviceDisplayName != nil {
                    map["ServiceDisplayName"] = self.serviceDisplayName!
                }
                if self.serviceName != nil {
                    map["ServiceName"] = self.serviceName!
                }
                if self.state != nil {
                    map["State"] = self.state!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CommissionStatus") && dict["CommissionStatus"] != nil {
                    self.commissionStatus = dict["CommissionStatus"] as! String
                }
                if dict.keys.contains("ComponentDisplayName") && dict["ComponentDisplayName"] != nil {
                    self.componentDisplayName = dict["ComponentDisplayName"] as! String
                }
                if dict.keys.contains("ComponentName") && dict["ComponentName"] != nil {
                    self.componentName = dict["ComponentName"] as! String
                }
                if dict.keys.contains("Cpu") && dict["Cpu"] != nil {
                    self.cpu = dict["Cpu"] as! Int32
                }
                if dict.keys.contains("HealthReportTime") && dict["HealthReportTime"] != nil {
                    self.healthReportTime = dict["HealthReportTime"] as! Int64
                }
                if dict.keys.contains("HealthStatus") && dict["HealthStatus"] != nil {
                    self.healthStatus = dict["HealthStatus"] as! String
                }
                if dict.keys.contains("HostId") && dict["HostId"] != nil {
                    self.hostId = dict["HostId"] as! String
                }
                if dict.keys.contains("HostInstanceId") && dict["HostInstanceId"] != nil {
                    self.hostInstanceId = dict["HostInstanceId"] as! String
                }
                if dict.keys.contains("HostName") && dict["HostName"] != nil {
                    self.hostName = dict["HostName"] as! String
                }
                if dict.keys.contains("InstanceType") && dict["InstanceType"] != nil {
                    self.instanceType = dict["InstanceType"] as! String
                }
                if dict.keys.contains("Memory") && dict["Memory"] != nil {
                    self.memory = dict["Memory"] as! Int32
                }
                if dict.keys.contains("NeedRestart") && dict["NeedRestart"] != nil {
                    self.needRestart = dict["NeedRestart"] as! Bool
                }
                if dict.keys.contains("PrivateIp") && dict["PrivateIp"] != nil {
                    self.privateIp = dict["PrivateIp"] as! String
                }
                if dict.keys.contains("PublicIp") && dict["PublicIp"] != nil {
                    self.publicIp = dict["PublicIp"] as! String
                }
                if dict.keys.contains("Role") && dict["Role"] != nil {
                    self.role = dict["Role"] as! String
                }
                if dict.keys.contains("SerialNumber") && dict["SerialNumber"] != nil {
                    self.serialNumber = dict["SerialNumber"] as! String
                }
                if dict.keys.contains("ServerStatus") && dict["ServerStatus"] != nil {
                    self.serverStatus = dict["ServerStatus"] as! String
                }
                if dict.keys.contains("ServiceDisplayName") && dict["ServiceDisplayName"] != nil {
                    self.serviceDisplayName = dict["ServiceDisplayName"] as! String
                }
                if dict.keys.contains("ServiceName") && dict["ServiceName"] != nil {
                    self.serviceName = dict["ServiceName"] as! String
                }
                if dict.keys.contains("State") && dict["State"] != nil {
                    self.state = dict["State"] as! String
                }
                if dict.keys.contains("Status") && dict["Status"] != nil {
                    self.status = dict["Status"] as! String
                }
            }
        }
        public var component: [ListClusterHostComponentResponseBody.ComponentList.Component]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.component != nil {
                var tmp : [Any] = []
                for k in self.component! {
                    tmp.append(k.toMap())
                }
                map["Component"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Component") && dict["Component"] != nil {
                var tmp : [ListClusterHostComponentResponseBody.ComponentList.Component] = []
                for v in dict["Component"] as! [Any] {
                    var model = ListClusterHostComponentResponseBody.ComponentList.Component()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.component = tmp
            }
        }
    }
    public var componentList: ListClusterHostComponentResponseBody.ComponentList?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var total: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.componentList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.componentList != nil {
            map["ComponentList"] = self.componentList?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.total != nil {
            map["Total"] = self.total!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ComponentList") && dict["ComponentList"] != nil {
            var model = ListClusterHostComponentResponseBody.ComponentList()
            model.fromMap(dict["ComponentList"] as! [String: Any])
            self.componentList = model
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Total") && dict["Total"] != nil {
            self.total = dict["Total"] as! Int32
        }
    }
}

public class ListClusterHostComponentResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListClusterHostComponentResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListClusterHostComponentResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListClusterHostGroupRequest : Tea.TeaModel {
    public var clusterId: String?

    public var hostGroupId: String?

    public var hostGroupName: String?

    public var hostGroupType: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceOwnerId: Int64?

    public var statusList: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.hostGroupId != nil {
            map["HostGroupId"] = self.hostGroupId!
        }
        if self.hostGroupName != nil {
            map["HostGroupName"] = self.hostGroupName!
        }
        if self.hostGroupType != nil {
            map["HostGroupType"] = self.hostGroupType!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.statusList != nil {
            map["StatusList"] = self.statusList!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("HostGroupId") && dict["HostGroupId"] != nil {
            self.hostGroupId = dict["HostGroupId"] as! String
        }
        if dict.keys.contains("HostGroupName") && dict["HostGroupName"] != nil {
            self.hostGroupName = dict["HostGroupName"] as! String
        }
        if dict.keys.contains("HostGroupType") && dict["HostGroupType"] != nil {
            self.hostGroupType = dict["HostGroupType"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") && dict["ResourceOwnerId"] != nil {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("StatusList") && dict["StatusList"] != nil {
            self.statusList = dict["StatusList"] as! [String]
        }
    }
}

public class ListClusterHostGroupResponseBody : Tea.TeaModel {
    public class HostGroupList : Tea.TeaModel {
        public class HostGroup : Tea.TeaModel {
            public var chargeType: String?

            public var comment: String?

            public var costSavingPercent: Double?

            public var cpu: Int32?

            public var dataDiskCount: Int32?

            public var dataDiskSize: Int32?

            public var dataDiskType: String?

            public var hostGroupChangeStatus: String?

            public var hostGroupChangeType: String?

            public var hostGroupId: String?

            public var hostGroupName: String?

            public var hostGroupSubType: String?

            public var hostGroupType: String?

            public var instanceType: String?

            public var lockReason: String?

            public var lockType: String?

            public var memory: Int32?

            public var nodeCount: Int32?

            public var payType: String?

            public var scalingGroupActiveStatus: String?

            public var scalingGroupBizId: String?

            public var scalingGroupConfigState: String?

            public var scalingGroupMaxNode: Int32?

            public var scalingGroupMinNode: Int32?

            public var scalingInMode: String?

            public var securityGroupId: String?

            public var status: String?

            public var systemDiskCount: Int32?

            public var systemDiskSize: Int32?

            public var systemDiskType: String?

            public var vswitchId: String?

            public var gmtCreate: String?

            public var gmtModified: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.chargeType != nil {
                    map["ChargeType"] = self.chargeType!
                }
                if self.comment != nil {
                    map["Comment"] = self.comment!
                }
                if self.costSavingPercent != nil {
                    map["CostSavingPercent"] = self.costSavingPercent!
                }
                if self.cpu != nil {
                    map["Cpu"] = self.cpu!
                }
                if self.dataDiskCount != nil {
                    map["DataDiskCount"] = self.dataDiskCount!
                }
                if self.dataDiskSize != nil {
                    map["DataDiskSize"] = self.dataDiskSize!
                }
                if self.dataDiskType != nil {
                    map["DataDiskType"] = self.dataDiskType!
                }
                if self.hostGroupChangeStatus != nil {
                    map["HostGroupChangeStatus"] = self.hostGroupChangeStatus!
                }
                if self.hostGroupChangeType != nil {
                    map["HostGroupChangeType"] = self.hostGroupChangeType!
                }
                if self.hostGroupId != nil {
                    map["HostGroupId"] = self.hostGroupId!
                }
                if self.hostGroupName != nil {
                    map["HostGroupName"] = self.hostGroupName!
                }
                if self.hostGroupSubType != nil {
                    map["HostGroupSubType"] = self.hostGroupSubType!
                }
                if self.hostGroupType != nil {
                    map["HostGroupType"] = self.hostGroupType!
                }
                if self.instanceType != nil {
                    map["InstanceType"] = self.instanceType!
                }
                if self.lockReason != nil {
                    map["LockReason"] = self.lockReason!
                }
                if self.lockType != nil {
                    map["LockType"] = self.lockType!
                }
                if self.memory != nil {
                    map["Memory"] = self.memory!
                }
                if self.nodeCount != nil {
                    map["NodeCount"] = self.nodeCount!
                }
                if self.payType != nil {
                    map["PayType"] = self.payType!
                }
                if self.scalingGroupActiveStatus != nil {
                    map["ScalingGroupActiveStatus"] = self.scalingGroupActiveStatus!
                }
                if self.scalingGroupBizId != nil {
                    map["ScalingGroupBizId"] = self.scalingGroupBizId!
                }
                if self.scalingGroupConfigState != nil {
                    map["ScalingGroupConfigState"] = self.scalingGroupConfigState!
                }
                if self.scalingGroupMaxNode != nil {
                    map["ScalingGroupMaxNode"] = self.scalingGroupMaxNode!
                }
                if self.scalingGroupMinNode != nil {
                    map["ScalingGroupMinNode"] = self.scalingGroupMinNode!
                }
                if self.scalingInMode != nil {
                    map["ScalingInMode"] = self.scalingInMode!
                }
                if self.securityGroupId != nil {
                    map["SecurityGroupId"] = self.securityGroupId!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.systemDiskCount != nil {
                    map["SystemDiskCount"] = self.systemDiskCount!
                }
                if self.systemDiskSize != nil {
                    map["SystemDiskSize"] = self.systemDiskSize!
                }
                if self.systemDiskType != nil {
                    map["SystemDiskType"] = self.systemDiskType!
                }
                if self.vswitchId != nil {
                    map["VswitchId"] = self.vswitchId!
                }
                if self.gmtCreate != nil {
                    map["gmtCreate"] = self.gmtCreate!
                }
                if self.gmtModified != nil {
                    map["gmtModified"] = self.gmtModified!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ChargeType") && dict["ChargeType"] != nil {
                    self.chargeType = dict["ChargeType"] as! String
                }
                if dict.keys.contains("Comment") && dict["Comment"] != nil {
                    self.comment = dict["Comment"] as! String
                }
                if dict.keys.contains("CostSavingPercent") && dict["CostSavingPercent"] != nil {
                    self.costSavingPercent = dict["CostSavingPercent"] as! Double
                }
                if dict.keys.contains("Cpu") && dict["Cpu"] != nil {
                    self.cpu = dict["Cpu"] as! Int32
                }
                if dict.keys.contains("DataDiskCount") && dict["DataDiskCount"] != nil {
                    self.dataDiskCount = dict["DataDiskCount"] as! Int32
                }
                if dict.keys.contains("DataDiskSize") && dict["DataDiskSize"] != nil {
                    self.dataDiskSize = dict["DataDiskSize"] as! Int32
                }
                if dict.keys.contains("DataDiskType") && dict["DataDiskType"] != nil {
                    self.dataDiskType = dict["DataDiskType"] as! String
                }
                if dict.keys.contains("HostGroupChangeStatus") && dict["HostGroupChangeStatus"] != nil {
                    self.hostGroupChangeStatus = dict["HostGroupChangeStatus"] as! String
                }
                if dict.keys.contains("HostGroupChangeType") && dict["HostGroupChangeType"] != nil {
                    self.hostGroupChangeType = dict["HostGroupChangeType"] as! String
                }
                if dict.keys.contains("HostGroupId") && dict["HostGroupId"] != nil {
                    self.hostGroupId = dict["HostGroupId"] as! String
                }
                if dict.keys.contains("HostGroupName") && dict["HostGroupName"] != nil {
                    self.hostGroupName = dict["HostGroupName"] as! String
                }
                if dict.keys.contains("HostGroupSubType") && dict["HostGroupSubType"] != nil {
                    self.hostGroupSubType = dict["HostGroupSubType"] as! String
                }
                if dict.keys.contains("HostGroupType") && dict["HostGroupType"] != nil {
                    self.hostGroupType = dict["HostGroupType"] as! String
                }
                if dict.keys.contains("InstanceType") && dict["InstanceType"] != nil {
                    self.instanceType = dict["InstanceType"] as! String
                }
                if dict.keys.contains("LockReason") && dict["LockReason"] != nil {
                    self.lockReason = dict["LockReason"] as! String
                }
                if dict.keys.contains("LockType") && dict["LockType"] != nil {
                    self.lockType = dict["LockType"] as! String
                }
                if dict.keys.contains("Memory") && dict["Memory"] != nil {
                    self.memory = dict["Memory"] as! Int32
                }
                if dict.keys.contains("NodeCount") && dict["NodeCount"] != nil {
                    self.nodeCount = dict["NodeCount"] as! Int32
                }
                if dict.keys.contains("PayType") && dict["PayType"] != nil {
                    self.payType = dict["PayType"] as! String
                }
                if dict.keys.contains("ScalingGroupActiveStatus") && dict["ScalingGroupActiveStatus"] != nil {
                    self.scalingGroupActiveStatus = dict["ScalingGroupActiveStatus"] as! String
                }
                if dict.keys.contains("ScalingGroupBizId") && dict["ScalingGroupBizId"] != nil {
                    self.scalingGroupBizId = dict["ScalingGroupBizId"] as! String
                }
                if dict.keys.contains("ScalingGroupConfigState") && dict["ScalingGroupConfigState"] != nil {
                    self.scalingGroupConfigState = dict["ScalingGroupConfigState"] as! String
                }
                if dict.keys.contains("ScalingGroupMaxNode") && dict["ScalingGroupMaxNode"] != nil {
                    self.scalingGroupMaxNode = dict["ScalingGroupMaxNode"] as! Int32
                }
                if dict.keys.contains("ScalingGroupMinNode") && dict["ScalingGroupMinNode"] != nil {
                    self.scalingGroupMinNode = dict["ScalingGroupMinNode"] as! Int32
                }
                if dict.keys.contains("ScalingInMode") && dict["ScalingInMode"] != nil {
                    self.scalingInMode = dict["ScalingInMode"] as! String
                }
                if dict.keys.contains("SecurityGroupId") && dict["SecurityGroupId"] != nil {
                    self.securityGroupId = dict["SecurityGroupId"] as! String
                }
                if dict.keys.contains("Status") && dict["Status"] != nil {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("SystemDiskCount") && dict["SystemDiskCount"] != nil {
                    self.systemDiskCount = dict["SystemDiskCount"] as! Int32
                }
                if dict.keys.contains("SystemDiskSize") && dict["SystemDiskSize"] != nil {
                    self.systemDiskSize = dict["SystemDiskSize"] as! Int32
                }
                if dict.keys.contains("SystemDiskType") && dict["SystemDiskType"] != nil {
                    self.systemDiskType = dict["SystemDiskType"] as! String
                }
                if dict.keys.contains("VswitchId") && dict["VswitchId"] != nil {
                    self.vswitchId = dict["VswitchId"] as! String
                }
                if dict.keys.contains("gmtCreate") && dict["gmtCreate"] != nil {
                    self.gmtCreate = dict["gmtCreate"] as! String
                }
                if dict.keys.contains("gmtModified") && dict["gmtModified"] != nil {
                    self.gmtModified = dict["gmtModified"] as! String
                }
            }
        }
        public var hostGroup: [ListClusterHostGroupResponseBody.HostGroupList.HostGroup]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.hostGroup != nil {
                var tmp : [Any] = []
                for k in self.hostGroup! {
                    tmp.append(k.toMap())
                }
                map["HostGroup"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("HostGroup") && dict["HostGroup"] != nil {
                var tmp : [ListClusterHostGroupResponseBody.HostGroupList.HostGroup] = []
                for v in dict["HostGroup"] as! [Any] {
                    var model = ListClusterHostGroupResponseBody.HostGroupList.HostGroup()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.hostGroup = tmp
            }
        }
    }
    public var clusterId: String?

    public var hostGroupList: ListClusterHostGroupResponseBody.HostGroupList?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var total: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.hostGroupList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.hostGroupList != nil {
            map["HostGroupList"] = self.hostGroupList?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.total != nil {
            map["Total"] = self.total!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("HostGroupList") && dict["HostGroupList"] != nil {
            var model = ListClusterHostGroupResponseBody.HostGroupList()
            model.fromMap(dict["HostGroupList"] as! [String: Any])
            self.hostGroupList = model
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Total") && dict["Total"] != nil {
            self.total = dict["Total"] as! Int32
        }
    }
}

public class ListClusterHostGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListClusterHostGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListClusterHostGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListClusterInstalledServiceRequest : Tea.TeaModel {
    public var clusterId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") && dict["ResourceOwnerId"] != nil {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class ListClusterInstalledServiceResponseBody : Tea.TeaModel {
    public class ClusterInstalledServiceList : Tea.TeaModel {
        public class ClusterInstalledService : Tea.TeaModel {
            public class ServiceActionList : Tea.TeaModel {
                public class ServiceAction : Tea.TeaModel {
                    public var actionName: String?

                    public var command: String?

                    public var componentName: String?

                    public var displayName: String?

                    public var serviceName: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.actionName != nil {
                            map["ActionName"] = self.actionName!
                        }
                        if self.command != nil {
                            map["Command"] = self.command!
                        }
                        if self.componentName != nil {
                            map["ComponentName"] = self.componentName!
                        }
                        if self.displayName != nil {
                            map["DisplayName"] = self.displayName!
                        }
                        if self.serviceName != nil {
                            map["ServiceName"] = self.serviceName!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("ActionName") && dict["ActionName"] != nil {
                            self.actionName = dict["ActionName"] as! String
                        }
                        if dict.keys.contains("Command") && dict["Command"] != nil {
                            self.command = dict["Command"] as! String
                        }
                        if dict.keys.contains("ComponentName") && dict["ComponentName"] != nil {
                            self.componentName = dict["ComponentName"] as! String
                        }
                        if dict.keys.contains("DisplayName") && dict["DisplayName"] != nil {
                            self.displayName = dict["DisplayName"] as! String
                        }
                        if dict.keys.contains("ServiceName") && dict["ServiceName"] != nil {
                            self.serviceName = dict["ServiceName"] as! String
                        }
                    }
                }
                public var serviceAction: [ListClusterInstalledServiceResponseBody.ClusterInstalledServiceList.ClusterInstalledService.ServiceActionList.ServiceAction]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.serviceAction != nil {
                        var tmp : [Any] = []
                        for k in self.serviceAction! {
                            tmp.append(k.toMap())
                        }
                        map["ServiceAction"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ServiceAction") && dict["ServiceAction"] != nil {
                        var tmp : [ListClusterInstalledServiceResponseBody.ClusterInstalledServiceList.ClusterInstalledService.ServiceActionList.ServiceAction] = []
                        for v in dict["ServiceAction"] as! [Any] {
                            var model = ListClusterInstalledServiceResponseBody.ClusterInstalledServiceList.ClusterInstalledService.ServiceActionList.ServiceAction()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.serviceAction = tmp
                    }
                }
            }
            public var serviceActionList: ListClusterInstalledServiceResponseBody.ClusterInstalledServiceList.ClusterInstalledService.ServiceActionList?

            public var serviceDisplayName: String?

            public var serviceEcmVersion: String?

            public var serviceName: String?

            public var serviceVersion: String?

            public var state: String?

            public var abnormalNum: Int32?

            public var comment: String?

            public var needRestartNum: Int32?

            public var notStartedNum: Int32?

            public var onlyClient: Bool?

            public var serviceStatus: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.serviceActionList?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.serviceActionList != nil {
                    map["ServiceActionList"] = self.serviceActionList?.toMap()
                }
                if self.serviceDisplayName != nil {
                    map["ServiceDisplayName"] = self.serviceDisplayName!
                }
                if self.serviceEcmVersion != nil {
                    map["ServiceEcmVersion"] = self.serviceEcmVersion!
                }
                if self.serviceName != nil {
                    map["ServiceName"] = self.serviceName!
                }
                if self.serviceVersion != nil {
                    map["ServiceVersion"] = self.serviceVersion!
                }
                if self.state != nil {
                    map["State"] = self.state!
                }
                if self.abnormalNum != nil {
                    map["abnormalNum"] = self.abnormalNum!
                }
                if self.comment != nil {
                    map["comment"] = self.comment!
                }
                if self.needRestartNum != nil {
                    map["needRestartNum"] = self.needRestartNum!
                }
                if self.notStartedNum != nil {
                    map["notStartedNum"] = self.notStartedNum!
                }
                if self.onlyClient != nil {
                    map["onlyClient"] = self.onlyClient!
                }
                if self.serviceStatus != nil {
                    map["serviceStatus"] = self.serviceStatus!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ServiceActionList") && dict["ServiceActionList"] != nil {
                    var model = ListClusterInstalledServiceResponseBody.ClusterInstalledServiceList.ClusterInstalledService.ServiceActionList()
                    model.fromMap(dict["ServiceActionList"] as! [String: Any])
                    self.serviceActionList = model
                }
                if dict.keys.contains("ServiceDisplayName") && dict["ServiceDisplayName"] != nil {
                    self.serviceDisplayName = dict["ServiceDisplayName"] as! String
                }
                if dict.keys.contains("ServiceEcmVersion") && dict["ServiceEcmVersion"] != nil {
                    self.serviceEcmVersion = dict["ServiceEcmVersion"] as! String
                }
                if dict.keys.contains("ServiceName") && dict["ServiceName"] != nil {
                    self.serviceName = dict["ServiceName"] as! String
                }
                if dict.keys.contains("ServiceVersion") && dict["ServiceVersion"] != nil {
                    self.serviceVersion = dict["ServiceVersion"] as! String
                }
                if dict.keys.contains("State") && dict["State"] != nil {
                    self.state = dict["State"] as! String
                }
                if dict.keys.contains("abnormalNum") && dict["abnormalNum"] != nil {
                    self.abnormalNum = dict["abnormalNum"] as! Int32
                }
                if dict.keys.contains("comment") && dict["comment"] != nil {
                    self.comment = dict["comment"] as! String
                }
                if dict.keys.contains("needRestartNum") && dict["needRestartNum"] != nil {
                    self.needRestartNum = dict["needRestartNum"] as! Int32
                }
                if dict.keys.contains("notStartedNum") && dict["notStartedNum"] != nil {
                    self.notStartedNum = dict["notStartedNum"] as! Int32
                }
                if dict.keys.contains("onlyClient") && dict["onlyClient"] != nil {
                    self.onlyClient = dict["onlyClient"] as! Bool
                }
                if dict.keys.contains("serviceStatus") && dict["serviceStatus"] != nil {
                    self.serviceStatus = dict["serviceStatus"] as! String
                }
            }
        }
        public var clusterInstalledService: [ListClusterInstalledServiceResponseBody.ClusterInstalledServiceList.ClusterInstalledService]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.clusterInstalledService != nil {
                var tmp : [Any] = []
                for k in self.clusterInstalledService! {
                    tmp.append(k.toMap())
                }
                map["ClusterInstalledService"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ClusterInstalledService") && dict["ClusterInstalledService"] != nil {
                var tmp : [ListClusterInstalledServiceResponseBody.ClusterInstalledServiceList.ClusterInstalledService] = []
                for v in dict["ClusterInstalledService"] as! [Any] {
                    var model = ListClusterInstalledServiceResponseBody.ClusterInstalledServiceList.ClusterInstalledService()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.clusterInstalledService = tmp
            }
        }
    }
    public var clusterInstalledServiceList: ListClusterInstalledServiceResponseBody.ClusterInstalledServiceList?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.clusterInstalledServiceList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterInstalledServiceList != nil {
            map["ClusterInstalledServiceList"] = self.clusterInstalledServiceList?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterInstalledServiceList") && dict["ClusterInstalledServiceList"] != nil {
            var model = ListClusterInstalledServiceResponseBody.ClusterInstalledServiceList()
            model.fromMap(dict["ClusterInstalledServiceList"] as! [String: Any])
            self.clusterInstalledServiceList = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListClusterInstalledServiceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListClusterInstalledServiceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListClusterInstalledServiceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListClusterOperationRequest : Tea.TeaModel {
    public var clusterId: String?

    public var operationId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceOwnerId: Int64?

    public var serviceName: String?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.operationId != nil {
            map["OperationId"] = self.operationId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.serviceName != nil {
            map["ServiceName"] = self.serviceName!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("OperationId") && dict["OperationId"] != nil {
            self.operationId = dict["OperationId"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") && dict["ResourceOwnerId"] != nil {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("ServiceName") && dict["ServiceName"] != nil {
            self.serviceName = dict["ServiceName"] as! String
        }
        if dict.keys.contains("Status") && dict["Status"] != nil {
            self.status = dict["Status"] as! String
        }
    }
}

public class ListClusterOperationResponseBody : Tea.TeaModel {
    public class ClusterOperationList : Tea.TeaModel {
        public class ClusterOperation : Tea.TeaModel {
            public var comment: String?

            public var duration: String?

            public var operationId: String?

            public var operationName: String?

            public var percentage: String?

            public var startTime: String?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.comment != nil {
                    map["Comment"] = self.comment!
                }
                if self.duration != nil {
                    map["Duration"] = self.duration!
                }
                if self.operationId != nil {
                    map["OperationId"] = self.operationId!
                }
                if self.operationName != nil {
                    map["OperationName"] = self.operationName!
                }
                if self.percentage != nil {
                    map["Percentage"] = self.percentage!
                }
                if self.startTime != nil {
                    map["StartTime"] = self.startTime!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Comment") && dict["Comment"] != nil {
                    self.comment = dict["Comment"] as! String
                }
                if dict.keys.contains("Duration") && dict["Duration"] != nil {
                    self.duration = dict["Duration"] as! String
                }
                if dict.keys.contains("OperationId") && dict["OperationId"] != nil {
                    self.operationId = dict["OperationId"] as! String
                }
                if dict.keys.contains("OperationName") && dict["OperationName"] != nil {
                    self.operationName = dict["OperationName"] as! String
                }
                if dict.keys.contains("Percentage") && dict["Percentage"] != nil {
                    self.percentage = dict["Percentage"] as! String
                }
                if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
                    self.startTime = dict["StartTime"] as! String
                }
                if dict.keys.contains("Status") && dict["Status"] != nil {
                    self.status = dict["Status"] as! String
                }
            }
        }
        public var clusterOperation: [ListClusterOperationResponseBody.ClusterOperationList.ClusterOperation]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.clusterOperation != nil {
                var tmp : [Any] = []
                for k in self.clusterOperation! {
                    tmp.append(k.toMap())
                }
                map["ClusterOperation"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ClusterOperation") && dict["ClusterOperation"] != nil {
                var tmp : [ListClusterOperationResponseBody.ClusterOperationList.ClusterOperation] = []
                for v in dict["ClusterOperation"] as! [Any] {
                    var model = ListClusterOperationResponseBody.ClusterOperationList.ClusterOperation()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.clusterOperation = tmp
            }
        }
    }
    public var clusterOperationList: ListClusterOperationResponseBody.ClusterOperationList?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.clusterOperationList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterOperationList != nil {
            map["ClusterOperationList"] = self.clusterOperationList?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterOperationList") && dict["ClusterOperationList"] != nil {
            var model = ListClusterOperationResponseBody.ClusterOperationList()
            model.fromMap(dict["ClusterOperationList"] as! [String: Any])
            self.clusterOperationList = model
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class ListClusterOperationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListClusterOperationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListClusterOperationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListClusterOperationHostRequest : Tea.TeaModel {
    public var clusterId: String?

    public var operationId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceOwnerId: Int64?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.operationId != nil {
            map["OperationId"] = self.operationId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("OperationId") && dict["OperationId"] != nil {
            self.operationId = dict["OperationId"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") && dict["ResourceOwnerId"] != nil {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("Status") && dict["Status"] != nil {
            self.status = dict["Status"] as! String
        }
    }
}

public class ListClusterOperationHostResponseBody : Tea.TeaModel {
    public class ClusterOperationHostList : Tea.TeaModel {
        public class ClusterOperationHost : Tea.TeaModel {
            public var hostId: String?

            public var hostName: String?

            public var percentage: String?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.hostId != nil {
                    map["HostId"] = self.hostId!
                }
                if self.hostName != nil {
                    map["HostName"] = self.hostName!
                }
                if self.percentage != nil {
                    map["Percentage"] = self.percentage!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("HostId") && dict["HostId"] != nil {
                    self.hostId = dict["HostId"] as! String
                }
                if dict.keys.contains("HostName") && dict["HostName"] != nil {
                    self.hostName = dict["HostName"] as! String
                }
                if dict.keys.contains("Percentage") && dict["Percentage"] != nil {
                    self.percentage = dict["Percentage"] as! String
                }
                if dict.keys.contains("Status") && dict["Status"] != nil {
                    self.status = dict["Status"] as! String
                }
            }
        }
        public var clusterOperationHost: [ListClusterOperationHostResponseBody.ClusterOperationHostList.ClusterOperationHost]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.clusterOperationHost != nil {
                var tmp : [Any] = []
                for k in self.clusterOperationHost! {
                    tmp.append(k.toMap())
                }
                map["ClusterOperationHost"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ClusterOperationHost") && dict["ClusterOperationHost"] != nil {
                var tmp : [ListClusterOperationHostResponseBody.ClusterOperationHostList.ClusterOperationHost] = []
                for v in dict["ClusterOperationHost"] as! [Any] {
                    var model = ListClusterOperationHostResponseBody.ClusterOperationHostList.ClusterOperationHost()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.clusterOperationHost = tmp
            }
        }
    }
    public var clusterOperationHostList: ListClusterOperationHostResponseBody.ClusterOperationHostList?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.clusterOperationHostList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterOperationHostList != nil {
            map["ClusterOperationHostList"] = self.clusterOperationHostList?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterOperationHostList") && dict["ClusterOperationHostList"] != nil {
            var model = ListClusterOperationHostResponseBody.ClusterOperationHostList()
            model.fromMap(dict["ClusterOperationHostList"] as! [String: Any])
            self.clusterOperationHostList = model
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class ListClusterOperationHostResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListClusterOperationHostResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListClusterOperationHostResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListClusterOperationHostTaskRequest : Tea.TeaModel {
    public var clusterId: String?

    public var hostId: String?

    public var operationId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceOwnerId: Int64?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.hostId != nil {
            map["HostId"] = self.hostId!
        }
        if self.operationId != nil {
            map["OperationId"] = self.operationId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("HostId") && dict["HostId"] != nil {
            self.hostId = dict["HostId"] as! String
        }
        if dict.keys.contains("OperationId") && dict["OperationId"] != nil {
            self.operationId = dict["OperationId"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") && dict["ResourceOwnerId"] != nil {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("Status") && dict["Status"] != nil {
            self.status = dict["Status"] as! String
        }
    }
}

public class ListClusterOperationHostTaskResponseBody : Tea.TeaModel {
    public class ClusterOperationHostTaskList : Tea.TeaModel {
        public class ClusterOperationHostTask : Tea.TeaModel {
            public var percentage: String?

            public var status: String?

            public var taskId: String?

            public var taskName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.percentage != nil {
                    map["Percentage"] = self.percentage!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.taskId != nil {
                    map["TaskId"] = self.taskId!
                }
                if self.taskName != nil {
                    map["TaskName"] = self.taskName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Percentage") && dict["Percentage"] != nil {
                    self.percentage = dict["Percentage"] as! String
                }
                if dict.keys.contains("Status") && dict["Status"] != nil {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("TaskId") && dict["TaskId"] != nil {
                    self.taskId = dict["TaskId"] as! String
                }
                if dict.keys.contains("TaskName") && dict["TaskName"] != nil {
                    self.taskName = dict["TaskName"] as! String
                }
            }
        }
        public var clusterOperationHostTask: [ListClusterOperationHostTaskResponseBody.ClusterOperationHostTaskList.ClusterOperationHostTask]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.clusterOperationHostTask != nil {
                var tmp : [Any] = []
                for k in self.clusterOperationHostTask! {
                    tmp.append(k.toMap())
                }
                map["ClusterOperationHostTask"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ClusterOperationHostTask") && dict["ClusterOperationHostTask"] != nil {
                var tmp : [ListClusterOperationHostTaskResponseBody.ClusterOperationHostTaskList.ClusterOperationHostTask] = []
                for v in dict["ClusterOperationHostTask"] as! [Any] {
                    var model = ListClusterOperationHostTaskResponseBody.ClusterOperationHostTaskList.ClusterOperationHostTask()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.clusterOperationHostTask = tmp
            }
        }
    }
    public var clusterOperationHostTaskList: ListClusterOperationHostTaskResponseBody.ClusterOperationHostTaskList?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.clusterOperationHostTaskList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterOperationHostTaskList != nil {
            map["ClusterOperationHostTaskList"] = self.clusterOperationHostTaskList?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterOperationHostTaskList") && dict["ClusterOperationHostTaskList"] != nil {
            var model = ListClusterOperationHostTaskResponseBody.ClusterOperationHostTaskList()
            model.fromMap(dict["ClusterOperationHostTaskList"] as! [String: Any])
            self.clusterOperationHostTaskList = model
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class ListClusterOperationHostTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListClusterOperationHostTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListClusterOperationHostTaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListClusterOperationTaskRequest : Tea.TeaModel {
    public var clusterId: String?

    public var operationId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceOwnerId: Int64?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.operationId != nil {
            map["OperationId"] = self.operationId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("OperationId") && dict["OperationId"] != nil {
            self.operationId = dict["OperationId"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") && dict["ResourceOwnerId"] != nil {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("Status") && dict["Status"] != nil {
            self.status = dict["Status"] as! String
        }
    }
}

public class ListClusterOperationTaskResponseBody : Tea.TeaModel {
    public class ClusterOperationTaskList : Tea.TeaModel {
        public class ClusterOperationTask : Tea.TeaModel {
            public var percentage: String?

            public var status: String?

            public var taskId: String?

            public var taskName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.percentage != nil {
                    map["Percentage"] = self.percentage!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.taskId != nil {
                    map["TaskId"] = self.taskId!
                }
                if self.taskName != nil {
                    map["TaskName"] = self.taskName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Percentage") && dict["Percentage"] != nil {
                    self.percentage = dict["Percentage"] as! String
                }
                if dict.keys.contains("Status") && dict["Status"] != nil {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("TaskId") && dict["TaskId"] != nil {
                    self.taskId = dict["TaskId"] as! String
                }
                if dict.keys.contains("TaskName") && dict["TaskName"] != nil {
                    self.taskName = dict["TaskName"] as! String
                }
            }
        }
        public var clusterOperationTask: [ListClusterOperationTaskResponseBody.ClusterOperationTaskList.ClusterOperationTask]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.clusterOperationTask != nil {
                var tmp : [Any] = []
                for k in self.clusterOperationTask! {
                    tmp.append(k.toMap())
                }
                map["ClusterOperationTask"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ClusterOperationTask") && dict["ClusterOperationTask"] != nil {
                var tmp : [ListClusterOperationTaskResponseBody.ClusterOperationTaskList.ClusterOperationTask] = []
                for v in dict["ClusterOperationTask"] as! [Any] {
                    var model = ListClusterOperationTaskResponseBody.ClusterOperationTaskList.ClusterOperationTask()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.clusterOperationTask = tmp
            }
        }
    }
    public var clusterOperationTaskList: ListClusterOperationTaskResponseBody.ClusterOperationTaskList?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.clusterOperationTaskList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterOperationTaskList != nil {
            map["ClusterOperationTaskList"] = self.clusterOperationTaskList?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterOperationTaskList") && dict["ClusterOperationTaskList"] != nil {
            var model = ListClusterOperationTaskResponseBody.ClusterOperationTaskList()
            model.fromMap(dict["ClusterOperationTaskList"] as! [String: Any])
            self.clusterOperationTaskList = model
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class ListClusterOperationTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListClusterOperationTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListClusterOperationTaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListClusterServiceRequest : Tea.TeaModel {
    public var clusterId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") && dict["ResourceOwnerId"] != nil {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class ListClusterServiceResponseBody : Tea.TeaModel {
    public class ClusterServiceList : Tea.TeaModel {
        public class ClusterService : Tea.TeaModel {
            public class ServiceActionList : Tea.TeaModel {
                public class ServiceAction : Tea.TeaModel {
                    public var actionName: String?

                    public var command: String?

                    public var componentName: String?

                    public var displayName: String?

                    public var serviceName: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.actionName != nil {
                            map["ActionName"] = self.actionName!
                        }
                        if self.command != nil {
                            map["Command"] = self.command!
                        }
                        if self.componentName != nil {
                            map["ComponentName"] = self.componentName!
                        }
                        if self.displayName != nil {
                            map["DisplayName"] = self.displayName!
                        }
                        if self.serviceName != nil {
                            map["ServiceName"] = self.serviceName!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("ActionName") && dict["ActionName"] != nil {
                            self.actionName = dict["ActionName"] as! String
                        }
                        if dict.keys.contains("Command") && dict["Command"] != nil {
                            self.command = dict["Command"] as! String
                        }
                        if dict.keys.contains("ComponentName") && dict["ComponentName"] != nil {
                            self.componentName = dict["ComponentName"] as! String
                        }
                        if dict.keys.contains("DisplayName") && dict["DisplayName"] != nil {
                            self.displayName = dict["DisplayName"] as! String
                        }
                        if dict.keys.contains("ServiceName") && dict["ServiceName"] != nil {
                            self.serviceName = dict["ServiceName"] as! String
                        }
                    }
                }
                public var serviceAction: [ListClusterServiceResponseBody.ClusterServiceList.ClusterService.ServiceActionList.ServiceAction]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.serviceAction != nil {
                        var tmp : [Any] = []
                        for k in self.serviceAction! {
                            tmp.append(k.toMap())
                        }
                        map["ServiceAction"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ServiceAction") && dict["ServiceAction"] != nil {
                        var tmp : [ListClusterServiceResponseBody.ClusterServiceList.ClusterService.ServiceActionList.ServiceAction] = []
                        for v in dict["ServiceAction"] as! [Any] {
                            var model = ListClusterServiceResponseBody.ClusterServiceList.ClusterService.ServiceActionList.ServiceAction()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.serviceAction = tmp
                    }
                }
            }
            public var abnormalNum: Int32?

            public var clientType: Bool?

            public var healthStatus: String?

            public var installStatus: Bool?

            public var needRestartInfo: String?

            public var needRestartNum: Int32?

            public var notStartInfo: String?

            public var serviceActionList: ListClusterServiceResponseBody.ClusterServiceList.ClusterService.ServiceActionList?

            public var serviceDisplayName: String?

            public var serviceName: String?

            public var serviceStatus: String?

            public var serviceVersion: String?

            public var state: String?

            public var stoppedNum: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.serviceActionList?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.abnormalNum != nil {
                    map["AbnormalNum"] = self.abnormalNum!
                }
                if self.clientType != nil {
                    map["ClientType"] = self.clientType!
                }
                if self.healthStatus != nil {
                    map["HealthStatus"] = self.healthStatus!
                }
                if self.installStatus != nil {
                    map["InstallStatus"] = self.installStatus!
                }
                if self.needRestartInfo != nil {
                    map["NeedRestartInfo"] = self.needRestartInfo!
                }
                if self.needRestartNum != nil {
                    map["NeedRestartNum"] = self.needRestartNum!
                }
                if self.notStartInfo != nil {
                    map["NotStartInfo"] = self.notStartInfo!
                }
                if self.serviceActionList != nil {
                    map["ServiceActionList"] = self.serviceActionList?.toMap()
                }
                if self.serviceDisplayName != nil {
                    map["ServiceDisplayName"] = self.serviceDisplayName!
                }
                if self.serviceName != nil {
                    map["ServiceName"] = self.serviceName!
                }
                if self.serviceStatus != nil {
                    map["ServiceStatus"] = self.serviceStatus!
                }
                if self.serviceVersion != nil {
                    map["ServiceVersion"] = self.serviceVersion!
                }
                if self.state != nil {
                    map["State"] = self.state!
                }
                if self.stoppedNum != nil {
                    map["StoppedNum"] = self.stoppedNum!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AbnormalNum") && dict["AbnormalNum"] != nil {
                    self.abnormalNum = dict["AbnormalNum"] as! Int32
                }
                if dict.keys.contains("ClientType") && dict["ClientType"] != nil {
                    self.clientType = dict["ClientType"] as! Bool
                }
                if dict.keys.contains("HealthStatus") && dict["HealthStatus"] != nil {
                    self.healthStatus = dict["HealthStatus"] as! String
                }
                if dict.keys.contains("InstallStatus") && dict["InstallStatus"] != nil {
                    self.installStatus = dict["InstallStatus"] as! Bool
                }
                if dict.keys.contains("NeedRestartInfo") && dict["NeedRestartInfo"] != nil {
                    self.needRestartInfo = dict["NeedRestartInfo"] as! String
                }
                if dict.keys.contains("NeedRestartNum") && dict["NeedRestartNum"] != nil {
                    self.needRestartNum = dict["NeedRestartNum"] as! Int32
                }
                if dict.keys.contains("NotStartInfo") && dict["NotStartInfo"] != nil {
                    self.notStartInfo = dict["NotStartInfo"] as! String
                }
                if dict.keys.contains("ServiceActionList") && dict["ServiceActionList"] != nil {
                    var model = ListClusterServiceResponseBody.ClusterServiceList.ClusterService.ServiceActionList()
                    model.fromMap(dict["ServiceActionList"] as! [String: Any])
                    self.serviceActionList = model
                }
                if dict.keys.contains("ServiceDisplayName") && dict["ServiceDisplayName"] != nil {
                    self.serviceDisplayName = dict["ServiceDisplayName"] as! String
                }
                if dict.keys.contains("ServiceName") && dict["ServiceName"] != nil {
                    self.serviceName = dict["ServiceName"] as! String
                }
                if dict.keys.contains("ServiceStatus") && dict["ServiceStatus"] != nil {
                    self.serviceStatus = dict["ServiceStatus"] as! String
                }
                if dict.keys.contains("ServiceVersion") && dict["ServiceVersion"] != nil {
                    self.serviceVersion = dict["ServiceVersion"] as! String
                }
                if dict.keys.contains("State") && dict["State"] != nil {
                    self.state = dict["State"] as! String
                }
                if dict.keys.contains("StoppedNum") && dict["StoppedNum"] != nil {
                    self.stoppedNum = dict["StoppedNum"] as! Int32
                }
            }
        }
        public var clusterService: [ListClusterServiceResponseBody.ClusterServiceList.ClusterService]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.clusterService != nil {
                var tmp : [Any] = []
                for k in self.clusterService! {
                    tmp.append(k.toMap())
                }
                map["ClusterService"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ClusterService") && dict["ClusterService"] != nil {
                var tmp : [ListClusterServiceResponseBody.ClusterServiceList.ClusterService] = []
                for v in dict["ClusterService"] as! [Any] {
                    var model = ListClusterServiceResponseBody.ClusterServiceList.ClusterService()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.clusterService = tmp
            }
        }
    }
    public var clusterServiceList: ListClusterServiceResponseBody.ClusterServiceList?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.clusterServiceList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterServiceList != nil {
            map["ClusterServiceList"] = self.clusterServiceList?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterServiceList") && dict["ClusterServiceList"] != nil {
            var model = ListClusterServiceResponseBody.ClusterServiceList()
            model.fromMap(dict["ClusterServiceList"] as! [String: Any])
            self.clusterServiceList = model
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class ListClusterServiceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListClusterServiceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListClusterServiceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListClusterServiceComponentHealthInfoRequest : Tea.TeaModel {
    public var clusterId: String?

    public var componentName: String?

    public var regionId: String?

    public var resourceOwnerId: Int64?

    public var serviceName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.componentName != nil {
            map["ComponentName"] = self.componentName!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.serviceName != nil {
            map["ServiceName"] = self.serviceName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("ComponentName") && dict["ComponentName"] != nil {
            self.componentName = dict["ComponentName"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") && dict["ResourceOwnerId"] != nil {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("ServiceName") && dict["ServiceName"] != nil {
            self.serviceName = dict["ServiceName"] as! String
        }
    }
}

public class ListClusterServiceComponentHealthInfoResponseBody : Tea.TeaModel {
    public class HealthInfoList : Tea.TeaModel {
        public class HealthInfo : Tea.TeaModel {
            public class HealthDetailList : Tea.TeaModel {
                public class HealthDetail : Tea.TeaModel {
                    public class HealthRuleParam : Tea.TeaModel {
                        public var component: String?

                        public var hostNames: String?

                        public var pass: String?

                        public var ruleDescription: String?

                        public var ruleId: String?

                        public var ruleTitle: String?

                        public var service: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.component != nil {
                                map["Component"] = self.component!
                            }
                            if self.hostNames != nil {
                                map["HostNames"] = self.hostNames!
                            }
                            if self.pass != nil {
                                map["Pass"] = self.pass!
                            }
                            if self.ruleDescription != nil {
                                map["RuleDescription"] = self.ruleDescription!
                            }
                            if self.ruleId != nil {
                                map["RuleId"] = self.ruleId!
                            }
                            if self.ruleTitle != nil {
                                map["RuleTitle"] = self.ruleTitle!
                            }
                            if self.service != nil {
                                map["Service"] = self.service!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Component") && dict["Component"] != nil {
                                self.component = dict["Component"] as! String
                            }
                            if dict.keys.contains("HostNames") && dict["HostNames"] != nil {
                                self.hostNames = dict["HostNames"] as! String
                            }
                            if dict.keys.contains("Pass") && dict["Pass"] != nil {
                                self.pass = dict["Pass"] as! String
                            }
                            if dict.keys.contains("RuleDescription") && dict["RuleDescription"] != nil {
                                self.ruleDescription = dict["RuleDescription"] as! String
                            }
                            if dict.keys.contains("RuleId") && dict["RuleId"] != nil {
                                self.ruleId = dict["RuleId"] as! String
                            }
                            if dict.keys.contains("RuleTitle") && dict["RuleTitle"] != nil {
                                self.ruleTitle = dict["RuleTitle"] as! String
                            }
                            if dict.keys.contains("Service") && dict["Service"] != nil {
                                self.service = dict["Service"] as! String
                            }
                        }
                    }
                    public var healthRuleParam: ListClusterServiceComponentHealthInfoResponseBody.HealthInfoList.HealthInfo.HealthDetailList.HealthDetail.HealthRuleParam?

                    public var code: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.healthRuleParam?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.healthRuleParam != nil {
                            map["HealthRuleParam"] = self.healthRuleParam?.toMap()
                        }
                        if self.code != nil {
                            map["code"] = self.code!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("HealthRuleParam") && dict["HealthRuleParam"] != nil {
                            var model = ListClusterServiceComponentHealthInfoResponseBody.HealthInfoList.HealthInfo.HealthDetailList.HealthDetail.HealthRuleParam()
                            model.fromMap(dict["HealthRuleParam"] as! [String: Any])
                            self.healthRuleParam = model
                        }
                        if dict.keys.contains("code") && dict["code"] != nil {
                            self.code = dict["code"] as! String
                        }
                    }
                }
                public var healthDetail: [ListClusterServiceComponentHealthInfoResponseBody.HealthInfoList.HealthInfo.HealthDetailList.HealthDetail]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.healthDetail != nil {
                        var tmp : [Any] = []
                        for k in self.healthDetail! {
                            tmp.append(k.toMap())
                        }
                        map["HealthDetail"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("HealthDetail") && dict["HealthDetail"] != nil {
                        var tmp : [ListClusterServiceComponentHealthInfoResponseBody.HealthInfoList.HealthInfo.HealthDetailList.HealthDetail] = []
                        for v in dict["HealthDetail"] as! [Any] {
                            var model = ListClusterServiceComponentHealthInfoResponseBody.HealthInfoList.HealthInfo.HealthDetailList.HealthDetail()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.healthDetail = tmp
                    }
                }
            }
            public var agentHeartBeatLostNum: Int32?

            public var badHealthNum: Int32?

            public var componentName: String?

            public var createdTime: Int64?

            public var disabledHealthNum: Int32?

            public var goodHealthNum: Int32?

            public var healthDetailList: ListClusterServiceComponentHealthInfoResponseBody.HealthInfoList.HealthInfo.HealthDetailList?

            public var healthLevel: String?

            public var healthStatus: String?

            public var manualStoppedNum: Int32?

            public var noneHealthNum: Int32?

            public var normalNum: Int32?

            public var serviceName: String?

            public var stoppedHealthNum: Int32?

            public var stoppedNum: Int32?

            public var totalNum: Int32?

            public var unknownHealthNum: Int32?

            public var warningHealthNum: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.healthDetailList?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.agentHeartBeatLostNum != nil {
                    map["AgentHeartBeatLostNum"] = self.agentHeartBeatLostNum!
                }
                if self.badHealthNum != nil {
                    map["BadHealthNum"] = self.badHealthNum!
                }
                if self.componentName != nil {
                    map["ComponentName"] = self.componentName!
                }
                if self.createdTime != nil {
                    map["CreatedTime"] = self.createdTime!
                }
                if self.disabledHealthNum != nil {
                    map["DisabledHealthNum"] = self.disabledHealthNum!
                }
                if self.goodHealthNum != nil {
                    map["GoodHealthNum"] = self.goodHealthNum!
                }
                if self.healthDetailList != nil {
                    map["HealthDetailList"] = self.healthDetailList?.toMap()
                }
                if self.healthLevel != nil {
                    map["HealthLevel"] = self.healthLevel!
                }
                if self.healthStatus != nil {
                    map["HealthStatus"] = self.healthStatus!
                }
                if self.manualStoppedNum != nil {
                    map["ManualStoppedNum"] = self.manualStoppedNum!
                }
                if self.noneHealthNum != nil {
                    map["NoneHealthNum"] = self.noneHealthNum!
                }
                if self.normalNum != nil {
                    map["NormalNum"] = self.normalNum!
                }
                if self.serviceName != nil {
                    map["ServiceName"] = self.serviceName!
                }
                if self.stoppedHealthNum != nil {
                    map["StoppedHealthNum"] = self.stoppedHealthNum!
                }
                if self.stoppedNum != nil {
                    map["StoppedNum"] = self.stoppedNum!
                }
                if self.totalNum != nil {
                    map["TotalNum"] = self.totalNum!
                }
                if self.unknownHealthNum != nil {
                    map["UnknownHealthNum"] = self.unknownHealthNum!
                }
                if self.warningHealthNum != nil {
                    map["WarningHealthNum"] = self.warningHealthNum!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AgentHeartBeatLostNum") && dict["AgentHeartBeatLostNum"] != nil {
                    self.agentHeartBeatLostNum = dict["AgentHeartBeatLostNum"] as! Int32
                }
                if dict.keys.contains("BadHealthNum") && dict["BadHealthNum"] != nil {
                    self.badHealthNum = dict["BadHealthNum"] as! Int32
                }
                if dict.keys.contains("ComponentName") && dict["ComponentName"] != nil {
                    self.componentName = dict["ComponentName"] as! String
                }
                if dict.keys.contains("CreatedTime") && dict["CreatedTime"] != nil {
                    self.createdTime = dict["CreatedTime"] as! Int64
                }
                if dict.keys.contains("DisabledHealthNum") && dict["DisabledHealthNum"] != nil {
                    self.disabledHealthNum = dict["DisabledHealthNum"] as! Int32
                }
                if dict.keys.contains("GoodHealthNum") && dict["GoodHealthNum"] != nil {
                    self.goodHealthNum = dict["GoodHealthNum"] as! Int32
                }
                if dict.keys.contains("HealthDetailList") && dict["HealthDetailList"] != nil {
                    var model = ListClusterServiceComponentHealthInfoResponseBody.HealthInfoList.HealthInfo.HealthDetailList()
                    model.fromMap(dict["HealthDetailList"] as! [String: Any])
                    self.healthDetailList = model
                }
                if dict.keys.contains("HealthLevel") && dict["HealthLevel"] != nil {
                    self.healthLevel = dict["HealthLevel"] as! String
                }
                if dict.keys.contains("HealthStatus") && dict["HealthStatus"] != nil {
                    self.healthStatus = dict["HealthStatus"] as! String
                }
                if dict.keys.contains("ManualStoppedNum") && dict["ManualStoppedNum"] != nil {
                    self.manualStoppedNum = dict["ManualStoppedNum"] as! Int32
                }
                if dict.keys.contains("NoneHealthNum") && dict["NoneHealthNum"] != nil {
                    self.noneHealthNum = dict["NoneHealthNum"] as! Int32
                }
                if dict.keys.contains("NormalNum") && dict["NormalNum"] != nil {
                    self.normalNum = dict["NormalNum"] as! Int32
                }
                if dict.keys.contains("ServiceName") && dict["ServiceName"] != nil {
                    self.serviceName = dict["ServiceName"] as! String
                }
                if dict.keys.contains("StoppedHealthNum") && dict["StoppedHealthNum"] != nil {
                    self.stoppedHealthNum = dict["StoppedHealthNum"] as! Int32
                }
                if dict.keys.contains("StoppedNum") && dict["StoppedNum"] != nil {
                    self.stoppedNum = dict["StoppedNum"] as! Int32
                }
                if dict.keys.contains("TotalNum") && dict["TotalNum"] != nil {
                    self.totalNum = dict["TotalNum"] as! Int32
                }
                if dict.keys.contains("UnknownHealthNum") && dict["UnknownHealthNum"] != nil {
                    self.unknownHealthNum = dict["UnknownHealthNum"] as! Int32
                }
                if dict.keys.contains("WarningHealthNum") && dict["WarningHealthNum"] != nil {
                    self.warningHealthNum = dict["WarningHealthNum"] as! Int32
                }
            }
        }
        public var healthInfo: [ListClusterServiceComponentHealthInfoResponseBody.HealthInfoList.HealthInfo]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.healthInfo != nil {
                var tmp : [Any] = []
                for k in self.healthInfo! {
                    tmp.append(k.toMap())
                }
                map["HealthInfo"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("HealthInfo") && dict["HealthInfo"] != nil {
                var tmp : [ListClusterServiceComponentHealthInfoResponseBody.HealthInfoList.HealthInfo] = []
                for v in dict["HealthInfo"] as! [Any] {
                    var model = ListClusterServiceComponentHealthInfoResponseBody.HealthInfoList.HealthInfo()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.healthInfo = tmp
            }
        }
    }
    public var clusterId: String?

    public var healthInfoList: ListClusterServiceComponentHealthInfoResponseBody.HealthInfoList?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.healthInfoList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.healthInfoList != nil {
            map["HealthInfoList"] = self.healthInfoList?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("HealthInfoList") && dict["HealthInfoList"] != nil {
            var model = ListClusterServiceComponentHealthInfoResponseBody.HealthInfoList()
            model.fromMap(dict["HealthInfoList"] as! [String: Any])
            self.healthInfoList = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListClusterServiceComponentHealthInfoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListClusterServiceComponentHealthInfoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListClusterServiceComponentHealthInfoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListClusterServiceConfigHistoryRequest : Tea.TeaModel {
    public var author: String?

    public var clusterId: String?

    public var comment: String?

    public var configFileName: String?

    public var configItemKey: String?

    public var configVersion: String?

    public var hostGroupId: String?

    public var hostInstanceId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceOwnerId: Int64?

    public var serviceName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.author != nil {
            map["Author"] = self.author!
        }
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.comment != nil {
            map["Comment"] = self.comment!
        }
        if self.configFileName != nil {
            map["ConfigFileName"] = self.configFileName!
        }
        if self.configItemKey != nil {
            map["ConfigItemKey"] = self.configItemKey!
        }
        if self.configVersion != nil {
            map["ConfigVersion"] = self.configVersion!
        }
        if self.hostGroupId != nil {
            map["HostGroupId"] = self.hostGroupId!
        }
        if self.hostInstanceId != nil {
            map["HostInstanceId"] = self.hostInstanceId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.serviceName != nil {
            map["ServiceName"] = self.serviceName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Author") && dict["Author"] != nil {
            self.author = dict["Author"] as! String
        }
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("Comment") && dict["Comment"] != nil {
            self.comment = dict["Comment"] as! String
        }
        if dict.keys.contains("ConfigFileName") && dict["ConfigFileName"] != nil {
            self.configFileName = dict["ConfigFileName"] as! String
        }
        if dict.keys.contains("ConfigItemKey") && dict["ConfigItemKey"] != nil {
            self.configItemKey = dict["ConfigItemKey"] as! String
        }
        if dict.keys.contains("ConfigVersion") && dict["ConfigVersion"] != nil {
            self.configVersion = dict["ConfigVersion"] as! String
        }
        if dict.keys.contains("HostGroupId") && dict["HostGroupId"] != nil {
            self.hostGroupId = dict["HostGroupId"] as! String
        }
        if dict.keys.contains("HostInstanceId") && dict["HostInstanceId"] != nil {
            self.hostInstanceId = dict["HostInstanceId"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") && dict["ResourceOwnerId"] != nil {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("ServiceName") && dict["ServiceName"] != nil {
            self.serviceName = dict["ServiceName"] as! String
        }
    }
}

public class ListClusterServiceConfigHistoryResponseBody : Tea.TeaModel {
    public class ConfigHistoryList : Tea.TeaModel {
        public class ConfigHistory : Tea.TeaModel {
            public var applied: Bool?

            public var author: String?

            public var comment: String?

            public var configFileName: String?

            public var configItemName: String?

            public var configVersion: String?

            public var createTime: Int64?

            public var hostGroupId: String?

            public var hostGroupName: String?

            public var hostInstanceId: String?

            public var hostName: String?

            public var newValue: String?

            public var oldValue: String?

            public var serviceName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.applied != nil {
                    map["Applied"] = self.applied!
                }
                if self.author != nil {
                    map["Author"] = self.author!
                }
                if self.comment != nil {
                    map["Comment"] = self.comment!
                }
                if self.configFileName != nil {
                    map["ConfigFileName"] = self.configFileName!
                }
                if self.configItemName != nil {
                    map["ConfigItemName"] = self.configItemName!
                }
                if self.configVersion != nil {
                    map["ConfigVersion"] = self.configVersion!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.hostGroupId != nil {
                    map["HostGroupId"] = self.hostGroupId!
                }
                if self.hostGroupName != nil {
                    map["HostGroupName"] = self.hostGroupName!
                }
                if self.hostInstanceId != nil {
                    map["HostInstanceId"] = self.hostInstanceId!
                }
                if self.hostName != nil {
                    map["HostName"] = self.hostName!
                }
                if self.newValue != nil {
                    map["NewValue"] = self.newValue!
                }
                if self.oldValue != nil {
                    map["OldValue"] = self.oldValue!
                }
                if self.serviceName != nil {
                    map["ServiceName"] = self.serviceName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Applied") && dict["Applied"] != nil {
                    self.applied = dict["Applied"] as! Bool
                }
                if dict.keys.contains("Author") && dict["Author"] != nil {
                    self.author = dict["Author"] as! String
                }
                if dict.keys.contains("Comment") && dict["Comment"] != nil {
                    self.comment = dict["Comment"] as! String
                }
                if dict.keys.contains("ConfigFileName") && dict["ConfigFileName"] != nil {
                    self.configFileName = dict["ConfigFileName"] as! String
                }
                if dict.keys.contains("ConfigItemName") && dict["ConfigItemName"] != nil {
                    self.configItemName = dict["ConfigItemName"] as! String
                }
                if dict.keys.contains("ConfigVersion") && dict["ConfigVersion"] != nil {
                    self.configVersion = dict["ConfigVersion"] as! String
                }
                if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                    self.createTime = dict["CreateTime"] as! Int64
                }
                if dict.keys.contains("HostGroupId") && dict["HostGroupId"] != nil {
                    self.hostGroupId = dict["HostGroupId"] as! String
                }
                if dict.keys.contains("HostGroupName") && dict["HostGroupName"] != nil {
                    self.hostGroupName = dict["HostGroupName"] as! String
                }
                if dict.keys.contains("HostInstanceId") && dict["HostInstanceId"] != nil {
                    self.hostInstanceId = dict["HostInstanceId"] as! String
                }
                if dict.keys.contains("HostName") && dict["HostName"] != nil {
                    self.hostName = dict["HostName"] as! String
                }
                if dict.keys.contains("NewValue") && dict["NewValue"] != nil {
                    self.newValue = dict["NewValue"] as! String
                }
                if dict.keys.contains("OldValue") && dict["OldValue"] != nil {
                    self.oldValue = dict["OldValue"] as! String
                }
                if dict.keys.contains("ServiceName") && dict["ServiceName"] != nil {
                    self.serviceName = dict["ServiceName"] as! String
                }
            }
        }
        public var configHistory: [ListClusterServiceConfigHistoryResponseBody.ConfigHistoryList.ConfigHistory]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.configHistory != nil {
                var tmp : [Any] = []
                for k in self.configHistory! {
                    tmp.append(k.toMap())
                }
                map["ConfigHistory"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ConfigHistory") && dict["ConfigHistory"] != nil {
                var tmp : [ListClusterServiceConfigHistoryResponseBody.ConfigHistoryList.ConfigHistory] = []
                for v in dict["ConfigHistory"] as! [Any] {
                    var model = ListClusterServiceConfigHistoryResponseBody.ConfigHistoryList.ConfigHistory()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.configHistory = tmp
            }
        }
    }
    public var configHistoryList: ListClusterServiceConfigHistoryResponseBody.ConfigHistoryList?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.configHistoryList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.configHistoryList != nil {
            map["ConfigHistoryList"] = self.configHistoryList?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ConfigHistoryList") && dict["ConfigHistoryList"] != nil {
            var model = ListClusterServiceConfigHistoryResponseBody.ConfigHistoryList()
            model.fromMap(dict["ConfigHistoryList"] as! [String: Any])
            self.configHistoryList = model
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class ListClusterServiceConfigHistoryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListClusterServiceConfigHistoryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListClusterServiceConfigHistoryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListClusterServiceQuickLinkRequest : Tea.TeaModel {
    public var clusterId: String?

    public var directType: Bool?

    public var regionId: String?

    public var resourceOwnerId: Int64?

    public var serviceName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.directType != nil {
            map["DirectType"] = self.directType!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.serviceName != nil {
            map["ServiceName"] = self.serviceName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("DirectType") && dict["DirectType"] != nil {
            self.directType = dict["DirectType"] as! Bool
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") && dict["ResourceOwnerId"] != nil {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("ServiceName") && dict["ServiceName"] != nil {
            self.serviceName = dict["ServiceName"] as! String
        }
    }
}

public class ListClusterServiceQuickLinkResponseBody : Tea.TeaModel {
    public class QuickLinkList : Tea.TeaModel {
        public class QuickLink : Tea.TeaModel {
            public var port: String?

            public var protocol_: String?

            public var quickLinkAddress: String?

            public var serviceDisplayName: String?

            public var serviceName: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.port != nil {
                    map["Port"] = self.port!
                }
                if self.protocol_ != nil {
                    map["Protocol"] = self.protocol_!
                }
                if self.quickLinkAddress != nil {
                    map["QuickLinkAddress"] = self.quickLinkAddress!
                }
                if self.serviceDisplayName != nil {
                    map["ServiceDisplayName"] = self.serviceDisplayName!
                }
                if self.serviceName != nil {
                    map["ServiceName"] = self.serviceName!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Port") && dict["Port"] != nil {
                    self.port = dict["Port"] as! String
                }
                if dict.keys.contains("Protocol") && dict["Protocol"] != nil {
                    self.protocol_ = dict["Protocol"] as! String
                }
                if dict.keys.contains("QuickLinkAddress") && dict["QuickLinkAddress"] != nil {
                    self.quickLinkAddress = dict["QuickLinkAddress"] as! String
                }
                if dict.keys.contains("ServiceDisplayName") && dict["ServiceDisplayName"] != nil {
                    self.serviceDisplayName = dict["ServiceDisplayName"] as! String
                }
                if dict.keys.contains("ServiceName") && dict["ServiceName"] != nil {
                    self.serviceName = dict["ServiceName"] as! String
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var quickLink: [ListClusterServiceQuickLinkResponseBody.QuickLinkList.QuickLink]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.quickLink != nil {
                var tmp : [Any] = []
                for k in self.quickLink! {
                    tmp.append(k.toMap())
                }
                map["QuickLink"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("QuickLink") && dict["QuickLink"] != nil {
                var tmp : [ListClusterServiceQuickLinkResponseBody.QuickLinkList.QuickLink] = []
                for v in dict["QuickLink"] as! [Any] {
                    var model = ListClusterServiceQuickLinkResponseBody.QuickLinkList.QuickLink()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.quickLink = tmp
            }
        }
    }
    public var quickLinkList: ListClusterServiceQuickLinkResponseBody.QuickLinkList?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.quickLinkList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.quickLinkList != nil {
            map["QuickLinkList"] = self.quickLinkList?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("QuickLinkList") && dict["QuickLinkList"] != nil {
            var model = ListClusterServiceQuickLinkResponseBody.QuickLinkList()
            model.fromMap(dict["QuickLinkList"] as! [String: Any])
            self.quickLinkList = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListClusterServiceQuickLinkResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListClusterServiceQuickLinkResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListClusterServiceQuickLinkResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListClusterTemplatesRequest : Tea.TeaModel {
    public var bizId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var productType: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.productType != nil {
            map["ProductType"] = self.productType!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("ProductType") && dict["ProductType"] != nil {
            self.productType = dict["ProductType"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") && dict["ResourceGroupId"] != nil {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") && dict["ResourceOwnerId"] != nil {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class ListClusterTemplatesResponseBody : Tea.TeaModel {
    public class TemplateInfoList : Tea.TeaModel {
        public class TemplateInfo : Tea.TeaModel {
            public class BootstrapActionList : Tea.TeaModel {
                public class BootstrapAction : Tea.TeaModel {
                    public var arg: String?

                    public var name: String?

                    public var path: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.arg != nil {
                            map["Arg"] = self.arg!
                        }
                        if self.name != nil {
                            map["Name"] = self.name!
                        }
                        if self.path != nil {
                            map["Path"] = self.path!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Arg") && dict["Arg"] != nil {
                            self.arg = dict["Arg"] as! String
                        }
                        if dict.keys.contains("Name") && dict["Name"] != nil {
                            self.name = dict["Name"] as! String
                        }
                        if dict.keys.contains("Path") && dict["Path"] != nil {
                            self.path = dict["Path"] as! String
                        }
                    }
                }
                public var bootstrapAction: [ListClusterTemplatesResponseBody.TemplateInfoList.TemplateInfo.BootstrapActionList.BootstrapAction]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bootstrapAction != nil {
                        var tmp : [Any] = []
                        for k in self.bootstrapAction! {
                            tmp.append(k.toMap())
                        }
                        map["BootstrapAction"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("BootstrapAction") && dict["BootstrapAction"] != nil {
                        var tmp : [ListClusterTemplatesResponseBody.TemplateInfoList.TemplateInfo.BootstrapActionList.BootstrapAction] = []
                        for v in dict["BootstrapAction"] as! [Any] {
                            var model = ListClusterTemplatesResponseBody.TemplateInfoList.TemplateInfo.BootstrapActionList.BootstrapAction()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.bootstrapAction = tmp
                    }
                }
            }
            public class ConfigList : Tea.TeaModel {
                public class Config : Tea.TeaModel {
                    public var configKey: String?

                    public var configValue: String?

                    public var encrypt: String?

                    public var fileName: String?

                    public var replace: String?

                    public var serviceName: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.configKey != nil {
                            map["ConfigKey"] = self.configKey!
                        }
                        if self.configValue != nil {
                            map["ConfigValue"] = self.configValue!
                        }
                        if self.encrypt != nil {
                            map["Encrypt"] = self.encrypt!
                        }
                        if self.fileName != nil {
                            map["FileName"] = self.fileName!
                        }
                        if self.replace != nil {
                            map["Replace"] = self.replace!
                        }
                        if self.serviceName != nil {
                            map["ServiceName"] = self.serviceName!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("ConfigKey") && dict["ConfigKey"] != nil {
                            self.configKey = dict["ConfigKey"] as! String
                        }
                        if dict.keys.contains("ConfigValue") && dict["ConfigValue"] != nil {
                            self.configValue = dict["ConfigValue"] as! String
                        }
                        if dict.keys.contains("Encrypt") && dict["Encrypt"] != nil {
                            self.encrypt = dict["Encrypt"] as! String
                        }
                        if dict.keys.contains("FileName") && dict["FileName"] != nil {
                            self.fileName = dict["FileName"] as! String
                        }
                        if dict.keys.contains("Replace") && dict["Replace"] != nil {
                            self.replace = dict["Replace"] as! String
                        }
                        if dict.keys.contains("ServiceName") && dict["ServiceName"] != nil {
                            self.serviceName = dict["ServiceName"] as! String
                        }
                    }
                }
                public var config: [ListClusterTemplatesResponseBody.TemplateInfoList.TemplateInfo.ConfigList.Config]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.config != nil {
                        var tmp : [Any] = []
                        for k in self.config! {
                            tmp.append(k.toMap())
                        }
                        map["Config"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Config") && dict["Config"] != nil {
                        var tmp : [ListClusterTemplatesResponseBody.TemplateInfoList.TemplateInfo.ConfigList.Config] = []
                        for v in dict["Config"] as! [Any] {
                            var model = ListClusterTemplatesResponseBody.TemplateInfoList.TemplateInfo.ConfigList.Config()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.config = tmp
                    }
                }
            }
            public class HostGroupList : Tea.TeaModel {
                public class HostGroup : Tea.TeaModel {
                    public var chargeType: String?

                    public var diskCapacity: Int32?

                    public var diskCount: Int32?

                    public var diskType: String?

                    public var hostGroupId: String?

                    public var hostGroupName: String?

                    public var hostGroupType: String?

                    public var instanceType: String?

                    public var multiInstanceTypes: String?

                    public var nodeCount: Int32?

                    public var period: String?

                    public var sysDiskCapacity: Int32?

                    public var sysDiskType: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.chargeType != nil {
                            map["ChargeType"] = self.chargeType!
                        }
                        if self.diskCapacity != nil {
                            map["DiskCapacity"] = self.diskCapacity!
                        }
                        if self.diskCount != nil {
                            map["DiskCount"] = self.diskCount!
                        }
                        if self.diskType != nil {
                            map["DiskType"] = self.diskType!
                        }
                        if self.hostGroupId != nil {
                            map["HostGroupId"] = self.hostGroupId!
                        }
                        if self.hostGroupName != nil {
                            map["HostGroupName"] = self.hostGroupName!
                        }
                        if self.hostGroupType != nil {
                            map["HostGroupType"] = self.hostGroupType!
                        }
                        if self.instanceType != nil {
                            map["InstanceType"] = self.instanceType!
                        }
                        if self.multiInstanceTypes != nil {
                            map["MultiInstanceTypes"] = self.multiInstanceTypes!
                        }
                        if self.nodeCount != nil {
                            map["NodeCount"] = self.nodeCount!
                        }
                        if self.period != nil {
                            map["Period"] = self.period!
                        }
                        if self.sysDiskCapacity != nil {
                            map["SysDiskCapacity"] = self.sysDiskCapacity!
                        }
                        if self.sysDiskType != nil {
                            map["SysDiskType"] = self.sysDiskType!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("ChargeType") && dict["ChargeType"] != nil {
                            self.chargeType = dict["ChargeType"] as! String
                        }
                        if dict.keys.contains("DiskCapacity") && dict["DiskCapacity"] != nil {
                            self.diskCapacity = dict["DiskCapacity"] as! Int32
                        }
                        if dict.keys.contains("DiskCount") && dict["DiskCount"] != nil {
                            self.diskCount = dict["DiskCount"] as! Int32
                        }
                        if dict.keys.contains("DiskType") && dict["DiskType"] != nil {
                            self.diskType = dict["DiskType"] as! String
                        }
                        if dict.keys.contains("HostGroupId") && dict["HostGroupId"] != nil {
                            self.hostGroupId = dict["HostGroupId"] as! String
                        }
                        if dict.keys.contains("HostGroupName") && dict["HostGroupName"] != nil {
                            self.hostGroupName = dict["HostGroupName"] as! String
                        }
                        if dict.keys.contains("HostGroupType") && dict["HostGroupType"] != nil {
                            self.hostGroupType = dict["HostGroupType"] as! String
                        }
                        if dict.keys.contains("InstanceType") && dict["InstanceType"] != nil {
                            self.instanceType = dict["InstanceType"] as! String
                        }
                        if dict.keys.contains("MultiInstanceTypes") && dict["MultiInstanceTypes"] != nil {
                            self.multiInstanceTypes = dict["MultiInstanceTypes"] as! String
                        }
                        if dict.keys.contains("NodeCount") && dict["NodeCount"] != nil {
                            self.nodeCount = dict["NodeCount"] as! Int32
                        }
                        if dict.keys.contains("Period") && dict["Period"] != nil {
                            self.period = dict["Period"] as! String
                        }
                        if dict.keys.contains("SysDiskCapacity") && dict["SysDiskCapacity"] != nil {
                            self.sysDiskCapacity = dict["SysDiskCapacity"] as! Int32
                        }
                        if dict.keys.contains("SysDiskType") && dict["SysDiskType"] != nil {
                            self.sysDiskType = dict["SysDiskType"] as! String
                        }
                    }
                }
                public var hostGroup: [ListClusterTemplatesResponseBody.TemplateInfoList.TemplateInfo.HostGroupList.HostGroup]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.hostGroup != nil {
                        var tmp : [Any] = []
                        for k in self.hostGroup! {
                            tmp.append(k.toMap())
                        }
                        map["HostGroup"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("HostGroup") && dict["HostGroup"] != nil {
                        var tmp : [ListClusterTemplatesResponseBody.TemplateInfoList.TemplateInfo.HostGroupList.HostGroup] = []
                        for v in dict["HostGroup"] as! [Any] {
                            var model = ListClusterTemplatesResponseBody.TemplateInfoList.TemplateInfo.HostGroupList.HostGroup()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.hostGroup = tmp
                    }
                }
            }
            public class SoftwareInfoList : Tea.TeaModel {
                public var softwareInfo: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.softwareInfo != nil {
                        map["SoftwareInfo"] = self.softwareInfo!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("SoftwareInfo") && dict["SoftwareInfo"] != nil {
                        self.softwareInfo = dict["SoftwareInfo"] as! [String]
                    }
                }
            }
            public var allowNotebook: Bool?

            public var bootstrapActionList: ListClusterTemplatesResponseBody.TemplateInfoList.TemplateInfo.BootstrapActionList?

            public var clusterType: String?

            public var configList: ListClusterTemplatesResponseBody.TemplateInfoList.TemplateInfo.ConfigList?

            public var configurations: String?

            public var createSource: String?

            public var depositType: String?

            public var easEnable: Bool?

            public var gmtCreate: Int64?

            public var gmtModified: Int64?

            public var highAvailabilityEnable: Bool?

            public var hostGroupList: ListClusterTemplatesResponseBody.TemplateInfoList.TemplateInfo.HostGroupList?

            public var id: String?

            public var initCustomHiveMetaDb: Bool?

            public var instanceGeneration: String?

            public var ioOptimized: Bool?

            public var isOpenPublicIp: Bool?

            public var keyPairName: String?

            public var logEnable: Bool?

            public var logPath: String?

            public var machineType: String?

            public var masterNodeTotal: Int32?

            public var metaStoreConf: String?

            public var metaStoreType: String?

            public var netType: String?

            public var securityGroupId: String?

            public var securityGroupName: String?

            public var softwareInfoList: ListClusterTemplatesResponseBody.TemplateInfoList.TemplateInfo.SoftwareInfoList?

            public var sshEnable: Bool?

            public var templateName: String?

            public var useCustomHiveMetaDb: Bool?

            public var useLocalMetaDb: Bool?

            public var userDefinedEmrEcsRole: String?

            public var userId: String?

            public var vSwitchId: String?

            public var vpcId: String?

            public var zoneId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.bootstrapActionList?.validate()
                try self.configList?.validate()
                try self.hostGroupList?.validate()
                try self.softwareInfoList?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.allowNotebook != nil {
                    map["AllowNotebook"] = self.allowNotebook!
                }
                if self.bootstrapActionList != nil {
                    map["BootstrapActionList"] = self.bootstrapActionList?.toMap()
                }
                if self.clusterType != nil {
                    map["ClusterType"] = self.clusterType!
                }
                if self.configList != nil {
                    map["ConfigList"] = self.configList?.toMap()
                }
                if self.configurations != nil {
                    map["Configurations"] = self.configurations!
                }
                if self.createSource != nil {
                    map["CreateSource"] = self.createSource!
                }
                if self.depositType != nil {
                    map["DepositType"] = self.depositType!
                }
                if self.easEnable != nil {
                    map["EasEnable"] = self.easEnable!
                }
                if self.gmtCreate != nil {
                    map["GmtCreate"] = self.gmtCreate!
                }
                if self.gmtModified != nil {
                    map["GmtModified"] = self.gmtModified!
                }
                if self.highAvailabilityEnable != nil {
                    map["HighAvailabilityEnable"] = self.highAvailabilityEnable!
                }
                if self.hostGroupList != nil {
                    map["HostGroupList"] = self.hostGroupList?.toMap()
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.initCustomHiveMetaDb != nil {
                    map["InitCustomHiveMetaDb"] = self.initCustomHiveMetaDb!
                }
                if self.instanceGeneration != nil {
                    map["InstanceGeneration"] = self.instanceGeneration!
                }
                if self.ioOptimized != nil {
                    map["IoOptimized"] = self.ioOptimized!
                }
                if self.isOpenPublicIp != nil {
                    map["IsOpenPublicIp"] = self.isOpenPublicIp!
                }
                if self.keyPairName != nil {
                    map["KeyPairName"] = self.keyPairName!
                }
                if self.logEnable != nil {
                    map["LogEnable"] = self.logEnable!
                }
                if self.logPath != nil {
                    map["LogPath"] = self.logPath!
                }
                if self.machineType != nil {
                    map["MachineType"] = self.machineType!
                }
                if self.masterNodeTotal != nil {
                    map["MasterNodeTotal"] = self.masterNodeTotal!
                }
                if self.metaStoreConf != nil {
                    map["MetaStoreConf"] = self.metaStoreConf!
                }
                if self.metaStoreType != nil {
                    map["MetaStoreType"] = self.metaStoreType!
                }
                if self.netType != nil {
                    map["NetType"] = self.netType!
                }
                if self.securityGroupId != nil {
                    map["SecurityGroupId"] = self.securityGroupId!
                }
                if self.securityGroupName != nil {
                    map["SecurityGroupName"] = self.securityGroupName!
                }
                if self.softwareInfoList != nil {
                    map["SoftwareInfoList"] = self.softwareInfoList?.toMap()
                }
                if self.sshEnable != nil {
                    map["SshEnable"] = self.sshEnable!
                }
                if self.templateName != nil {
                    map["TemplateName"] = self.templateName!
                }
                if self.useCustomHiveMetaDb != nil {
                    map["UseCustomHiveMetaDb"] = self.useCustomHiveMetaDb!
                }
                if self.useLocalMetaDb != nil {
                    map["UseLocalMetaDb"] = self.useLocalMetaDb!
                }
                if self.userDefinedEmrEcsRole != nil {
                    map["UserDefinedEmrEcsRole"] = self.userDefinedEmrEcsRole!
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                if self.vSwitchId != nil {
                    map["VSwitchId"] = self.vSwitchId!
                }
                if self.vpcId != nil {
                    map["VpcId"] = self.vpcId!
                }
                if self.zoneId != nil {
                    map["ZoneId"] = self.zoneId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AllowNotebook") && dict["AllowNotebook"] != nil {
                    self.allowNotebook = dict["AllowNotebook"] as! Bool
                }
                if dict.keys.contains("BootstrapActionList") && dict["BootstrapActionList"] != nil {
                    var model = ListClusterTemplatesResponseBody.TemplateInfoList.TemplateInfo.BootstrapActionList()
                    model.fromMap(dict["BootstrapActionList"] as! [String: Any])
                    self.bootstrapActionList = model
                }
                if dict.keys.contains("ClusterType") && dict["ClusterType"] != nil {
                    self.clusterType = dict["ClusterType"] as! String
                }
                if dict.keys.contains("ConfigList") && dict["ConfigList"] != nil {
                    var model = ListClusterTemplatesResponseBody.TemplateInfoList.TemplateInfo.ConfigList()
                    model.fromMap(dict["ConfigList"] as! [String: Any])
                    self.configList = model
                }
                if dict.keys.contains("Configurations") && dict["Configurations"] != nil {
                    self.configurations = dict["Configurations"] as! String
                }
                if dict.keys.contains("CreateSource") && dict["CreateSource"] != nil {
                    self.createSource = dict["CreateSource"] as! String
                }
                if dict.keys.contains("DepositType") && dict["DepositType"] != nil {
                    self.depositType = dict["DepositType"] as! String
                }
                if dict.keys.contains("EasEnable") && dict["EasEnable"] != nil {
                    self.easEnable = dict["EasEnable"] as! Bool
                }
                if dict.keys.contains("GmtCreate") && dict["GmtCreate"] != nil {
                    self.gmtCreate = dict["GmtCreate"] as! Int64
                }
                if dict.keys.contains("GmtModified") && dict["GmtModified"] != nil {
                    self.gmtModified = dict["GmtModified"] as! Int64
                }
                if dict.keys.contains("HighAvailabilityEnable") && dict["HighAvailabilityEnable"] != nil {
                    self.highAvailabilityEnable = dict["HighAvailabilityEnable"] as! Bool
                }
                if dict.keys.contains("HostGroupList") && dict["HostGroupList"] != nil {
                    var model = ListClusterTemplatesResponseBody.TemplateInfoList.TemplateInfo.HostGroupList()
                    model.fromMap(dict["HostGroupList"] as! [String: Any])
                    self.hostGroupList = model
                }
                if dict.keys.contains("Id") && dict["Id"] != nil {
                    self.id = dict["Id"] as! String
                }
                if dict.keys.contains("InitCustomHiveMetaDb") && dict["InitCustomHiveMetaDb"] != nil {
                    self.initCustomHiveMetaDb = dict["InitCustomHiveMetaDb"] as! Bool
                }
                if dict.keys.contains("InstanceGeneration") && dict["InstanceGeneration"] != nil {
                    self.instanceGeneration = dict["InstanceGeneration"] as! String
                }
                if dict.keys.contains("IoOptimized") && dict["IoOptimized"] != nil {
                    self.ioOptimized = dict["IoOptimized"] as! Bool
                }
                if dict.keys.contains("IsOpenPublicIp") && dict["IsOpenPublicIp"] != nil {
                    self.isOpenPublicIp = dict["IsOpenPublicIp"] as! Bool
                }
                if dict.keys.contains("KeyPairName") && dict["KeyPairName"] != nil {
                    self.keyPairName = dict["KeyPairName"] as! String
                }
                if dict.keys.contains("LogEnable") && dict["LogEnable"] != nil {
                    self.logEnable = dict["LogEnable"] as! Bool
                }
                if dict.keys.contains("LogPath") && dict["LogPath"] != nil {
                    self.logPath = dict["LogPath"] as! String
                }
                if dict.keys.contains("MachineType") && dict["MachineType"] != nil {
                    self.machineType = dict["MachineType"] as! String
                }
                if dict.keys.contains("MasterNodeTotal") && dict["MasterNodeTotal"] != nil {
                    self.masterNodeTotal = dict["MasterNodeTotal"] as! Int32
                }
                if dict.keys.contains("MetaStoreConf") && dict["MetaStoreConf"] != nil {
                    self.metaStoreConf = dict["MetaStoreConf"] as! String
                }
                if dict.keys.contains("MetaStoreType") && dict["MetaStoreType"] != nil {
                    self.metaStoreType = dict["MetaStoreType"] as! String
                }
                if dict.keys.contains("NetType") && dict["NetType"] != nil {
                    self.netType = dict["NetType"] as! String
                }
                if dict.keys.contains("SecurityGroupId") && dict["SecurityGroupId"] != nil {
                    self.securityGroupId = dict["SecurityGroupId"] as! String
                }
                if dict.keys.contains("SecurityGroupName") && dict["SecurityGroupName"] != nil {
                    self.securityGroupName = dict["SecurityGroupName"] as! String
                }
                if dict.keys.contains("SoftwareInfoList") && dict["SoftwareInfoList"] != nil {
                    var model = ListClusterTemplatesResponseBody.TemplateInfoList.TemplateInfo.SoftwareInfoList()
                    model.fromMap(dict["SoftwareInfoList"] as! [String: Any])
                    self.softwareInfoList = model
                }
                if dict.keys.contains("SshEnable") && dict["SshEnable"] != nil {
                    self.sshEnable = dict["SshEnable"] as! Bool
                }
                if dict.keys.contains("TemplateName") && dict["TemplateName"] != nil {
                    self.templateName = dict["TemplateName"] as! String
                }
                if dict.keys.contains("UseCustomHiveMetaDb") && dict["UseCustomHiveMetaDb"] != nil {
                    self.useCustomHiveMetaDb = dict["UseCustomHiveMetaDb"] as! Bool
                }
                if dict.keys.contains("UseLocalMetaDb") && dict["UseLocalMetaDb"] != nil {
                    self.useLocalMetaDb = dict["UseLocalMetaDb"] as! Bool
                }
                if dict.keys.contains("UserDefinedEmrEcsRole") && dict["UserDefinedEmrEcsRole"] != nil {
                    self.userDefinedEmrEcsRole = dict["UserDefinedEmrEcsRole"] as! String
                }
                if dict.keys.contains("UserId") && dict["UserId"] != nil {
                    self.userId = dict["UserId"] as! String
                }
                if dict.keys.contains("VSwitchId") && dict["VSwitchId"] != nil {
                    self.vSwitchId = dict["VSwitchId"] as! String
                }
                if dict.keys.contains("VpcId") && dict["VpcId"] != nil {
                    self.vpcId = dict["VpcId"] as! String
                }
                if dict.keys.contains("ZoneId") && dict["ZoneId"] != nil {
                    self.zoneId = dict["ZoneId"] as! String
                }
            }
        }
        public var templateInfo: [ListClusterTemplatesResponseBody.TemplateInfoList.TemplateInfo]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.templateInfo != nil {
                var tmp : [Any] = []
                for k in self.templateInfo! {
                    tmp.append(k.toMap())
                }
                map["TemplateInfo"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("TemplateInfo") && dict["TemplateInfo"] != nil {
                var tmp : [ListClusterTemplatesResponseBody.TemplateInfoList.TemplateInfo] = []
                for v in dict["TemplateInfo"] as! [Any] {
                    var model = ListClusterTemplatesResponseBody.TemplateInfoList.TemplateInfo()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.templateInfo = tmp
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var templateInfoList: ListClusterTemplatesResponseBody.TemplateInfoList?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.templateInfoList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.templateInfoList != nil {
            map["TemplateInfoList"] = self.templateInfoList?.toMap()
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TemplateInfoList") && dict["TemplateInfoList"] != nil {
            var model = ListClusterTemplatesResponseBody.TemplateInfoList()
            model.fromMap(dict["TemplateInfoList"] as! [String: Any])
            self.templateInfoList = model
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class ListClusterTemplatesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListClusterTemplatesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListClusterTemplatesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListClustersRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") && dict["Key"] != nil {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") && dict["Value"] != nil {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var clusterTypeList: [String]?

    public var createType: String?

    public var defaultStatus: Bool?

    public var depositType: String?

    public var expiredTagList: [String]?

    public var isDesc: Bool?

    public var machineType: String?

    public var name: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerId: Int64?

    public var statusList: [String]?

    public var tag: [ListClustersRequest.Tag]?

    public var vpcId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterTypeList != nil {
            map["ClusterTypeList"] = self.clusterTypeList!
        }
        if self.createType != nil {
            map["CreateType"] = self.createType!
        }
        if self.defaultStatus != nil {
            map["DefaultStatus"] = self.defaultStatus!
        }
        if self.depositType != nil {
            map["DepositType"] = self.depositType!
        }
        if self.expiredTagList != nil {
            map["ExpiredTagList"] = self.expiredTagList!
        }
        if self.isDesc != nil {
            map["IsDesc"] = self.isDesc!
        }
        if self.machineType != nil {
            map["MachineType"] = self.machineType!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.statusList != nil {
            map["StatusList"] = self.statusList!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterTypeList") && dict["ClusterTypeList"] != nil {
            self.clusterTypeList = dict["ClusterTypeList"] as! [String]
        }
        if dict.keys.contains("CreateType") && dict["CreateType"] != nil {
            self.createType = dict["CreateType"] as! String
        }
        if dict.keys.contains("DefaultStatus") && dict["DefaultStatus"] != nil {
            self.defaultStatus = dict["DefaultStatus"] as! Bool
        }
        if dict.keys.contains("DepositType") && dict["DepositType"] != nil {
            self.depositType = dict["DepositType"] as! String
        }
        if dict.keys.contains("ExpiredTagList") && dict["ExpiredTagList"] != nil {
            self.expiredTagList = dict["ExpiredTagList"] as! [String]
        }
        if dict.keys.contains("IsDesc") && dict["IsDesc"] != nil {
            self.isDesc = dict["IsDesc"] as! Bool
        }
        if dict.keys.contains("MachineType") && dict["MachineType"] != nil {
            self.machineType = dict["MachineType"] as! String
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") && dict["ResourceGroupId"] != nil {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") && dict["ResourceOwnerId"] != nil {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("StatusList") && dict["StatusList"] != nil {
            self.statusList = dict["StatusList"] as! [String]
        }
        if dict.keys.contains("Tag") && dict["Tag"] != nil {
            var tmp : [ListClustersRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = ListClustersRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
        if dict.keys.contains("VpcId") && dict["VpcId"] != nil {
            self.vpcId = dict["VpcId"] as! String
        }
    }
}

public class ListClustersResponseBody : Tea.TeaModel {
    public class Clusters : Tea.TeaModel {
        public class ClusterInfo : Tea.TeaModel {
            public class FailReason : Tea.TeaModel {
                public var errorCode: String?

                public var errorMsg: String?

                public var requestId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.errorCode != nil {
                        map["ErrorCode"] = self.errorCode!
                    }
                    if self.errorMsg != nil {
                        map["ErrorMsg"] = self.errorMsg!
                    }
                    if self.requestId != nil {
                        map["RequestId"] = self.requestId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
                        self.errorCode = dict["ErrorCode"] as! String
                    }
                    if dict.keys.contains("ErrorMsg") && dict["ErrorMsg"] != nil {
                        self.errorMsg = dict["ErrorMsg"] as! String
                    }
                    if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
                        self.requestId = dict["RequestId"] as! String
                    }
                }
            }
            public class OrderTaskInfo : Tea.TeaModel {
                public var currentCount: Int32?

                public var orderIdList: String?

                public var targetCount: Int32?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.currentCount != nil {
                        map["CurrentCount"] = self.currentCount!
                    }
                    if self.orderIdList != nil {
                        map["OrderIdList"] = self.orderIdList!
                    }
                    if self.targetCount != nil {
                        map["TargetCount"] = self.targetCount!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("CurrentCount") && dict["CurrentCount"] != nil {
                        self.currentCount = dict["CurrentCount"] as! Int32
                    }
                    if dict.keys.contains("OrderIdList") && dict["OrderIdList"] != nil {
                        self.orderIdList = dict["OrderIdList"] as! String
                    }
                    if dict.keys.contains("TargetCount") && dict["TargetCount"] != nil {
                        self.targetCount = dict["TargetCount"] as! Int32
                    }
                }
            }
            public class Tags : Tea.TeaModel {
                public class Tag : Tea.TeaModel {
                    public var tagKey: String?

                    public var tagValue: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.tagKey != nil {
                            map["TagKey"] = self.tagKey!
                        }
                        if self.tagValue != nil {
                            map["TagValue"] = self.tagValue!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("TagKey") && dict["TagKey"] != nil {
                            self.tagKey = dict["TagKey"] as! String
                        }
                        if dict.keys.contains("TagValue") && dict["TagValue"] != nil {
                            self.tagValue = dict["TagValue"] as! String
                        }
                    }
                }
                public var tag: [ListClustersResponseBody.Clusters.ClusterInfo.Tags.Tag]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.tag != nil {
                        var tmp : [Any] = []
                        for k in self.tag! {
                            tmp.append(k.toMap())
                        }
                        map["Tag"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Tag") && dict["Tag"] != nil {
                        var tmp : [ListClustersResponseBody.Clusters.ClusterInfo.Tags.Tag] = []
                        for v in dict["Tag"] as! [Any] {
                            var model = ListClustersResponseBody.Clusters.ClusterInfo.Tags.Tag()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.tag = tmp
                    }
                }
            }
            public var chargeType: String?

            public var createResource: String?

            public var createTime: Int64?

            public var depositType: String?

            public var expiredTime: Int64?

            public var failReason: ListClustersResponseBody.Clusters.ClusterInfo.FailReason?

            public var hasUncompletedOrder: Bool?

            public var id: String?

            public var k8sClusterId: String?

            public var machineType: String?

            public var metaStoreType: String?

            public var name: String?

            public var operationId: Int64?

            public var orderList: String?

            public var orderTaskInfo: ListClustersResponseBody.Clusters.ClusterInfo.OrderTaskInfo?

            public var period: Int32?

            public var runningTime: Int32?

            public var status: String?

            public var tags: ListClustersResponseBody.Clusters.ClusterInfo.Tags?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.failReason?.validate()
                try self.orderTaskInfo?.validate()
                try self.tags?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.chargeType != nil {
                    map["ChargeType"] = self.chargeType!
                }
                if self.createResource != nil {
                    map["CreateResource"] = self.createResource!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.depositType != nil {
                    map["DepositType"] = self.depositType!
                }
                if self.expiredTime != nil {
                    map["ExpiredTime"] = self.expiredTime!
                }
                if self.failReason != nil {
                    map["FailReason"] = self.failReason?.toMap()
                }
                if self.hasUncompletedOrder != nil {
                    map["HasUncompletedOrder"] = self.hasUncompletedOrder!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.k8sClusterId != nil {
                    map["K8sClusterId"] = self.k8sClusterId!
                }
                if self.machineType != nil {
                    map["MachineType"] = self.machineType!
                }
                if self.metaStoreType != nil {
                    map["MetaStoreType"] = self.metaStoreType!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.operationId != nil {
                    map["OperationId"] = self.operationId!
                }
                if self.orderList != nil {
                    map["OrderList"] = self.orderList!
                }
                if self.orderTaskInfo != nil {
                    map["OrderTaskInfo"] = self.orderTaskInfo?.toMap()
                }
                if self.period != nil {
                    map["Period"] = self.period!
                }
                if self.runningTime != nil {
                    map["RunningTime"] = self.runningTime!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.tags != nil {
                    map["Tags"] = self.tags?.toMap()
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ChargeType") && dict["ChargeType"] != nil {
                    self.chargeType = dict["ChargeType"] as! String
                }
                if dict.keys.contains("CreateResource") && dict["CreateResource"] != nil {
                    self.createResource = dict["CreateResource"] as! String
                }
                if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                    self.createTime = dict["CreateTime"] as! Int64
                }
                if dict.keys.contains("DepositType") && dict["DepositType"] != nil {
                    self.depositType = dict["DepositType"] as! String
                }
                if dict.keys.contains("ExpiredTime") && dict["ExpiredTime"] != nil {
                    self.expiredTime = dict["ExpiredTime"] as! Int64
                }
                if dict.keys.contains("FailReason") && dict["FailReason"] != nil {
                    var model = ListClustersResponseBody.Clusters.ClusterInfo.FailReason()
                    model.fromMap(dict["FailReason"] as! [String: Any])
                    self.failReason = model
                }
                if dict.keys.contains("HasUncompletedOrder") && dict["HasUncompletedOrder"] != nil {
                    self.hasUncompletedOrder = dict["HasUncompletedOrder"] as! Bool
                }
                if dict.keys.contains("Id") && dict["Id"] != nil {
                    self.id = dict["Id"] as! String
                }
                if dict.keys.contains("K8sClusterId") && dict["K8sClusterId"] != nil {
                    self.k8sClusterId = dict["K8sClusterId"] as! String
                }
                if dict.keys.contains("MachineType") && dict["MachineType"] != nil {
                    self.machineType = dict["MachineType"] as! String
                }
                if dict.keys.contains("MetaStoreType") && dict["MetaStoreType"] != nil {
                    self.metaStoreType = dict["MetaStoreType"] as! String
                }
                if dict.keys.contains("Name") && dict["Name"] != nil {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("OperationId") && dict["OperationId"] != nil {
                    self.operationId = dict["OperationId"] as! Int64
                }
                if dict.keys.contains("OrderList") && dict["OrderList"] != nil {
                    self.orderList = dict["OrderList"] as! String
                }
                if dict.keys.contains("OrderTaskInfo") && dict["OrderTaskInfo"] != nil {
                    var model = ListClustersResponseBody.Clusters.ClusterInfo.OrderTaskInfo()
                    model.fromMap(dict["OrderTaskInfo"] as! [String: Any])
                    self.orderTaskInfo = model
                }
                if dict.keys.contains("Period") && dict["Period"] != nil {
                    self.period = dict["Period"] as! Int32
                }
                if dict.keys.contains("RunningTime") && dict["RunningTime"] != nil {
                    self.runningTime = dict["RunningTime"] as! Int32
                }
                if dict.keys.contains("Status") && dict["Status"] != nil {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("Tags") && dict["Tags"] != nil {
                    var model = ListClustersResponseBody.Clusters.ClusterInfo.Tags()
                    model.fromMap(dict["Tags"] as! [String: Any])
                    self.tags = model
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var clusterInfo: [ListClustersResponseBody.Clusters.ClusterInfo]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.clusterInfo != nil {
                var tmp : [Any] = []
                for k in self.clusterInfo! {
                    tmp.append(k.toMap())
                }
                map["ClusterInfo"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ClusterInfo") && dict["ClusterInfo"] != nil {
                var tmp : [ListClustersResponseBody.Clusters.ClusterInfo] = []
                for v in dict["ClusterInfo"] as! [Any] {
                    var model = ListClustersResponseBody.Clusters.ClusterInfo()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.clusterInfo = tmp
            }
        }
    }
    public var clusters: ListClustersResponseBody.Clusters?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.clusters?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusters != nil {
            map["Clusters"] = self.clusters?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Clusters") && dict["Clusters"] != nil {
            var model = ListClustersResponseBody.Clusters()
            model.fromMap(dict["Clusters"] as! [String: Any])
            self.clusters = model
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class ListClustersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListClustersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListClustersResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListEmrAvailableConfigRequest : Tea.TeaModel {
    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") && dict["ResourceGroupId"] != nil {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") && dict["ResourceOwnerId"] != nil {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class ListEmrAvailableConfigResponseBody : Tea.TeaModel {
    public class EmrMainVersionList : Tea.TeaModel {
        public class EmrMainVersion : Tea.TeaModel {
            public class ClusterTypeInfoList : Tea.TeaModel {
                public class ClusterTypeInfo : Tea.TeaModel {
                    public class ClusterServiceInfoList : Tea.TeaModel {
                        public class ClusterServiceInfo : Tea.TeaModel {
                            public var mandatory: Bool?

                            public var serviceDisplayName: String?

                            public var serviceName: String?

                            public var serviceVersion: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.mandatory != nil {
                                    map["Mandatory"] = self.mandatory!
                                }
                                if self.serviceDisplayName != nil {
                                    map["ServiceDisplayName"] = self.serviceDisplayName!
                                }
                                if self.serviceName != nil {
                                    map["ServiceName"] = self.serviceName!
                                }
                                if self.serviceVersion != nil {
                                    map["ServiceVersion"] = self.serviceVersion!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Mandatory") && dict["Mandatory"] != nil {
                                    self.mandatory = dict["Mandatory"] as! Bool
                                }
                                if dict.keys.contains("ServiceDisplayName") && dict["ServiceDisplayName"] != nil {
                                    self.serviceDisplayName = dict["ServiceDisplayName"] as! String
                                }
                                if dict.keys.contains("ServiceName") && dict["ServiceName"] != nil {
                                    self.serviceName = dict["ServiceName"] as! String
                                }
                                if dict.keys.contains("ServiceVersion") && dict["ServiceVersion"] != nil {
                                    self.serviceVersion = dict["ServiceVersion"] as! String
                                }
                            }
                        }
                        public var clusterServiceInfo: [ListEmrAvailableConfigResponseBody.EmrMainVersionList.EmrMainVersion.ClusterTypeInfoList.ClusterTypeInfo.ClusterServiceInfoList.ClusterServiceInfo]?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.clusterServiceInfo != nil {
                                var tmp : [Any] = []
                                for k in self.clusterServiceInfo! {
                                    tmp.append(k.toMap())
                                }
                                map["ClusterServiceInfo"] = tmp
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("ClusterServiceInfo") && dict["ClusterServiceInfo"] != nil {
                                var tmp : [ListEmrAvailableConfigResponseBody.EmrMainVersionList.EmrMainVersion.ClusterTypeInfoList.ClusterTypeInfo.ClusterServiceInfoList.ClusterServiceInfo] = []
                                for v in dict["ClusterServiceInfo"] as! [Any] {
                                    var model = ListEmrAvailableConfigResponseBody.EmrMainVersionList.EmrMainVersion.ClusterTypeInfoList.ClusterTypeInfo.ClusterServiceInfoList.ClusterServiceInfo()
                                    if v != nil {
                                        model.fromMap(v as! [String: Any])
                                    }
                                    tmp.append(model)
                                }
                                self.clusterServiceInfo = tmp
                            }
                        }
                    }
                    public var clusterServiceInfoList: ListEmrAvailableConfigResponseBody.EmrMainVersionList.EmrMainVersion.ClusterTypeInfoList.ClusterTypeInfo.ClusterServiceInfoList?

                    public var clusterType: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.clusterServiceInfoList?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.clusterServiceInfoList != nil {
                            map["ClusterServiceInfoList"] = self.clusterServiceInfoList?.toMap()
                        }
                        if self.clusterType != nil {
                            map["ClusterType"] = self.clusterType!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("ClusterServiceInfoList") && dict["ClusterServiceInfoList"] != nil {
                            var model = ListEmrAvailableConfigResponseBody.EmrMainVersionList.EmrMainVersion.ClusterTypeInfoList.ClusterTypeInfo.ClusterServiceInfoList()
                            model.fromMap(dict["ClusterServiceInfoList"] as! [String: Any])
                            self.clusterServiceInfoList = model
                        }
                        if dict.keys.contains("ClusterType") && dict["ClusterType"] != nil {
                            self.clusterType = dict["ClusterType"] as! String
                        }
                    }
                }
                public var clusterTypeInfo: [ListEmrAvailableConfigResponseBody.EmrMainVersionList.EmrMainVersion.ClusterTypeInfoList.ClusterTypeInfo]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.clusterTypeInfo != nil {
                        var tmp : [Any] = []
                        for k in self.clusterTypeInfo! {
                            tmp.append(k.toMap())
                        }
                        map["ClusterTypeInfo"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ClusterTypeInfo") && dict["ClusterTypeInfo"] != nil {
                        var tmp : [ListEmrAvailableConfigResponseBody.EmrMainVersionList.EmrMainVersion.ClusterTypeInfoList.ClusterTypeInfo] = []
                        for v in dict["ClusterTypeInfo"] as! [Any] {
                            var model = ListEmrAvailableConfigResponseBody.EmrMainVersionList.EmrMainVersion.ClusterTypeInfoList.ClusterTypeInfo()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.clusterTypeInfo = tmp
                    }
                }
            }
            public var clusterTypeInfoList: ListEmrAvailableConfigResponseBody.EmrMainVersionList.EmrMainVersion.ClusterTypeInfoList?

            public var ecmVersion: Bool?

            public var extraInfo: String?

            public var mainVersionName: String?

            public var onCloudNative: Bool?

            public var publishType: String?

            public var regionId: String?

            public var stackName: String?

            public var stackVersion: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.clusterTypeInfoList?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.clusterTypeInfoList != nil {
                    map["ClusterTypeInfoList"] = self.clusterTypeInfoList?.toMap()
                }
                if self.ecmVersion != nil {
                    map["EcmVersion"] = self.ecmVersion!
                }
                if self.extraInfo != nil {
                    map["ExtraInfo"] = self.extraInfo!
                }
                if self.mainVersionName != nil {
                    map["MainVersionName"] = self.mainVersionName!
                }
                if self.onCloudNative != nil {
                    map["OnCloudNative"] = self.onCloudNative!
                }
                if self.publishType != nil {
                    map["PublishType"] = self.publishType!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.stackName != nil {
                    map["StackName"] = self.stackName!
                }
                if self.stackVersion != nil {
                    map["StackVersion"] = self.stackVersion!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ClusterTypeInfoList") && dict["ClusterTypeInfoList"] != nil {
                    var model = ListEmrAvailableConfigResponseBody.EmrMainVersionList.EmrMainVersion.ClusterTypeInfoList()
                    model.fromMap(dict["ClusterTypeInfoList"] as! [String: Any])
                    self.clusterTypeInfoList = model
                }
                if dict.keys.contains("EcmVersion") && dict["EcmVersion"] != nil {
                    self.ecmVersion = dict["EcmVersion"] as! Bool
                }
                if dict.keys.contains("ExtraInfo") && dict["ExtraInfo"] != nil {
                    self.extraInfo = dict["ExtraInfo"] as! String
                }
                if dict.keys.contains("MainVersionName") && dict["MainVersionName"] != nil {
                    self.mainVersionName = dict["MainVersionName"] as! String
                }
                if dict.keys.contains("OnCloudNative") && dict["OnCloudNative"] != nil {
                    self.onCloudNative = dict["OnCloudNative"] as! Bool
                }
                if dict.keys.contains("PublishType") && dict["PublishType"] != nil {
                    self.publishType = dict["PublishType"] as! String
                }
                if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("StackName") && dict["StackName"] != nil {
                    self.stackName = dict["StackName"] as! String
                }
                if dict.keys.contains("StackVersion") && dict["StackVersion"] != nil {
                    self.stackVersion = dict["StackVersion"] as! String
                }
            }
        }
        public var emrMainVersion: [ListEmrAvailableConfigResponseBody.EmrMainVersionList.EmrMainVersion]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.emrMainVersion != nil {
                var tmp : [Any] = []
                for k in self.emrMainVersion! {
                    tmp.append(k.toMap())
                }
                map["EmrMainVersion"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EmrMainVersion") && dict["EmrMainVersion"] != nil {
                var tmp : [ListEmrAvailableConfigResponseBody.EmrMainVersionList.EmrMainVersion] = []
                for v in dict["EmrMainVersion"] as! [Any] {
                    var model = ListEmrAvailableConfigResponseBody.EmrMainVersionList.EmrMainVersion()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.emrMainVersion = tmp
            }
        }
    }
    public class KeyPairNameList : Tea.TeaModel {
        public var keyPairName: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.keyPairName != nil {
                map["KeyPairName"] = self.keyPairName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("KeyPairName") && dict["KeyPairName"] != nil {
                self.keyPairName = dict["KeyPairName"] as! [String]
            }
        }
    }
    public class SecurityGroupList : Tea.TeaModel {
        public class SecurityGroup : Tea.TeaModel {
            public var availableInstanceAmount: Int32?

            public var creationTime: String?

            public var description_: String?

            public var ecsCount: Int32?

            public var securityGroupId: String?

            public var securityGroupName: String?

            public var securityGroupType: String?

            public var vpcId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.availableInstanceAmount != nil {
                    map["AvailableInstanceAmount"] = self.availableInstanceAmount!
                }
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.ecsCount != nil {
                    map["EcsCount"] = self.ecsCount!
                }
                if self.securityGroupId != nil {
                    map["SecurityGroupId"] = self.securityGroupId!
                }
                if self.securityGroupName != nil {
                    map["SecurityGroupName"] = self.securityGroupName!
                }
                if self.securityGroupType != nil {
                    map["SecurityGroupType"] = self.securityGroupType!
                }
                if self.vpcId != nil {
                    map["VpcId"] = self.vpcId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AvailableInstanceAmount") && dict["AvailableInstanceAmount"] != nil {
                    self.availableInstanceAmount = dict["AvailableInstanceAmount"] as! Int32
                }
                if dict.keys.contains("CreationTime") && dict["CreationTime"] != nil {
                    self.creationTime = dict["CreationTime"] as! String
                }
                if dict.keys.contains("Description") && dict["Description"] != nil {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("EcsCount") && dict["EcsCount"] != nil {
                    self.ecsCount = dict["EcsCount"] as! Int32
                }
                if dict.keys.contains("SecurityGroupId") && dict["SecurityGroupId"] != nil {
                    self.securityGroupId = dict["SecurityGroupId"] as! String
                }
                if dict.keys.contains("SecurityGroupName") && dict["SecurityGroupName"] != nil {
                    self.securityGroupName = dict["SecurityGroupName"] as! String
                }
                if dict.keys.contains("SecurityGroupType") && dict["SecurityGroupType"] != nil {
                    self.securityGroupType = dict["SecurityGroupType"] as! String
                }
                if dict.keys.contains("VpcId") && dict["VpcId"] != nil {
                    self.vpcId = dict["VpcId"] as! String
                }
            }
        }
        public var securityGroup: [ListEmrAvailableConfigResponseBody.SecurityGroupList.SecurityGroup]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.securityGroup != nil {
                var tmp : [Any] = []
                for k in self.securityGroup! {
                    tmp.append(k.toMap())
                }
                map["SecurityGroup"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("SecurityGroup") && dict["SecurityGroup"] != nil {
                var tmp : [ListEmrAvailableConfigResponseBody.SecurityGroupList.SecurityGroup] = []
                for v in dict["SecurityGroup"] as! [Any] {
                    var model = ListEmrAvailableConfigResponseBody.SecurityGroupList.SecurityGroup()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.securityGroup = tmp
            }
        }
    }
    public class VpcInfoList : Tea.TeaModel {
        public class VpcInfo : Tea.TeaModel {
            public class VswitchInfoList : Tea.TeaModel {
                public class VswitchInfo : Tea.TeaModel {
                    public var availableIpAddressCount: Int64?

                    public var cidrBlock: String?

                    public var creationTime: String?

                    public var description_: String?

                    public var vpcId: String?

                    public var vswitchId: String?

                    public var vswitchName: String?

                    public var zoneId: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.availableIpAddressCount != nil {
                            map["AvailableIpAddressCount"] = self.availableIpAddressCount!
                        }
                        if self.cidrBlock != nil {
                            map["CidrBlock"] = self.cidrBlock!
                        }
                        if self.creationTime != nil {
                            map["CreationTime"] = self.creationTime!
                        }
                        if self.description_ != nil {
                            map["Description"] = self.description_!
                        }
                        if self.vpcId != nil {
                            map["VpcId"] = self.vpcId!
                        }
                        if self.vswitchId != nil {
                            map["VswitchId"] = self.vswitchId!
                        }
                        if self.vswitchName != nil {
                            map["VswitchName"] = self.vswitchName!
                        }
                        if self.zoneId != nil {
                            map["ZoneId"] = self.zoneId!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("AvailableIpAddressCount") && dict["AvailableIpAddressCount"] != nil {
                            self.availableIpAddressCount = dict["AvailableIpAddressCount"] as! Int64
                        }
                        if dict.keys.contains("CidrBlock") && dict["CidrBlock"] != nil {
                            self.cidrBlock = dict["CidrBlock"] as! String
                        }
                        if dict.keys.contains("CreationTime") && dict["CreationTime"] != nil {
                            self.creationTime = dict["CreationTime"] as! String
                        }
                        if dict.keys.contains("Description") && dict["Description"] != nil {
                            self.description_ = dict["Description"] as! String
                        }
                        if dict.keys.contains("VpcId") && dict["VpcId"] != nil {
                            self.vpcId = dict["VpcId"] as! String
                        }
                        if dict.keys.contains("VswitchId") && dict["VswitchId"] != nil {
                            self.vswitchId = dict["VswitchId"] as! String
                        }
                        if dict.keys.contains("VswitchName") && dict["VswitchName"] != nil {
                            self.vswitchName = dict["VswitchName"] as! String
                        }
                        if dict.keys.contains("ZoneId") && dict["ZoneId"] != nil {
                            self.zoneId = dict["ZoneId"] as! String
                        }
                    }
                }
                public var vswitchInfo: [ListEmrAvailableConfigResponseBody.VpcInfoList.VpcInfo.VswitchInfoList.VswitchInfo]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.vswitchInfo != nil {
                        var tmp : [Any] = []
                        for k in self.vswitchInfo! {
                            tmp.append(k.toMap())
                        }
                        map["VswitchInfo"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("VswitchInfo") && dict["VswitchInfo"] != nil {
                        var tmp : [ListEmrAvailableConfigResponseBody.VpcInfoList.VpcInfo.VswitchInfoList.VswitchInfo] = []
                        for v in dict["VswitchInfo"] as! [Any] {
                            var model = ListEmrAvailableConfigResponseBody.VpcInfoList.VpcInfo.VswitchInfoList.VswitchInfo()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.vswitchInfo = tmp
                    }
                }
            }
            public var cidrBlock: String?

            public var creationTime: String?

            public var description_: String?

            public var VRouterId: String?

            public var vpcId: String?

            public var vpcName: String?

            public var vswitchInfoList: ListEmrAvailableConfigResponseBody.VpcInfoList.VpcInfo.VswitchInfoList?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.vswitchInfoList?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cidrBlock != nil {
                    map["CidrBlock"] = self.cidrBlock!
                }
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.VRouterId != nil {
                    map["VRouterId"] = self.VRouterId!
                }
                if self.vpcId != nil {
                    map["VpcId"] = self.vpcId!
                }
                if self.vpcName != nil {
                    map["VpcName"] = self.vpcName!
                }
                if self.vswitchInfoList != nil {
                    map["VswitchInfoList"] = self.vswitchInfoList?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CidrBlock") && dict["CidrBlock"] != nil {
                    self.cidrBlock = dict["CidrBlock"] as! String
                }
                if dict.keys.contains("CreationTime") && dict["CreationTime"] != nil {
                    self.creationTime = dict["CreationTime"] as! String
                }
                if dict.keys.contains("Description") && dict["Description"] != nil {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("VRouterId") && dict["VRouterId"] != nil {
                    self.VRouterId = dict["VRouterId"] as! String
                }
                if dict.keys.contains("VpcId") && dict["VpcId"] != nil {
                    self.vpcId = dict["VpcId"] as! String
                }
                if dict.keys.contains("VpcName") && dict["VpcName"] != nil {
                    self.vpcName = dict["VpcName"] as! String
                }
                if dict.keys.contains("VswitchInfoList") && dict["VswitchInfoList"] != nil {
                    var model = ListEmrAvailableConfigResponseBody.VpcInfoList.VpcInfo.VswitchInfoList()
                    model.fromMap(dict["VswitchInfoList"] as! [String: Any])
                    self.vswitchInfoList = model
                }
            }
        }
        public var vpcInfo: [ListEmrAvailableConfigResponseBody.VpcInfoList.VpcInfo]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.vpcInfo != nil {
                var tmp : [Any] = []
                for k in self.vpcInfo! {
                    tmp.append(k.toMap())
                }
                map["VpcInfo"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("VpcInfo") && dict["VpcInfo"] != nil {
                var tmp : [ListEmrAvailableConfigResponseBody.VpcInfoList.VpcInfo] = []
                for v in dict["VpcInfo"] as! [Any] {
                    var model = ListEmrAvailableConfigResponseBody.VpcInfoList.VpcInfo()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.vpcInfo = tmp
            }
        }
    }
    public var emrMainVersionList: ListEmrAvailableConfigResponseBody.EmrMainVersionList?

    public var keyPairNameList: ListEmrAvailableConfigResponseBody.KeyPairNameList?

    public var requestId: String?

    public var securityGroupList: ListEmrAvailableConfigResponseBody.SecurityGroupList?

    public var vpcInfoList: ListEmrAvailableConfigResponseBody.VpcInfoList?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.emrMainVersionList?.validate()
        try self.keyPairNameList?.validate()
        try self.securityGroupList?.validate()
        try self.vpcInfoList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.emrMainVersionList != nil {
            map["EmrMainVersionList"] = self.emrMainVersionList?.toMap()
        }
        if self.keyPairNameList != nil {
            map["KeyPairNameList"] = self.keyPairNameList?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.securityGroupList != nil {
            map["SecurityGroupList"] = self.securityGroupList?.toMap()
        }
        if self.vpcInfoList != nil {
            map["VpcInfoList"] = self.vpcInfoList?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EmrMainVersionList") && dict["EmrMainVersionList"] != nil {
            var model = ListEmrAvailableConfigResponseBody.EmrMainVersionList()
            model.fromMap(dict["EmrMainVersionList"] as! [String: Any])
            self.emrMainVersionList = model
        }
        if dict.keys.contains("KeyPairNameList") && dict["KeyPairNameList"] != nil {
            var model = ListEmrAvailableConfigResponseBody.KeyPairNameList()
            model.fromMap(dict["KeyPairNameList"] as! [String: Any])
            self.keyPairNameList = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SecurityGroupList") && dict["SecurityGroupList"] != nil {
            var model = ListEmrAvailableConfigResponseBody.SecurityGroupList()
            model.fromMap(dict["SecurityGroupList"] as! [String: Any])
            self.securityGroupList = model
        }
        if dict.keys.contains("VpcInfoList") && dict["VpcInfoList"] != nil {
            var model = ListEmrAvailableConfigResponseBody.VpcInfoList()
            model.fromMap(dict["VpcInfoList"] as! [String: Any])
            self.vpcInfoList = model
        }
    }
}

public class ListEmrAvailableConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListEmrAvailableConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListEmrAvailableConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListEmrAvailableResourceRequest : Tea.TeaModel {
    public var clusterId: String?

    public var clusterType: String?

    public var dataDiskType: String?

    public var depositType: String?

    public var destinationResource: String?

    public var emrVersion: String?

    public var instanceChargeType: String?

    public var instanceType: String?

    public var netType: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerId: Int64?

    public var spotStrategy: String?

    public var systemDiskType: String?

    public var zoneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.clusterType != nil {
            map["ClusterType"] = self.clusterType!
        }
        if self.dataDiskType != nil {
            map["DataDiskType"] = self.dataDiskType!
        }
        if self.depositType != nil {
            map["DepositType"] = self.depositType!
        }
        if self.destinationResource != nil {
            map["DestinationResource"] = self.destinationResource!
        }
        if self.emrVersion != nil {
            map["EmrVersion"] = self.emrVersion!
        }
        if self.instanceChargeType != nil {
            map["InstanceChargeType"] = self.instanceChargeType!
        }
        if self.instanceType != nil {
            map["InstanceType"] = self.instanceType!
        }
        if self.netType != nil {
            map["NetType"] = self.netType!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.spotStrategy != nil {
            map["SpotStrategy"] = self.spotStrategy!
        }
        if self.systemDiskType != nil {
            map["SystemDiskType"] = self.systemDiskType!
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("ClusterType") && dict["ClusterType"] != nil {
            self.clusterType = dict["ClusterType"] as! String
        }
        if dict.keys.contains("DataDiskType") && dict["DataDiskType"] != nil {
            self.dataDiskType = dict["DataDiskType"] as! String
        }
        if dict.keys.contains("DepositType") && dict["DepositType"] != nil {
            self.depositType = dict["DepositType"] as! String
        }
        if dict.keys.contains("DestinationResource") && dict["DestinationResource"] != nil {
            self.destinationResource = dict["DestinationResource"] as! String
        }
        if dict.keys.contains("EmrVersion") && dict["EmrVersion"] != nil {
            self.emrVersion = dict["EmrVersion"] as! String
        }
        if dict.keys.contains("InstanceChargeType") && dict["InstanceChargeType"] != nil {
            self.instanceChargeType = dict["InstanceChargeType"] as! String
        }
        if dict.keys.contains("InstanceType") && dict["InstanceType"] != nil {
            self.instanceType = dict["InstanceType"] as! String
        }
        if dict.keys.contains("NetType") && dict["NetType"] != nil {
            self.netType = dict["NetType"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") && dict["ResourceGroupId"] != nil {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") && dict["ResourceOwnerId"] != nil {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("SpotStrategy") && dict["SpotStrategy"] != nil {
            self.spotStrategy = dict["SpotStrategy"] as! String
        }
        if dict.keys.contains("SystemDiskType") && dict["SystemDiskType"] != nil {
            self.systemDiskType = dict["SystemDiskType"] as! String
        }
        if dict.keys.contains("ZoneId") && dict["ZoneId"] != nil {
            self.zoneId = dict["ZoneId"] as! String
        }
    }
}

public class ListEmrAvailableResourceResponseBody : Tea.TeaModel {
    public class EmrZoneInfoList : Tea.TeaModel {
        public class EmrZoneInfo : Tea.TeaModel {
            public class EmrResourceInfoList : Tea.TeaModel {
                public class EmrResourceInfo : Tea.TeaModel {
                    public class SupportedResourceList : Tea.TeaModel {
                        public class SupportedResource : Tea.TeaModel {
                            public class EmrInstanceType : Tea.TeaModel {
                                public var baselineCredit: Int32?

                                public var cpuCoreCount: Int32?

                                public var eniQuantity: Int32?

                                public var GPUAmount: Int32?

                                public var GPUSpec: String?

                                public var initialCredit: Int32?

                                public var instanceBandwidthRx: Int32?

                                public var instanceBandwidthTx: Int32?

                                public var instancePpsRx: Int64?

                                public var instancePpsTx: Int64?

                                public var instanceType: String?

                                public var instanceTypeFamily: String?

                                public var localStorageAmount: Int32?

                                public var localStorageCapacity: Int64?

                                public var localStorageCategory: String?

                                public var memorySize: Int32?

                                public override init() {
                                    super.init()
                                }

                                public init(_ dict: [String: Any]) {
                                    super.init()
                                    self.fromMap(dict)
                                }

                                public override func validate() throws -> Void {
                                }

                                public override func toMap() -> [String : Any] {
                                    var map = super.toMap()
                                    if self.baselineCredit != nil {
                                        map["BaselineCredit"] = self.baselineCredit!
                                    }
                                    if self.cpuCoreCount != nil {
                                        map["CpuCoreCount"] = self.cpuCoreCount!
                                    }
                                    if self.eniQuantity != nil {
                                        map["EniQuantity"] = self.eniQuantity!
                                    }
                                    if self.GPUAmount != nil {
                                        map["GPUAmount"] = self.GPUAmount!
                                    }
                                    if self.GPUSpec != nil {
                                        map["GPUSpec"] = self.GPUSpec!
                                    }
                                    if self.initialCredit != nil {
                                        map["InitialCredit"] = self.initialCredit!
                                    }
                                    if self.instanceBandwidthRx != nil {
                                        map["InstanceBandwidthRx"] = self.instanceBandwidthRx!
                                    }
                                    if self.instanceBandwidthTx != nil {
                                        map["InstanceBandwidthTx"] = self.instanceBandwidthTx!
                                    }
                                    if self.instancePpsRx != nil {
                                        map["InstancePpsRx"] = self.instancePpsRx!
                                    }
                                    if self.instancePpsTx != nil {
                                        map["InstancePpsTx"] = self.instancePpsTx!
                                    }
                                    if self.instanceType != nil {
                                        map["InstanceType"] = self.instanceType!
                                    }
                                    if self.instanceTypeFamily != nil {
                                        map["InstanceTypeFamily"] = self.instanceTypeFamily!
                                    }
                                    if self.localStorageAmount != nil {
                                        map["LocalStorageAmount"] = self.localStorageAmount!
                                    }
                                    if self.localStorageCapacity != nil {
                                        map["LocalStorageCapacity"] = self.localStorageCapacity!
                                    }
                                    if self.localStorageCategory != nil {
                                        map["LocalStorageCategory"] = self.localStorageCategory!
                                    }
                                    if self.memorySize != nil {
                                        map["MemorySize"] = self.memorySize!
                                    }
                                    return map
                                }

                                public override func fromMap(_ dict: [String: Any]) -> Void {
                                    if dict.keys.contains("BaselineCredit") && dict["BaselineCredit"] != nil {
                                        self.baselineCredit = dict["BaselineCredit"] as! Int32
                                    }
                                    if dict.keys.contains("CpuCoreCount") && dict["CpuCoreCount"] != nil {
                                        self.cpuCoreCount = dict["CpuCoreCount"] as! Int32
                                    }
                                    if dict.keys.contains("EniQuantity") && dict["EniQuantity"] != nil {
                                        self.eniQuantity = dict["EniQuantity"] as! Int32
                                    }
                                    if dict.keys.contains("GPUAmount") && dict["GPUAmount"] != nil {
                                        self.GPUAmount = dict["GPUAmount"] as! Int32
                                    }
                                    if dict.keys.contains("GPUSpec") && dict["GPUSpec"] != nil {
                                        self.GPUSpec = dict["GPUSpec"] as! String
                                    }
                                    if dict.keys.contains("InitialCredit") && dict["InitialCredit"] != nil {
                                        self.initialCredit = dict["InitialCredit"] as! Int32
                                    }
                                    if dict.keys.contains("InstanceBandwidthRx") && dict["InstanceBandwidthRx"] != nil {
                                        self.instanceBandwidthRx = dict["InstanceBandwidthRx"] as! Int32
                                    }
                                    if dict.keys.contains("InstanceBandwidthTx") && dict["InstanceBandwidthTx"] != nil {
                                        self.instanceBandwidthTx = dict["InstanceBandwidthTx"] as! Int32
                                    }
                                    if dict.keys.contains("InstancePpsRx") && dict["InstancePpsRx"] != nil {
                                        self.instancePpsRx = dict["InstancePpsRx"] as! Int64
                                    }
                                    if dict.keys.contains("InstancePpsTx") && dict["InstancePpsTx"] != nil {
                                        self.instancePpsTx = dict["InstancePpsTx"] as! Int64
                                    }
                                    if dict.keys.contains("InstanceType") && dict["InstanceType"] != nil {
                                        self.instanceType = dict["InstanceType"] as! String
                                    }
                                    if dict.keys.contains("InstanceTypeFamily") && dict["InstanceTypeFamily"] != nil {
                                        self.instanceTypeFamily = dict["InstanceTypeFamily"] as! String
                                    }
                                    if dict.keys.contains("LocalStorageAmount") && dict["LocalStorageAmount"] != nil {
                                        self.localStorageAmount = dict["LocalStorageAmount"] as! Int32
                                    }
                                    if dict.keys.contains("LocalStorageCapacity") && dict["LocalStorageCapacity"] != nil {
                                        self.localStorageCapacity = dict["LocalStorageCapacity"] as! Int64
                                    }
                                    if dict.keys.contains("LocalStorageCategory") && dict["LocalStorageCategory"] != nil {
                                        self.localStorageCategory = dict["LocalStorageCategory"] as! String
                                    }
                                    if dict.keys.contains("MemorySize") && dict["MemorySize"] != nil {
                                        self.memorySize = dict["MemorySize"] as! Int32
                                    }
                                }
                            }
                            public class SupportNodeTypeList : Tea.TeaModel {
                                public var supportNodeType: [String]?

                                public override init() {
                                    super.init()
                                }

                                public init(_ dict: [String: Any]) {
                                    super.init()
                                    self.fromMap(dict)
                                }

                                public override func validate() throws -> Void {
                                }

                                public override func toMap() -> [String : Any] {
                                    var map = super.toMap()
                                    if self.supportNodeType != nil {
                                        map["SupportNodeType"] = self.supportNodeType!
                                    }
                                    return map
                                }

                                public override func fromMap(_ dict: [String: Any]) -> Void {
                                    if dict.keys.contains("SupportNodeType") && dict["SupportNodeType"] != nil {
                                        self.supportNodeType = dict["SupportNodeType"] as! [String]
                                    }
                                }
                            }
                            public var emrInstanceType: ListEmrAvailableResourceResponseBody.EmrZoneInfoList.EmrZoneInfo.EmrResourceInfoList.EmrResourceInfo.SupportedResourceList.SupportedResource.EmrInstanceType?

                            public var max: Int32?

                            public var min: Int32?

                            public var supportNodeTypeList: ListEmrAvailableResourceResponseBody.EmrZoneInfoList.EmrZoneInfo.EmrResourceInfoList.EmrResourceInfo.SupportedResourceList.SupportedResource.SupportNodeTypeList?

                            public var unit: String?

                            public var value: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                                try self.emrInstanceType?.validate()
                                try self.supportNodeTypeList?.validate()
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.emrInstanceType != nil {
                                    map["EmrInstanceType"] = self.emrInstanceType?.toMap()
                                }
                                if self.max != nil {
                                    map["Max"] = self.max!
                                }
                                if self.min != nil {
                                    map["Min"] = self.min!
                                }
                                if self.supportNodeTypeList != nil {
                                    map["SupportNodeTypeList"] = self.supportNodeTypeList?.toMap()
                                }
                                if self.unit != nil {
                                    map["Unit"] = self.unit!
                                }
                                if self.value != nil {
                                    map["Value"] = self.value!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("EmrInstanceType") && dict["EmrInstanceType"] != nil {
                                    var model = ListEmrAvailableResourceResponseBody.EmrZoneInfoList.EmrZoneInfo.EmrResourceInfoList.EmrResourceInfo.SupportedResourceList.SupportedResource.EmrInstanceType()
                                    model.fromMap(dict["EmrInstanceType"] as! [String: Any])
                                    self.emrInstanceType = model
                                }
                                if dict.keys.contains("Max") && dict["Max"] != nil {
                                    self.max = dict["Max"] as! Int32
                                }
                                if dict.keys.contains("Min") && dict["Min"] != nil {
                                    self.min = dict["Min"] as! Int32
                                }
                                if dict.keys.contains("SupportNodeTypeList") && dict["SupportNodeTypeList"] != nil {
                                    var model = ListEmrAvailableResourceResponseBody.EmrZoneInfoList.EmrZoneInfo.EmrResourceInfoList.EmrResourceInfo.SupportedResourceList.SupportedResource.SupportNodeTypeList()
                                    model.fromMap(dict["SupportNodeTypeList"] as! [String: Any])
                                    self.supportNodeTypeList = model
                                }
                                if dict.keys.contains("Unit") && dict["Unit"] != nil {
                                    self.unit = dict["Unit"] as! String
                                }
                                if dict.keys.contains("Value") && dict["Value"] != nil {
                                    self.value = dict["Value"] as! String
                                }
                            }
                        }
                        public var supportedResource: [ListEmrAvailableResourceResponseBody.EmrZoneInfoList.EmrZoneInfo.EmrResourceInfoList.EmrResourceInfo.SupportedResourceList.SupportedResource]?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.supportedResource != nil {
                                var tmp : [Any] = []
                                for k in self.supportedResource! {
                                    tmp.append(k.toMap())
                                }
                                map["SupportedResource"] = tmp
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("SupportedResource") && dict["SupportedResource"] != nil {
                                var tmp : [ListEmrAvailableResourceResponseBody.EmrZoneInfoList.EmrZoneInfo.EmrResourceInfoList.EmrResourceInfo.SupportedResourceList.SupportedResource] = []
                                for v in dict["SupportedResource"] as! [Any] {
                                    var model = ListEmrAvailableResourceResponseBody.EmrZoneInfoList.EmrZoneInfo.EmrResourceInfoList.EmrResourceInfo.SupportedResourceList.SupportedResource()
                                    if v != nil {
                                        model.fromMap(v as! [String: Any])
                                    }
                                    tmp.append(model)
                                }
                                self.supportedResource = tmp
                            }
                        }
                    }
                    public var supportedResourceList: ListEmrAvailableResourceResponseBody.EmrZoneInfoList.EmrZoneInfo.EmrResourceInfoList.EmrResourceInfo.SupportedResourceList?

                    public var type: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.supportedResourceList?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.supportedResourceList != nil {
                            map["SupportedResourceList"] = self.supportedResourceList?.toMap()
                        }
                        if self.type != nil {
                            map["Type"] = self.type!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("SupportedResourceList") && dict["SupportedResourceList"] != nil {
                            var model = ListEmrAvailableResourceResponseBody.EmrZoneInfoList.EmrZoneInfo.EmrResourceInfoList.EmrResourceInfo.SupportedResourceList()
                            model.fromMap(dict["SupportedResourceList"] as! [String: Any])
                            self.supportedResourceList = model
                        }
                        if dict.keys.contains("Type") && dict["Type"] != nil {
                            self.type = dict["Type"] as! String
                        }
                    }
                }
                public var emrResourceInfo: [ListEmrAvailableResourceResponseBody.EmrZoneInfoList.EmrZoneInfo.EmrResourceInfoList.EmrResourceInfo]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.emrResourceInfo != nil {
                        var tmp : [Any] = []
                        for k in self.emrResourceInfo! {
                            tmp.append(k.toMap())
                        }
                        map["EmrResourceInfo"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("EmrResourceInfo") && dict["EmrResourceInfo"] != nil {
                        var tmp : [ListEmrAvailableResourceResponseBody.EmrZoneInfoList.EmrZoneInfo.EmrResourceInfoList.EmrResourceInfo] = []
                        for v in dict["EmrResourceInfo"] as! [Any] {
                            var model = ListEmrAvailableResourceResponseBody.EmrZoneInfoList.EmrZoneInfo.EmrResourceInfoList.EmrResourceInfo()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.emrResourceInfo = tmp
                    }
                }
            }
            public var emrResourceInfoList: ListEmrAvailableResourceResponseBody.EmrZoneInfoList.EmrZoneInfo.EmrResourceInfoList?

            public var zoneId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.emrResourceInfoList?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.emrResourceInfoList != nil {
                    map["EmrResourceInfoList"] = self.emrResourceInfoList?.toMap()
                }
                if self.zoneId != nil {
                    map["ZoneId"] = self.zoneId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("EmrResourceInfoList") && dict["EmrResourceInfoList"] != nil {
                    var model = ListEmrAvailableResourceResponseBody.EmrZoneInfoList.EmrZoneInfo.EmrResourceInfoList()
                    model.fromMap(dict["EmrResourceInfoList"] as! [String: Any])
                    self.emrResourceInfoList = model
                }
                if dict.keys.contains("ZoneId") && dict["ZoneId"] != nil {
                    self.zoneId = dict["ZoneId"] as! String
                }
            }
        }
        public var emrZoneInfo: [ListEmrAvailableResourceResponseBody.EmrZoneInfoList.EmrZoneInfo]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.emrZoneInfo != nil {
                var tmp : [Any] = []
                for k in self.emrZoneInfo! {
                    tmp.append(k.toMap())
                }
                map["EmrZoneInfo"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EmrZoneInfo") && dict["EmrZoneInfo"] != nil {
                var tmp : [ListEmrAvailableResourceResponseBody.EmrZoneInfoList.EmrZoneInfo] = []
                for v in dict["EmrZoneInfo"] as! [Any] {
                    var model = ListEmrAvailableResourceResponseBody.EmrZoneInfoList.EmrZoneInfo()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.emrZoneInfo = tmp
            }
        }
    }
    public var emrZoneInfoList: ListEmrAvailableResourceResponseBody.EmrZoneInfoList?

    public var regionId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.emrZoneInfoList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.emrZoneInfoList != nil {
            map["EmrZoneInfoList"] = self.emrZoneInfoList?.toMap()
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EmrZoneInfoList") && dict["EmrZoneInfoList"] != nil {
            var model = ListEmrAvailableResourceResponseBody.EmrZoneInfoList()
            model.fromMap(dict["EmrZoneInfoList"] as! [String: Any])
            self.emrZoneInfoList = model
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListEmrAvailableResourceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListEmrAvailableResourceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListEmrAvailableResourceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListEmrMainVersionRequest : Tea.TeaModel {
    public var emrVersion: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceOwnerId: Int64?

    public var stackName: String?

    public var stackVersion: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.emrVersion != nil {
            map["EmrVersion"] = self.emrVersion!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.stackName != nil {
            map["StackName"] = self.stackName!
        }
        if self.stackVersion != nil {
            map["StackVersion"] = self.stackVersion!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EmrVersion") && dict["EmrVersion"] != nil {
            self.emrVersion = dict["EmrVersion"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") && dict["ResourceOwnerId"] != nil {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("StackName") && dict["StackName"] != nil {
            self.stackName = dict["StackName"] as! String
        }
        if dict.keys.contains("StackVersion") && dict["StackVersion"] != nil {
            self.stackVersion = dict["StackVersion"] as! String
        }
    }
}

public class ListEmrMainVersionResponseBody : Tea.TeaModel {
    public class EmrMainVersionList : Tea.TeaModel {
        public class EmrMainVersion : Tea.TeaModel {
            public class ClusterTypeInfoList : Tea.TeaModel {
                public class ClusterTypeInfo : Tea.TeaModel {
                    public class ServiceInfoList : Tea.TeaModel {
                        public class ServiceInfo : Tea.TeaModel {
                            public var display: Bool?

                            public var mandatory: Bool?

                            public var serviceDisplayName: String?

                            public var serviceDisplayVersion: String?

                            public var serviceName: String?

                            public var serviceVersion: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.display != nil {
                                    map["Display"] = self.display!
                                }
                                if self.mandatory != nil {
                                    map["Mandatory"] = self.mandatory!
                                }
                                if self.serviceDisplayName != nil {
                                    map["ServiceDisplayName"] = self.serviceDisplayName!
                                }
                                if self.serviceDisplayVersion != nil {
                                    map["ServiceDisplayVersion"] = self.serviceDisplayVersion!
                                }
                                if self.serviceName != nil {
                                    map["ServiceName"] = self.serviceName!
                                }
                                if self.serviceVersion != nil {
                                    map["ServiceVersion"] = self.serviceVersion!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Display") && dict["Display"] != nil {
                                    self.display = dict["Display"] as! Bool
                                }
                                if dict.keys.contains("Mandatory") && dict["Mandatory"] != nil {
                                    self.mandatory = dict["Mandatory"] as! Bool
                                }
                                if dict.keys.contains("ServiceDisplayName") && dict["ServiceDisplayName"] != nil {
                                    self.serviceDisplayName = dict["ServiceDisplayName"] as! String
                                }
                                if dict.keys.contains("ServiceDisplayVersion") && dict["ServiceDisplayVersion"] != nil {
                                    self.serviceDisplayVersion = dict["ServiceDisplayVersion"] as! String
                                }
                                if dict.keys.contains("ServiceName") && dict["ServiceName"] != nil {
                                    self.serviceName = dict["ServiceName"] as! String
                                }
                                if dict.keys.contains("ServiceVersion") && dict["ServiceVersion"] != nil {
                                    self.serviceVersion = dict["ServiceVersion"] as! String
                                }
                            }
                        }
                        public var serviceInfo: [ListEmrMainVersionResponseBody.EmrMainVersionList.EmrMainVersion.ClusterTypeInfoList.ClusterTypeInfo.ServiceInfoList.ServiceInfo]?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.serviceInfo != nil {
                                var tmp : [Any] = []
                                for k in self.serviceInfo! {
                                    tmp.append(k.toMap())
                                }
                                map["ServiceInfo"] = tmp
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("ServiceInfo") && dict["ServiceInfo"] != nil {
                                var tmp : [ListEmrMainVersionResponseBody.EmrMainVersionList.EmrMainVersion.ClusterTypeInfoList.ClusterTypeInfo.ServiceInfoList.ServiceInfo] = []
                                for v in dict["ServiceInfo"] as! [Any] {
                                    var model = ListEmrMainVersionResponseBody.EmrMainVersionList.EmrMainVersion.ClusterTypeInfoList.ClusterTypeInfo.ServiceInfoList.ServiceInfo()
                                    if v != nil {
                                        model.fromMap(v as! [String: Any])
                                    }
                                    tmp.append(model)
                                }
                                self.serviceInfo = tmp
                            }
                        }
                    }
                    public var clusterType: String?

                    public var serviceInfoList: ListEmrMainVersionResponseBody.EmrMainVersionList.EmrMainVersion.ClusterTypeInfoList.ClusterTypeInfo.ServiceInfoList?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.serviceInfoList?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.clusterType != nil {
                            map["ClusterType"] = self.clusterType!
                        }
                        if self.serviceInfoList != nil {
                            map["ServiceInfoList"] = self.serviceInfoList?.toMap()
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("ClusterType") && dict["ClusterType"] != nil {
                            self.clusterType = dict["ClusterType"] as! String
                        }
                        if dict.keys.contains("ServiceInfoList") && dict["ServiceInfoList"] != nil {
                            var model = ListEmrMainVersionResponseBody.EmrMainVersionList.EmrMainVersion.ClusterTypeInfoList.ClusterTypeInfo.ServiceInfoList()
                            model.fromMap(dict["ServiceInfoList"] as! [String: Any])
                            self.serviceInfoList = model
                        }
                    }
                }
                public var clusterTypeInfo: [ListEmrMainVersionResponseBody.EmrMainVersionList.EmrMainVersion.ClusterTypeInfoList.ClusterTypeInfo]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.clusterTypeInfo != nil {
                        var tmp : [Any] = []
                        for k in self.clusterTypeInfo! {
                            tmp.append(k.toMap())
                        }
                        map["ClusterTypeInfo"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ClusterTypeInfo") && dict["ClusterTypeInfo"] != nil {
                        var tmp : [ListEmrMainVersionResponseBody.EmrMainVersionList.EmrMainVersion.ClusterTypeInfoList.ClusterTypeInfo] = []
                        for v in dict["ClusterTypeInfo"] as! [Any] {
                            var model = ListEmrMainVersionResponseBody.EmrMainVersionList.EmrMainVersion.ClusterTypeInfoList.ClusterTypeInfo()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.clusterTypeInfo = tmp
                    }
                }
            }
            public class ClusterTypeWhiteUserList : Tea.TeaModel {
                public class ClusterTypeWhiteUser : Tea.TeaModel {
                    public var clusterType: String?

                    public var userId: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.clusterType != nil {
                            map["ClusterType"] = self.clusterType!
                        }
                        if self.userId != nil {
                            map["UserId"] = self.userId!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("ClusterType") && dict["ClusterType"] != nil {
                            self.clusterType = dict["ClusterType"] as! String
                        }
                        if dict.keys.contains("UserId") && dict["UserId"] != nil {
                            self.userId = dict["UserId"] as! String
                        }
                    }
                }
                public var clusterTypeWhiteUser: [ListEmrMainVersionResponseBody.EmrMainVersionList.EmrMainVersion.ClusterTypeWhiteUserList.ClusterTypeWhiteUser]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.clusterTypeWhiteUser != nil {
                        var tmp : [Any] = []
                        for k in self.clusterTypeWhiteUser! {
                            tmp.append(k.toMap())
                        }
                        map["ClusterTypeWhiteUser"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ClusterTypeWhiteUser") && dict["ClusterTypeWhiteUser"] != nil {
                        var tmp : [ListEmrMainVersionResponseBody.EmrMainVersionList.EmrMainVersion.ClusterTypeWhiteUserList.ClusterTypeWhiteUser] = []
                        for v in dict["ClusterTypeWhiteUser"] as! [Any] {
                            var model = ListEmrMainVersionResponseBody.EmrMainVersionList.EmrMainVersion.ClusterTypeWhiteUserList.ClusterTypeWhiteUser()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.clusterTypeWhiteUser = tmp
                    }
                }
            }
            public class WhiteUserList : Tea.TeaModel {
                public var whiteUser: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.whiteUser != nil {
                        map["WhiteUser"] = self.whiteUser!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("WhiteUser") && dict["WhiteUser"] != nil {
                        self.whiteUser = dict["WhiteUser"] as! [String]
                    }
                }
            }
            public var clusterTypeInfoList: ListEmrMainVersionResponseBody.EmrMainVersionList.EmrMainVersion.ClusterTypeInfoList?

            public var clusterTypeWhiteUserList: ListEmrMainVersionResponseBody.EmrMainVersionList.EmrMainVersion.ClusterTypeWhiteUserList?

            public var display: Bool?

            public var ecmVersion: Bool?

            public var emrVersion: String?

            public var imageId: String?

            public var publishType: String?

            public var regionId: String?

            public var stackName: String?

            public var stackVersion: String?

            public var whiteUserList: ListEmrMainVersionResponseBody.EmrMainVersionList.EmrMainVersion.WhiteUserList?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.clusterTypeInfoList?.validate()
                try self.clusterTypeWhiteUserList?.validate()
                try self.whiteUserList?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.clusterTypeInfoList != nil {
                    map["ClusterTypeInfoList"] = self.clusterTypeInfoList?.toMap()
                }
                if self.clusterTypeWhiteUserList != nil {
                    map["ClusterTypeWhiteUserList"] = self.clusterTypeWhiteUserList?.toMap()
                }
                if self.display != nil {
                    map["Display"] = self.display!
                }
                if self.ecmVersion != nil {
                    map["EcmVersion"] = self.ecmVersion!
                }
                if self.emrVersion != nil {
                    map["EmrVersion"] = self.emrVersion!
                }
                if self.imageId != nil {
                    map["ImageId"] = self.imageId!
                }
                if self.publishType != nil {
                    map["PublishType"] = self.publishType!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.stackName != nil {
                    map["StackName"] = self.stackName!
                }
                if self.stackVersion != nil {
                    map["StackVersion"] = self.stackVersion!
                }
                if self.whiteUserList != nil {
                    map["WhiteUserList"] = self.whiteUserList?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ClusterTypeInfoList") && dict["ClusterTypeInfoList"] != nil {
                    var model = ListEmrMainVersionResponseBody.EmrMainVersionList.EmrMainVersion.ClusterTypeInfoList()
                    model.fromMap(dict["ClusterTypeInfoList"] as! [String: Any])
                    self.clusterTypeInfoList = model
                }
                if dict.keys.contains("ClusterTypeWhiteUserList") && dict["ClusterTypeWhiteUserList"] != nil {
                    var model = ListEmrMainVersionResponseBody.EmrMainVersionList.EmrMainVersion.ClusterTypeWhiteUserList()
                    model.fromMap(dict["ClusterTypeWhiteUserList"] as! [String: Any])
                    self.clusterTypeWhiteUserList = model
                }
                if dict.keys.contains("Display") && dict["Display"] != nil {
                    self.display = dict["Display"] as! Bool
                }
                if dict.keys.contains("EcmVersion") && dict["EcmVersion"] != nil {
                    self.ecmVersion = dict["EcmVersion"] as! Bool
                }
                if dict.keys.contains("EmrVersion") && dict["EmrVersion"] != nil {
                    self.emrVersion = dict["EmrVersion"] as! String
                }
                if dict.keys.contains("ImageId") && dict["ImageId"] != nil {
                    self.imageId = dict["ImageId"] as! String
                }
                if dict.keys.contains("PublishType") && dict["PublishType"] != nil {
                    self.publishType = dict["PublishType"] as! String
                }
                if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("StackName") && dict["StackName"] != nil {
                    self.stackName = dict["StackName"] as! String
                }
                if dict.keys.contains("StackVersion") && dict["StackVersion"] != nil {
                    self.stackVersion = dict["StackVersion"] as! String
                }
                if dict.keys.contains("WhiteUserList") && dict["WhiteUserList"] != nil {
                    var model = ListEmrMainVersionResponseBody.EmrMainVersionList.EmrMainVersion.WhiteUserList()
                    model.fromMap(dict["WhiteUserList"] as! [String: Any])
                    self.whiteUserList = model
                }
            }
        }
        public var emrMainVersion: [ListEmrMainVersionResponseBody.EmrMainVersionList.EmrMainVersion]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.emrMainVersion != nil {
                var tmp : [Any] = []
                for k in self.emrMainVersion! {
                    tmp.append(k.toMap())
                }
                map["EmrMainVersion"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EmrMainVersion") && dict["EmrMainVersion"] != nil {
                var tmp : [ListEmrMainVersionResponseBody.EmrMainVersionList.EmrMainVersion] = []
                for v in dict["EmrMainVersion"] as! [Any] {
                    var model = ListEmrMainVersionResponseBody.EmrMainVersionList.EmrMainVersion()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.emrMainVersion = tmp
            }
        }
    }
    public var emrMainVersionList: ListEmrMainVersionResponseBody.EmrMainVersionList?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.emrMainVersionList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.emrMainVersionList != nil {
            map["EmrMainVersionList"] = self.emrMainVersionList?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EmrMainVersionList") && dict["EmrMainVersionList"] != nil {
            var model = ListEmrMainVersionResponseBody.EmrMainVersionList()
            model.fromMap(dict["EmrMainVersionList"] as! [String: Any])
            self.emrMainVersionList = model
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class ListEmrMainVersionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListEmrMainVersionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListEmrMainVersionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListFlowRequest : Tea.TeaModel {
    public var clusterId: String?

    public var id: String?

    public var jobId: String?

    public var name: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var periodic: Bool?

    public var projectId: String?

    public var regionId: String?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.periodic != nil {
            map["Periodic"] = self.periodic!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! String
        }
        if dict.keys.contains("JobId") && dict["JobId"] != nil {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("Periodic") && dict["Periodic"] != nil {
            self.periodic = dict["Periodic"] as! Bool
        }
        if dict.keys.contains("ProjectId") && dict["ProjectId"] != nil {
            self.projectId = dict["ProjectId"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("Status") && dict["Status"] != nil {
            self.status = dict["Status"] as! String
        }
    }
}

public class ListFlowResponseBody : Tea.TeaModel {
    public class Flow : Tea.TeaModel {
        public class Flow : Tea.TeaModel {
            public var alertConf: String?

            public var alertDingDingGroupBizId: String?

            public var alertUserGroupBizId: String?

            public var categoryId: String?

            public var clusterId: String?

            public var createCluster: Bool?

            public var cronExpr: String?

            public var description_: String?

            public var endSchedule: Int64?

            public var gmtCreate: Int64?

            public var gmtModified: Int64?

            public var graph: String?

            public var hostName: String?

            public var id: String?

            public var name: String?

            public var periodic: Bool?

            public var projectId: String?

            public var startSchedule: Int64?

            public var status: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.alertConf != nil {
                    map["AlertConf"] = self.alertConf!
                }
                if self.alertDingDingGroupBizId != nil {
                    map["AlertDingDingGroupBizId"] = self.alertDingDingGroupBizId!
                }
                if self.alertUserGroupBizId != nil {
                    map["AlertUserGroupBizId"] = self.alertUserGroupBizId!
                }
                if self.categoryId != nil {
                    map["CategoryId"] = self.categoryId!
                }
                if self.clusterId != nil {
                    map["ClusterId"] = self.clusterId!
                }
                if self.createCluster != nil {
                    map["CreateCluster"] = self.createCluster!
                }
                if self.cronExpr != nil {
                    map["CronExpr"] = self.cronExpr!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.endSchedule != nil {
                    map["EndSchedule"] = self.endSchedule!
                }
                if self.gmtCreate != nil {
                    map["GmtCreate"] = self.gmtCreate!
                }
                if self.gmtModified != nil {
                    map["GmtModified"] = self.gmtModified!
                }
                if self.graph != nil {
                    map["Graph"] = self.graph!
                }
                if self.hostName != nil {
                    map["HostName"] = self.hostName!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.periodic != nil {
                    map["Periodic"] = self.periodic!
                }
                if self.projectId != nil {
                    map["ProjectId"] = self.projectId!
                }
                if self.startSchedule != nil {
                    map["StartSchedule"] = self.startSchedule!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AlertConf") && dict["AlertConf"] != nil {
                    self.alertConf = dict["AlertConf"] as! String
                }
                if dict.keys.contains("AlertDingDingGroupBizId") && dict["AlertDingDingGroupBizId"] != nil {
                    self.alertDingDingGroupBizId = dict["AlertDingDingGroupBizId"] as! String
                }
                if dict.keys.contains("AlertUserGroupBizId") && dict["AlertUserGroupBizId"] != nil {
                    self.alertUserGroupBizId = dict["AlertUserGroupBizId"] as! String
                }
                if dict.keys.contains("CategoryId") && dict["CategoryId"] != nil {
                    self.categoryId = dict["CategoryId"] as! String
                }
                if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
                    self.clusterId = dict["ClusterId"] as! String
                }
                if dict.keys.contains("CreateCluster") && dict["CreateCluster"] != nil {
                    self.createCluster = dict["CreateCluster"] as! Bool
                }
                if dict.keys.contains("CronExpr") && dict["CronExpr"] != nil {
                    self.cronExpr = dict["CronExpr"] as! String
                }
                if dict.keys.contains("Description") && dict["Description"] != nil {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("EndSchedule") && dict["EndSchedule"] != nil {
                    self.endSchedule = dict["EndSchedule"] as! Int64
                }
                if dict.keys.contains("GmtCreate") && dict["GmtCreate"] != nil {
                    self.gmtCreate = dict["GmtCreate"] as! Int64
                }
                if dict.keys.contains("GmtModified") && dict["GmtModified"] != nil {
                    self.gmtModified = dict["GmtModified"] as! Int64
                }
                if dict.keys.contains("Graph") && dict["Graph"] != nil {
                    self.graph = dict["Graph"] as! String
                }
                if dict.keys.contains("HostName") && dict["HostName"] != nil {
                    self.hostName = dict["HostName"] as! String
                }
                if dict.keys.contains("Id") && dict["Id"] != nil {
                    self.id = dict["Id"] as! String
                }
                if dict.keys.contains("Name") && dict["Name"] != nil {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Periodic") && dict["Periodic"] != nil {
                    self.periodic = dict["Periodic"] as! Bool
                }
                if dict.keys.contains("ProjectId") && dict["ProjectId"] != nil {
                    self.projectId = dict["ProjectId"] as! String
                }
                if dict.keys.contains("StartSchedule") && dict["StartSchedule"] != nil {
                    self.startSchedule = dict["StartSchedule"] as! Int64
                }
                if dict.keys.contains("Status") && dict["Status"] != nil {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var flow: [ListFlowResponseBody.Flow.Flow]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.flow != nil {
                var tmp : [Any] = []
                for k in self.flow! {
                    tmp.append(k.toMap())
                }
                map["Flow"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Flow") && dict["Flow"] != nil {
                var tmp : [ListFlowResponseBody.Flow.Flow] = []
                for v in dict["Flow"] as! [Any] {
                    var model = ListFlowResponseBody.Flow.Flow()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.flow = tmp
            }
        }
    }
    public var flow: ListFlowResponseBody.Flow?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var total: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.flow?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.flow != nil {
            map["Flow"] = self.flow?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.total != nil {
            map["Total"] = self.total!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Flow") && dict["Flow"] != nil {
            var model = ListFlowResponseBody.Flow()
            model.fromMap(dict["Flow"] as! [String: Any])
            self.flow = model
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Total") && dict["Total"] != nil {
            self.total = dict["Total"] as! Int32
        }
    }
}

public class ListFlowResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListFlowResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListFlowResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListFlowCategoryRequest : Tea.TeaModel {
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var parentId: String?

    public var projectId: String?

    public var regionId: String?

    public var root: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.parentId != nil {
            map["ParentId"] = self.parentId!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.root != nil {
            map["Root"] = self.root!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("ParentId") && dict["ParentId"] != nil {
            self.parentId = dict["ParentId"] as! String
        }
        if dict.keys.contains("ProjectId") && dict["ProjectId"] != nil {
            self.projectId = dict["ProjectId"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("Root") && dict["Root"] != nil {
            self.root = dict["Root"] as! Bool
        }
    }
}

public class ListFlowCategoryResponseBody : Tea.TeaModel {
    public class Categories : Tea.TeaModel {
        public class Category : Tea.TeaModel {
            public var categoryType: String?

            public var gmtCreate: Int64?

            public var gmtModified: Int64?

            public var id: String?

            public var name: String?

            public var objectId: String?

            public var objectType: String?

            public var parentId: String?

            public var projectId: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.categoryType != nil {
                    map["CategoryType"] = self.categoryType!
                }
                if self.gmtCreate != nil {
                    map["GmtCreate"] = self.gmtCreate!
                }
                if self.gmtModified != nil {
                    map["GmtModified"] = self.gmtModified!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.objectId != nil {
                    map["ObjectId"] = self.objectId!
                }
                if self.objectType != nil {
                    map["ObjectType"] = self.objectType!
                }
                if self.parentId != nil {
                    map["ParentId"] = self.parentId!
                }
                if self.projectId != nil {
                    map["ProjectId"] = self.projectId!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CategoryType") && dict["CategoryType"] != nil {
                    self.categoryType = dict["CategoryType"] as! String
                }
                if dict.keys.contains("GmtCreate") && dict["GmtCreate"] != nil {
                    self.gmtCreate = dict["GmtCreate"] as! Int64
                }
                if dict.keys.contains("GmtModified") && dict["GmtModified"] != nil {
                    self.gmtModified = dict["GmtModified"] as! Int64
                }
                if dict.keys.contains("Id") && dict["Id"] != nil {
                    self.id = dict["Id"] as! String
                }
                if dict.keys.contains("Name") && dict["Name"] != nil {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("ObjectId") && dict["ObjectId"] != nil {
                    self.objectId = dict["ObjectId"] as! String
                }
                if dict.keys.contains("ObjectType") && dict["ObjectType"] != nil {
                    self.objectType = dict["ObjectType"] as! String
                }
                if dict.keys.contains("ParentId") && dict["ParentId"] != nil {
                    self.parentId = dict["ParentId"] as! String
                }
                if dict.keys.contains("ProjectId") && dict["ProjectId"] != nil {
                    self.projectId = dict["ProjectId"] as! String
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var category: [ListFlowCategoryResponseBody.Categories.Category]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.category != nil {
                var tmp : [Any] = []
                for k in self.category! {
                    tmp.append(k.toMap())
                }
                map["Category"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Category") && dict["Category"] != nil {
                var tmp : [ListFlowCategoryResponseBody.Categories.Category] = []
                for v in dict["Category"] as! [Any] {
                    var model = ListFlowCategoryResponseBody.Categories.Category()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.category = tmp
            }
        }
    }
    public var categories: ListFlowCategoryResponseBody.Categories?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var total: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.categories?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.categories != nil {
            map["Categories"] = self.categories?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.total != nil {
            map["Total"] = self.total!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Categories") && dict["Categories"] != nil {
            var model = ListFlowCategoryResponseBody.Categories()
            model.fromMap(dict["Categories"] as! [String: Any])
            self.categories = model
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Total") && dict["Total"] != nil {
            self.total = dict["Total"] as! Int32
        }
    }
}

public class ListFlowCategoryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListFlowCategoryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListFlowCategoryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListFlowClusterRequest : Tea.TeaModel {
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var projectId: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("ProjectId") && dict["ProjectId"] != nil {
            self.projectId = dict["ProjectId"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") && dict["ResourceGroupId"] != nil {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
    }
}

public class ListFlowClusterResponseBody : Tea.TeaModel {
    public class Clusters : Tea.TeaModel {
        public class ClusterInfo : Tea.TeaModel {
            public class FailReason : Tea.TeaModel {
                public var errorCode: String?

                public var errorMsg: String?

                public var requestId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.errorCode != nil {
                        map["ErrorCode"] = self.errorCode!
                    }
                    if self.errorMsg != nil {
                        map["ErrorMsg"] = self.errorMsg!
                    }
                    if self.requestId != nil {
                        map["RequestId"] = self.requestId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
                        self.errorCode = dict["ErrorCode"] as! String
                    }
                    if dict.keys.contains("ErrorMsg") && dict["ErrorMsg"] != nil {
                        self.errorMsg = dict["ErrorMsg"] as! String
                    }
                    if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
                        self.requestId = dict["RequestId"] as! String
                    }
                }
            }
            public class OrderTaskInfo : Tea.TeaModel {
                public var currentCount: Int32?

                public var orderIdList: String?

                public var targetCount: Int32?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.currentCount != nil {
                        map["CurrentCount"] = self.currentCount!
                    }
                    if self.orderIdList != nil {
                        map["OrderIdList"] = self.orderIdList!
                    }
                    if self.targetCount != nil {
                        map["TargetCount"] = self.targetCount!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("CurrentCount") && dict["CurrentCount"] != nil {
                        self.currentCount = dict["CurrentCount"] as! Int32
                    }
                    if dict.keys.contains("OrderIdList") && dict["OrderIdList"] != nil {
                        self.orderIdList = dict["OrderIdList"] as! String
                    }
                    if dict.keys.contains("TargetCount") && dict["TargetCount"] != nil {
                        self.targetCount = dict["TargetCount"] as! Int32
                    }
                }
            }
            public var chargeType: String?

            public var createResource: String?

            public var createTime: Int64?

            public var expiredTime: Int64?

            public var failReason: ListFlowClusterResponseBody.Clusters.ClusterInfo.FailReason?

            public var hasUncompletedOrder: Bool?

            public var id: String?

            public var k8sClusterId: String?

            public var name: String?

            public var orderList: String?

            public var orderTaskInfo: ListFlowClusterResponseBody.Clusters.ClusterInfo.OrderTaskInfo?

            public var period: Int32?

            public var runningTime: Int32?

            public var status: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.failReason?.validate()
                try self.orderTaskInfo?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.chargeType != nil {
                    map["ChargeType"] = self.chargeType!
                }
                if self.createResource != nil {
                    map["CreateResource"] = self.createResource!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.expiredTime != nil {
                    map["ExpiredTime"] = self.expiredTime!
                }
                if self.failReason != nil {
                    map["FailReason"] = self.failReason?.toMap()
                }
                if self.hasUncompletedOrder != nil {
                    map["HasUncompletedOrder"] = self.hasUncompletedOrder!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.k8sClusterId != nil {
                    map["K8sClusterId"] = self.k8sClusterId!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.orderList != nil {
                    map["OrderList"] = self.orderList!
                }
                if self.orderTaskInfo != nil {
                    map["OrderTaskInfo"] = self.orderTaskInfo?.toMap()
                }
                if self.period != nil {
                    map["Period"] = self.period!
                }
                if self.runningTime != nil {
                    map["RunningTime"] = self.runningTime!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ChargeType") && dict["ChargeType"] != nil {
                    self.chargeType = dict["ChargeType"] as! String
                }
                if dict.keys.contains("CreateResource") && dict["CreateResource"] != nil {
                    self.createResource = dict["CreateResource"] as! String
                }
                if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                    self.createTime = dict["CreateTime"] as! Int64
                }
                if dict.keys.contains("ExpiredTime") && dict["ExpiredTime"] != nil {
                    self.expiredTime = dict["ExpiredTime"] as! Int64
                }
                if dict.keys.contains("FailReason") && dict["FailReason"] != nil {
                    var model = ListFlowClusterResponseBody.Clusters.ClusterInfo.FailReason()
                    model.fromMap(dict["FailReason"] as! [String: Any])
                    self.failReason = model
                }
                if dict.keys.contains("HasUncompletedOrder") && dict["HasUncompletedOrder"] != nil {
                    self.hasUncompletedOrder = dict["HasUncompletedOrder"] as! Bool
                }
                if dict.keys.contains("Id") && dict["Id"] != nil {
                    self.id = dict["Id"] as! String
                }
                if dict.keys.contains("K8sClusterId") && dict["K8sClusterId"] != nil {
                    self.k8sClusterId = dict["K8sClusterId"] as! String
                }
                if dict.keys.contains("Name") && dict["Name"] != nil {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("OrderList") && dict["OrderList"] != nil {
                    self.orderList = dict["OrderList"] as! String
                }
                if dict.keys.contains("OrderTaskInfo") && dict["OrderTaskInfo"] != nil {
                    var model = ListFlowClusterResponseBody.Clusters.ClusterInfo.OrderTaskInfo()
                    model.fromMap(dict["OrderTaskInfo"] as! [String: Any])
                    self.orderTaskInfo = model
                }
                if dict.keys.contains("Period") && dict["Period"] != nil {
                    self.period = dict["Period"] as! Int32
                }
                if dict.keys.contains("RunningTime") && dict["RunningTime"] != nil {
                    self.runningTime = dict["RunningTime"] as! Int32
                }
                if dict.keys.contains("Status") && dict["Status"] != nil {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var clusterInfo: [ListFlowClusterResponseBody.Clusters.ClusterInfo]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.clusterInfo != nil {
                var tmp : [Any] = []
                for k in self.clusterInfo! {
                    tmp.append(k.toMap())
                }
                map["ClusterInfo"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ClusterInfo") && dict["ClusterInfo"] != nil {
                var tmp : [ListFlowClusterResponseBody.Clusters.ClusterInfo] = []
                for v in dict["ClusterInfo"] as! [Any] {
                    var model = ListFlowClusterResponseBody.Clusters.ClusterInfo()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.clusterInfo = tmp
            }
        }
    }
    public var clusters: ListFlowClusterResponseBody.Clusters?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.clusters?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusters != nil {
            map["Clusters"] = self.clusters?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Clusters") && dict["Clusters"] != nil {
            var model = ListFlowClusterResponseBody.Clusters()
            model.fromMap(dict["Clusters"] as! [String: Any])
            self.clusters = model
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class ListFlowClusterResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListFlowClusterResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListFlowClusterResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListFlowClusterAllRequest : Tea.TeaModel {
    public var productType: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.productType != nil {
            map["ProductType"] = self.productType!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ProductType") && dict["ProductType"] != nil {
            self.productType = dict["ProductType"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") && dict["ResourceGroupId"] != nil {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
    }
}

public class ListFlowClusterAllResponseBody : Tea.TeaModel {
    public class Clusters : Tea.TeaModel {
        public class ClusterInfo : Tea.TeaModel {
            public class FailReason : Tea.TeaModel {
                public var errorCode: String?

                public var errorMsg: String?

                public var requestId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.errorCode != nil {
                        map["ErrorCode"] = self.errorCode!
                    }
                    if self.errorMsg != nil {
                        map["ErrorMsg"] = self.errorMsg!
                    }
                    if self.requestId != nil {
                        map["RequestId"] = self.requestId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ErrorCode") && dict["ErrorCode"] != nil {
                        self.errorCode = dict["ErrorCode"] as! String
                    }
                    if dict.keys.contains("ErrorMsg") && dict["ErrorMsg"] != nil {
                        self.errorMsg = dict["ErrorMsg"] as! String
                    }
                    if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
                        self.requestId = dict["RequestId"] as! String
                    }
                }
            }
            public class OrderTaskInfo : Tea.TeaModel {
                public var currentCount: Int32?

                public var orderIdList: String?

                public var targetCount: Int32?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.currentCount != nil {
                        map["CurrentCount"] = self.currentCount!
                    }
                    if self.orderIdList != nil {
                        map["OrderIdList"] = self.orderIdList!
                    }
                    if self.targetCount != nil {
                        map["TargetCount"] = self.targetCount!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("CurrentCount") && dict["CurrentCount"] != nil {
                        self.currentCount = dict["CurrentCount"] as! Int32
                    }
                    if dict.keys.contains("OrderIdList") && dict["OrderIdList"] != nil {
                        self.orderIdList = dict["OrderIdList"] as! String
                    }
                    if dict.keys.contains("TargetCount") && dict["TargetCount"] != nil {
                        self.targetCount = dict["TargetCount"] as! Int32
                    }
                }
            }
            public var chargeType: String?

            public var createResource: String?

            public var createTime: Int64?

            public var expiredTime: Int64?

            public var failReason: ListFlowClusterAllResponseBody.Clusters.ClusterInfo.FailReason?

            public var hasUncompletedOrder: Bool?

            public var id: String?

            public var k8sClusterId: String?

            public var name: String?

            public var orderList: String?

            public var orderTaskInfo: ListFlowClusterAllResponseBody.Clusters.ClusterInfo.OrderTaskInfo?

            public var period: Int32?

            public var runningTime: Int32?

            public var status: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.failReason?.validate()
                try self.orderTaskInfo?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.chargeType != nil {
                    map["ChargeType"] = self.chargeType!
                }
                if self.createResource != nil {
                    map["CreateResource"] = self.createResource!
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.expiredTime != nil {
                    map["ExpiredTime"] = self.expiredTime!
                }
                if self.failReason != nil {
                    map["FailReason"] = self.failReason?.toMap()
                }
                if self.hasUncompletedOrder != nil {
                    map["HasUncompletedOrder"] = self.hasUncompletedOrder!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.k8sClusterId != nil {
                    map["K8sClusterId"] = self.k8sClusterId!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.orderList != nil {
                    map["OrderList"] = self.orderList!
                }
                if self.orderTaskInfo != nil {
                    map["OrderTaskInfo"] = self.orderTaskInfo?.toMap()
                }
                if self.period != nil {
                    map["Period"] = self.period!
                }
                if self.runningTime != nil {
                    map["RunningTime"] = self.runningTime!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ChargeType") && dict["ChargeType"] != nil {
                    self.chargeType = dict["ChargeType"] as! String
                }
                if dict.keys.contains("CreateResource") && dict["CreateResource"] != nil {
                    self.createResource = dict["CreateResource"] as! String
                }
                if dict.keys.contains("CreateTime") && dict["CreateTime"] != nil {
                    self.createTime = dict["CreateTime"] as! Int64
                }
                if dict.keys.contains("ExpiredTime") && dict["ExpiredTime"] != nil {
                    self.expiredTime = dict["ExpiredTime"] as! Int64
                }
                if dict.keys.contains("FailReason") && dict["FailReason"] != nil {
                    var model = ListFlowClusterAllResponseBody.Clusters.ClusterInfo.FailReason()
                    model.fromMap(dict["FailReason"] as! [String: Any])
                    self.failReason = model
                }
                if dict.keys.contains("HasUncompletedOrder") && dict["HasUncompletedOrder"] != nil {
                    self.hasUncompletedOrder = dict["HasUncompletedOrder"] as! Bool
                }
                if dict.keys.contains("Id") && dict["Id"] != nil {
                    self.id = dict["Id"] as! String
                }
                if dict.keys.contains("K8sClusterId") && dict["K8sClusterId"] != nil {
                    self.k8sClusterId = dict["K8sClusterId"] as! String
                }
                if dict.keys.contains("Name") && dict["Name"] != nil {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("OrderList") && dict["OrderList"] != nil {
                    self.orderList = dict["OrderList"] as! String
                }
                if dict.keys.contains("OrderTaskInfo") && dict["OrderTaskInfo"] != nil {
                    var model = ListFlowClusterAllResponseBody.Clusters.ClusterInfo.OrderTaskInfo()
                    model.fromMap(dict["OrderTaskInfo"] as! [String: Any])
                    self.orderTaskInfo = model
                }
                if dict.keys.contains("Period") && dict["Period"] != nil {
                    self.period = dict["Period"] as! Int32
                }
                if dict.keys.contains("RunningTime") && dict["RunningTime"] != nil {
                    self.runningTime = dict["RunningTime"] as! Int32
                }
                if dict.keys.contains("Status") && dict["Status"] != nil {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var clusterInfo: [ListFlowClusterAllResponseBody.Clusters.ClusterInfo]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.clusterInfo != nil {
                var tmp : [Any] = []
                for k in self.clusterInfo! {
                    tmp.append(k.toMap())
                }
                map["ClusterInfo"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ClusterInfo") && dict["ClusterInfo"] != nil {
                var tmp : [ListFlowClusterAllResponseBody.Clusters.ClusterInfo] = []
                for v in dict["ClusterInfo"] as! [Any] {
                    var model = ListFlowClusterAllResponseBody.Clusters.ClusterInfo()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.clusterInfo = tmp
            }
        }
    }
    public var clusters: ListFlowClusterAllResponseBody.Clusters?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.clusters?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusters != nil {
            map["Clusters"] = self.clusters?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Clusters") && dict["Clusters"] != nil {
            var model = ListFlowClusterAllResponseBody.Clusters()
            model.fromMap(dict["Clusters"] as! [String: Any])
            self.clusters = model
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class ListFlowClusterAllResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListFlowClusterAllResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListFlowClusterAllResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListFlowClusterAllHostsRequest : Tea.TeaModel {
    public var clusterId: String?

    public var projectId: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("ProjectId") && dict["ProjectId"] != nil {
            self.projectId = dict["ProjectId"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") && dict["ResourceGroupId"] != nil {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
    }
}

public class ListFlowClusterAllHostsResponseBody : Tea.TeaModel {
    public class HostList : Tea.TeaModel {
        public class Host : Tea.TeaModel {
            public var cpu: Int32?

            public var hostId: String?

            public var hostInstanceId: String?

            public var hostName: String?

            public var instanceType: String?

            public var memory: Int32?

            public var privateIp: String?

            public var publicIp: String?

            public var role: String?

            public var serialNumber: String?

            public var status: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cpu != nil {
                    map["Cpu"] = self.cpu!
                }
                if self.hostId != nil {
                    map["HostId"] = self.hostId!
                }
                if self.hostInstanceId != nil {
                    map["HostInstanceId"] = self.hostInstanceId!
                }
                if self.hostName != nil {
                    map["HostName"] = self.hostName!
                }
                if self.instanceType != nil {
                    map["InstanceType"] = self.instanceType!
                }
                if self.memory != nil {
                    map["Memory"] = self.memory!
                }
                if self.privateIp != nil {
                    map["PrivateIp"] = self.privateIp!
                }
                if self.publicIp != nil {
                    map["PublicIp"] = self.publicIp!
                }
                if self.role != nil {
                    map["Role"] = self.role!
                }
                if self.serialNumber != nil {
                    map["SerialNumber"] = self.serialNumber!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Cpu") && dict["Cpu"] != nil {
                    self.cpu = dict["Cpu"] as! Int32
                }
                if dict.keys.contains("HostId") && dict["HostId"] != nil {
                    self.hostId = dict["HostId"] as! String
                }
                if dict.keys.contains("HostInstanceId") && dict["HostInstanceId"] != nil {
                    self.hostInstanceId = dict["HostInstanceId"] as! String
                }
                if dict.keys.contains("HostName") && dict["HostName"] != nil {
                    self.hostName = dict["HostName"] as! String
                }
                if dict.keys.contains("InstanceType") && dict["InstanceType"] != nil {
                    self.instanceType = dict["InstanceType"] as! String
                }
                if dict.keys.contains("Memory") && dict["Memory"] != nil {
                    self.memory = dict["Memory"] as! Int32
                }
                if dict.keys.contains("PrivateIp") && dict["PrivateIp"] != nil {
                    self.privateIp = dict["PrivateIp"] as! String
                }
                if dict.keys.contains("PublicIp") && dict["PublicIp"] != nil {
                    self.publicIp = dict["PublicIp"] as! String
                }
                if dict.keys.contains("Role") && dict["Role"] != nil {
                    self.role = dict["Role"] as! String
                }
                if dict.keys.contains("SerialNumber") && dict["SerialNumber"] != nil {
                    self.serialNumber = dict["SerialNumber"] as! String
                }
                if dict.keys.contains("Status") && dict["Status"] != nil {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var host: [ListFlowClusterAllHostsResponseBody.HostList.Host]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.host != nil {
                var tmp : [Any] = []
                for k in self.host! {
                    tmp.append(k.toMap())
                }
                map["Host"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Host") && dict["Host"] != nil {
                var tmp : [ListFlowClusterAllHostsResponseBody.HostList.Host] = []
                for v in dict["Host"] as! [Any] {
                    var model = ListFlowClusterAllHostsResponseBody.HostList.Host()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.host = tmp
            }
        }
    }
    public var hostList: ListFlowClusterAllHostsResponseBody.HostList?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.hostList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.hostList != nil {
            map["HostList"] = self.hostList?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("HostList") && dict["HostList"] != nil {
            var model = ListFlowClusterAllHostsResponseBody.HostList()
            model.fromMap(dict["HostList"] as! [String: Any])
            self.hostList = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListFlowClusterAllHostsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListFlowClusterAllHostsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListFlowClusterAllHostsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListFlowClusterHostRequest : Tea.TeaModel {
    public var clusterId: String?

    public var projectId: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("ProjectId") && dict["ProjectId"] != nil {
            self.projectId = dict["ProjectId"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") && dict["ResourceGroupId"] != nil {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
    }
}

public class ListFlowClusterHostResponseBody : Tea.TeaModel {
    public class HostList : Tea.TeaModel {
        public class Host : Tea.TeaModel {
            public var cpu: Int32?

            public var hostId: String?

            public var hostInstanceId: String?

            public var hostName: String?

            public var instanceType: String?

            public var memory: Int32?

            public var privateIp: String?

            public var publicIp: String?

            public var role: String?

            public var serialNumber: String?

            public var status: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cpu != nil {
                    map["Cpu"] = self.cpu!
                }
                if self.hostId != nil {
                    map["HostId"] = self.hostId!
                }
                if self.hostInstanceId != nil {
                    map["HostInstanceId"] = self.hostInstanceId!
                }
                if self.hostName != nil {
                    map["HostName"] = self.hostName!
                }
                if self.instanceType != nil {
                    map["InstanceType"] = self.instanceType!
                }
                if self.memory != nil {
                    map["Memory"] = self.memory!
                }
                if self.privateIp != nil {
                    map["PrivateIp"] = self.privateIp!
                }
                if self.publicIp != nil {
                    map["PublicIp"] = self.publicIp!
                }
                if self.role != nil {
                    map["Role"] = self.role!
                }
                if self.serialNumber != nil {
                    map["SerialNumber"] = self.serialNumber!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Cpu") && dict["Cpu"] != nil {
                    self.cpu = dict["Cpu"] as! Int32
                }
                if dict.keys.contains("HostId") && dict["HostId"] != nil {
                    self.hostId = dict["HostId"] as! String
                }
                if dict.keys.contains("HostInstanceId") && dict["HostInstanceId"] != nil {
                    self.hostInstanceId = dict["HostInstanceId"] as! String
                }
                if dict.keys.contains("HostName") && dict["HostName"] != nil {
                    self.hostName = dict["HostName"] as! String
                }
                if dict.keys.contains("InstanceType") && dict["InstanceType"] != nil {
                    self.instanceType = dict["InstanceType"] as! String
                }
                if dict.keys.contains("Memory") && dict["Memory"] != nil {
                    self.memory = dict["Memory"] as! Int32
                }
                if dict.keys.contains("PrivateIp") && dict["PrivateIp"] != nil {
                    self.privateIp = dict["PrivateIp"] as! String
                }
                if dict.keys.contains("PublicIp") && dict["PublicIp"] != nil {
                    self.publicIp = dict["PublicIp"] as! String
                }
                if dict.keys.contains("Role") && dict["Role"] != nil {
                    self.role = dict["Role"] as! String
                }
                if dict.keys.contains("SerialNumber") && dict["SerialNumber"] != nil {
                    self.serialNumber = dict["SerialNumber"] as! String
                }
                if dict.keys.contains("Status") && dict["Status"] != nil {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var host: [ListFlowClusterHostResponseBody.HostList.Host]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.host != nil {
                var tmp : [Any] = []
                for k in self.host! {
                    tmp.append(k.toMap())
                }
                map["Host"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Host") && dict["Host"] != nil {
                var tmp : [ListFlowClusterHostResponseBody.HostList.Host] = []
                for v in dict["Host"] as! [Any] {
                    var model = ListFlowClusterHostResponseBody.HostList.Host()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.host = tmp
            }
        }
    }
    public var hostList: ListFlowClusterHostResponseBody.HostList?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.hostList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.hostList != nil {
            map["HostList"] = self.hostList?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("HostList") && dict["HostList"] != nil {
            var model = ListFlowClusterHostResponseBody.HostList()
            model.fromMap(dict["HostList"] as! [String: Any])
            self.hostList = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ListFlowClusterHostResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListFlowClusterHostResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListFlowClusterHostResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListFlowInstanceRequest : Tea.TeaModel {
    public var flowId: String?

    public var flowName: String?

    public var id: String?

    public var instanceId: String?

    public var nodeInstanceId: String?

    public var orderBy: String?

    public var orderType: String?

    public var owner: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var projectId: String?

    public var regionId: String?

    public var statusList: [String]?

    public var timeRange: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.flowId != nil {
            map["FlowId"] = self.flowId!
        }
        if self.flowName != nil {
            map["FlowName"] = self.flowName!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.nodeInstanceId != nil {
            map["NodeInstanceId"] = self.nodeInstanceId!
        }
        if self.orderBy != nil {
            map["OrderBy"] = self.orderBy!
        }
        if self.orderType != nil {
            map["OrderType"] = self.orderType!
        }
        if self.owner != nil {
            map["Owner"] = self.owner!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.statusList != nil {
            map["StatusList"] = self.statusList!
        }
        if self.timeRange != nil {
            map["TimeRange"] = self.timeRange!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FlowId") && dict["FlowId"] != nil {
            self.flowId = dict["FlowId"] as! String
        }
        if dict.keys.contains("FlowName") && dict["FlowName"] != nil {
            self.flowName = dict["FlowName"] as! String
        }
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("NodeInstanceId") && dict["NodeInstanceId"] != nil {
            self.nodeInstanceId = dict["NodeInstanceId"] as! String
        }
        if dict.keys.contains("OrderBy") && dict["OrderBy"] != nil {
            self.orderBy = dict["OrderBy"] as! String
        }
        if dict.keys.contains("OrderType") && dict["OrderType"] != nil {
            self.orderType = dict["OrderType"] as! String
        }
        if dict.keys.contains("Owner") && dict["Owner"] != nil {
            self.owner = dict["Owner"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("ProjectId") && dict["ProjectId"] != nil {
            self.projectId = dict["ProjectId"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("StatusList") && dict["StatusList"] != nil {
            self.statusList = dict["StatusList"] as! [String]
        }
        if dict.keys.contains("TimeRange") && dict["TimeRange"] != nil {
            self.timeRange = dict["TimeRange"] as! String
        }
    }
}

public class ListFlowInstanceResponseBody : Tea.TeaModel {
    public class FlowInstances : Tea.TeaModel {
        public class FlowInstance : Tea.TeaModel {
            public var clusterId: String?

            public var duration: Int64?

            public var endTime: Int64?

            public var flowId: String?

            public var flowName: String?

            public var gmtCreate: Int64?

            public var gmtModified: Int64?

            public var hasNodeFailed: Bool?

            public var id: String?

            public var owner: String?

            public var projectId: String?

            public var scheduleTime: Int64?

            public var startTime: Int64?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.clusterId != nil {
                    map["ClusterId"] = self.clusterId!
                }
                if self.duration != nil {
                    map["Duration"] = self.duration!
                }
                if self.endTime != nil {
                    map["EndTime"] = self.endTime!
                }
                if self.flowId != nil {
                    map["FlowId"] = self.flowId!
                }
                if self.flowName != nil {
                    map["FlowName"] = self.flowName!
                }
                if self.gmtCreate != nil {
                    map["GmtCreate"] = self.gmtCreate!
                }
                if self.gmtModified != nil {
                    map["GmtModified"] = self.gmtModified!
                }
                if self.hasNodeFailed != nil {
                    map["HasNodeFailed"] = self.hasNodeFailed!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.owner != nil {
                    map["Owner"] = self.owner!
                }
                if self.projectId != nil {
                    map["ProjectId"] = self.projectId!
                }
                if self.scheduleTime != nil {
                    map["ScheduleTime"] = self.scheduleTime!
                }
                if self.startTime != nil {
                    map["StartTime"] = self.startTime!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
                    self.clusterId = dict["ClusterId"] as! String
                }
                if dict.keys.contains("Duration") && dict["Duration"] != nil {
                    self.duration = dict["Duration"] as! Int64
                }
                if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
                    self.endTime = dict["EndTime"] as! Int64
                }
                if dict.keys.contains("FlowId") && dict["FlowId"] != nil {
                    self.flowId = dict["FlowId"] as! String
                }
                if dict.keys.contains("FlowName") && dict["FlowName"] != nil {
                    self.flowName = dict["FlowName"] as! String
                }
                if dict.keys.contains("GmtCreate") && dict["GmtCreate"] != nil {
                    self.gmtCreate = dict["GmtCreate"] as! Int64
                }
                if dict.keys.contains("GmtModified") && dict["GmtModified"] != nil {
                    self.gmtModified = dict["GmtModified"] as! Int64
                }
                if dict.keys.contains("HasNodeFailed") && dict["HasNodeFailed"] != nil {
                    self.hasNodeFailed = dict["HasNodeFailed"] as! Bool
                }
                if dict.keys.contains("Id") && dict["Id"] != nil {
                    self.id = dict["Id"] as! String
                }
                if dict.keys.contains("Owner") && dict["Owner"] != nil {
                    self.owner = dict["Owner"] as! String
                }
                if dict.keys.contains("ProjectId") && dict["ProjectId"] != nil {
                    self.projectId = dict["ProjectId"] as! String
                }
                if dict.keys.contains("ScheduleTime") && dict["ScheduleTime"] != nil {
                    self.scheduleTime = dict["ScheduleTime"] as! Int64
                }
                if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
                    self.startTime = dict["StartTime"] as! Int64
                }
                if dict.keys.contains("Status") && dict["Status"] != nil {
                    self.status = dict["Status"] as! String
                }
            }
        }
        public var flowInstance: [ListFlowInstanceResponseBody.FlowInstances.FlowInstance]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.flowInstance != nil {
                var tmp : [Any] = []
                for k in self.flowInstance! {
                    tmp.append(k.toMap())
                }
                map["FlowInstance"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("FlowInstance") && dict["FlowInstance"] != nil {
                var tmp : [ListFlowInstanceResponseBody.FlowInstances.FlowInstance] = []
                for v in dict["FlowInstance"] as! [Any] {
                    var model = ListFlowInstanceResponseBody.FlowInstances.FlowInstance()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.flowInstance = tmp
            }
        }
    }
    public var flowInstances: ListFlowInstanceResponseBody.FlowInstances?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var total: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.flowInstances?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.flowInstances != nil {
            map["FlowInstances"] = self.flowInstances?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.total != nil {
            map["Total"] = self.total!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FlowInstances") && dict["FlowInstances"] != nil {
            var model = ListFlowInstanceResponseBody.FlowInstances()
            model.fromMap(dict["FlowInstances"] as! [String: Any])
            self.flowInstances = model
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Total") && dict["Total"] != nil {
            self.total = dict["Total"] as! Int32
        }
    }
}

public class ListFlowInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListFlowInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListFlowInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListFlowJobRequest : Tea.TeaModel {
    public var adhoc: Bool?

    public var id: String?

    public var name: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var projectId: String?

    public var regionId: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.adhoc != nil {
            map["Adhoc"] = self.adhoc!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Adhoc") && dict["Adhoc"] != nil {
            self.adhoc = dict["Adhoc"] as! Bool
        }
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! String
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("ProjectId") && dict["ProjectId"] != nil {
            self.projectId = dict["ProjectId"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("Type") && dict["Type"] != nil {
            self.type = dict["Type"] as! String
        }
    }
}

public class ListFlowJobResponseBody : Tea.TeaModel {
    public class JobList : Tea.TeaModel {
        public class Job : Tea.TeaModel {
            public class ResourceList : Tea.TeaModel {
                public class Resource : Tea.TeaModel {
                    public var alias: String?

                    public var path: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.alias != nil {
                            map["Alias"] = self.alias!
                        }
                        if self.path != nil {
                            map["Path"] = self.path!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Alias") && dict["Alias"] != nil {
                            self.alias = dict["Alias"] as! String
                        }
                        if dict.keys.contains("Path") && dict["Path"] != nil {
                            self.path = dict["Path"] as! String
                        }
                    }
                }
                public var resource: [ListFlowJobResponseBody.JobList.Job.ResourceList.Resource]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.resource != nil {
                        var tmp : [Any] = []
                        for k in self.resource! {
                            tmp.append(k.toMap())
                        }
                        map["Resource"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Resource") && dict["Resource"] != nil {
                        var tmp : [ListFlowJobResponseBody.JobList.Job.ResourceList.Resource] = []
                        for v in dict["Resource"] as! [Any] {
                            var model = ListFlowJobResponseBody.JobList.Job.ResourceList.Resource()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.resource = tmp
                    }
                }
            }
            public var adhoc: String?

            public var alertConf: String?

            public var categoryId: String?

            public var customVariables: String?

            public var description_: String?

            public var envConf: String?

            public var failAct: String?

            public var gmtCreate: Int64?

            public var gmtModified: Int64?

            public var id: String?

            public var lastInstanceDetail: String?

            public var maxRetry: Int32?

            public var monitorConf: String?

            public var name: String?

            public var paramConf: String?

            public var params: String?

            public var resourceList: ListFlowJobResponseBody.JobList.Job.ResourceList?

            public var retryInterval: Int64?

            public var runConf: String?

            public var type: String?

            public var mode: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.resourceList?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.adhoc != nil {
                    map["Adhoc"] = self.adhoc!
                }
                if self.alertConf != nil {
                    map["AlertConf"] = self.alertConf!
                }
                if self.categoryId != nil {
                    map["CategoryId"] = self.categoryId!
                }
                if self.customVariables != nil {
                    map["CustomVariables"] = self.customVariables!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.envConf != nil {
                    map["EnvConf"] = self.envConf!
                }
                if self.failAct != nil {
                    map["FailAct"] = self.failAct!
                }
                if self.gmtCreate != nil {
                    map["GmtCreate"] = self.gmtCreate!
                }
                if self.gmtModified != nil {
                    map["GmtModified"] = self.gmtModified!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.lastInstanceDetail != nil {
                    map["LastInstanceDetail"] = self.lastInstanceDetail!
                }
                if self.maxRetry != nil {
                    map["MaxRetry"] = self.maxRetry!
                }
                if self.monitorConf != nil {
                    map["MonitorConf"] = self.monitorConf!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.paramConf != nil {
                    map["ParamConf"] = self.paramConf!
                }
                if self.params != nil {
                    map["Params"] = self.params!
                }
                if self.resourceList != nil {
                    map["ResourceList"] = self.resourceList?.toMap()
                }
                if self.retryInterval != nil {
                    map["RetryInterval"] = self.retryInterval!
                }
                if self.runConf != nil {
                    map["RunConf"] = self.runConf!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.mode != nil {
                    map["mode"] = self.mode!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Adhoc") && dict["Adhoc"] != nil {
                    self.adhoc = dict["Adhoc"] as! String
                }
                if dict.keys.contains("AlertConf") && dict["AlertConf"] != nil {
                    self.alertConf = dict["AlertConf"] as! String
                }
                if dict.keys.contains("CategoryId") && dict["CategoryId"] != nil {
                    self.categoryId = dict["CategoryId"] as! String
                }
                if dict.keys.contains("CustomVariables") && dict["CustomVariables"] != nil {
                    self.customVariables = dict["CustomVariables"] as! String
                }
                if dict.keys.contains("Description") && dict["Description"] != nil {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("EnvConf") && dict["EnvConf"] != nil {
                    self.envConf = dict["EnvConf"] as! String
                }
                if dict.keys.contains("FailAct") && dict["FailAct"] != nil {
                    self.failAct = dict["FailAct"] as! String
                }
                if dict.keys.contains("GmtCreate") && dict["GmtCreate"] != nil {
                    self.gmtCreate = dict["GmtCreate"] as! Int64
                }
                if dict.keys.contains("GmtModified") && dict["GmtModified"] != nil {
                    self.gmtModified = dict["GmtModified"] as! Int64
                }
                if dict.keys.contains("Id") && dict["Id"] != nil {
                    self.id = dict["Id"] as! String
                }
                if dict.keys.contains("LastInstanceDetail") && dict["LastInstanceDetail"] != nil {
                    self.lastInstanceDetail = dict["LastInstanceDetail"] as! String
                }
                if dict.keys.contains("MaxRetry") && dict["MaxRetry"] != nil {
                    self.maxRetry = dict["MaxRetry"] as! Int32
                }
                if dict.keys.contains("MonitorConf") && dict["MonitorConf"] != nil {
                    self.monitorConf = dict["MonitorConf"] as! String
                }
                if dict.keys.contains("Name") && dict["Name"] != nil {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("ParamConf") && dict["ParamConf"] != nil {
                    self.paramConf = dict["ParamConf"] as! String
                }
                if dict.keys.contains("Params") && dict["Params"] != nil {
                    self.params = dict["Params"] as! String
                }
                if dict.keys.contains("ResourceList") && dict["ResourceList"] != nil {
                    var model = ListFlowJobResponseBody.JobList.Job.ResourceList()
                    model.fromMap(dict["ResourceList"] as! [String: Any])
                    self.resourceList = model
                }
                if dict.keys.contains("RetryInterval") && dict["RetryInterval"] != nil {
                    self.retryInterval = dict["RetryInterval"] as! Int64
                }
                if dict.keys.contains("RunConf") && dict["RunConf"] != nil {
                    self.runConf = dict["RunConf"] as! String
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("mode") && dict["mode"] != nil {
                    self.mode = dict["mode"] as! String
                }
            }
        }
        public var job: [ListFlowJobResponseBody.JobList.Job]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.job != nil {
                var tmp : [Any] = []
                for k in self.job! {
                    tmp.append(k.toMap())
                }
                map["Job"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Job") && dict["Job"] != nil {
                var tmp : [ListFlowJobResponseBody.JobList.Job] = []
                for v in dict["Job"] as! [Any] {
                    var model = ListFlowJobResponseBody.JobList.Job()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.job = tmp
            }
        }
    }
    public var jobList: ListFlowJobResponseBody.JobList?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var total: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.jobList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.jobList != nil {
            map["JobList"] = self.jobList?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.total != nil {
            map["Total"] = self.total!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("JobList") && dict["JobList"] != nil {
            var model = ListFlowJobResponseBody.JobList()
            model.fromMap(dict["JobList"] as! [String: Any])
            self.jobList = model
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Total") && dict["Total"] != nil {
            self.total = dict["Total"] as! Int32
        }
    }
}

public class ListFlowJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListFlowJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListFlowJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListFlowJobHistoryRequest : Tea.TeaModel {
    public var id: String?

    public var instanceId: String?

    public var jobType: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var projectId: String?

    public var regionId: String?

    public var statusList: [String]?

    public var timeRange: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.jobType != nil {
            map["JobType"] = self.jobType!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.statusList != nil {
            map["StatusList"] = self.statusList!
        }
        if self.timeRange != nil {
            map["TimeRange"] = self.timeRange!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! String
        }
        if dict.keys.contains("InstanceId") && dict["InstanceId"] != nil {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("JobType") && dict["JobType"] != nil {
            self.jobType = dict["JobType"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("ProjectId") && dict["ProjectId"] != nil {
            self.projectId = dict["ProjectId"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("StatusList") && dict["StatusList"] != nil {
            self.statusList = dict["StatusList"] as! [String]
        }
        if dict.keys.contains("TimeRange") && dict["TimeRange"] != nil {
            self.timeRange = dict["TimeRange"] as! String
        }
    }
}

public class ListFlowJobHistoryResponseBody : Tea.TeaModel {
    public class NodeInstances : Tea.TeaModel {
        public class NodeInstance : Tea.TeaModel {
            public var clusterId: String?

            public var endTime: Int64?

            public var envConf: String?

            public var externalId: String?

            public var externalInfo: String?

            public var externalStatus: String?

            public var failAct: String?

            public var gmtCreate: Int64?

            public var gmtModified: Int64?

            public var hostName: String?

            public var id: String?

            public var jobId: String?

            public var jobName: String?

            public var jobParams: String?

            public var jobType: String?

            public var maxRetry: Int32?

            public var nodeName: String?

            public var paramConf: String?

            public var projectId: String?

            public var retries: Int32?

            public var retryInterval: Int64?

            public var runConf: String?

            public var startTime: Int64?

            public var status: String?

            public var type: String?

            public var pending: Bool?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.clusterId != nil {
                    map["ClusterId"] = self.clusterId!
                }
                if self.endTime != nil {
                    map["EndTime"] = self.endTime!
                }
                if self.envConf != nil {
                    map["EnvConf"] = self.envConf!
                }
                if self.externalId != nil {
                    map["ExternalId"] = self.externalId!
                }
                if self.externalInfo != nil {
                    map["ExternalInfo"] = self.externalInfo!
                }
                if self.externalStatus != nil {
                    map["ExternalStatus"] = self.externalStatus!
                }
                if self.failAct != nil {
                    map["FailAct"] = self.failAct!
                }
                if self.gmtCreate != nil {
                    map["GmtCreate"] = self.gmtCreate!
                }
                if self.gmtModified != nil {
                    map["GmtModified"] = self.gmtModified!
                }
                if self.hostName != nil {
                    map["HostName"] = self.hostName!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.jobId != nil {
                    map["JobId"] = self.jobId!
                }
                if self.jobName != nil {
                    map["JobName"] = self.jobName!
                }
                if self.jobParams != nil {
                    map["JobParams"] = self.jobParams!
                }
                if self.jobType != nil {
                    map["JobType"] = self.jobType!
                }
                if self.maxRetry != nil {
                    map["MaxRetry"] = self.maxRetry!
                }
                if self.nodeName != nil {
                    map["NodeName"] = self.nodeName!
                }
                if self.paramConf != nil {
                    map["ParamConf"] = self.paramConf!
                }
                if self.projectId != nil {
                    map["ProjectId"] = self.projectId!
                }
                if self.retries != nil {
                    map["Retries"] = self.retries!
                }
                if self.retryInterval != nil {
                    map["RetryInterval"] = self.retryInterval!
                }
                if self.runConf != nil {
                    map["RunConf"] = self.runConf!
                }
                if self.startTime != nil {
                    map["StartTime"] = self.startTime!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.pending != nil {
                    map["pending"] = self.pending!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
                    self.clusterId = dict["ClusterId"] as! String
                }
                if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
                    self.endTime = dict["EndTime"] as! Int64
                }
                if dict.keys.contains("EnvConf") && dict["EnvConf"] != nil {
                    self.envConf = dict["EnvConf"] as! String
                }
                if dict.keys.contains("ExternalId") && dict["ExternalId"] != nil {
                    self.externalId = dict["ExternalId"] as! String
                }
                if dict.keys.contains("ExternalInfo") && dict["ExternalInfo"] != nil {
                    self.externalInfo = dict["ExternalInfo"] as! String
                }
                if dict.keys.contains("ExternalStatus") && dict["ExternalStatus"] != nil {
                    self.externalStatus = dict["ExternalStatus"] as! String
                }
                if dict.keys.contains("FailAct") && dict["FailAct"] != nil {
                    self.failAct = dict["FailAct"] as! String
                }
                if dict.keys.contains("GmtCreate") && dict["GmtCreate"] != nil {
                    self.gmtCreate = dict["GmtCreate"] as! Int64
                }
                if dict.keys.contains("GmtModified") && dict["GmtModified"] != nil {
                    self.gmtModified = dict["GmtModified"] as! Int64
                }
                if dict.keys.contains("HostName") && dict["HostName"] != nil {
                    self.hostName = dict["HostName"] as! String
                }
                if dict.keys.contains("Id") && dict["Id"] != nil {
                    self.id = dict["Id"] as! String
                }
                if dict.keys.contains("JobId") && dict["JobId"] != nil {
                    self.jobId = dict["JobId"] as! String
                }
                if dict.keys.contains("JobName") && dict["JobName"] != nil {
                    self.jobName = dict["JobName"] as! String
                }
                if dict.keys.contains("JobParams") && dict["JobParams"] != nil {
                    self.jobParams = dict["JobParams"] as! String
                }
                if dict.keys.contains("JobType") && dict["JobType"] != nil {
                    self.jobType = dict["JobType"] as! String
                }
                if dict.keys.contains("MaxRetry") && dict["MaxRetry"] != nil {
                    self.maxRetry = dict["MaxRetry"] as! Int32
                }
                if dict.keys.contains("NodeName") && dict["NodeName"] != nil {
                    self.nodeName = dict["NodeName"] as! String
                }
                if dict.keys.contains("ParamConf") && dict["ParamConf"] != nil {
                    self.paramConf = dict["ParamConf"] as! String
                }
                if dict.keys.contains("ProjectId") && dict["ProjectId"] != nil {
                    self.projectId = dict["ProjectId"] as! String
                }
                if dict.keys.contains("Retries") && dict["Retries"] != nil {
                    self.retries = dict["Retries"] as! Int32
                }
                if dict.keys.contains("RetryInterval") && dict["RetryInterval"] != nil {
                    self.retryInterval = dict["RetryInterval"] as! Int64
                }
                if dict.keys.contains("RunConf") && dict["RunConf"] != nil {
                    self.runConf = dict["RunConf"] as! String
                }
                if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
                    self.startTime = dict["StartTime"] as! Int64
                }
                if dict.keys.contains("Status") && dict["Status"] != nil {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("pending") && dict["pending"] != nil {
                    self.pending = dict["pending"] as! Bool
                }
            }
        }
        public var nodeInstance: [ListFlowJobHistoryResponseBody.NodeInstances.NodeInstance]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.nodeInstance != nil {
                var tmp : [Any] = []
                for k in self.nodeInstance! {
                    tmp.append(k.toMap())
                }
                map["NodeInstance"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("NodeInstance") && dict["NodeInstance"] != nil {
                var tmp : [ListFlowJobHistoryResponseBody.NodeInstances.NodeInstance] = []
                for v in dict["NodeInstance"] as! [Any] {
                    var model = ListFlowJobHistoryResponseBody.NodeInstances.NodeInstance()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.nodeInstance = tmp
            }
        }
    }
    public var nodeInstances: ListFlowJobHistoryResponseBody.NodeInstances?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var total: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.nodeInstances?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nodeInstances != nil {
            map["NodeInstances"] = self.nodeInstances?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.total != nil {
            map["Total"] = self.total!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NodeInstances") && dict["NodeInstances"] != nil {
            var model = ListFlowJobHistoryResponseBody.NodeInstances()
            model.fromMap(dict["NodeInstances"] as! [String: Any])
            self.nodeInstances = model
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Total") && dict["Total"] != nil {
            self.total = dict["Total"] as! Int32
        }
    }
}

public class ListFlowJobHistoryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListFlowJobHistoryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListFlowJobHistoryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListFlowNodeInstanceRequest : Tea.TeaModel {
    public var orderBy: String?

    public var orderType: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var projectId: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var startTime: Int64?

    public var statusList: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.orderBy != nil {
            map["OrderBy"] = self.orderBy!
        }
        if self.orderType != nil {
            map["OrderType"] = self.orderType!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.statusList != nil {
            map["StatusList"] = self.statusList!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OrderBy") && dict["OrderBy"] != nil {
            self.orderBy = dict["OrderBy"] as! String
        }
        if dict.keys.contains("OrderType") && dict["OrderType"] != nil {
            self.orderType = dict["OrderType"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("ProjectId") && dict["ProjectId"] != nil {
            self.projectId = dict["ProjectId"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") && dict["ResourceGroupId"] != nil {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
            self.startTime = dict["StartTime"] as! Int64
        }
        if dict.keys.contains("StatusList") && dict["StatusList"] != nil {
            self.statusList = dict["StatusList"] as! [String]
        }
    }
}

public class ListFlowNodeInstanceResponseBody : Tea.TeaModel {
    public class FlowNodeInstances : Tea.TeaModel {
        public class FlowNodeInstance : Tea.TeaModel {
            public var clusterId: String?

            public var duration: Int64?

            public var endTime: Int64?

            public var externalChildIds: String?

            public var externalId: String?

            public var externalInfo: String?

            public var externalStatus: String?

            public var externalSubId: String?

            public var failAct: String?

            public var flowId: String?

            public var flowInstanceId: String?

            public var gmtCreate: Int64?

            public var gmtModified: Int64?

            public var hostName: String?

            public var id: String?

            public var jobId: String?

            public var jobName: String?

            public var jobParams: String?

            public var jobType: String?

            public var maxRetry: String?

            public var nodeName: String?

            public var pending: Bool?

            public var projectId: String?

            public var retries: Int32?

            public var retryInterval: String?

            public var startTime: Int64?

            public var status: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.clusterId != nil {
                    map["ClusterId"] = self.clusterId!
                }
                if self.duration != nil {
                    map["Duration"] = self.duration!
                }
                if self.endTime != nil {
                    map["EndTime"] = self.endTime!
                }
                if self.externalChildIds != nil {
                    map["ExternalChildIds"] = self.externalChildIds!
                }
                if self.externalId != nil {
                    map["ExternalId"] = self.externalId!
                }
                if self.externalInfo != nil {
                    map["ExternalInfo"] = self.externalInfo!
                }
                if self.externalStatus != nil {
                    map["ExternalStatus"] = self.externalStatus!
                }
                if self.externalSubId != nil {
                    map["ExternalSubId"] = self.externalSubId!
                }
                if self.failAct != nil {
                    map["FailAct"] = self.failAct!
                }
                if self.flowId != nil {
                    map["FlowId"] = self.flowId!
                }
                if self.flowInstanceId != nil {
                    map["FlowInstanceId"] = self.flowInstanceId!
                }
                if self.gmtCreate != nil {
                    map["GmtCreate"] = self.gmtCreate!
                }
                if self.gmtModified != nil {
                    map["GmtModified"] = self.gmtModified!
                }
                if self.hostName != nil {
                    map["HostName"] = self.hostName!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.jobId != nil {
                    map["JobId"] = self.jobId!
                }
                if self.jobName != nil {
                    map["JobName"] = self.jobName!
                }
                if self.jobParams != nil {
                    map["JobParams"] = self.jobParams!
                }
                if self.jobType != nil {
                    map["JobType"] = self.jobType!
                }
                if self.maxRetry != nil {
                    map["MaxRetry"] = self.maxRetry!
                }
                if self.nodeName != nil {
                    map["NodeName"] = self.nodeName!
                }
                if self.pending != nil {
                    map["Pending"] = self.pending!
                }
                if self.projectId != nil {
                    map["ProjectId"] = self.projectId!
                }
                if self.retries != nil {
                    map["Retries"] = self.retries!
                }
                if self.retryInterval != nil {
                    map["RetryInterval"] = self.retryInterval!
                }
                if self.startTime != nil {
                    map["StartTime"] = self.startTime!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
                    self.clusterId = dict["ClusterId"] as! String
                }
                if dict.keys.contains("Duration") && dict["Duration"] != nil {
                    self.duration = dict["Duration"] as! Int64
                }
                if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
                    self.endTime = dict["EndTime"] as! Int64
                }
                if dict.keys.contains("ExternalChildIds") && dict["ExternalChildIds"] != nil {
                    self.externalChildIds = dict["ExternalChildIds"] as! String
                }
                if dict.keys.contains("ExternalId") && dict["ExternalId"] != nil {
                    self.externalId = dict["ExternalId"] as! String
                }
                if dict.keys.contains("ExternalInfo") && dict["ExternalInfo"] != nil {
                    self.externalInfo = dict["ExternalInfo"] as! String
                }
                if dict.keys.contains("ExternalStatus") && dict["ExternalStatus"] != nil {
                    self.externalStatus = dict["ExternalStatus"] as! String
                }
                if dict.keys.contains("ExternalSubId") && dict["ExternalSubId"] != nil {
                    self.externalSubId = dict["ExternalSubId"] as! String
                }
                if dict.keys.contains("FailAct") && dict["FailAct"] != nil {
                    self.failAct = dict["FailAct"] as! String
                }
                if dict.keys.contains("FlowId") && dict["FlowId"] != nil {
                    self.flowId = dict["FlowId"] as! String
                }
                if dict.keys.contains("FlowInstanceId") && dict["FlowInstanceId"] != nil {
                    self.flowInstanceId = dict["FlowInstanceId"] as! String
                }
                if dict.keys.contains("GmtCreate") && dict["GmtCreate"] != nil {
                    self.gmtCreate = dict["GmtCreate"] as! Int64
                }
                if dict.keys.contains("GmtModified") && dict["GmtModified"] != nil {
                    self.gmtModified = dict["GmtModified"] as! Int64
                }
                if dict.keys.contains("HostName") && dict["HostName"] != nil {
                    self.hostName = dict["HostName"] as! String
                }
                if dict.keys.contains("Id") && dict["Id"] != nil {
                    self.id = dict["Id"] as! String
                }
                if dict.keys.contains("JobId") && dict["JobId"] != nil {
                    self.jobId = dict["JobId"] as! String
                }
                if dict.keys.contains("JobName") && dict["JobName"] != nil {
                    self.jobName = dict["JobName"] as! String
                }
                if dict.keys.contains("JobParams") && dict["JobParams"] != nil {
                    self.jobParams = dict["JobParams"] as! String
                }
                if dict.keys.contains("JobType") && dict["JobType"] != nil {
                    self.jobType = dict["JobType"] as! String
                }
                if dict.keys.contains("MaxRetry") && dict["MaxRetry"] != nil {
                    self.maxRetry = dict["MaxRetry"] as! String
                }
                if dict.keys.contains("NodeName") && dict["NodeName"] != nil {
                    self.nodeName = dict["NodeName"] as! String
                }
                if dict.keys.contains("Pending") && dict["Pending"] != nil {
                    self.pending = dict["Pending"] as! Bool
                }
                if dict.keys.contains("ProjectId") && dict["ProjectId"] != nil {
                    self.projectId = dict["ProjectId"] as! String
                }
                if dict.keys.contains("Retries") && dict["Retries"] != nil {
                    self.retries = dict["Retries"] as! Int32
                }
                if dict.keys.contains("RetryInterval") && dict["RetryInterval"] != nil {
                    self.retryInterval = dict["RetryInterval"] as! String
                }
                if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
                    self.startTime = dict["StartTime"] as! Int64
                }
                if dict.keys.contains("Status") && dict["Status"] != nil {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("Type") && dict["Type"] != nil {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var flowNodeInstance: [ListFlowNodeInstanceResponseBody.FlowNodeInstances.FlowNodeInstance]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.flowNodeInstance != nil {
                var tmp : [Any] = []
                for k in self.flowNodeInstance! {
                    tmp.append(k.toMap())
                }
                map["FlowNodeInstance"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("FlowNodeInstance") && dict["FlowNodeInstance"] != nil {
                var tmp : [ListFlowNodeInstanceResponseBody.FlowNodeInstances.FlowNodeInstance] = []
                for v in dict["FlowNodeInstance"] as! [Any] {
                    var model = ListFlowNodeInstanceResponseBody.FlowNodeInstances.FlowNodeInstance()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.flowNodeInstance = tmp
            }
        }
    }
    public var flowNodeInstances: ListFlowNodeInstanceResponseBody.FlowNodeInstances?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var total: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.flowNodeInstances?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.flowNodeInstances != nil {
            map["FlowNodeInstances"] = self.flowNodeInstances?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.total != nil {
            map["Total"] = self.total!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FlowNodeInstances") && dict["FlowNodeInstances"] != nil {
            var model = ListFlowNodeInstanceResponseBody.FlowNodeInstances()
            model.fromMap(dict["FlowNodeInstances"] as! [String: Any])
            self.flowNodeInstances = model
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Total") && dict["Total"] != nil {
            self.total = dict["Total"] as! Int32
        }
    }
}

public class ListFlowNodeInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListFlowNodeInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListFlowNodeInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListFlowNodeInstanceContainerStatusRequest : Tea.TeaModel {
    public var nodeInstanceId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var projectId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nodeInstanceId != nil {
            map["NodeInstanceId"] = self.nodeInstanceId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NodeInstanceId") && dict["NodeInstanceId"] != nil {
            self.nodeInstanceId = dict["NodeInstanceId"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("ProjectId") && dict["ProjectId"] != nil {
            self.projectId = dict["ProjectId"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class ListFlowNodeInstanceContainerStatusResponseBody : Tea.TeaModel {
    public class ContainerStatusList : Tea.TeaModel {
        public class ContainerStatus : Tea.TeaModel {
            public var applicationId: String?

            public var containerId: String?

            public var hostName: String?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.applicationId != nil {
                    map["ApplicationId"] = self.applicationId!
                }
                if self.containerId != nil {
                    map["ContainerId"] = self.containerId!
                }
                if self.hostName != nil {
                    map["HostName"] = self.hostName!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ApplicationId") && dict["ApplicationId"] != nil {
                    self.applicationId = dict["ApplicationId"] as! String
                }
                if dict.keys.contains("ContainerId") && dict["ContainerId"] != nil {
                    self.containerId = dict["ContainerId"] as! String
                }
                if dict.keys.contains("HostName") && dict["HostName"] != nil {
                    self.hostName = dict["HostName"] as! String
                }
                if dict.keys.contains("Status") && dict["Status"] != nil {
                    self.status = dict["Status"] as! String
                }
            }
        }
        public var containerStatus: [ListFlowNodeInstanceContainerStatusResponseBody.ContainerStatusList.ContainerStatus]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.containerStatus != nil {
                var tmp : [Any] = []
                for k in self.containerStatus! {
                    tmp.append(k.toMap())
                }
                map["ContainerStatus"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ContainerStatus") && dict["ContainerStatus"] != nil {
                var tmp : [ListFlowNodeInstanceContainerStatusResponseBody.ContainerStatusList.ContainerStatus] = []
                for v in dict["ContainerStatus"] as! [Any] {
                    var model = ListFlowNodeInstanceContainerStatusResponseBody.ContainerStatusList.ContainerStatus()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.containerStatus = tmp
            }
        }
    }
    public var containerStatusList: ListFlowNodeInstanceContainerStatusResponseBody.ContainerStatusList?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var total: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.containerStatusList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.containerStatusList != nil {
            map["ContainerStatusList"] = self.containerStatusList?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.total != nil {
            map["Total"] = self.total!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ContainerStatusList") && dict["ContainerStatusList"] != nil {
            var model = ListFlowNodeInstanceContainerStatusResponseBody.ContainerStatusList()
            model.fromMap(dict["ContainerStatusList"] as! [String: Any])
            self.containerStatusList = model
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Total") && dict["Total"] != nil {
            self.total = dict["Total"] as! Int32
        }
    }
}

public class ListFlowNodeInstanceContainerStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListFlowNodeInstanceContainerStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListFlowNodeInstanceContainerStatusResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListFlowNodeSqlResultRequest : Tea.TeaModel {
    public var length: Int32?

    public var nodeInstanceId: String?

    public var offset: Int32?

    public var projectId: String?

    public var regionId: String?

    public var sqlIndex: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.length != nil {
            map["Length"] = self.length!
        }
        if self.nodeInstanceId != nil {
            map["NodeInstanceId"] = self.nodeInstanceId!
        }
        if self.offset != nil {
            map["Offset"] = self.offset!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.sqlIndex != nil {
            map["SqlIndex"] = self.sqlIndex!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Length") && dict["Length"] != nil {
            self.length = dict["Length"] as! Int32
        }
        if dict.keys.contains("NodeInstanceId") && dict["NodeInstanceId"] != nil {
            self.nodeInstanceId = dict["NodeInstanceId"] as! String
        }
        if dict.keys.contains("Offset") && dict["Offset"] != nil {
            self.offset = dict["Offset"] as! Int32
        }
        if dict.keys.contains("ProjectId") && dict["ProjectId"] != nil {
            self.projectId = dict["ProjectId"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("SqlIndex") && dict["SqlIndex"] != nil {
            self.sqlIndex = dict["SqlIndex"] as! Int32
        }
    }
}

public class ListFlowNodeSqlResultResponseBody : Tea.TeaModel {
    public class HeaderList : Tea.TeaModel {
        public var header: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.header != nil {
                map["Header"] = self.header!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Header") && dict["Header"] != nil {
                self.header = dict["Header"] as! [String]
            }
        }
    }
    public class RowList : Tea.TeaModel {
        public class Row : Tea.TeaModel {
            public class RowItemList : Tea.TeaModel {
                public var rowItem: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.rowItem != nil {
                        map["rowItem"] = self.rowItem!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("rowItem") && dict["rowItem"] != nil {
                        self.rowItem = dict["rowItem"] as! [String]
                    }
                }
            }
            public var rowIndex: Int32?

            public var rowItemList: ListFlowNodeSqlResultResponseBody.RowList.Row.RowItemList?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.rowItemList?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.rowIndex != nil {
                    map["RowIndex"] = self.rowIndex!
                }
                if self.rowItemList != nil {
                    map["RowItemList"] = self.rowItemList?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("RowIndex") && dict["RowIndex"] != nil {
                    self.rowIndex = dict["RowIndex"] as! Int32
                }
                if dict.keys.contains("RowItemList") && dict["RowItemList"] != nil {
                    var model = ListFlowNodeSqlResultResponseBody.RowList.Row.RowItemList()
                    model.fromMap(dict["RowItemList"] as! [String: Any])
                    self.rowItemList = model
                }
            }
        }
        public var row: [ListFlowNodeSqlResultResponseBody.RowList.Row]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.row != nil {
                var tmp : [Any] = []
                for k in self.row! {
                    tmp.append(k.toMap())
                }
                map["Row"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Row") && dict["Row"] != nil {
                var tmp : [ListFlowNodeSqlResultResponseBody.RowList.Row] = []
                for v in dict["Row"] as! [Any] {
                    var model = ListFlowNodeSqlResultResponseBody.RowList.Row()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.row = tmp
            }
        }
    }
    public var end: Bool?

    public var headerList: ListFlowNodeSqlResultResponseBody.HeaderList?

    public var requestId: String?

    public var rowList: ListFlowNodeSqlResultResponseBody.RowList?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.headerList?.validate()
        try self.rowList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.end != nil {
            map["End"] = self.end!
        }
        if self.headerList != nil {
            map["HeaderList"] = self.headerList?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.rowList != nil {
            map["RowList"] = self.rowList?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("End") && dict["End"] != nil {
            self.end = dict["End"] as! Bool
        }
        if dict.keys.contains("HeaderList") && dict["HeaderList"] != nil {
            var model = ListFlowNodeSqlResultResponseBody.HeaderList()
            model.fromMap(dict["HeaderList"] as! [String: Any])
            self.headerList = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("RowList") && dict["RowList"] != nil {
            var model = ListFlowNodeSqlResultResponseBody.RowList()
            model.fromMap(dict["RowList"] as! [String: Any])
            self.rowList = model
        }
    }
}

public class ListFlowNodeSqlResultResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListFlowNodeSqlResultResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListFlowNodeSqlResultResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListFlowProjectRequest : Tea.TeaModel {
    public var name: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var productType: String?

    public var projectId: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.productType != nil {
            map["ProductType"] = self.productType!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("ProductType") && dict["ProductType"] != nil {
            self.productType = dict["ProductType"] as! String
        }
        if dict.keys.contains("ProjectId") && dict["ProjectId"] != nil {
            self.projectId = dict["ProjectId"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") && dict["ResourceGroupId"] != nil {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
    }
}

public class ListFlowProjectResponseBody : Tea.TeaModel {
    public class Projects : Tea.TeaModel {
        public class Project : Tea.TeaModel {
            public var description_: String?

            public var gmtCreate: Int64?

            public var gmtModified: Int64?

            public var id: String?

            public var name: String?

            public var userId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.gmtCreate != nil {
                    map["GmtCreate"] = self.gmtCreate!
                }
                if self.gmtModified != nil {
                    map["GmtModified"] = self.gmtModified!
                }
                if self.id != nil {
                    map["Id"] = self.id!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.userId != nil {
                    map["UserId"] = self.userId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Description") && dict["Description"] != nil {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("GmtCreate") && dict["GmtCreate"] != nil {
                    self.gmtCreate = dict["GmtCreate"] as! Int64
                }
                if dict.keys.contains("GmtModified") && dict["GmtModified"] != nil {
                    self.gmtModified = dict["GmtModified"] as! Int64
                }
                if dict.keys.contains("Id") && dict["Id"] != nil {
                    self.id = dict["Id"] as! String
                }
                if dict.keys.contains("Name") && dict["Name"] != nil {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("UserId") && dict["UserId"] != nil {
                    self.userId = dict["UserId"] as! String
                }
            }
        }
        public var project: [ListFlowProjectResponseBody.Projects.Project]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.project != nil {
                var tmp : [Any] = []
                for k in self.project! {
                    tmp.append(k.toMap())
                }
                map["Project"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Project") && dict["Project"] != nil {
                var tmp : [ListFlowProjectResponseBody.Projects.Project] = []
                for v in dict["Project"] as! [Any] {
                    var model = ListFlowProjectResponseBody.Projects.Project()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.project = tmp
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var projects: ListFlowProjectResponseBody.Projects?

    public var requestId: String?

    public var total: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.projects?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.projects != nil {
            map["Projects"] = self.projects?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.total != nil {
            map["Total"] = self.total!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("Projects") && dict["Projects"] != nil {
            var model = ListFlowProjectResponseBody.Projects()
            model.fromMap(dict["Projects"] as! [String: Any])
            self.projects = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Total") && dict["Total"] != nil {
            self.total = dict["Total"] as! Int32
        }
    }
}

public class ListFlowProjectResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListFlowProjectResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListFlowProjectResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListFlowProjectClusterSettingRequest : Tea.TeaModel {
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var projectId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("ProjectId") && dict["ProjectId"] != nil {
            self.projectId = dict["ProjectId"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class ListFlowProjectClusterSettingResponseBody : Tea.TeaModel {
    public class ClusterSettings : Tea.TeaModel {
        public class ClusterSetting : Tea.TeaModel {
            public class HostList : Tea.TeaModel {
                public var host: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.host != nil {
                        map["Host"] = self.host!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Host") && dict["Host"] != nil {
                        self.host = dict["Host"] as! [String]
                    }
                }
            }
            public class QueueList : Tea.TeaModel {
                public var queue: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.queue != nil {
                        map["Queue"] = self.queue!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Queue") && dict["Queue"] != nil {
                        self.queue = dict["Queue"] as! [String]
                    }
                }
            }
            public class UserList : Tea.TeaModel {
                public var user: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.user != nil {
                        map["User"] = self.user!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("User") && dict["User"] != nil {
                        self.user = dict["User"] as! [String]
                    }
                }
            }
            public var clusterId: String?

            public var clusterName: String?

            public var defaultQueue: String?

            public var defaultUser: String?

            public var gmtCreate: Int64?

            public var gmtModified: Int64?

            public var hostList: ListFlowProjectClusterSettingResponseBody.ClusterSettings.ClusterSetting.HostList?

            public var k8sClusterId: String?

            public var projectId: String?

            public var queueList: ListFlowProjectClusterSettingResponseBody.ClusterSettings.ClusterSetting.QueueList?

            public var userList: ListFlowProjectClusterSettingResponseBody.ClusterSettings.ClusterSetting.UserList?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.hostList?.validate()
                try self.queueList?.validate()
                try self.userList?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.clusterId != nil {
                    map["ClusterId"] = self.clusterId!
                }
                if self.clusterName != nil {
                    map["ClusterName"] = self.clusterName!
                }
                if self.defaultQueue != nil {
                    map["DefaultQueue"] = self.defaultQueue!
                }
                if self.defaultUser != nil {
                    map["DefaultUser"] = self.defaultUser!
                }
                if self.gmtCreate != nil {
                    map["GmtCreate"] = self.gmtCreate!
                }
                if self.gmtModified != nil {
                    map["GmtModified"] = self.gmtModified!
                }
                if self.hostList != nil {
                    map["HostList"] = self.hostList?.toMap()
                }
                if self.k8sClusterId != nil {
                    map["K8sClusterId"] = self.k8sClusterId!
                }
                if self.projectId != nil {
                    map["ProjectId"] = self.projectId!
                }
                if self.queueList != nil {
                    map["QueueList"] = self.queueList?.toMap()
                }
                if self.userList != nil {
                    map["UserList"] = self.userList?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
                    self.clusterId = dict["ClusterId"] as! String
                }
                if dict.keys.contains("ClusterName") && dict["ClusterName"] != nil {
                    self.clusterName = dict["ClusterName"] as! String
                }
                if dict.keys.contains("DefaultQueue") && dict["DefaultQueue"] != nil {
                    self.defaultQueue = dict["DefaultQueue"] as! String
                }
                if dict.keys.contains("DefaultUser") && dict["DefaultUser"] != nil {
                    self.defaultUser = dict["DefaultUser"] as! String
                }
                if dict.keys.contains("GmtCreate") && dict["GmtCreate"] != nil {
                    self.gmtCreate = dict["GmtCreate"] as! Int64
                }
                if dict.keys.contains("GmtModified") && dict["GmtModified"] != nil {
                    self.gmtModified = dict["GmtModified"] as! Int64
                }
                if dict.keys.contains("HostList") && dict["HostList"] != nil {
                    var model = ListFlowProjectClusterSettingResponseBody.ClusterSettings.ClusterSetting.HostList()
                    model.fromMap(dict["HostList"] as! [String: Any])
                    self.hostList = model
                }
                if dict.keys.contains("K8sClusterId") && dict["K8sClusterId"] != nil {
                    self.k8sClusterId = dict["K8sClusterId"] as! String
                }
                if dict.keys.contains("ProjectId") && dict["ProjectId"] != nil {
                    self.projectId = dict["ProjectId"] as! String
                }
                if dict.keys.contains("QueueList") && dict["QueueList"] != nil {
                    var model = ListFlowProjectClusterSettingResponseBody.ClusterSettings.ClusterSetting.QueueList()
                    model.fromMap(dict["QueueList"] as! [String: Any])
                    self.queueList = model
                }
                if dict.keys.contains("UserList") && dict["UserList"] != nil {
                    var model = ListFlowProjectClusterSettingResponseBody.ClusterSettings.ClusterSetting.UserList()
                    model.fromMap(dict["UserList"] as! [String: Any])
                    self.userList = model
                }
            }
        }
        public var clusterSetting: [ListFlowProjectClusterSettingResponseBody.ClusterSettings.ClusterSetting]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.clusterSetting != nil {
                var tmp : [Any] = []
                for k in self.clusterSetting! {
                    tmp.append(k.toMap())
                }
                map["ClusterSetting"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ClusterSetting") && dict["ClusterSetting"] != nil {
                var tmp : [ListFlowProjectClusterSettingResponseBody.ClusterSettings.ClusterSetting] = []
                for v in dict["ClusterSetting"] as! [Any] {
                    var model = ListFlowProjectClusterSettingResponseBody.ClusterSettings.ClusterSetting()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.clusterSetting = tmp
            }
        }
    }
    public var clusterSettings: ListFlowProjectClusterSettingResponseBody.ClusterSettings?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var total: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.clusterSettings?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterSettings != nil {
            map["ClusterSettings"] = self.clusterSettings?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.total != nil {
            map["Total"] = self.total!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterSettings") && dict["ClusterSettings"] != nil {
            var model = ListFlowProjectClusterSettingResponseBody.ClusterSettings()
            model.fromMap(dict["ClusterSettings"] as! [String: Any])
            self.clusterSettings = model
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Total") && dict["Total"] != nil {
            self.total = dict["Total"] as! Int32
        }
    }
}

public class ListFlowProjectClusterSettingResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListFlowProjectClusterSettingResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListFlowProjectClusterSettingResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListFlowProjectUserRequest : Tea.TeaModel {
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var projectId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("ProjectId") && dict["ProjectId"] != nil {
            self.projectId = dict["ProjectId"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class ListFlowProjectUserResponseBody : Tea.TeaModel {
    public class Users : Tea.TeaModel {
        public class User : Tea.TeaModel {
            public var accountUserId: String?

            public var gmtCreate: Int64?

            public var gmtModified: Int64?

            public var ownerId: String?

            public var projectId: String?

            public var userName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.accountUserId != nil {
                    map["AccountUserId"] = self.accountUserId!
                }
                if self.gmtCreate != nil {
                    map["GmtCreate"] = self.gmtCreate!
                }
                if self.gmtModified != nil {
                    map["GmtModified"] = self.gmtModified!
                }
                if self.ownerId != nil {
                    map["OwnerId"] = self.ownerId!
                }
                if self.projectId != nil {
                    map["ProjectId"] = self.projectId!
                }
                if self.userName != nil {
                    map["UserName"] = self.userName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AccountUserId") && dict["AccountUserId"] != nil {
                    self.accountUserId = dict["AccountUserId"] as! String
                }
                if dict.keys.contains("GmtCreate") && dict["GmtCreate"] != nil {
                    self.gmtCreate = dict["GmtCreate"] as! Int64
                }
                if dict.keys.contains("GmtModified") && dict["GmtModified"] != nil {
                    self.gmtModified = dict["GmtModified"] as! Int64
                }
                if dict.keys.contains("OwnerId") && dict["OwnerId"] != nil {
                    self.ownerId = dict["OwnerId"] as! String
                }
                if dict.keys.contains("ProjectId") && dict["ProjectId"] != nil {
                    self.projectId = dict["ProjectId"] as! String
                }
                if dict.keys.contains("UserName") && dict["UserName"] != nil {
                    self.userName = dict["UserName"] as! String
                }
            }
        }
        public var user: [ListFlowProjectUserResponseBody.Users.User]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.user != nil {
                var tmp : [Any] = []
                for k in self.user! {
                    tmp.append(k.toMap())
                }
                map["User"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("User") && dict["User"] != nil {
                var tmp : [ListFlowProjectUserResponseBody.Users.User] = []
                for v in dict["User"] as! [Any] {
                    var model = ListFlowProjectUserResponseBody.Users.User()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.user = tmp
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var total: Int32?

    public var users: ListFlowProjectUserResponseBody.Users?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.users?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.total != nil {
            map["Total"] = self.total!
        }
        if self.users != nil {
            map["Users"] = self.users?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Total") && dict["Total"] != nil {
            self.total = dict["Total"] as! Int32
        }
        if dict.keys.contains("Users") && dict["Users"] != nil {
            var model = ListFlowProjectUserResponseBody.Users()
            model.fromMap(dict["Users"] as! [String: Any])
            self.users = model
        }
    }
}

public class ListFlowProjectUserResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListFlowProjectUserResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListFlowProjectUserResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListResourcePoolRequest : Tea.TeaModel {
    public var clusterId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var poolType: String?

    public var regionId: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.poolType != nil {
            map["PoolType"] = self.poolType!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("PoolType") && dict["PoolType"] != nil {
            self.poolType = dict["PoolType"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") && dict["ResourceOwnerId"] != nil {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class ListResourcePoolResponseBody : Tea.TeaModel {
    public class PoolInfoList : Tea.TeaModel {
        public class PoolInfo : Tea.TeaModel {
            public class EcmResourcePool : Tea.TeaModel {
                public var active: Bool?

                public var id: Int64?

                public var name: String?

                public var note: String?

                public var poolType: String?

                public var userId: String?

                public var yarnSiteConfig: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.active != nil {
                        map["Active"] = self.active!
                    }
                    if self.id != nil {
                        map["Id"] = self.id!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    if self.note != nil {
                        map["Note"] = self.note!
                    }
                    if self.poolType != nil {
                        map["PoolType"] = self.poolType!
                    }
                    if self.userId != nil {
                        map["UserId"] = self.userId!
                    }
                    if self.yarnSiteConfig != nil {
                        map["YarnSiteConfig"] = self.yarnSiteConfig!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Active") && dict["Active"] != nil {
                        self.active = dict["Active"] as! Bool
                    }
                    if dict.keys.contains("Id") && dict["Id"] != nil {
                        self.id = dict["Id"] as! Int64
                    }
                    if dict.keys.contains("Name") && dict["Name"] != nil {
                        self.name = dict["Name"] as! String
                    }
                    if dict.keys.contains("Note") && dict["Note"] != nil {
                        self.note = dict["Note"] as! String
                    }
                    if dict.keys.contains("PoolType") && dict["PoolType"] != nil {
                        self.poolType = dict["PoolType"] as! String
                    }
                    if dict.keys.contains("UserId") && dict["UserId"] != nil {
                        self.userId = dict["UserId"] as! String
                    }
                    if dict.keys.contains("YarnSiteConfig") && dict["YarnSiteConfig"] != nil {
                        self.yarnSiteConfig = dict["YarnSiteConfig"] as! String
                    }
                }
            }
            public class EcmResourcePoolConfigList : Tea.TeaModel {
                public class EcmResourcePoolConfig : Tea.TeaModel {
                    public var category: String?

                    public var configKey: String?

                    public var configType: String?

                    public var configValue: String?

                    public var id: Int64?

                    public var note: String?

                    public var status: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.category != nil {
                            map["Category"] = self.category!
                        }
                        if self.configKey != nil {
                            map["ConfigKey"] = self.configKey!
                        }
                        if self.configType != nil {
                            map["ConfigType"] = self.configType!
                        }
                        if self.configValue != nil {
                            map["ConfigValue"] = self.configValue!
                        }
                        if self.id != nil {
                            map["Id"] = self.id!
                        }
                        if self.note != nil {
                            map["Note"] = self.note!
                        }
                        if self.status != nil {
                            map["Status"] = self.status!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Category") && dict["Category"] != nil {
                            self.category = dict["Category"] as! String
                        }
                        if dict.keys.contains("ConfigKey") && dict["ConfigKey"] != nil {
                            self.configKey = dict["ConfigKey"] as! String
                        }
                        if dict.keys.contains("ConfigType") && dict["ConfigType"] != nil {
                            self.configType = dict["ConfigType"] as! String
                        }
                        if dict.keys.contains("ConfigValue") && dict["ConfigValue"] != nil {
                            self.configValue = dict["ConfigValue"] as! String
                        }
                        if dict.keys.contains("Id") && dict["Id"] != nil {
                            self.id = dict["Id"] as! Int64
                        }
                        if dict.keys.contains("Note") && dict["Note"] != nil {
                            self.note = dict["Note"] as! String
                        }
                        if dict.keys.contains("Status") && dict["Status"] != nil {
                            self.status = dict["Status"] as! String
                        }
                    }
                }
                public var ecmResourcePoolConfig: [ListResourcePoolResponseBody.PoolInfoList.PoolInfo.EcmResourcePoolConfigList.EcmResourcePoolConfig]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.ecmResourcePoolConfig != nil {
                        var tmp : [Any] = []
                        for k in self.ecmResourcePoolConfig! {
                            tmp.append(k.toMap())
                        }
                        map["EcmResourcePoolConfig"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("EcmResourcePoolConfig") && dict["EcmResourcePoolConfig"] != nil {
                        var tmp : [ListResourcePoolResponseBody.PoolInfoList.PoolInfo.EcmResourcePoolConfigList.EcmResourcePoolConfig] = []
                        for v in dict["EcmResourcePoolConfig"] as! [Any] {
                            var model = ListResourcePoolResponseBody.PoolInfoList.PoolInfo.EcmResourcePoolConfigList.EcmResourcePoolConfig()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.ecmResourcePoolConfig = tmp
                    }
                }
            }
            public class QueueList : Tea.TeaModel {
                public class Queue : Tea.TeaModel {
                    public class EcmResourcePoolConfigList : Tea.TeaModel {
                        public class EcmResourcePoolConfig : Tea.TeaModel {
                            public var category: String?

                            public var configKey: String?

                            public var configType: String?

                            public var configValue: String?

                            public var id: Int64?

                            public var note: String?

                            public var status: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.category != nil {
                                    map["Category"] = self.category!
                                }
                                if self.configKey != nil {
                                    map["ConfigKey"] = self.configKey!
                                }
                                if self.configType != nil {
                                    map["ConfigType"] = self.configType!
                                }
                                if self.configValue != nil {
                                    map["ConfigValue"] = self.configValue!
                                }
                                if self.id != nil {
                                    map["Id"] = self.id!
                                }
                                if self.note != nil {
                                    map["Note"] = self.note!
                                }
                                if self.status != nil {
                                    map["Status"] = self.status!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Category") && dict["Category"] != nil {
                                    self.category = dict["Category"] as! String
                                }
                                if dict.keys.contains("ConfigKey") && dict["ConfigKey"] != nil {
                                    self.configKey = dict["ConfigKey"] as! String
                                }
                                if dict.keys.contains("ConfigType") && dict["ConfigType"] != nil {
                                    self.configType = dict["ConfigType"] as! String
                                }
                                if dict.keys.contains("ConfigValue") && dict["ConfigValue"] != nil {
                                    self.configValue = dict["ConfigValue"] as! String
                                }
                                if dict.keys.contains("Id") && dict["Id"] != nil {
                                    self.id = dict["Id"] as! Int64
                                }
                                if dict.keys.contains("Note") && dict["Note"] != nil {
                                    self.note = dict["Note"] as! String
                                }
                                if dict.keys.contains("Status") && dict["Status"] != nil {
                                    self.status = dict["Status"] as! String
                                }
                            }
                        }
                        public var ecmResourcePoolConfig: [ListResourcePoolResponseBody.PoolInfoList.PoolInfo.QueueList.Queue.EcmResourcePoolConfigList.EcmResourcePoolConfig]?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.ecmResourcePoolConfig != nil {
                                var tmp : [Any] = []
                                for k in self.ecmResourcePoolConfig! {
                                    tmp.append(k.toMap())
                                }
                                map["EcmResourcePoolConfig"] = tmp
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("EcmResourcePoolConfig") && dict["EcmResourcePoolConfig"] != nil {
                                var tmp : [ListResourcePoolResponseBody.PoolInfoList.PoolInfo.QueueList.Queue.EcmResourcePoolConfigList.EcmResourcePoolConfig] = []
                                for v in dict["EcmResourcePoolConfig"] as! [Any] {
                                    var model = ListResourcePoolResponseBody.PoolInfoList.PoolInfo.QueueList.Queue.EcmResourcePoolConfigList.EcmResourcePoolConfig()
                                    if v != nil {
                                        model.fromMap(v as! [String: Any])
                                    }
                                    tmp.append(model)
                                }
                                self.ecmResourcePoolConfig = tmp
                            }
                        }
                    }
                    public class EcmResourceQueue : Tea.TeaModel {
                        public var id: Int64?

                        public var leaf: Bool?

                        public var name: String?

                        public var parentQueueId: Int64?

                        public var qualifiedName: String?

                        public var queueType: String?

                        public var resourcePoolId: Int64?

                        public var status: String?

                        public var userId: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.id != nil {
                                map["Id"] = self.id!
                            }
                            if self.leaf != nil {
                                map["Leaf"] = self.leaf!
                            }
                            if self.name != nil {
                                map["Name"] = self.name!
                            }
                            if self.parentQueueId != nil {
                                map["ParentQueueId"] = self.parentQueueId!
                            }
                            if self.qualifiedName != nil {
                                map["QualifiedName"] = self.qualifiedName!
                            }
                            if self.queueType != nil {
                                map["QueueType"] = self.queueType!
                            }
                            if self.resourcePoolId != nil {
                                map["ResourcePoolId"] = self.resourcePoolId!
                            }
                            if self.status != nil {
                                map["Status"] = self.status!
                            }
                            if self.userId != nil {
                                map["UserId"] = self.userId!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Id") && dict["Id"] != nil {
                                self.id = dict["Id"] as! Int64
                            }
                            if dict.keys.contains("Leaf") && dict["Leaf"] != nil {
                                self.leaf = dict["Leaf"] as! Bool
                            }
                            if dict.keys.contains("Name") && dict["Name"] != nil {
                                self.name = dict["Name"] as! String
                            }
                            if dict.keys.contains("ParentQueueId") && dict["ParentQueueId"] != nil {
                                self.parentQueueId = dict["ParentQueueId"] as! Int64
                            }
                            if dict.keys.contains("QualifiedName") && dict["QualifiedName"] != nil {
                                self.qualifiedName = dict["QualifiedName"] as! String
                            }
                            if dict.keys.contains("QueueType") && dict["QueueType"] != nil {
                                self.queueType = dict["QueueType"] as! String
                            }
                            if dict.keys.contains("ResourcePoolId") && dict["ResourcePoolId"] != nil {
                                self.resourcePoolId = dict["ResourcePoolId"] as! Int64
                            }
                            if dict.keys.contains("Status") && dict["Status"] != nil {
                                self.status = dict["Status"] as! String
                            }
                            if dict.keys.contains("UserId") && dict["UserId"] != nil {
                                self.userId = dict["UserId"] as! String
                            }
                        }
                    }
                    public var ecmResourcePoolConfigList: ListResourcePoolResponseBody.PoolInfoList.PoolInfo.QueueList.Queue.EcmResourcePoolConfigList?

                    public var ecmResourceQueue: ListResourcePoolResponseBody.PoolInfoList.PoolInfo.QueueList.Queue.EcmResourceQueue?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.ecmResourcePoolConfigList?.validate()
                        try self.ecmResourceQueue?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.ecmResourcePoolConfigList != nil {
                            map["EcmResourcePoolConfigList"] = self.ecmResourcePoolConfigList?.toMap()
                        }
                        if self.ecmResourceQueue != nil {
                            map["EcmResourceQueue"] = self.ecmResourceQueue?.toMap()
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("EcmResourcePoolConfigList") && dict["EcmResourcePoolConfigList"] != nil {
                            var model = ListResourcePoolResponseBody.PoolInfoList.PoolInfo.QueueList.Queue.EcmResourcePoolConfigList()
                            model.fromMap(dict["EcmResourcePoolConfigList"] as! [String: Any])
                            self.ecmResourcePoolConfigList = model
                        }
                        if dict.keys.contains("EcmResourceQueue") && dict["EcmResourceQueue"] != nil {
                            var model = ListResourcePoolResponseBody.PoolInfoList.PoolInfo.QueueList.Queue.EcmResourceQueue()
                            model.fromMap(dict["EcmResourceQueue"] as! [String: Any])
                            self.ecmResourceQueue = model
                        }
                    }
                }
                public var queue: [ListResourcePoolResponseBody.PoolInfoList.PoolInfo.QueueList.Queue]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.queue != nil {
                        var tmp : [Any] = []
                        for k in self.queue! {
                            tmp.append(k.toMap())
                        }
                        map["Queue"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Queue") && dict["Queue"] != nil {
                        var tmp : [ListResourcePoolResponseBody.PoolInfoList.PoolInfo.QueueList.Queue] = []
                        for v in dict["Queue"] as! [Any] {
                            var model = ListResourcePoolResponseBody.PoolInfoList.PoolInfo.QueueList.Queue()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.queue = tmp
                    }
                }
            }
            public var ecmResourcePool: ListResourcePoolResponseBody.PoolInfoList.PoolInfo.EcmResourcePool?

            public var ecmResourcePoolConfigList: ListResourcePoolResponseBody.PoolInfoList.PoolInfo.EcmResourcePoolConfigList?

            public var queueList: ListResourcePoolResponseBody.PoolInfoList.PoolInfo.QueueList?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.ecmResourcePool?.validate()
                try self.ecmResourcePoolConfigList?.validate()
                try self.queueList?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.ecmResourcePool != nil {
                    map["EcmResourcePool"] = self.ecmResourcePool?.toMap()
                }
                if self.ecmResourcePoolConfigList != nil {
                    map["EcmResourcePoolConfigList"] = self.ecmResourcePoolConfigList?.toMap()
                }
                if self.queueList != nil {
                    map["QueueList"] = self.queueList?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("EcmResourcePool") && dict["EcmResourcePool"] != nil {
                    var model = ListResourcePoolResponseBody.PoolInfoList.PoolInfo.EcmResourcePool()
                    model.fromMap(dict["EcmResourcePool"] as! [String: Any])
                    self.ecmResourcePool = model
                }
                if dict.keys.contains("EcmResourcePoolConfigList") && dict["EcmResourcePoolConfigList"] != nil {
                    var model = ListResourcePoolResponseBody.PoolInfoList.PoolInfo.EcmResourcePoolConfigList()
                    model.fromMap(dict["EcmResourcePoolConfigList"] as! [String: Any])
                    self.ecmResourcePoolConfigList = model
                }
                if dict.keys.contains("QueueList") && dict["QueueList"] != nil {
                    var model = ListResourcePoolResponseBody.PoolInfoList.PoolInfo.QueueList()
                    model.fromMap(dict["QueueList"] as! [String: Any])
                    self.queueList = model
                }
            }
        }
        public var poolInfo: [ListResourcePoolResponseBody.PoolInfoList.PoolInfo]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.poolInfo != nil {
                var tmp : [Any] = []
                for k in self.poolInfo! {
                    tmp.append(k.toMap())
                }
                map["PoolInfo"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PoolInfo") && dict["PoolInfo"] != nil {
                var tmp : [ListResourcePoolResponseBody.PoolInfoList.PoolInfo] = []
                for v in dict["PoolInfo"] as! [Any] {
                    var model = ListResourcePoolResponseBody.PoolInfoList.PoolInfo()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.poolInfo = tmp
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var poolInfoList: ListResourcePoolResponseBody.PoolInfoList?

    public var requestId: String?

    public var total: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.poolInfoList?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.poolInfoList != nil {
            map["PoolInfoList"] = self.poolInfoList?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.total != nil {
            map["Total"] = self.total!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("PoolInfoList") && dict["PoolInfoList"] != nil {
            var model = ListResourcePoolResponseBody.PoolInfoList()
            model.fromMap(dict["PoolInfoList"] as! [String: Any])
            self.poolInfoList = model
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Total") && dict["Total"] != nil {
            self.total = dict["Total"] as! Int32
        }
    }
}

public class ListResourcePoolResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListResourcePoolResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListResourcePoolResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListScalingActivityV2Request : Tea.TeaModel {
    public var clusterBizId: String?

    public var currentSize: Int32?

    public var hostGroupId: String?

    public var hostGroupName: String?

    public var limit: Int32?

    public var orderField: String?

    public var orderMode: String?

    public var pageCount: Int32?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerId: Int64?

    public var scalingGroupBizId: String?

    public var scalingRuleName: String?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterBizId != nil {
            map["ClusterBizId"] = self.clusterBizId!
        }
        if self.currentSize != nil {
            map["CurrentSize"] = self.currentSize!
        }
        if self.hostGroupId != nil {
            map["HostGroupId"] = self.hostGroupId!
        }
        if self.hostGroupName != nil {
            map["HostGroupName"] = self.hostGroupName!
        }
        if self.limit != nil {
            map["Limit"] = self.limit!
        }
        if self.orderField != nil {
            map["OrderField"] = self.orderField!
        }
        if self.orderMode != nil {
            map["OrderMode"] = self.orderMode!
        }
        if self.pageCount != nil {
            map["PageCount"] = self.pageCount!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.scalingGroupBizId != nil {
            map["ScalingGroupBizId"] = self.scalingGroupBizId!
        }
        if self.scalingRuleName != nil {
            map["ScalingRuleName"] = self.scalingRuleName!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterBizId") && dict["ClusterBizId"] != nil {
            self.clusterBizId = dict["ClusterBizId"] as! String
        }
        if dict.keys.contains("CurrentSize") && dict["CurrentSize"] != nil {
            self.currentSize = dict["CurrentSize"] as! Int32
        }
        if dict.keys.contains("HostGroupId") && dict["HostGroupId"] != nil {
            self.hostGroupId = dict["HostGroupId"] as! String
        }
        if dict.keys.contains("HostGroupName") && dict["HostGroupName"] != nil {
            self.hostGroupName = dict["HostGroupName"] as! String
        }
        if dict.keys.contains("Limit") && dict["Limit"] != nil {
            self.limit = dict["Limit"] as! Int32
        }
        if dict.keys.contains("OrderField") && dict["OrderField"] != nil {
            self.orderField = dict["OrderField"] as! String
        }
        if dict.keys.contains("OrderMode") && dict["OrderMode"] != nil {
            self.orderMode = dict["OrderMode"] as! String
        }
        if dict.keys.contains("PageCount") && dict["PageCount"] != nil {
            self.pageCount = dict["PageCount"] as! Int32
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") && dict["ResourceGroupId"] != nil {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") && dict["ResourceOwnerId"] != nil {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("ScalingGroupBizId") && dict["ScalingGroupBizId"] != nil {
            self.scalingGroupBizId = dict["ScalingGroupBizId"] as! String
        }
        if dict.keys.contains("ScalingRuleName") && dict["ScalingRuleName"] != nil {
            self.scalingRuleName = dict["ScalingRuleName"] as! String
        }
        if dict.keys.contains("Status") && dict["Status"] != nil {
            self.status = dict["Status"] as! String
        }
    }
}

public class ListScalingActivityV2ResponseBody : Tea.TeaModel {
    public class Items : Tea.TeaModel {
        public class Item : Tea.TeaModel {
            public var bizId: String?

            public var cause: String?

            public var description_: String?

            public var endTime: Int64?

            public var expectNum: Int32?

            public var hostGroupBizId: String?

            public var hostGroupName: String?

            public var instanceIds: String?

            public var scalingRuleId: String?

            public var scalingRuleName: String?

            public var startTime: Int64?

            public var status: String?

            public var totalCapacity: Int32?

            public var transition: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bizId != nil {
                    map["BizId"] = self.bizId!
                }
                if self.cause != nil {
                    map["Cause"] = self.cause!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.endTime != nil {
                    map["EndTime"] = self.endTime!
                }
                if self.expectNum != nil {
                    map["ExpectNum"] = self.expectNum!
                }
                if self.hostGroupBizId != nil {
                    map["HostGroupBizId"] = self.hostGroupBizId!
                }
                if self.hostGroupName != nil {
                    map["HostGroupName"] = self.hostGroupName!
                }
                if self.instanceIds != nil {
                    map["InstanceIds"] = self.instanceIds!
                }
                if self.scalingRuleId != nil {
                    map["ScalingRuleId"] = self.scalingRuleId!
                }
                if self.scalingRuleName != nil {
                    map["ScalingRuleName"] = self.scalingRuleName!
                }
                if self.startTime != nil {
                    map["StartTime"] = self.startTime!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.totalCapacity != nil {
                    map["TotalCapacity"] = self.totalCapacity!
                }
                if self.transition != nil {
                    map["Transition"] = self.transition!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BizId") && dict["BizId"] != nil {
                    self.bizId = dict["BizId"] as! String
                }
                if dict.keys.contains("Cause") && dict["Cause"] != nil {
                    self.cause = dict["Cause"] as! String
                }
                if dict.keys.contains("Description") && dict["Description"] != nil {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("EndTime") && dict["EndTime"] != nil {
                    self.endTime = dict["EndTime"] as! Int64
                }
                if dict.keys.contains("ExpectNum") && dict["ExpectNum"] != nil {
                    self.expectNum = dict["ExpectNum"] as! Int32
                }
                if dict.keys.contains("HostGroupBizId") && dict["HostGroupBizId"] != nil {
                    self.hostGroupBizId = dict["HostGroupBizId"] as! String
                }
                if dict.keys.contains("HostGroupName") && dict["HostGroupName"] != nil {
                    self.hostGroupName = dict["HostGroupName"] as! String
                }
                if dict.keys.contains("InstanceIds") && dict["InstanceIds"] != nil {
                    self.instanceIds = dict["InstanceIds"] as! String
                }
                if dict.keys.contains("ScalingRuleId") && dict["ScalingRuleId"] != nil {
                    self.scalingRuleId = dict["ScalingRuleId"] as! String
                }
                if dict.keys.contains("ScalingRuleName") && dict["ScalingRuleName"] != nil {
                    self.scalingRuleName = dict["ScalingRuleName"] as! String
                }
                if dict.keys.contains("StartTime") && dict["StartTime"] != nil {
                    self.startTime = dict["StartTime"] as! Int64
                }
                if dict.keys.contains("Status") && dict["Status"] != nil {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("TotalCapacity") && dict["TotalCapacity"] != nil {
                    self.totalCapacity = dict["TotalCapacity"] as! Int32
                }
                if dict.keys.contains("Transition") && dict["Transition"] != nil {
                    self.transition = dict["Transition"] as! String
                }
            }
        }
        public var item: [ListScalingActivityV2ResponseBody.Items.Item]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.item != nil {
                var tmp : [Any] = []
                for k in self.item! {
                    tmp.append(k.toMap())
                }
                map["Item"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Item") && dict["Item"] != nil {
                var tmp : [ListScalingActivityV2ResponseBody.Items.Item] = []
                for v in dict["Item"] as! [Any] {
                    var model = ListScalingActivityV2ResponseBody.Items.Item()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.item = tmp
            }
        }
    }
    public var items: ListScalingActivityV2ResponseBody.Items?

    public var nextToken: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.items?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.items != nil {
            map["Items"] = self.items?.toMap()
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Items") && dict["Items"] != nil {
            var model = ListScalingActivityV2ResponseBody.Items()
            model.fromMap(dict["Items"] as! [String: Any])
            self.items = model
        }
        if dict.keys.contains("NextToken") && dict["NextToken"] != nil {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class ListScalingActivityV2Response : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListScalingActivityV2ResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListScalingActivityV2ResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListScalingConfigItemV2Request : Tea.TeaModel {
    public var configItemType: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerId: Int64?

    public var scalingGroupBizId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.configItemType != nil {
            map["ConfigItemType"] = self.configItemType!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.scalingGroupBizId != nil {
            map["ScalingGroupBizId"] = self.scalingGroupBizId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ConfigItemType") && dict["ConfigItemType"] != nil {
            self.configItemType = dict["ConfigItemType"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") && dict["ResourceGroupId"] != nil {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") && dict["ResourceOwnerId"] != nil {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("ScalingGroupBizId") && dict["ScalingGroupBizId"] != nil {
            self.scalingGroupBizId = dict["ScalingGroupBizId"] as! String
        }
    }
}

public class ListScalingConfigItemV2ResponseBody : Tea.TeaModel {
    public class Items : Tea.TeaModel {
        public class Item : Tea.TeaModel {
            public var configItemInformation: String?

            public var configItemType: String?

            public var scalingConfigItemBizId: String?

            public var scalingGroupBizId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.configItemInformation != nil {
                    map["ConfigItemInformation"] = self.configItemInformation!
                }
                if self.configItemType != nil {
                    map["ConfigItemType"] = self.configItemType!
                }
                if self.scalingConfigItemBizId != nil {
                    map["ScalingConfigItemBizId"] = self.scalingConfigItemBizId!
                }
                if self.scalingGroupBizId != nil {
                    map["ScalingGroupBizId"] = self.scalingGroupBizId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ConfigItemInformation") && dict["ConfigItemInformation"] != nil {
                    self.configItemInformation = dict["ConfigItemInformation"] as! String
                }
                if dict.keys.contains("ConfigItemType") && dict["ConfigItemType"] != nil {
                    self.configItemType = dict["ConfigItemType"] as! String
                }
                if dict.keys.contains("ScalingConfigItemBizId") && dict["ScalingConfigItemBizId"] != nil {
                    self.scalingConfigItemBizId = dict["ScalingConfigItemBizId"] as! String
                }
                if dict.keys.contains("ScalingGroupBizId") && dict["ScalingGroupBizId"] != nil {
                    self.scalingGroupBizId = dict["ScalingGroupBizId"] as! String
                }
            }
        }
        public var item: [ListScalingConfigItemV2ResponseBody.Items.Item]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.item != nil {
                var tmp : [Any] = []
                for k in self.item! {
                    tmp.append(k.toMap())
                }
                map["Item"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Item") && dict["Item"] != nil {
                var tmp : [ListScalingConfigItemV2ResponseBody.Items.Item] = []
                for v in dict["Item"] as! [Any] {
                    var model = ListScalingConfigItemV2ResponseBody.Items.Item()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.item = tmp
            }
        }
    }
    public var items: ListScalingConfigItemV2ResponseBody.Items?

    public var nextToken: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.items?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.items != nil {
            map["Items"] = self.items?.toMap()
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Items") && dict["Items"] != nil {
            var model = ListScalingConfigItemV2ResponseBody.Items()
            model.fromMap(dict["Items"] as! [String: Any])
            self.items = model
        }
        if dict.keys.contains("NextToken") && dict["NextToken"] != nil {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class ListScalingConfigItemV2Response : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListScalingConfigItemV2ResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListScalingConfigItemV2ResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListScalingGroupV2Request : Tea.TeaModel {
    public var clusterBizId: String?

    public var currentSize: Int32?

    public var limit: Int32?

    public var orderField: String?

    public var orderMode: String?

    public var pageCount: Int32?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterBizId != nil {
            map["ClusterBizId"] = self.clusterBizId!
        }
        if self.currentSize != nil {
            map["CurrentSize"] = self.currentSize!
        }
        if self.limit != nil {
            map["Limit"] = self.limit!
        }
        if self.orderField != nil {
            map["OrderField"] = self.orderField!
        }
        if self.orderMode != nil {
            map["OrderMode"] = self.orderMode!
        }
        if self.pageCount != nil {
            map["PageCount"] = self.pageCount!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterBizId") && dict["ClusterBizId"] != nil {
            self.clusterBizId = dict["ClusterBizId"] as! String
        }
        if dict.keys.contains("CurrentSize") && dict["CurrentSize"] != nil {
            self.currentSize = dict["CurrentSize"] as! Int32
        }
        if dict.keys.contains("Limit") && dict["Limit"] != nil {
            self.limit = dict["Limit"] as! Int32
        }
        if dict.keys.contains("OrderField") && dict["OrderField"] != nil {
            self.orderField = dict["OrderField"] as! String
        }
        if dict.keys.contains("OrderMode") && dict["OrderMode"] != nil {
            self.orderMode = dict["OrderMode"] as! String
        }
        if dict.keys.contains("PageCount") && dict["PageCount"] != nil {
            self.pageCount = dict["PageCount"] as! Int32
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") && dict["ResourceGroupId"] != nil {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") && dict["ResourceOwnerId"] != nil {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class ListScalingGroupV2ResponseBody : Tea.TeaModel {
    public class Items : Tea.TeaModel {
        public class Item : Tea.TeaModel {
            public var activeStatus: String?

            public var description_: String?

            public var hostGroupBizId: String?

            public var name: String?

            public var scalingGroupId: String?

            public var scalingInMode: String?

            public var scalingMaxSize: Int32?

            public var scalingMinSize: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.activeStatus != nil {
                    map["ActiveStatus"] = self.activeStatus!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.hostGroupBizId != nil {
                    map["HostGroupBizId"] = self.hostGroupBizId!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.scalingGroupId != nil {
                    map["ScalingGroupId"] = self.scalingGroupId!
                }
                if self.scalingInMode != nil {
                    map["ScalingInMode"] = self.scalingInMode!
                }
                if self.scalingMaxSize != nil {
                    map["ScalingMaxSize"] = self.scalingMaxSize!
                }
                if self.scalingMinSize != nil {
                    map["ScalingMinSize"] = self.scalingMinSize!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ActiveStatus") && dict["ActiveStatus"] != nil {
                    self.activeStatus = dict["ActiveStatus"] as! String
                }
                if dict.keys.contains("Description") && dict["Description"] != nil {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("HostGroupBizId") && dict["HostGroupBizId"] != nil {
                    self.hostGroupBizId = dict["HostGroupBizId"] as! String
                }
                if dict.keys.contains("Name") && dict["Name"] != nil {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("ScalingGroupId") && dict["ScalingGroupId"] != nil {
                    self.scalingGroupId = dict["ScalingGroupId"] as! String
                }
                if dict.keys.contains("ScalingInMode") && dict["ScalingInMode"] != nil {
                    self.scalingInMode = dict["ScalingInMode"] as! String
                }
                if dict.keys.contains("ScalingMaxSize") && dict["ScalingMaxSize"] != nil {
                    self.scalingMaxSize = dict["ScalingMaxSize"] as! Int32
                }
                if dict.keys.contains("ScalingMinSize") && dict["ScalingMinSize"] != nil {
                    self.scalingMinSize = dict["ScalingMinSize"] as! Int32
                }
            }
        }
        public var item: [ListScalingGroupV2ResponseBody.Items.Item]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.item != nil {
                var tmp : [Any] = []
                for k in self.item! {
                    tmp.append(k.toMap())
                }
                map["Item"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Item") && dict["Item"] != nil {
                var tmp : [ListScalingGroupV2ResponseBody.Items.Item] = []
                for v in dict["Item"] as! [Any] {
                    var model = ListScalingGroupV2ResponseBody.Items.Item()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.item = tmp
            }
        }
    }
    public var items: ListScalingGroupV2ResponseBody.Items?

    public var nextToken: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.items?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.items != nil {
            map["Items"] = self.items?.toMap()
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Items") && dict["Items"] != nil {
            var model = ListScalingGroupV2ResponseBody.Items()
            model.fromMap(dict["Items"] as! [String: Any])
            self.items = model
        }
        if dict.keys.contains("NextToken") && dict["NextToken"] != nil {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("PageNumber") && dict["PageNumber"] != nil {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") && dict["PageSize"] != nil {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") && dict["TotalCount"] != nil {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class ListScalingGroupV2Response : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListScalingGroupV2ResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListScalingGroupV2ResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListTagResourcesRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") && dict["Key"] != nil {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") && dict["Value"] != nil {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var nextToken: String?

    public var regionId: String?

    public var resourceId: [String]?

    public var resourceOwnerId: Int64?

    public var resourceType: String?

    public var tag: [ListTagResourcesRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NextToken") && dict["NextToken"] != nil {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceId") && dict["ResourceId"] != nil {
            self.resourceId = dict["ResourceId"] as! [String]
        }
        if dict.keys.contains("ResourceOwnerId") && dict["ResourceOwnerId"] != nil {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceType") && dict["ResourceType"] != nil {
            self.resourceType = dict["ResourceType"] as! String
        }
        if dict.keys.contains("Tag") && dict["Tag"] != nil {
            var tmp : [ListTagResourcesRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = ListTagResourcesRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
    }
}

public class ListTagResourcesResponseBody : Tea.TeaModel {
    public class TagResources : Tea.TeaModel {
        public class TagResource : Tea.TeaModel {
            public var resourceId: String?

            public var resourceType: String?

            public var tagKey: String?

            public var tagValue: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.resourceId != nil {
                    map["ResourceId"] = self.resourceId!
                }
                if self.resourceType != nil {
                    map["ResourceType"] = self.resourceType!
                }
                if self.tagKey != nil {
                    map["TagKey"] = self.tagKey!
                }
                if self.tagValue != nil {
                    map["TagValue"] = self.tagValue!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ResourceId") && dict["ResourceId"] != nil {
                    self.resourceId = dict["ResourceId"] as! String
                }
                if dict.keys.contains("ResourceType") && dict["ResourceType"] != nil {
                    self.resourceType = dict["ResourceType"] as! String
                }
                if dict.keys.contains("TagKey") && dict["TagKey"] != nil {
                    self.tagKey = dict["TagKey"] as! String
                }
                if dict.keys.contains("TagValue") && dict["TagValue"] != nil {
                    self.tagValue = dict["TagValue"] as! String
                }
            }
        }
        public var tagResource: [ListTagResourcesResponseBody.TagResources.TagResource]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tagResource != nil {
                var tmp : [Any] = []
                for k in self.tagResource! {
                    tmp.append(k.toMap())
                }
                map["TagResource"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("TagResource") && dict["TagResource"] != nil {
                var tmp : [ListTagResourcesResponseBody.TagResources.TagResource] = []
                for v in dict["TagResource"] as! [Any] {
                    var model = ListTagResourcesResponseBody.TagResources.TagResource()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.tagResource = tmp
            }
        }
    }
    public var nextToken: String?

    public var requestId: String?

    public var tagResources: ListTagResourcesResponseBody.TagResources?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tagResources?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.tagResources != nil {
            map["TagResources"] = self.tagResources?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NextToken") && dict["NextToken"] != nil {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TagResources") && dict["TagResources"] != nil {
            var model = ListTagResourcesResponseBody.TagResources()
            model.fromMap(dict["TagResources"] as! [String: Any])
            self.tagResources = model
        }
    }
}

public class ListTagResourcesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListTagResourcesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ListTagResourcesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyClusterNameRequest : Tea.TeaModel {
    public var id: String?

    public var name: String?

    public var regionId: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! String
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") && dict["ResourceOwnerId"] != nil {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class ModifyClusterNameResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyClusterNameResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyClusterNameResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ModifyClusterNameResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyClusterServiceConfigRequest : Tea.TeaModel {
    public var clusterId: String?

    public var comment: String?

    public var configParams: String?

    public var configType: String?

    public var customConfigParams: String?

    public var gatewayClusterIdList: [String]?

    public var groupId: String?

    public var hostInstanceId: String?

    public var refreshHostConfig: Bool?

    public var regionId: String?

    public var resourceOwnerId: Int64?

    public var serviceName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.comment != nil {
            map["Comment"] = self.comment!
        }
        if self.configParams != nil {
            map["ConfigParams"] = self.configParams!
        }
        if self.configType != nil {
            map["ConfigType"] = self.configType!
        }
        if self.customConfigParams != nil {
            map["CustomConfigParams"] = self.customConfigParams!
        }
        if self.gatewayClusterIdList != nil {
            map["GatewayClusterIdList"] = self.gatewayClusterIdList!
        }
        if self.groupId != nil {
            map["GroupId"] = self.groupId!
        }
        if self.hostInstanceId != nil {
            map["HostInstanceId"] = self.hostInstanceId!
        }
        if self.refreshHostConfig != nil {
            map["RefreshHostConfig"] = self.refreshHostConfig!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.serviceName != nil {
            map["ServiceName"] = self.serviceName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("Comment") && dict["Comment"] != nil {
            self.comment = dict["Comment"] as! String
        }
        if dict.keys.contains("ConfigParams") && dict["ConfigParams"] != nil {
            self.configParams = dict["ConfigParams"] as! String
        }
        if dict.keys.contains("ConfigType") && dict["ConfigType"] != nil {
            self.configType = dict["ConfigType"] as! String
        }
        if dict.keys.contains("CustomConfigParams") && dict["CustomConfigParams"] != nil {
            self.customConfigParams = dict["CustomConfigParams"] as! String
        }
        if dict.keys.contains("GatewayClusterIdList") && dict["GatewayClusterIdList"] != nil {
            self.gatewayClusterIdList = dict["GatewayClusterIdList"] as! [String]
        }
        if dict.keys.contains("GroupId") && dict["GroupId"] != nil {
            self.groupId = dict["GroupId"] as! String
        }
        if dict.keys.contains("HostInstanceId") && dict["HostInstanceId"] != nil {
            self.hostInstanceId = dict["HostInstanceId"] as! String
        }
        if dict.keys.contains("RefreshHostConfig") && dict["RefreshHostConfig"] != nil {
            self.refreshHostConfig = dict["RefreshHostConfig"] as! Bool
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") && dict["ResourceOwnerId"] != nil {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("ServiceName") && dict["ServiceName"] != nil {
            self.serviceName = dict["ServiceName"] as! String
        }
    }
}

public class ModifyClusterServiceConfigResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyClusterServiceConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyClusterServiceConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ModifyClusterServiceConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyClusterTemplateRequest : Tea.TeaModel {
    public class BootstrapAction : Tea.TeaModel {
        public var arg: String?

        public var executionFailStrategy: String?

        public var executionMoment: String?

        public var executionTarget: String?

        public var name: String?

        public var path: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.arg != nil {
                map["Arg"] = self.arg!
            }
            if self.executionFailStrategy != nil {
                map["ExecutionFailStrategy"] = self.executionFailStrategy!
            }
            if self.executionMoment != nil {
                map["ExecutionMoment"] = self.executionMoment!
            }
            if self.executionTarget != nil {
                map["ExecutionTarget"] = self.executionTarget!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            if self.path != nil {
                map["Path"] = self.path!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Arg") && dict["Arg"] != nil {
                self.arg = dict["Arg"] as! String
            }
            if dict.keys.contains("ExecutionFailStrategy") && dict["ExecutionFailStrategy"] != nil {
                self.executionFailStrategy = dict["ExecutionFailStrategy"] as! String
            }
            if dict.keys.contains("ExecutionMoment") && dict["ExecutionMoment"] != nil {
                self.executionMoment = dict["ExecutionMoment"] as! String
            }
            if dict.keys.contains("ExecutionTarget") && dict["ExecutionTarget"] != nil {
                self.executionTarget = dict["ExecutionTarget"] as! String
            }
            if dict.keys.contains("Name") && dict["Name"] != nil {
                self.name = dict["Name"] as! String
            }
            if dict.keys.contains("Path") && dict["Path"] != nil {
                self.path = dict["Path"] as! String
            }
        }
    }
    public class Config : Tea.TeaModel {
        public var configKey: String?

        public var configValue: String?

        public var encrypt: String?

        public var fileName: String?

        public var replace: String?

        public var serviceName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.configKey != nil {
                map["ConfigKey"] = self.configKey!
            }
            if self.configValue != nil {
                map["ConfigValue"] = self.configValue!
            }
            if self.encrypt != nil {
                map["Encrypt"] = self.encrypt!
            }
            if self.fileName != nil {
                map["FileName"] = self.fileName!
            }
            if self.replace != nil {
                map["Replace"] = self.replace!
            }
            if self.serviceName != nil {
                map["ServiceName"] = self.serviceName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ConfigKey") && dict["ConfigKey"] != nil {
                self.configKey = dict["ConfigKey"] as! String
            }
            if dict.keys.contains("ConfigValue") && dict["ConfigValue"] != nil {
                self.configValue = dict["ConfigValue"] as! String
            }
            if dict.keys.contains("Encrypt") && dict["Encrypt"] != nil {
                self.encrypt = dict["Encrypt"] as! String
            }
            if dict.keys.contains("FileName") && dict["FileName"] != nil {
                self.fileName = dict["FileName"] as! String
            }
            if dict.keys.contains("Replace") && dict["Replace"] != nil {
                self.replace = dict["Replace"] as! String
            }
            if dict.keys.contains("ServiceName") && dict["ServiceName"] != nil {
                self.serviceName = dict["ServiceName"] as! String
            }
        }
    }
    public class HostGroup : Tea.TeaModel {
        public var autoRenew: Bool?

        public var chargeType: String?

        public var clusterId: String?

        public var comment: String?

        public var createType: String?

        public var diskCapacity: Int32?

        public var diskCount: Int32?

        public var diskType: String?

        public var hostGroupId: String?

        public var hostGroupName: String?

        public var hostGroupType: String?

        public var instanceType: String?

        public var multiInstanceTypes: String?

        public var nodeCount: Int32?

        public var period: Int32?

        public var sysDiskCapacity: Int32?

        public var sysDiskType: String?

        public var vSwitchId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.autoRenew != nil {
                map["AutoRenew"] = self.autoRenew!
            }
            if self.chargeType != nil {
                map["ChargeType"] = self.chargeType!
            }
            if self.clusterId != nil {
                map["ClusterId"] = self.clusterId!
            }
            if self.comment != nil {
                map["Comment"] = self.comment!
            }
            if self.createType != nil {
                map["CreateType"] = self.createType!
            }
            if self.diskCapacity != nil {
                map["DiskCapacity"] = self.diskCapacity!
            }
            if self.diskCount != nil {
                map["DiskCount"] = self.diskCount!
            }
            if self.diskType != nil {
                map["DiskType"] = self.diskType!
            }
            if self.hostGroupId != nil {
                map["HostGroupId"] = self.hostGroupId!
            }
            if self.hostGroupName != nil {
                map["HostGroupName"] = self.hostGroupName!
            }
            if self.hostGroupType != nil {
                map["HostGroupType"] = self.hostGroupType!
            }
            if self.instanceType != nil {
                map["InstanceType"] = self.instanceType!
            }
            if self.multiInstanceTypes != nil {
                map["MultiInstanceTypes"] = self.multiInstanceTypes!
            }
            if self.nodeCount != nil {
                map["NodeCount"] = self.nodeCount!
            }
            if self.period != nil {
                map["Period"] = self.period!
            }
            if self.sysDiskCapacity != nil {
                map["SysDiskCapacity"] = self.sysDiskCapacity!
            }
            if self.sysDiskType != nil {
                map["SysDiskType"] = self.sysDiskType!
            }
            if self.vSwitchId != nil {
                map["VSwitchId"] = self.vSwitchId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AutoRenew") && dict["AutoRenew"] != nil {
                self.autoRenew = dict["AutoRenew"] as! Bool
            }
            if dict.keys.contains("ChargeType") && dict["ChargeType"] != nil {
                self.chargeType = dict["ChargeType"] as! String
            }
            if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
                self.clusterId = dict["ClusterId"] as! String
            }
            if dict.keys.contains("Comment") && dict["Comment"] != nil {
                self.comment = dict["Comment"] as! String
            }
            if dict.keys.contains("CreateType") && dict["CreateType"] != nil {
                self.createType = dict["CreateType"] as! String
            }
            if dict.keys.contains("DiskCapacity") && dict["DiskCapacity"] != nil {
                self.diskCapacity = dict["DiskCapacity"] as! Int32
            }
            if dict.keys.contains("DiskCount") && dict["DiskCount"] != nil {
                self.diskCount = dict["DiskCount"] as! Int32
            }
            if dict.keys.contains("DiskType") && dict["DiskType"] != nil {
                self.diskType = dict["DiskType"] as! String
            }
            if dict.keys.contains("HostGroupId") && dict["HostGroupId"] != nil {
                self.hostGroupId = dict["HostGroupId"] as! String
            }
            if dict.keys.contains("HostGroupName") && dict["HostGroupName"] != nil {
                self.hostGroupName = dict["HostGroupName"] as! String
            }
            if dict.keys.contains("HostGroupType") && dict["HostGroupType"] != nil {
                self.hostGroupType = dict["HostGroupType"] as! String
            }
            if dict.keys.contains("InstanceType") && dict["InstanceType"] != nil {
                self.instanceType = dict["InstanceType"] as! String
            }
            if dict.keys.contains("MultiInstanceTypes") && dict["MultiInstanceTypes"] != nil {
                self.multiInstanceTypes = dict["MultiInstanceTypes"] as! String
            }
            if dict.keys.contains("NodeCount") && dict["NodeCount"] != nil {
                self.nodeCount = dict["NodeCount"] as! Int32
            }
            if dict.keys.contains("Period") && dict["Period"] != nil {
                self.period = dict["Period"] as! Int32
            }
            if dict.keys.contains("SysDiskCapacity") && dict["SysDiskCapacity"] != nil {
                self.sysDiskCapacity = dict["SysDiskCapacity"] as! Int32
            }
            if dict.keys.contains("SysDiskType") && dict["SysDiskType"] != nil {
                self.sysDiskType = dict["SysDiskType"] as! String
            }
            if dict.keys.contains("VSwitchId") && dict["VSwitchId"] != nil {
                self.vSwitchId = dict["VSwitchId"] as! String
            }
        }
    }
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") && dict["Key"] != nil {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") && dict["Value"] != nil {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var autoRenew: Bool?

    public var bizId: String?

    public var bootstrapAction: [ModifyClusterTemplateRequest.BootstrapAction]?

    public var chargeType: String?

    public var clusterType: String?

    public var config: [ModifyClusterTemplateRequest.Config]?

    public var configurations: String?

    public var dataDiskEncrypted: Bool?

    public var dataDiskKMSKeyId: String?

    public var depositType: String?

    public var easEnable: Bool?

    public var emrVer: String?

    public var highAvailabilityEnable: Bool?

    public var hostGroup: [ModifyClusterTemplateRequest.HostGroup]?

    public var initCustomHiveMetaDb: Bool?

    public var instanceGeneration: String?

    public var ioOptimized: Bool?

    public var isOpenPublicIp: Bool?

    public var keyPairName: String?

    public var logPath: String?

    public var machineType: String?

    public var masterPwd: String?

    public var metaStoreConf: String?

    public var metaStoreType: String?

    public var netType: String?

    public var optionSoftWareList: [String]?

    public var period: Int32?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerId: Int64?

    public var securityGroupId: String?

    public var securityGroupName: String?

    public var sshEnable: Bool?

    public var tag: [ModifyClusterTemplateRequest.Tag]?

    public var templateName: String?

    public var useCustomHiveMetaDb: Bool?

    public var useLocalMetaDb: Bool?

    public var userDefinedEmrEcsRole: String?

    public var vSwitchId: String?

    public var vpcId: String?

    public var zoneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.autoRenew != nil {
            map["AutoRenew"] = self.autoRenew!
        }
        if self.bizId != nil {
            map["BizId"] = self.bizId!
        }
        if self.bootstrapAction != nil {
            var tmp : [Any] = []
            for k in self.bootstrapAction! {
                tmp.append(k.toMap())
            }
            map["BootstrapAction"] = tmp
        }
        if self.chargeType != nil {
            map["ChargeType"] = self.chargeType!
        }
        if self.clusterType != nil {
            map["ClusterType"] = self.clusterType!
        }
        if self.config != nil {
            var tmp : [Any] = []
            for k in self.config! {
                tmp.append(k.toMap())
            }
            map["Config"] = tmp
        }
        if self.configurations != nil {
            map["Configurations"] = self.configurations!
        }
        if self.dataDiskEncrypted != nil {
            map["DataDiskEncrypted"] = self.dataDiskEncrypted!
        }
        if self.dataDiskKMSKeyId != nil {
            map["DataDiskKMSKeyId"] = self.dataDiskKMSKeyId!
        }
        if self.depositType != nil {
            map["DepositType"] = self.depositType!
        }
        if self.easEnable != nil {
            map["EasEnable"] = self.easEnable!
        }
        if self.emrVer != nil {
            map["EmrVer"] = self.emrVer!
        }
        if self.highAvailabilityEnable != nil {
            map["HighAvailabilityEnable"] = self.highAvailabilityEnable!
        }
        if self.hostGroup != nil {
            var tmp : [Any] = []
            for k in self.hostGroup! {
                tmp.append(k.toMap())
            }
            map["HostGroup"] = tmp
        }
        if self.initCustomHiveMetaDb != nil {
            map["InitCustomHiveMetaDb"] = self.initCustomHiveMetaDb!
        }
        if self.instanceGeneration != nil {
            map["InstanceGeneration"] = self.instanceGeneration!
        }
        if self.ioOptimized != nil {
            map["IoOptimized"] = self.ioOptimized!
        }
        if self.isOpenPublicIp != nil {
            map["IsOpenPublicIp"] = self.isOpenPublicIp!
        }
        if self.keyPairName != nil {
            map["KeyPairName"] = self.keyPairName!
        }
        if self.logPath != nil {
            map["LogPath"] = self.logPath!
        }
        if self.machineType != nil {
            map["MachineType"] = self.machineType!
        }
        if self.masterPwd != nil {
            map["MasterPwd"] = self.masterPwd!
        }
        if self.metaStoreConf != nil {
            map["MetaStoreConf"] = self.metaStoreConf!
        }
        if self.metaStoreType != nil {
            map["MetaStoreType"] = self.metaStoreType!
        }
        if self.netType != nil {
            map["NetType"] = self.netType!
        }
        if self.optionSoftWareList != nil {
            map["OptionSoftWareList"] = self.optionSoftWareList!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.securityGroupId != nil {
            map["SecurityGroupId"] = self.securityGroupId!
        }
        if self.securityGroupName != nil {
            map["SecurityGroupName"] = self.securityGroupName!
        }
        if self.sshEnable != nil {
            map["SshEnable"] = self.sshEnable!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.templateName != nil {
            map["TemplateName"] = self.templateName!
        }
        if self.useCustomHiveMetaDb != nil {
            map["UseCustomHiveMetaDb"] = self.useCustomHiveMetaDb!
        }
        if self.useLocalMetaDb != nil {
            map["UseLocalMetaDb"] = self.useLocalMetaDb!
        }
        if self.userDefinedEmrEcsRole != nil {
            map["UserDefinedEmrEcsRole"] = self.userDefinedEmrEcsRole!
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AutoRenew") && dict["AutoRenew"] != nil {
            self.autoRenew = dict["AutoRenew"] as! Bool
        }
        if dict.keys.contains("BizId") && dict["BizId"] != nil {
            self.bizId = dict["BizId"] as! String
        }
        if dict.keys.contains("BootstrapAction") && dict["BootstrapAction"] != nil {
            var tmp : [ModifyClusterTemplateRequest.BootstrapAction] = []
            for v in dict["BootstrapAction"] as! [Any] {
                var model = ModifyClusterTemplateRequest.BootstrapAction()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.bootstrapAction = tmp
        }
        if dict.keys.contains("ChargeType") && dict["ChargeType"] != nil {
            self.chargeType = dict["ChargeType"] as! String
        }
        if dict.keys.contains("ClusterType") && dict["ClusterType"] != nil {
            self.clusterType = dict["ClusterType"] as! String
        }
        if dict.keys.contains("Config") && dict["Config"] != nil {
            var tmp : [ModifyClusterTemplateRequest.Config] = []
            for v in dict["Config"] as! [Any] {
                var model = ModifyClusterTemplateRequest.Config()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.config = tmp
        }
        if dict.keys.contains("Configurations") && dict["Configurations"] != nil {
            self.configurations = dict["Configurations"] as! String
        }
        if dict.keys.contains("DataDiskEncrypted") && dict["DataDiskEncrypted"] != nil {
            self.dataDiskEncrypted = dict["DataDiskEncrypted"] as! Bool
        }
        if dict.keys.contains("DataDiskKMSKeyId") && dict["DataDiskKMSKeyId"] != nil {
            self.dataDiskKMSKeyId = dict["DataDiskKMSKeyId"] as! String
        }
        if dict.keys.contains("DepositType") && dict["DepositType"] != nil {
            self.depositType = dict["DepositType"] as! String
        }
        if dict.keys.contains("EasEnable") && dict["EasEnable"] != nil {
            self.easEnable = dict["EasEnable"] as! Bool
        }
        if dict.keys.contains("EmrVer") && dict["EmrVer"] != nil {
            self.emrVer = dict["EmrVer"] as! String
        }
        if dict.keys.contains("HighAvailabilityEnable") && dict["HighAvailabilityEnable"] != nil {
            self.highAvailabilityEnable = dict["HighAvailabilityEnable"] as! Bool
        }
        if dict.keys.contains("HostGroup") && dict["HostGroup"] != nil {
            var tmp : [ModifyClusterTemplateRequest.HostGroup] = []
            for v in dict["HostGroup"] as! [Any] {
                var model = ModifyClusterTemplateRequest.HostGroup()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.hostGroup = tmp
        }
        if dict.keys.contains("InitCustomHiveMetaDb") && dict["InitCustomHiveMetaDb"] != nil {
            self.initCustomHiveMetaDb = dict["InitCustomHiveMetaDb"] as! Bool
        }
        if dict.keys.contains("InstanceGeneration") && dict["InstanceGeneration"] != nil {
            self.instanceGeneration = dict["InstanceGeneration"] as! String
        }
        if dict.keys.contains("IoOptimized") && dict["IoOptimized"] != nil {
            self.ioOptimized = dict["IoOptimized"] as! Bool
        }
        if dict.keys.contains("IsOpenPublicIp") && dict["IsOpenPublicIp"] != nil {
            self.isOpenPublicIp = dict["IsOpenPublicIp"] as! Bool
        }
        if dict.keys.contains("KeyPairName") && dict["KeyPairName"] != nil {
            self.keyPairName = dict["KeyPairName"] as! String
        }
        if dict.keys.contains("LogPath") && dict["LogPath"] != nil {
            self.logPath = dict["LogPath"] as! String
        }
        if dict.keys.contains("MachineType") && dict["MachineType"] != nil {
            self.machineType = dict["MachineType"] as! String
        }
        if dict.keys.contains("MasterPwd") && dict["MasterPwd"] != nil {
            self.masterPwd = dict["MasterPwd"] as! String
        }
        if dict.keys.contains("MetaStoreConf") && dict["MetaStoreConf"] != nil {
            self.metaStoreConf = dict["MetaStoreConf"] as! String
        }
        if dict.keys.contains("MetaStoreType") && dict["MetaStoreType"] != nil {
            self.metaStoreType = dict["MetaStoreType"] as! String
        }
        if dict.keys.contains("NetType") && dict["NetType"] != nil {
            self.netType = dict["NetType"] as! String
        }
        if dict.keys.contains("OptionSoftWareList") && dict["OptionSoftWareList"] != nil {
            self.optionSoftWareList = dict["OptionSoftWareList"] as! [String]
        }
        if dict.keys.contains("Period") && dict["Period"] != nil {
            self.period = dict["Period"] as! Int32
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") && dict["ResourceGroupId"] != nil {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") && dict["ResourceOwnerId"] != nil {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("SecurityGroupId") && dict["SecurityGroupId"] != nil {
            self.securityGroupId = dict["SecurityGroupId"] as! String
        }
        if dict.keys.contains("SecurityGroupName") && dict["SecurityGroupName"] != nil {
            self.securityGroupName = dict["SecurityGroupName"] as! String
        }
        if dict.keys.contains("SshEnable") && dict["SshEnable"] != nil {
            self.sshEnable = dict["SshEnable"] as! Bool
        }
        if dict.keys.contains("Tag") && dict["Tag"] != nil {
            var tmp : [ModifyClusterTemplateRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = ModifyClusterTemplateRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
        if dict.keys.contains("TemplateName") && dict["TemplateName"] != nil {
            self.templateName = dict["TemplateName"] as! String
        }
        if dict.keys.contains("UseCustomHiveMetaDb") && dict["UseCustomHiveMetaDb"] != nil {
            self.useCustomHiveMetaDb = dict["UseCustomHiveMetaDb"] as! Bool
        }
        if dict.keys.contains("UseLocalMetaDb") && dict["UseLocalMetaDb"] != nil {
            self.useLocalMetaDb = dict["UseLocalMetaDb"] as! Bool
        }
        if dict.keys.contains("UserDefinedEmrEcsRole") && dict["UserDefinedEmrEcsRole"] != nil {
            self.userDefinedEmrEcsRole = dict["UserDefinedEmrEcsRole"] as! String
        }
        if dict.keys.contains("VSwitchId") && dict["VSwitchId"] != nil {
            self.vSwitchId = dict["VSwitchId"] as! String
        }
        if dict.keys.contains("VpcId") && dict["VpcId"] != nil {
            self.vpcId = dict["VpcId"] as! String
        }
        if dict.keys.contains("ZoneId") && dict["ZoneId"] != nil {
            self.zoneId = dict["ZoneId"] as! String
        }
    }
}

public class ModifyClusterTemplateResponseBody : Tea.TeaModel {
    public var clusterTemplateId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterTemplateId != nil {
            map["ClusterTemplateId"] = self.clusterTemplateId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterTemplateId") && dict["ClusterTemplateId"] != nil {
            self.clusterTemplateId = dict["ClusterTemplateId"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyClusterTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyClusterTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ModifyClusterTemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyFlowCategoryRequest : Tea.TeaModel {
    public var id: String?

    public var name: String?

    public var parentId: String?

    public var projectId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.parentId != nil {
            map["ParentId"] = self.parentId!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! String
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("ParentId") && dict["ParentId"] != nil {
            self.parentId = dict["ParentId"] as! String
        }
        if dict.keys.contains("ProjectId") && dict["ProjectId"] != nil {
            self.projectId = dict["ProjectId"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class ModifyFlowCategoryResponseBody : Tea.TeaModel {
    public var data: Bool?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! Bool
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyFlowCategoryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyFlowCategoryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ModifyFlowCategoryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyFlowForWebRequest : Tea.TeaModel {
    public var alertConf: String?

    public var alertDingDingGroupBizId: String?

    public var alertUserGroupBizId: String?

    public var clusterId: String?

    public var createCluster: Bool?

    public var cronExpr: String?

    public var description_: String?

    public var endSchedule: Int64?

    public var graph: String?

    public var hostName: String?

    public var id: String?

    public var lifecycle: String?

    public var logArchiveLocation: String?

    public var name: String?

    public var namespace: String?

    public var parentCategory: String?

    public var parentFlowList: String?

    public var periodic: Bool?

    public var projectId: String?

    public var regionId: String?

    public var startSchedule: Int64?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.alertConf != nil {
            map["AlertConf"] = self.alertConf!
        }
        if self.alertDingDingGroupBizId != nil {
            map["AlertDingDingGroupBizId"] = self.alertDingDingGroupBizId!
        }
        if self.alertUserGroupBizId != nil {
            map["AlertUserGroupBizId"] = self.alertUserGroupBizId!
        }
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.createCluster != nil {
            map["CreateCluster"] = self.createCluster!
        }
        if self.cronExpr != nil {
            map["CronExpr"] = self.cronExpr!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.endSchedule != nil {
            map["EndSchedule"] = self.endSchedule!
        }
        if self.graph != nil {
            map["Graph"] = self.graph!
        }
        if self.hostName != nil {
            map["HostName"] = self.hostName!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.lifecycle != nil {
            map["Lifecycle"] = self.lifecycle!
        }
        if self.logArchiveLocation != nil {
            map["LogArchiveLocation"] = self.logArchiveLocation!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        if self.parentCategory != nil {
            map["ParentCategory"] = self.parentCategory!
        }
        if self.parentFlowList != nil {
            map["ParentFlowList"] = self.parentFlowList!
        }
        if self.periodic != nil {
            map["Periodic"] = self.periodic!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.startSchedule != nil {
            map["StartSchedule"] = self.startSchedule!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AlertConf") && dict["AlertConf"] != nil {
            self.alertConf = dict["AlertConf"] as! String
        }
        if dict.keys.contains("AlertDingDingGroupBizId") && dict["AlertDingDingGroupBizId"] != nil {
            self.alertDingDingGroupBizId = dict["AlertDingDingGroupBizId"] as! String
        }
        if dict.keys.contains("AlertUserGroupBizId") && dict["AlertUserGroupBizId"] != nil {
            self.alertUserGroupBizId = dict["AlertUserGroupBizId"] as! String
        }
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("CreateCluster") && dict["CreateCluster"] != nil {
            self.createCluster = dict["CreateCluster"] as! Bool
        }
        if dict.keys.contains("CronExpr") && dict["CronExpr"] != nil {
            self.cronExpr = dict["CronExpr"] as! String
        }
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("EndSchedule") && dict["EndSchedule"] != nil {
            self.endSchedule = dict["EndSchedule"] as! Int64
        }
        if dict.keys.contains("Graph") && dict["Graph"] != nil {
            self.graph = dict["Graph"] as! String
        }
        if dict.keys.contains("HostName") && dict["HostName"] != nil {
            self.hostName = dict["HostName"] as! String
        }
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! String
        }
        if dict.keys.contains("Lifecycle") && dict["Lifecycle"] != nil {
            self.lifecycle = dict["Lifecycle"] as! String
        }
        if dict.keys.contains("LogArchiveLocation") && dict["LogArchiveLocation"] != nil {
            self.logArchiveLocation = dict["LogArchiveLocation"] as! String
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
            self.namespace = dict["Namespace"] as! String
        }
        if dict.keys.contains("ParentCategory") && dict["ParentCategory"] != nil {
            self.parentCategory = dict["ParentCategory"] as! String
        }
        if dict.keys.contains("ParentFlowList") && dict["ParentFlowList"] != nil {
            self.parentFlowList = dict["ParentFlowList"] as! String
        }
        if dict.keys.contains("Periodic") && dict["Periodic"] != nil {
            self.periodic = dict["Periodic"] as! Bool
        }
        if dict.keys.contains("ProjectId") && dict["ProjectId"] != nil {
            self.projectId = dict["ProjectId"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("StartSchedule") && dict["StartSchedule"] != nil {
            self.startSchedule = dict["StartSchedule"] as! Int64
        }
        if dict.keys.contains("Status") && dict["Status"] != nil {
            self.status = dict["Status"] as! String
        }
    }
}

public class ModifyFlowForWebResponseBody : Tea.TeaModel {
    public var data: Bool?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! Bool
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyFlowForWebResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyFlowForWebResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ModifyFlowForWebResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyFlowProjectRequest : Tea.TeaModel {
    public var description_: String?

    public var name: String?

    public var projectId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("ProjectId") && dict["ProjectId"] != nil {
            self.projectId = dict["ProjectId"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class ModifyFlowProjectResponseBody : Tea.TeaModel {
    public var data: Bool?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! Bool
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyFlowProjectResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyFlowProjectResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ModifyFlowProjectResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyFlowProjectClusterSettingRequest : Tea.TeaModel {
    public var clusterId: String?

    public var defaultQueue: String?

    public var defaultUser: String?

    public var hostList: [String]?

    public var projectId: String?

    public var queueList: [String]?

    public var regionId: String?

    public var userList: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.defaultQueue != nil {
            map["DefaultQueue"] = self.defaultQueue!
        }
        if self.defaultUser != nil {
            map["DefaultUser"] = self.defaultUser!
        }
        if self.hostList != nil {
            map["HostList"] = self.hostList!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.queueList != nil {
            map["QueueList"] = self.queueList!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.userList != nil {
            map["UserList"] = self.userList!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("DefaultQueue") && dict["DefaultQueue"] != nil {
            self.defaultQueue = dict["DefaultQueue"] as! String
        }
        if dict.keys.contains("DefaultUser") && dict["DefaultUser"] != nil {
            self.defaultUser = dict["DefaultUser"] as! String
        }
        if dict.keys.contains("HostList") && dict["HostList"] != nil {
            self.hostList = dict["HostList"] as! [String]
        }
        if dict.keys.contains("ProjectId") && dict["ProjectId"] != nil {
            self.projectId = dict["ProjectId"] as! String
        }
        if dict.keys.contains("QueueList") && dict["QueueList"] != nil {
            self.queueList = dict["QueueList"] as! [String]
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("UserList") && dict["UserList"] != nil {
            self.userList = dict["UserList"] as! [String]
        }
    }
}

public class ModifyFlowProjectClusterSettingResponseBody : Tea.TeaModel {
    public var data: Bool?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! Bool
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyFlowProjectClusterSettingResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyFlowProjectClusterSettingResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ModifyFlowProjectClusterSettingResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyResourcePoolRequest : Tea.TeaModel {
    public class Config : Tea.TeaModel {
        public var category: String?

        public var configKey: String?

        public var configValue: String?

        public var id: String?

        public var note: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.category != nil {
                map["Category"] = self.category!
            }
            if self.configKey != nil {
                map["ConfigKey"] = self.configKey!
            }
            if self.configValue != nil {
                map["ConfigValue"] = self.configValue!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.note != nil {
                map["Note"] = self.note!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Category") && dict["Category"] != nil {
                self.category = dict["Category"] as! String
            }
            if dict.keys.contains("ConfigKey") && dict["ConfigKey"] != nil {
                self.configKey = dict["ConfigKey"] as! String
            }
            if dict.keys.contains("ConfigValue") && dict["ConfigValue"] != nil {
                self.configValue = dict["ConfigValue"] as! String
            }
            if dict.keys.contains("Id") && dict["Id"] != nil {
                self.id = dict["Id"] as! String
            }
            if dict.keys.contains("Note") && dict["Note"] != nil {
                self.note = dict["Note"] as! String
            }
        }
    }
    public var active: Bool?

    public var clusterId: String?

    public var config: [ModifyResourcePoolRequest.Config]?

    public var id: String?

    public var name: String?

    public var regionId: String?

    public var resourceOwnerId: Int64?

    public var yarnsiteconfig: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.active != nil {
            map["Active"] = self.active!
        }
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.config != nil {
            var tmp : [Any] = []
            for k in self.config! {
                tmp.append(k.toMap())
            }
            map["Config"] = tmp
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.yarnsiteconfig != nil {
            map["Yarnsiteconfig"] = self.yarnsiteconfig!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Active") && dict["Active"] != nil {
            self.active = dict["Active"] as! Bool
        }
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("Config") && dict["Config"] != nil {
            var tmp : [ModifyResourcePoolRequest.Config] = []
            for v in dict["Config"] as! [Any] {
                var model = ModifyResourcePoolRequest.Config()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.config = tmp
        }
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! String
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") && dict["ResourceOwnerId"] != nil {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("Yarnsiteconfig") && dict["Yarnsiteconfig"] != nil {
            self.yarnsiteconfig = dict["Yarnsiteconfig"] as! String
        }
    }
}

public class ModifyResourcePoolResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyResourcePoolResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyResourcePoolResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ModifyResourcePoolResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyResourcePoolSchedulerTypeRequest : Tea.TeaModel {
    public var clusterId: String?

    public var regionId: String?

    public var resourceOwnerId: Int64?

    public var schedulerType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.schedulerType != nil {
            map["SchedulerType"] = self.schedulerType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") && dict["ResourceOwnerId"] != nil {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("SchedulerType") && dict["SchedulerType"] != nil {
            self.schedulerType = dict["SchedulerType"] as! String
        }
    }
}

public class ModifyResourcePoolSchedulerTypeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyResourcePoolSchedulerTypeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyResourcePoolSchedulerTypeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ModifyResourcePoolSchedulerTypeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyResourceQueueRequest : Tea.TeaModel {
    public class Config : Tea.TeaModel {
        public var category: String?

        public var configKey: String?

        public var configValue: String?

        public var id: Int64?

        public var note: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.category != nil {
                map["Category"] = self.category!
            }
            if self.configKey != nil {
                map["ConfigKey"] = self.configKey!
            }
            if self.configValue != nil {
                map["ConfigValue"] = self.configValue!
            }
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.note != nil {
                map["Note"] = self.note!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Category") && dict["Category"] != nil {
                self.category = dict["Category"] as! String
            }
            if dict.keys.contains("ConfigKey") && dict["ConfigKey"] != nil {
                self.configKey = dict["ConfigKey"] as! String
            }
            if dict.keys.contains("ConfigValue") && dict["ConfigValue"] != nil {
                self.configValue = dict["ConfigValue"] as! String
            }
            if dict.keys.contains("Id") && dict["Id"] != nil {
                self.id = dict["Id"] as! Int64
            }
            if dict.keys.contains("Note") && dict["Note"] != nil {
                self.note = dict["Note"] as! String
            }
        }
    }
    public var clusterId: String?

    public var config: [ModifyResourceQueueRequest.Config]?

    public var id: String?

    public var leaf: Bool?

    public var name: String?

    public var parentQueueId: Int64?

    public var qualifiedName: String?

    public var regionId: String?

    public var resourceOwnerId: Int64?

    public var resourcePoolId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.config != nil {
            var tmp : [Any] = []
            for k in self.config! {
                tmp.append(k.toMap())
            }
            map["Config"] = tmp
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.leaf != nil {
            map["Leaf"] = self.leaf!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.parentQueueId != nil {
            map["ParentQueueId"] = self.parentQueueId!
        }
        if self.qualifiedName != nil {
            map["QualifiedName"] = self.qualifiedName!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.resourcePoolId != nil {
            map["ResourcePoolId"] = self.resourcePoolId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("Config") && dict["Config"] != nil {
            var tmp : [ModifyResourceQueueRequest.Config] = []
            for v in dict["Config"] as! [Any] {
                var model = ModifyResourceQueueRequest.Config()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.config = tmp
        }
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! String
        }
        if dict.keys.contains("Leaf") && dict["Leaf"] != nil {
            self.leaf = dict["Leaf"] as! Bool
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("ParentQueueId") && dict["ParentQueueId"] != nil {
            self.parentQueueId = dict["ParentQueueId"] as! Int64
        }
        if dict.keys.contains("QualifiedName") && dict["QualifiedName"] != nil {
            self.qualifiedName = dict["QualifiedName"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") && dict["ResourceOwnerId"] != nil {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("ResourcePoolId") && dict["ResourcePoolId"] != nil {
            self.resourcePoolId = dict["ResourcePoolId"] as! Int64
        }
    }
}

public class ModifyResourceQueueResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyResourceQueueResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyResourceQueueResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ModifyResourceQueueResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyScalingConfigItemV2Request : Tea.TeaModel {
    public var configItemBizId: String?

    public var configItemInformation: String?

    public var configItemType: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerId: Int64?

    public var scalingGroupBizId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.configItemBizId != nil {
            map["ConfigItemBizId"] = self.configItemBizId!
        }
        if self.configItemInformation != nil {
            map["ConfigItemInformation"] = self.configItemInformation!
        }
        if self.configItemType != nil {
            map["ConfigItemType"] = self.configItemType!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.scalingGroupBizId != nil {
            map["ScalingGroupBizId"] = self.scalingGroupBizId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ConfigItemBizId") && dict["ConfigItemBizId"] != nil {
            self.configItemBizId = dict["ConfigItemBizId"] as! String
        }
        if dict.keys.contains("ConfigItemInformation") && dict["ConfigItemInformation"] != nil {
            self.configItemInformation = dict["ConfigItemInformation"] as! String
        }
        if dict.keys.contains("ConfigItemType") && dict["ConfigItemType"] != nil {
            self.configItemType = dict["ConfigItemType"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") && dict["ResourceGroupId"] != nil {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") && dict["ResourceOwnerId"] != nil {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("ScalingGroupBizId") && dict["ScalingGroupBizId"] != nil {
            self.scalingGroupBizId = dict["ScalingGroupBizId"] as! String
        }
    }
}

public class ModifyScalingConfigItemV2ResponseBody : Tea.TeaModel {
    public var data: Bool?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! Bool
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyScalingConfigItemV2Response : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyScalingConfigItemV2ResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ModifyScalingConfigItemV2ResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyScalingGroupV2Request : Tea.TeaModel {
    public var description_: String?

    public var name: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerId: Int64?

    public var scalingGroupBizId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.scalingGroupBizId != nil {
            map["ScalingGroupBizId"] = self.scalingGroupBizId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") && dict["Description"] != nil {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("Name") && dict["Name"] != nil {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") && dict["ResourceGroupId"] != nil {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") && dict["ResourceOwnerId"] != nil {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("ScalingGroupBizId") && dict["ScalingGroupBizId"] != nil {
            self.scalingGroupBizId = dict["ScalingGroupBizId"] as! String
        }
    }
}

public class ModifyScalingGroupV2ResponseBody : Tea.TeaModel {
    public var data: Bool?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! Bool
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyScalingGroupV2Response : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyScalingGroupV2ResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ModifyScalingGroupV2ResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RefreshClusterResourcePoolRequest : Tea.TeaModel {
    public var clusterId: String?

    public var regionId: String?

    public var resourceOwnerId: Int64?

    public var resourcePoolId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.resourcePoolId != nil {
            map["ResourcePoolId"] = self.resourcePoolId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") && dict["ResourceOwnerId"] != nil {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("ResourcePoolId") && dict["ResourcePoolId"] != nil {
            self.resourcePoolId = dict["ResourcePoolId"] as! Int64
        }
    }
}

public class RefreshClusterResourcePoolResponseBody : Tea.TeaModel {
    public var operationId: String?

    public var requestId: String?

    public var workFlowInstanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.operationId != nil {
            map["OperationId"] = self.operationId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.workFlowInstanceId != nil {
            map["WorkFlowInstanceId"] = self.workFlowInstanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OperationId") && dict["OperationId"] != nil {
            self.operationId = dict["OperationId"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("WorkFlowInstanceId") && dict["WorkFlowInstanceId"] != nil {
            self.workFlowInstanceId = dict["WorkFlowInstanceId"] as! String
        }
    }
}

public class RefreshClusterResourcePoolResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RefreshClusterResourcePoolResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = RefreshClusterResourcePoolResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ReleaseClusterRequest : Tea.TeaModel {
    public var forceRelease: Bool?

    public var id: String?

    public var regionId: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.forceRelease != nil {
            map["ForceRelease"] = self.forceRelease!
        }
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ForceRelease") && dict["ForceRelease"] != nil {
            self.forceRelease = dict["ForceRelease"] as! Bool
        }
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") && dict["ResourceOwnerId"] != nil {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class ReleaseClusterResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ReleaseClusterResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ReleaseClusterResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ReleaseClusterResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ReleaseClusterHostGroupRequest : Tea.TeaModel {
    public var clusterId: String?

    public var decommissionTimeout: Int32?

    public var enableGracefulDecommission: Bool?

    public var hostGroupId: String?

    public var instanceIdList: String?

    public var regionId: String?

    public var releaseNumber: Int32?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.decommissionTimeout != nil {
            map["DecommissionTimeout"] = self.decommissionTimeout!
        }
        if self.enableGracefulDecommission != nil {
            map["EnableGracefulDecommission"] = self.enableGracefulDecommission!
        }
        if self.hostGroupId != nil {
            map["HostGroupId"] = self.hostGroupId!
        }
        if self.instanceIdList != nil {
            map["InstanceIdList"] = self.instanceIdList!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.releaseNumber != nil {
            map["ReleaseNumber"] = self.releaseNumber!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("DecommissionTimeout") && dict["DecommissionTimeout"] != nil {
            self.decommissionTimeout = dict["DecommissionTimeout"] as! Int32
        }
        if dict.keys.contains("EnableGracefulDecommission") && dict["EnableGracefulDecommission"] != nil {
            self.enableGracefulDecommission = dict["EnableGracefulDecommission"] as! Bool
        }
        if dict.keys.contains("HostGroupId") && dict["HostGroupId"] != nil {
            self.hostGroupId = dict["HostGroupId"] as! String
        }
        if dict.keys.contains("InstanceIdList") && dict["InstanceIdList"] != nil {
            self.instanceIdList = dict["InstanceIdList"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ReleaseNumber") && dict["ReleaseNumber"] != nil {
            self.releaseNumber = dict["ReleaseNumber"] as! Int32
        }
        if dict.keys.contains("ResourceOwnerId") && dict["ResourceOwnerId"] != nil {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class ReleaseClusterHostGroupResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ReleaseClusterHostGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ReleaseClusterHostGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ReleaseClusterHostGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RemoveScalingConfigItemV2Request : Tea.TeaModel {
    public var configItemBizId: String?

    public var configItemType: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerId: Int64?

    public var scalingGroupBizId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.configItemBizId != nil {
            map["ConfigItemBizId"] = self.configItemBizId!
        }
        if self.configItemType != nil {
            map["ConfigItemType"] = self.configItemType!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.scalingGroupBizId != nil {
            map["ScalingGroupBizId"] = self.scalingGroupBizId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ConfigItemBizId") && dict["ConfigItemBizId"] != nil {
            self.configItemBizId = dict["ConfigItemBizId"] as! String
        }
        if dict.keys.contains("ConfigItemType") && dict["ConfigItemType"] != nil {
            self.configItemType = dict["ConfigItemType"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") && dict["ResourceGroupId"] != nil {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") && dict["ResourceOwnerId"] != nil {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("ScalingGroupBizId") && dict["ScalingGroupBizId"] != nil {
            self.scalingGroupBizId = dict["ScalingGroupBizId"] as! String
        }
    }
}

public class RemoveScalingConfigItemV2ResponseBody : Tea.TeaModel {
    public var data: Bool?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! Bool
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class RemoveScalingConfigItemV2Response : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RemoveScalingConfigItemV2ResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = RemoveScalingConfigItemV2ResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RerunFlowRequest : Tea.TeaModel {
    public var flowInstanceId: String?

    public var projectId: String?

    public var reRunFail: Bool?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.flowInstanceId != nil {
            map["FlowInstanceId"] = self.flowInstanceId!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.reRunFail != nil {
            map["ReRunFail"] = self.reRunFail!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FlowInstanceId") && dict["FlowInstanceId"] != nil {
            self.flowInstanceId = dict["FlowInstanceId"] as! String
        }
        if dict.keys.contains("ProjectId") && dict["ProjectId"] != nil {
            self.projectId = dict["ProjectId"] as! String
        }
        if dict.keys.contains("ReRunFail") && dict["ReRunFail"] != nil {
            self.reRunFail = dict["ReRunFail"] as! Bool
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class RerunFlowResponseBody : Tea.TeaModel {
    public var data: Bool?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! Bool
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class RerunFlowResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RerunFlowResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = RerunFlowResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ResizeClusterV2Request : Tea.TeaModel {
    public class HostComponentInfo : Tea.TeaModel {
        public var componentNameList: [String]?

        public var hostName: String?

        public var serviceName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.componentNameList != nil {
                map["ComponentNameList"] = self.componentNameList!
            }
            if self.hostName != nil {
                map["HostName"] = self.hostName!
            }
            if self.serviceName != nil {
                map["ServiceName"] = self.serviceName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ComponentNameList") && dict["ComponentNameList"] != nil {
                self.componentNameList = dict["ComponentNameList"] as! [String]
            }
            if dict.keys.contains("HostName") && dict["HostName"] != nil {
                self.hostName = dict["HostName"] as! String
            }
            if dict.keys.contains("ServiceName") && dict["ServiceName"] != nil {
                self.serviceName = dict["ServiceName"] as! String
            }
        }
    }
    public class HostGroup : Tea.TeaModel {
        public var autoRenew: Bool?

        public var chargeType: String?

        public var clusterId: String?

        public var comment: String?

        public var createType: String?

        public var diskCapacity: Int32?

        public var diskCount: Int32?

        public var diskType: String?

        public var hostGroupId: String?

        public var hostGroupName: String?

        public var hostGroupType: String?

        public var hostKeyPairName: String?

        public var hostPassword: String?

        public var instanceType: String?

        public var nodeCount: Int32?

        public var period: Int32?

        public var privatePoolOptionsId: String?

        public var privatePoolOptionsMatchCriteria: String?

        public var sysDiskCapacity: Int32?

        public var sysDiskType: String?

        public var vswitchId: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.autoRenew != nil {
                map["AutoRenew"] = self.autoRenew!
            }
            if self.chargeType != nil {
                map["ChargeType"] = self.chargeType!
            }
            if self.clusterId != nil {
                map["ClusterId"] = self.clusterId!
            }
            if self.comment != nil {
                map["Comment"] = self.comment!
            }
            if self.createType != nil {
                map["CreateType"] = self.createType!
            }
            if self.diskCapacity != nil {
                map["DiskCapacity"] = self.diskCapacity!
            }
            if self.diskCount != nil {
                map["DiskCount"] = self.diskCount!
            }
            if self.diskType != nil {
                map["DiskType"] = self.diskType!
            }
            if self.hostGroupId != nil {
                map["HostGroupId"] = self.hostGroupId!
            }
            if self.hostGroupName != nil {
                map["HostGroupName"] = self.hostGroupName!
            }
            if self.hostGroupType != nil {
                map["HostGroupType"] = self.hostGroupType!
            }
            if self.hostKeyPairName != nil {
                map["HostKeyPairName"] = self.hostKeyPairName!
            }
            if self.hostPassword != nil {
                map["HostPassword"] = self.hostPassword!
            }
            if self.instanceType != nil {
                map["InstanceType"] = self.instanceType!
            }
            if self.nodeCount != nil {
                map["NodeCount"] = self.nodeCount!
            }
            if self.period != nil {
                map["Period"] = self.period!
            }
            if self.privatePoolOptionsId != nil {
                map["PrivatePoolOptionsId"] = self.privatePoolOptionsId!
            }
            if self.privatePoolOptionsMatchCriteria != nil {
                map["PrivatePoolOptionsMatchCriteria"] = self.privatePoolOptionsMatchCriteria!
            }
            if self.sysDiskCapacity != nil {
                map["SysDiskCapacity"] = self.sysDiskCapacity!
            }
            if self.sysDiskType != nil {
                map["SysDiskType"] = self.sysDiskType!
            }
            if self.vswitchId != nil {
                map["VswitchId"] = self.vswitchId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AutoRenew") && dict["AutoRenew"] != nil {
                self.autoRenew = dict["AutoRenew"] as! Bool
            }
            if dict.keys.contains("ChargeType") && dict["ChargeType"] != nil {
                self.chargeType = dict["ChargeType"] as! String
            }
            if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
                self.clusterId = dict["ClusterId"] as! String
            }
            if dict.keys.contains("Comment") && dict["Comment"] != nil {
                self.comment = dict["Comment"] as! String
            }
            if dict.keys.contains("CreateType") && dict["CreateType"] != nil {
                self.createType = dict["CreateType"] as! String
            }
            if dict.keys.contains("DiskCapacity") && dict["DiskCapacity"] != nil {
                self.diskCapacity = dict["DiskCapacity"] as! Int32
            }
            if dict.keys.contains("DiskCount") && dict["DiskCount"] != nil {
                self.diskCount = dict["DiskCount"] as! Int32
            }
            if dict.keys.contains("DiskType") && dict["DiskType"] != nil {
                self.diskType = dict["DiskType"] as! String
            }
            if dict.keys.contains("HostGroupId") && dict["HostGroupId"] != nil {
                self.hostGroupId = dict["HostGroupId"] as! String
            }
            if dict.keys.contains("HostGroupName") && dict["HostGroupName"] != nil {
                self.hostGroupName = dict["HostGroupName"] as! String
            }
            if dict.keys.contains("HostGroupType") && dict["HostGroupType"] != nil {
                self.hostGroupType = dict["HostGroupType"] as! String
            }
            if dict.keys.contains("HostKeyPairName") && dict["HostKeyPairName"] != nil {
                self.hostKeyPairName = dict["HostKeyPairName"] as! String
            }
            if dict.keys.contains("HostPassword") && dict["HostPassword"] != nil {
                self.hostPassword = dict["HostPassword"] as! String
            }
            if dict.keys.contains("InstanceType") && dict["InstanceType"] != nil {
                self.instanceType = dict["InstanceType"] as! String
            }
            if dict.keys.contains("NodeCount") && dict["NodeCount"] != nil {
                self.nodeCount = dict["NodeCount"] as! Int32
            }
            if dict.keys.contains("Period") && dict["Period"] != nil {
                self.period = dict["Period"] as! Int32
            }
            if dict.keys.contains("PrivatePoolOptionsId") && dict["PrivatePoolOptionsId"] != nil {
                self.privatePoolOptionsId = dict["PrivatePoolOptionsId"] as! String
            }
            if dict.keys.contains("PrivatePoolOptionsMatchCriteria") && dict["PrivatePoolOptionsMatchCriteria"] != nil {
                self.privatePoolOptionsMatchCriteria = dict["PrivatePoolOptionsMatchCriteria"] as! String
            }
            if dict.keys.contains("SysDiskCapacity") && dict["SysDiskCapacity"] != nil {
                self.sysDiskCapacity = dict["SysDiskCapacity"] as! Int32
            }
            if dict.keys.contains("SysDiskType") && dict["SysDiskType"] != nil {
                self.sysDiskType = dict["SysDiskType"] as! String
            }
            if dict.keys.contains("VswitchId") && dict["VswitchId"] != nil {
                self.vswitchId = dict["VswitchId"] as! Int32
            }
        }
    }
    public class PromotionInfo : Tea.TeaModel {
        public var productCode: String?

        public var promotionOptionCode: String?

        public var promotionOptionNo: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.productCode != nil {
                map["ProductCode"] = self.productCode!
            }
            if self.promotionOptionCode != nil {
                map["PromotionOptionCode"] = self.promotionOptionCode!
            }
            if self.promotionOptionNo != nil {
                map["PromotionOptionNo"] = self.promotionOptionNo!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ProductCode") && dict["ProductCode"] != nil {
                self.productCode = dict["ProductCode"] as! String
            }
            if dict.keys.contains("PromotionOptionCode") && dict["PromotionOptionCode"] != nil {
                self.promotionOptionCode = dict["PromotionOptionCode"] as! String
            }
            if dict.keys.contains("PromotionOptionNo") && dict["PromotionOptionNo"] != nil {
                self.promotionOptionNo = dict["PromotionOptionNo"] as! String
            }
        }
    }
    public var autoPayOrder: Bool?

    public var clickhouseConf: String?

    public var clusterId: String?

    public var hostComponentInfo: [ResizeClusterV2Request.HostComponentInfo]?

    public var hostGroup: [ResizeClusterV2Request.HostGroup]?

    public var isOpenPublicIp: Bool?

    public var promotionInfo: [ResizeClusterV2Request.PromotionInfo]?

    public var regionId: String?

    public var vswitchId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.autoPayOrder != nil {
            map["AutoPayOrder"] = self.autoPayOrder!
        }
        if self.clickhouseConf != nil {
            map["ClickhouseConf"] = self.clickhouseConf!
        }
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.hostComponentInfo != nil {
            var tmp : [Any] = []
            for k in self.hostComponentInfo! {
                tmp.append(k.toMap())
            }
            map["HostComponentInfo"] = tmp
        }
        if self.hostGroup != nil {
            var tmp : [Any] = []
            for k in self.hostGroup! {
                tmp.append(k.toMap())
            }
            map["HostGroup"] = tmp
        }
        if self.isOpenPublicIp != nil {
            map["IsOpenPublicIp"] = self.isOpenPublicIp!
        }
        if self.promotionInfo != nil {
            var tmp : [Any] = []
            for k in self.promotionInfo! {
                tmp.append(k.toMap())
            }
            map["PromotionInfo"] = tmp
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.vswitchId != nil {
            map["VswitchId"] = self.vswitchId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AutoPayOrder") && dict["AutoPayOrder"] != nil {
            self.autoPayOrder = dict["AutoPayOrder"] as! Bool
        }
        if dict.keys.contains("ClickhouseConf") && dict["ClickhouseConf"] != nil {
            self.clickhouseConf = dict["ClickhouseConf"] as! String
        }
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("HostComponentInfo") && dict["HostComponentInfo"] != nil {
            var tmp : [ResizeClusterV2Request.HostComponentInfo] = []
            for v in dict["HostComponentInfo"] as! [Any] {
                var model = ResizeClusterV2Request.HostComponentInfo()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.hostComponentInfo = tmp
        }
        if dict.keys.contains("HostGroup") && dict["HostGroup"] != nil {
            var tmp : [ResizeClusterV2Request.HostGroup] = []
            for v in dict["HostGroup"] as! [Any] {
                var model = ResizeClusterV2Request.HostGroup()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.hostGroup = tmp
        }
        if dict.keys.contains("IsOpenPublicIp") && dict["IsOpenPublicIp"] != nil {
            self.isOpenPublicIp = dict["IsOpenPublicIp"] as! Bool
        }
        if dict.keys.contains("PromotionInfo") && dict["PromotionInfo"] != nil {
            var tmp : [ResizeClusterV2Request.PromotionInfo] = []
            for v in dict["PromotionInfo"] as! [Any] {
                var model = ResizeClusterV2Request.PromotionInfo()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.promotionInfo = tmp
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("VswitchId") && dict["VswitchId"] != nil {
            self.vswitchId = dict["VswitchId"] as! String
        }
    }
}

public class ResizeClusterV2ResponseBody : Tea.TeaModel {
    public var clusterId: String?

    public var operationId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.operationId != nil {
            map["OperationId"] = self.operationId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("OperationId") && dict["OperationId"] != nil {
            self.operationId = dict["OperationId"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ResizeClusterV2Response : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ResizeClusterV2ResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ResizeClusterV2ResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ResumeFlowRequest : Tea.TeaModel {
    public var flowInstanceId: String?

    public var projectId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.flowInstanceId != nil {
            map["FlowInstanceId"] = self.flowInstanceId!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FlowInstanceId") && dict["FlowInstanceId"] != nil {
            self.flowInstanceId = dict["FlowInstanceId"] as! String
        }
        if dict.keys.contains("ProjectId") && dict["ProjectId"] != nil {
            self.projectId = dict["ProjectId"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class ResumeFlowResponseBody : Tea.TeaModel {
    public var data: Bool?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! Bool
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ResumeFlowResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ResumeFlowResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = ResumeFlowResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RunClusterServiceActionRequest : Tea.TeaModel {
    public var clusterId: String?

    public var comment: String?

    public var componentNameList: String?

    public var customCommand: String?

    public var customParams: String?

    public var executeStrategy: String?

    public var hostGroupIdList: [String]?

    public var hostIdList: String?

    public var interval: Int64?

    public var isRolling: Bool?

    public var nodeCountPerBatch: Int32?

    public var onlyRestartStaleConfigNodes: Bool?

    public var regionId: String?

    public var resourceOwnerId: Int64?

    public var serviceActionName: String?

    public var serviceName: String?

    public var totlerateFailCount: Int32?

    public var turnOnMaintenanceMode: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.comment != nil {
            map["Comment"] = self.comment!
        }
        if self.componentNameList != nil {
            map["ComponentNameList"] = self.componentNameList!
        }
        if self.customCommand != nil {
            map["CustomCommand"] = self.customCommand!
        }
        if self.customParams != nil {
            map["CustomParams"] = self.customParams!
        }
        if self.executeStrategy != nil {
            map["ExecuteStrategy"] = self.executeStrategy!
        }
        if self.hostGroupIdList != nil {
            map["HostGroupIdList"] = self.hostGroupIdList!
        }
        if self.hostIdList != nil {
            map["HostIdList"] = self.hostIdList!
        }
        if self.interval != nil {
            map["Interval"] = self.interval!
        }
        if self.isRolling != nil {
            map["IsRolling"] = self.isRolling!
        }
        if self.nodeCountPerBatch != nil {
            map["NodeCountPerBatch"] = self.nodeCountPerBatch!
        }
        if self.onlyRestartStaleConfigNodes != nil {
            map["OnlyRestartStaleConfigNodes"] = self.onlyRestartStaleConfigNodes!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.serviceActionName != nil {
            map["ServiceActionName"] = self.serviceActionName!
        }
        if self.serviceName != nil {
            map["ServiceName"] = self.serviceName!
        }
        if self.totlerateFailCount != nil {
            map["TotlerateFailCount"] = self.totlerateFailCount!
        }
        if self.turnOnMaintenanceMode != nil {
            map["TurnOnMaintenanceMode"] = self.turnOnMaintenanceMode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("Comment") && dict["Comment"] != nil {
            self.comment = dict["Comment"] as! String
        }
        if dict.keys.contains("ComponentNameList") && dict["ComponentNameList"] != nil {
            self.componentNameList = dict["ComponentNameList"] as! String
        }
        if dict.keys.contains("CustomCommand") && dict["CustomCommand"] != nil {
            self.customCommand = dict["CustomCommand"] as! String
        }
        if dict.keys.contains("CustomParams") && dict["CustomParams"] != nil {
            self.customParams = dict["CustomParams"] as! String
        }
        if dict.keys.contains("ExecuteStrategy") && dict["ExecuteStrategy"] != nil {
            self.executeStrategy = dict["ExecuteStrategy"] as! String
        }
        if dict.keys.contains("HostGroupIdList") && dict["HostGroupIdList"] != nil {
            self.hostGroupIdList = dict["HostGroupIdList"] as! [String]
        }
        if dict.keys.contains("HostIdList") && dict["HostIdList"] != nil {
            self.hostIdList = dict["HostIdList"] as! String
        }
        if dict.keys.contains("Interval") && dict["Interval"] != nil {
            self.interval = dict["Interval"] as! Int64
        }
        if dict.keys.contains("IsRolling") && dict["IsRolling"] != nil {
            self.isRolling = dict["IsRolling"] as! Bool
        }
        if dict.keys.contains("NodeCountPerBatch") && dict["NodeCountPerBatch"] != nil {
            self.nodeCountPerBatch = dict["NodeCountPerBatch"] as! Int32
        }
        if dict.keys.contains("OnlyRestartStaleConfigNodes") && dict["OnlyRestartStaleConfigNodes"] != nil {
            self.onlyRestartStaleConfigNodes = dict["OnlyRestartStaleConfigNodes"] as! Bool
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") && dict["ResourceOwnerId"] != nil {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("ServiceActionName") && dict["ServiceActionName"] != nil {
            self.serviceActionName = dict["ServiceActionName"] as! String
        }
        if dict.keys.contains("ServiceName") && dict["ServiceName"] != nil {
            self.serviceName = dict["ServiceName"] as! String
        }
        if dict.keys.contains("TotlerateFailCount") && dict["TotlerateFailCount"] != nil {
            self.totlerateFailCount = dict["TotlerateFailCount"] as! Int32
        }
        if dict.keys.contains("TurnOnMaintenanceMode") && dict["TurnOnMaintenanceMode"] != nil {
            self.turnOnMaintenanceMode = dict["TurnOnMaintenanceMode"] as! Bool
        }
    }
}

public class RunClusterServiceActionResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class RunClusterServiceActionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RunClusterServiceActionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = RunClusterServiceActionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RunScalingActionV2Request : Tea.TeaModel {
    public var actionParam: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerId: Int64?

    public var scalingActionType: String?

    public var scalingGroupBizId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.actionParam != nil {
            map["ActionParam"] = self.actionParam!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.scalingActionType != nil {
            map["ScalingActionType"] = self.scalingActionType!
        }
        if self.scalingGroupBizId != nil {
            map["ScalingGroupBizId"] = self.scalingGroupBizId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ActionParam") && dict["ActionParam"] != nil {
            self.actionParam = dict["ActionParam"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") && dict["ResourceGroupId"] != nil {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") && dict["ResourceOwnerId"] != nil {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("ScalingActionType") && dict["ScalingActionType"] != nil {
            self.scalingActionType = dict["ScalingActionType"] as! String
        }
        if dict.keys.contains("ScalingGroupBizId") && dict["ScalingGroupBizId"] != nil {
            self.scalingGroupBizId = dict["ScalingGroupBizId"] as! String
        }
    }
}

public class RunScalingActionV2ResponseBody : Tea.TeaModel {
    public var data: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class RunScalingActionV2Response : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RunScalingActionV2ResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = RunScalingActionV2ResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class StartFlowRequest : Tea.TeaModel {
    public var flowInstanceId: String?

    public var projectId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.flowInstanceId != nil {
            map["FlowInstanceId"] = self.flowInstanceId!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FlowInstanceId") && dict["FlowInstanceId"] != nil {
            self.flowInstanceId = dict["FlowInstanceId"] as! String
        }
        if dict.keys.contains("ProjectId") && dict["ProjectId"] != nil {
            self.projectId = dict["ProjectId"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class StartFlowResponseBody : Tea.TeaModel {
    public var data: Bool?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! Bool
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class StartFlowResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StartFlowResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = StartFlowResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SubmitFlowRequest : Tea.TeaModel {
    public var conf: String?

    public var flowId: String?

    public var projectId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.conf != nil {
            map["Conf"] = self.conf!
        }
        if self.flowId != nil {
            map["FlowId"] = self.flowId!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Conf") && dict["Conf"] != nil {
            self.conf = dict["Conf"] as! String
        }
        if dict.keys.contains("FlowId") && dict["FlowId"] != nil {
            self.flowId = dict["FlowId"] as! String
        }
        if dict.keys.contains("ProjectId") && dict["ProjectId"] != nil {
            self.projectId = dict["ProjectId"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class SubmitFlowResponseBody : Tea.TeaModel {
    public var id: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SubmitFlowResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SubmitFlowResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = SubmitFlowResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SubmitFlowJobRequest : Tea.TeaModel {
    public var clusterId: String?

    public var conf: String?

    public var hostName: String?

    public var jobId: String?

    public var jobInstanceId: String?

    public var namespace: String?

    public var projectId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.conf != nil {
            map["Conf"] = self.conf!
        }
        if self.hostName != nil {
            map["HostName"] = self.hostName!
        }
        if self.jobId != nil {
            map["JobId"] = self.jobId!
        }
        if self.jobInstanceId != nil {
            map["JobInstanceId"] = self.jobInstanceId!
        }
        if self.namespace != nil {
            map["Namespace"] = self.namespace!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") && dict["ClusterId"] != nil {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("Conf") && dict["Conf"] != nil {
            self.conf = dict["Conf"] as! String
        }
        if dict.keys.contains("HostName") && dict["HostName"] != nil {
            self.hostName = dict["HostName"] as! String
        }
        if dict.keys.contains("JobId") && dict["JobId"] != nil {
            self.jobId = dict["JobId"] as! String
        }
        if dict.keys.contains("JobInstanceId") && dict["JobInstanceId"] != nil {
            self.jobInstanceId = dict["JobInstanceId"] as! String
        }
        if dict.keys.contains("Namespace") && dict["Namespace"] != nil {
            self.namespace = dict["Namespace"] as! String
        }
        if dict.keys.contains("ProjectId") && dict["ProjectId"] != nil {
            self.projectId = dict["ProjectId"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class SubmitFlowJobResponseBody : Tea.TeaModel {
    public var id: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.id != nil {
            map["Id"] = self.id!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Id") && dict["Id"] != nil {
            self.id = dict["Id"] as! String
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SubmitFlowJobResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SubmitFlowJobResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = SubmitFlowJobResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SuspendFlowRequest : Tea.TeaModel {
    public var flowInstanceId: String?

    public var projectId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.flowInstanceId != nil {
            map["FlowInstanceId"] = self.flowInstanceId!
        }
        if self.projectId != nil {
            map["ProjectId"] = self.projectId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FlowInstanceId") && dict["FlowInstanceId"] != nil {
            self.flowInstanceId = dict["FlowInstanceId"] as! String
        }
        if dict.keys.contains("ProjectId") && dict["ProjectId"] != nil {
            self.projectId = dict["ProjectId"] as! String
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class SuspendFlowResponseBody : Tea.TeaModel {
    public var data: Bool?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") && dict["Data"] != nil {
            self.data = dict["Data"] as! Bool
        }
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SuspendFlowResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SuspendFlowResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = SuspendFlowResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class TagResourcesRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") && dict["Key"] != nil {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") && dict["Value"] != nil {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var regionId: String?

    public var resourceId: [String]?

    public var resourceOwnerId: Int64?

    public var resourceType: String?

    public var tag: [TagResourcesRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceId") && dict["ResourceId"] != nil {
            self.resourceId = dict["ResourceId"] as! [String]
        }
        if dict.keys.contains("ResourceOwnerId") && dict["ResourceOwnerId"] != nil {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceType") && dict["ResourceType"] != nil {
            self.resourceType = dict["ResourceType"] as! String
        }
        if dict.keys.contains("Tag") && dict["Tag"] != nil {
            var tmp : [TagResourcesRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = TagResourcesRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
    }
}

public class TagResourcesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class TagResourcesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: TagResourcesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = TagResourcesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UntagResourcesRequest : Tea.TeaModel {
    public var all: Bool?

    public var regionId: String?

    public var resourceId: [String]?

    public var resourceOwnerId: Int64?

    public var resourceType: String?

    public var tagKey: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.all != nil {
            map["All"] = self.all!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.tagKey != nil {
            map["TagKey"] = self.tagKey!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("All") && dict["All"] != nil {
            self.all = dict["All"] as! Bool
        }
        if dict.keys.contains("RegionId") && dict["RegionId"] != nil {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceId") && dict["ResourceId"] != nil {
            self.resourceId = dict["ResourceId"] as! [String]
        }
        if dict.keys.contains("ResourceOwnerId") && dict["ResourceOwnerId"] != nil {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceType") && dict["ResourceType"] != nil {
            self.resourceType = dict["ResourceType"] as! String
        }
        if dict.keys.contains("TagKey") && dict["TagKey"] != nil {
            self.tagKey = dict["TagKey"] as! [String]
        }
    }
}

public class UntagResourcesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") && dict["RequestId"] != nil {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UntagResourcesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UntagResourcesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") && dict["headers"] != nil {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") && dict["statusCode"] != nil {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") && dict["body"] != nil {
            var model = UntagResourcesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}
